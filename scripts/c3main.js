// Generated by Construct, the game and animation creation tool
// Visit: https://www.construct.net

"use strict";
var EPSILON$$module$content$working$237635295$scripts$c3runtime = 1E-6,
    ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime = "undefined" !== typeof Float32Array ? Float32Array : Array,
    RANDOM$$module$content$working$237635295$scripts$c3runtime = Math.random,
    ANGLE_ORDER$$module$content$working$237635295$scripts$c3runtime = "zyx",
    degree$$module$content$working$237635295$scripts$c3runtime = Math.PI / 180;
Math.hypot || (Math.hypot = function() {
    for (var a = 0, b = arguments.length; b--;)
        a += arguments[b] * arguments[b];
    return Math.sqrt(a)
});
var common$$module$content$working$237635295$scripts$c3runtime = {
    __proto__: null,
    EPSILON: EPSILON$$module$content$working$237635295$scripts$c3runtime,
    get ARRAY_TYPE() {
        return ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime
    },
    RANDOM: RANDOM$$module$content$working$237635295$scripts$c3runtime,
    ANGLE_ORDER: ANGLE_ORDER$$module$content$working$237635295$scripts$c3runtime,
    setMatrixArrayType: function(a) {
        ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime = a
    },
    toRadian: function(a) {
        return a *
        degree$$module$content$working$237635295$scripts$c3runtime
    },
    equals: function(a, b) {
        return Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(a), Math.abs(b))
    }
};
function multiply$8(a, b, c) {
    var d = b[0],
        e = b[1],
        f = b[2];
    b = b[3];
    var g = c[0],
        h = c[1],
        k = c[2];
    c = c[3];
    a[0] = d * g + f * h;
    a[1] = e * g + b * h;
    a[2] = d * k + f * c;
    a[3] = e * k + b * c;
    return a
}
function subtract$6(a, b, c) {
    a[0] = b[0] - c[0];
    a[1] = b[1] - c[1];
    a[2] = b[2] - c[2];
    a[3] = b[3] - c[3];
    return a
}
var mul$8$$module$content$working$237635295$scripts$c3runtime = multiply$8,
    sub$6$$module$content$working$237635295$scripts$c3runtime = subtract$6,
    mat2$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: function() {
            var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(4);
            ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[1] = 0, a[2] = 0);
            a[0] = 1;
            a[3] = 1;
            return a
        },
        clone: function(a) {
            var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(4);
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            return b
        },
        copy: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[3];
            return a
        },
        identity: function(a) {
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 1;
            return a
        },
        fromValues: function(a, b, c, d) {
            var e = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(4);
            e[0] = a;
            e[1] = b;
            e[2] = c;
            e[3] = d;
            return e
        },
        set: function(a, b, c, d, e) {
            a[0] = b;
            a[1] = c;
            a[2] = d;
            a[3] = e;
            return a
        },
        transpose: function(a, b) {
            if (a === b) {
                var c = b[1];
                a[1] = b[2];
                a[2] = c
            } else
                a[0] = b[0],
                a[1] = b[2],
                a[2] = b[1],
                a[3] = b[3];
            return a
        },
        invert: function(a,
        b) {
            var c = b[0],
                d = b[1],
                e = b[2];
            b = b[3];
            var f = c * b - e * d;
            if (!f)
                return null;
            f = 1 / f;
            a[0] = b * f;
            a[1] = -d * f;
            a[2] = -e * f;
            a[3] = c * f;
            return a
        },
        adjoint: function(a, b) {
            var c = b[0];
            a[0] = b[3];
            a[1] = -b[1];
            a[2] = -b[2];
            a[3] = c;
            return a
        },
        determinant: function(a) {
            return a[0] * a[3] - a[2] * a[1]
        },
        multiply: multiply$8,
        rotate: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2];
            b = b[3];
            var g = Math.sin(c);
            c = Math.cos(c);
            a[0] = d * c + f * g;
            a[1] = e * c + b * g;
            a[2] = d * -g + f * c;
            a[3] = e * -g + b * c;
            return a
        },
        scale: function(a, b, c) {
            var d = b[1],
                e = b[2],
                f = b[3],
                g = c[0];
            c = c[1];
            a[0] = b[0] * g;
            a[1] =
            d * g;
            a[2] = e * c;
            a[3] = f * c;
            return a
        },
        fromRotation: function(a, b) {
            var c = Math.sin(b);
            b = Math.cos(b);
            a[0] = b;
            a[1] = c;
            a[2] = -c;
            a[3] = b;
            return a
        },
        fromScaling: function(a, b) {
            a[0] = b[0];
            a[1] = 0;
            a[2] = 0;
            a[3] = b[1];
            return a
        },
        str: function(a) {
            return "mat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")"
        },
        frob: function(a) {
            return Math.hypot(a[0], a[1], a[2], a[3])
        },
        LDU: function(a, b, c, d) {
            a[2] = d[2] / d[0];
            c[0] = d[0];
            c[1] = d[1];
            c[3] = d[3] - a[2] * c[1];
            return [a, b, c]
        },
        add: function(a, b, c) {
            a[0] = b[0] + c[0];
            a[1] = b[1] + c[1];
            a[2] = b[2] + c[2];
            a[3] = b[3] + c[3];
            return a
        },
        subtract: subtract$6,
        exactEquals: function(a, b) {
            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
        },
        equals: function(a, b) {
            var c = a[0],
                d = a[1],
                e = a[2];
            a = a[3];
            var f = b[0],
                g = b[1],
                h = b[2];
            b = b[3];
            return Math.abs(c - f) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(c), Math.abs(f)) && Math.abs(d - g) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(d), Math.abs(g)) && Math.abs(e - h) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1,
                Math.abs(e), Math.abs(h)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(a), Math.abs(b))
        },
        multiplyScalar: function(a, b, c) {
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            a[2] = b[2] * c;
            a[3] = b[3] * c;
            return a
        },
        multiplyScalarAndAdd: function(a, b, c, d) {
            a[0] = b[0] + c[0] * d;
            a[1] = b[1] + c[1] * d;
            a[2] = b[2] + c[2] * d;
            a[3] = b[3] + c[3] * d;
            return a
        },
        mul: mul$8$$module$content$working$237635295$scripts$c3runtime,
        sub: sub$6$$module$content$working$237635295$scripts$c3runtime
    });
function multiply$7(a, b, c) {
    var d = b[0],
        e = b[1],
        f = b[2],
        g = b[3],
        h = b[4];
    b = b[5];
    var k = c[0],
        l = c[1],
        m = c[2],
        n = c[3],
        p = c[4];
    c = c[5];
    a[0] = d * k + f * l;
    a[1] = e * k + g * l;
    a[2] = d * m + f * n;
    a[3] = e * m + g * n;
    a[4] = d * p + f * c + h;
    a[5] = e * p + g * c + b;
    return a
}
function subtract$5(a, b, c) {
    a[0] = b[0] - c[0];
    a[1] = b[1] - c[1];
    a[2] = b[2] - c[2];
    a[3] = b[3] - c[3];
    a[4] = b[4] - c[4];
    a[5] = b[5] - c[5];
    return a
}
var mul$7$$module$content$working$237635295$scripts$c3runtime = multiply$7,
    sub$5$$module$content$working$237635295$scripts$c3runtime = subtract$5,
    mat2d$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: function() {
            var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(6);
            ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[1] = 0, a[2] = 0, a[4] = 0, a[5] = 0);
            a[0] = 1;
            a[3] = 1;
            return a
        },
        clone: function(a) {
            var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(6);
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            return b
        },
        copy: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[3];
            a[4] = b[4];
            a[5] = b[5];
            return a
        },
        identity: function(a) {
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 1;
            a[4] = 0;
            a[5] = 0;
            return a
        },
        fromValues: function(a, b, c, d, e, f) {
            var g = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(6);
            g[0] = a;
            g[1] = b;
            g[2] = c;
            g[3] = d;
            g[4] = e;
            g[5] = f;
            return g
        },
        set: function(a, b, c, d, e, f, g) {
            a[0] = b;
            a[1] = c;
            a[2] = d;
            a[3] = e;
            a[4] = f;
            a[5] = g;
            return a
        },
        invert: function(a, b) {
            var c = b[0],
                d = b[1],
                e = b[2],
                f = b[3],
                g = b[4];
            b = b[5];
            var h = c * f - d * e;
            if (!h)
                return null;
            h = 1 / h;
            a[0] = f * h;
            a[1] = -d * h;
            a[2] = -e * h;
            a[3] = c * h;
            a[4] = (e * b - f * g) * h;
            a[5] = (d * g - c * b) * h;
            return a
        },
        determinant: function(a) {
            return a[0] * a[3] - a[1] * a[2]
        },
        multiply: multiply$7,
        rotate: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2],
                g = b[3],
                h = b[4];
            b = b[5];
            var k = Math.sin(c);
            c = Math.cos(c);
            a[0] = d * c + f * k;
            a[1] = e * c + g * k;
            a[2] = d * -k + f * c;
            a[3] = e * -k + g * c;
            a[4] = h;
            a[5] = b;
            return a
        },
        scale: function(a, b, c) {
            var d = b[1],
                e = b[2],
                f = b[3],
                g = b[4],
                h = b[5],
                k = c[0];
            c = c[1];
            a[0] = b[0] * k;
            a[1] = d * k;
            a[2] = e * c;
            a[3] = f * c;
            a[4] = g;
            a[5] = h;
            return a
        },
        translate: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2],
                g = b[3],
                h = b[4];
            b = b[5];
            var k = c[0];
            c = c[1];
            a[0] = d;
            a[1] = e;
            a[2] = f;
            a[3] = g;
            a[4] = d * k + f * c + h;
            a[5] = e * k + g * c + b;
            return a
        },
        fromRotation: function(a, b) {
            var c = Math.sin(b);
            b = Math.cos(b);
            a[0] = b;
            a[1] = c;
            a[2] = -c;
            a[3] = b;
            a[4] = 0;
            a[5] = 0;
            return a
        },
        fromScaling: function(a, b) {
            a[0] = b[0];
            a[1] = 0;
            a[2] = 0;
            a[3] = b[1];
            a[4] = 0;
            a[5] = 0;
            return a
        },
        fromTranslation: function(a, b) {
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 1;
            a[4] = b[0];
            a[5] = b[1];
            return a
        },
        str: function(a) {
            return "mat2d(" +
            a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ")"
        },
        frob: function(a) {
            return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5], 1)
        },
        add: function(a, b, c) {
            a[0] = b[0] + c[0];
            a[1] = b[1] + c[1];
            a[2] = b[2] + c[2];
            a[3] = b[3] + c[3];
            a[4] = b[4] + c[4];
            a[5] = b[5] + c[5];
            return a
        },
        subtract: subtract$5,
        multiplyScalar: function(a, b, c) {
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            a[2] = b[2] * c;
            a[3] = b[3] * c;
            a[4] = b[4] * c;
            a[5] = b[5] * c;
            return a
        },
        multiplyScalarAndAdd: function(a, b, c, d) {
            a[0] = b[0] + c[0] * d;
            a[1] = b[1] + c[1] * d;
            a[2] = b[2] + c[2] * d;
            a[3] = b[3] + c[3] * d;
            a[4] = b[4] + c[4] *
            d;
            a[5] = b[5] + c[5] * d;
            return a
        },
        exactEquals: function(a, b) {
            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5]
        },
        equals: function(a, b) {
            var c = a[0],
                d = a[1],
                e = a[2],
                f = a[3],
                g = a[4];
            a = a[5];
            var h = b[0],
                k = b[1],
                l = b[2],
                m = b[3],
                n = b[4];
            b = b[5];
            return Math.abs(c - h) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(c), Math.abs(h)) && Math.abs(d - k) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(d), Math.abs(k)) && Math.abs(e - l) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(e), Math.abs(l)) && Math.abs(f - m) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(f), Math.abs(m)) && Math.abs(g - n) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(g), Math.abs(n)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(a), Math.abs(b))
        },
        mul: mul$7$$module$content$working$237635295$scripts$c3runtime,
        sub: sub$5$$module$content$working$237635295$scripts$c3runtime
    });
function create$6() {
    var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(9);
    ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[5] = 0, a[6] = 0, a[7] = 0);
    a[0] = 1;
    a[4] = 1;
    a[8] = 1;
    return a
}
function multiply$6(a, b, c) {
    var d = b[0],
        e = b[1],
        f = b[2],
        g = b[3],
        h = b[4],
        k = b[5],
        l = b[6],
        m = b[7];
    b = b[8];
    var n = c[0],
        p = c[1],
        q = c[2],
        r = c[3],
        t = c[4],
        u = c[5],
        v = c[6],
        w = c[7];
    c = c[8];
    a[0] = n * d + p * g + q * l;
    a[1] = n * e + p * h + q * m;
    a[2] = n * f + p * k + q * b;
    a[3] = r * d + t * g + u * l;
    a[4] = r * e + t * h + u * m;
    a[5] = r * f + t * k + u * b;
    a[6] = v * d + w * g + c * l;
    a[7] = v * e + w * h + c * m;
    a[8] = v * f + w * k + c * b;
    return a
}
function subtract$4(a, b, c) {
    a[0] = b[0] - c[0];
    a[1] = b[1] - c[1];
    a[2] = b[2] - c[2];
    a[3] = b[3] - c[3];
    a[4] = b[4] - c[4];
    a[5] = b[5] - c[5];
    a[6] = b[6] - c[6];
    a[7] = b[7] - c[7];
    a[8] = b[8] - c[8];
    return a
}
var mul$6$$module$content$working$237635295$scripts$c3runtime = multiply$6,
    sub$4$$module$content$working$237635295$scripts$c3runtime = subtract$4,
    mat3$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: create$6,
        fromMat4: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[4];
            a[4] = b[5];
            a[5] = b[6];
            a[6] = b[8];
            a[7] = b[9];
            a[8] = b[10];
            return a
        },
        clone: function(a) {
            var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(9);
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            return b
        },
        copy: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[3];
            a[4] = b[4];
            a[5] = b[5];
            a[6] = b[6];
            a[7] = b[7];
            a[8] = b[8];
            return a
        },
        fromValues: function(a, b, c, d, e, f, g, h, k) {
            var l = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(9);
            l[0] = a;
            l[1] = b;
            l[2] = c;
            l[3] = d;
            l[4] = e;
            l[5] = f;
            l[6] = g;
            l[7] = h;
            l[8] = k;
            return l
        },
        set: function(a, b, c, d, e, f, g, h, k, l) {
            a[0] = b;
            a[1] = c;
            a[2] = d;
            a[3] = e;
            a[4] = f;
            a[5] = g;
            a[6] = h;
            a[7] = k;
            a[8] = l;
            return a
        },
        identity: function(a) {
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 1;
            a[5] = 0;
            a[6] = 0;
            a[7] = 0;
            a[8] = 1;
            return a
        },
        transpose: function(a, b) {
            if (a === b) {
                var c = b[1],
                    d = b[2],
                    e = b[5];
                a[1] = b[3];
                a[2] = b[6];
                a[3] = c;
                a[5] = b[7];
                a[6] = d;
                a[7] = e
            } else
                a[0] = b[0],
                a[1] = b[3],
                a[2] = b[6],
                a[3] = b[1],
                a[4] = b[4],
                a[5] = b[7],
                a[6] = b[2],
                a[7] = b[5],
                a[8] = b[8];
            return a
        },
        invert: function(a, b) {
            var c = b[0],
                d = b[1],
                e = b[2],
                f = b[3],
                g = b[4],
                h = b[5],
                k = b[6],
                l = b[7];
            b = b[8];
            var m = b * g - h * l,
                n = -b * f + h * k,
                p = l * f - g * k,
                q = c * m + d * n + e * p;
            if (!q)
                return null;
            q = 1 / q;
            a[0] = m * q;
            a[1] = (-b * d + e * l) * q;
            a[2] = (h * d - e * g) * q;
            a[3] = n * q;
            a[4] = (b *
            c - e * k) * q;
            a[5] = (-h * c + e * f) * q;
            a[6] = p * q;
            a[7] = (-l * c + d * k) * q;
            a[8] = (g * c - d * f) * q;
            return a
        },
        adjoint: function(a, b) {
            var c = b[0],
                d = b[1],
                e = b[2],
                f = b[3],
                g = b[4],
                h = b[5],
                k = b[6],
                l = b[7];
            b = b[8];
            a[0] = g * b - h * l;
            a[1] = e * l - d * b;
            a[2] = d * h - e * g;
            a[3] = h * k - f * b;
            a[4] = c * b - e * k;
            a[5] = e * f - c * h;
            a[6] = f * l - g * k;
            a[7] = d * k - c * l;
            a[8] = c * g - d * f;
            return a
        },
        determinant: function(a) {
            var b = a[3],
                c = a[4],
                d = a[5],
                e = a[6],
                f = a[7],
                g = a[8];
            return a[0] * (g * c - d * f) + a[1] * (-g * b + d * e) + a[2] * (f * b - c * e)
        },
        multiply: multiply$6,
        translate: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2],
                g = b[3],
                h =
                b[4],
                k = b[5],
                l = b[6],
                m = b[7];
            b = b[8];
            var n = c[0];
            c = c[1];
            a[0] = d;
            a[1] = e;
            a[2] = f;
            a[3] = g;
            a[4] = h;
            a[5] = k;
            a[6] = n * d + c * g + l;
            a[7] = n * e + c * h + m;
            a[8] = n * f + c * k + b;
            return a
        },
        rotate: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2],
                g = b[3],
                h = b[4],
                k = b[5],
                l = b[6],
                m = b[7];
            b = b[8];
            var n = Math.sin(c);
            c = Math.cos(c);
            a[0] = c * d + n * g;
            a[1] = c * e + n * h;
            a[2] = c * f + n * k;
            a[3] = c * g - n * d;
            a[4] = c * h - n * e;
            a[5] = c * k - n * f;
            a[6] = l;
            a[7] = m;
            a[8] = b;
            return a
        },
        scale: function(a, b, c) {
            var d = c[0];
            c = c[1];
            a[0] = d * b[0];
            a[1] = d * b[1];
            a[2] = d * b[2];
            a[3] = c * b[3];
            a[4] = c * b[4];
            a[5] = c * b[5];
            a[6] = b[6];
            a[7] = b[7];
            a[8] = b[8];
            return a
        },
        fromTranslation: function(a, b) {
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 1;
            a[5] = 0;
            a[6] = b[0];
            a[7] = b[1];
            a[8] = 1;
            return a
        },
        fromRotation: function(a, b) {
            var c = Math.sin(b);
            b = Math.cos(b);
            a[0] = b;
            a[1] = c;
            a[2] = 0;
            a[3] = -c;
            a[4] = b;
            a[5] = 0;
            a[6] = 0;
            a[7] = 0;
            a[8] = 1;
            return a
        },
        fromScaling: function(a, b) {
            a[0] = b[0];
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = b[1];
            a[5] = 0;
            a[6] = 0;
            a[7] = 0;
            a[8] = 1;
            return a
        },
        fromMat2d: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = 0;
            a[3] = b[2];
            a[4] = b[3];
            a[5] = 0;
            a[6] = b[4];
            a[7] = b[5];
            a[8] = 1;
            return a
        },
        fromQuat: function(a,
        b) {
            var c = b[0],
                d = b[1],
                e = b[2];
            b = b[3];
            var f = c + c,
                g = d + d,
                h = e + e;
            c *= f;
            var k = d * f;
            d *= g;
            var l = e * f,
                m = e * g;
            e *= h;
            f *= b;
            g *= b;
            b *= h;
            a[0] = 1 - d - e;
            a[3] = k - b;
            a[6] = l + g;
            a[1] = k + b;
            a[4] = 1 - c - e;
            a[7] = m - f;
            a[2] = l - g;
            a[5] = m + f;
            a[8] = 1 - c - d;
            return a
        },
        normalFromMat4: function(a, b) {
            var c = b[0],
                d = b[1],
                e = b[2],
                f = b[3],
                g = b[4],
                h = b[5],
                k = b[6],
                l = b[7],
                m = b[8],
                n = b[9],
                p = b[10],
                q = b[11],
                r = b[12],
                t = b[13],
                u = b[14];
            b = b[15];
            var v = c * h - d * g,
                w = c * k - e * g,
                x = c * l - f * g,
                y = d * k - e * h,
                z = d * l - f * h,
                A = e * l - f * k,
                B = m * t - n * r,
                C = m * u - p * r;
            m = m * b - q * r;
            var D = n * u - p * t;
            n = n * b - q * t;
            p = p * b - q * u;
            q = v * p - w * n + x *
            D + y * m - z * C + A * B;
            if (!q)
                return null;
            q = 1 / q;
            a[0] = (h * p - k * n + l * D) * q;
            a[1] = (k * m - g * p - l * C) * q;
            a[2] = (g * n - h * m + l * B) * q;
            a[3] = (e * n - d * p - f * D) * q;
            a[4] = (c * p - e * m + f * C) * q;
            a[5] = (d * m - c * n - f * B) * q;
            a[6] = (t * A - u * z + b * y) * q;
            a[7] = (u * x - r * A - b * w) * q;
            a[8] = (r * z - t * x + b * v) * q;
            return a
        },
        projection: function(a, b, c) {
            a[0] = 2 / b;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = -2 / c;
            a[5] = 0;
            a[6] = -1;
            a[7] = 1;
            a[8] = 1;
            return a
        },
        str: function(a) {
            return "mat3(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ")"
        },
        frob: function(a) {
            return Math.hypot(a[0],
            a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])
        },
        add: function(a, b, c) {
            a[0] = b[0] + c[0];
            a[1] = b[1] + c[1];
            a[2] = b[2] + c[2];
            a[3] = b[3] + c[3];
            a[4] = b[4] + c[4];
            a[5] = b[5] + c[5];
            a[6] = b[6] + c[6];
            a[7] = b[7] + c[7];
            a[8] = b[8] + c[8];
            return a
        },
        subtract: subtract$4,
        multiplyScalar: function(a, b, c) {
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            a[2] = b[2] * c;
            a[3] = b[3] * c;
            a[4] = b[4] * c;
            a[5] = b[5] * c;
            a[6] = b[6] * c;
            a[7] = b[7] * c;
            a[8] = b[8] * c;
            return a
        },
        multiplyScalarAndAdd: function(a, b, c, d) {
            a[0] = b[0] + c[0] * d;
            a[1] = b[1] + c[1] * d;
            a[2] = b[2] + c[2] * d;
            a[3] = b[3] + c[3] * d;
            a[4] = b[4] + c[4] * d;
            a[5] =
            b[5] + c[5] * d;
            a[6] = b[6] + c[6] * d;
            a[7] = b[7] + c[7] * d;
            a[8] = b[8] + c[8] * d;
            return a
        },
        exactEquals: function(a, b) {
            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8]
        },
        equals: function(a, b) {
            var c = a[0],
                d = a[1],
                e = a[2],
                f = a[3],
                g = a[4],
                h = a[5],
                k = a[6],
                l = a[7];
            a = a[8];
            var m = b[0],
                n = b[1],
                p = b[2],
                q = b[3],
                r = b[4],
                t = b[5],
                u = b[6],
                v = b[7];
            b = b[8];
            return Math.abs(c - m) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(c), Math.abs(m)) && Math.abs(d -
                n) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(d), Math.abs(n)) && Math.abs(e - p) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(e), Math.abs(p)) && Math.abs(f - q) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(f), Math.abs(q)) && Math.abs(g - r) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(g), Math.abs(r)) && Math.abs(h - t) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(h), Math.abs(t)) && Math.abs(k - u) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(k), Math.abs(u)) && Math.abs(l - v) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(l), Math.abs(v)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(a), Math.abs(b))
        },
        mul: mul$6$$module$content$working$237635295$scripts$c3runtime,
        sub: sub$4$$module$content$working$237635295$scripts$c3runtime
    });
function identity$2(a) {
    a[0] = 1;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = 1;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[10] = 1;
    a[11] = 0;
    a[12] = 0;
    a[13] = 0;
    a[14] = 0;
    a[15] = 1;
    return a
}
function multiply$5(a, b, c) {
    var d = b[0],
        e = b[1],
        f = b[2],
        g = b[3],
        h = b[4],
        k = b[5],
        l = b[6],
        m = b[7],
        n = b[8],
        p = b[9],
        q = b[10],
        r = b[11],
        t = b[12],
        u = b[13],
        v = b[14];
    b = b[15];
    var w = c[0],
        x = c[1],
        y = c[2],
        z = c[3];
    a[0] = w * d + x * h + y * n + z * t;
    a[1] = w * e + x * k + y * p + z * u;
    a[2] = w * f + x * l + y * q + z * v;
    a[3] = w * g + x * m + y * r + z * b;
    w = c[4];
    x = c[5];
    y = c[6];
    z = c[7];
    a[4] = w * d + x * h + y * n + z * t;
    a[5] = w * e + x * k + y * p + z * u;
    a[6] = w * f + x * l + y * q + z * v;
    a[7] = w * g + x * m + y * r + z * b;
    w = c[8];
    x = c[9];
    y = c[10];
    z = c[11];
    a[8] = w * d + x * h + y * n + z * t;
    a[9] = w * e + x * k + y * p + z * u;
    a[10] = w * f + x * l + y * q + z * v;
    a[11] = w * g + x * m + y * r + z * b;
    w = c[12];
    x = c[13];
    y = c[14];
    z = c[15];
    a[12] = w * d + x * h + y * n + z * t;
    a[13] = w * e + x * k + y * p + z * u;
    a[14] = w * f + x * l + y * q + z * v;
    a[15] = w * g + x * m + y * r + z * b;
    return a
}
function fromRotationTranslation$1(a, b, c) {
    var d = b[0],
        e = b[1],
        f = b[2],
        g = b[3],
        h = d + d,
        k = e + e,
        l = f + f;
    b = d * h;
    var m = d * k;
    d *= l;
    var n = e * k;
    e *= l;
    f *= l;
    h *= g;
    k *= g;
    g *= l;
    a[0] = 1 - (n + f);
    a[1] = m + g;
    a[2] = d - k;
    a[3] = 0;
    a[4] = m - g;
    a[5] = 1 - (b + f);
    a[6] = e + h;
    a[7] = 0;
    a[8] = d + k;
    a[9] = e - h;
    a[10] = 1 - (b + n);
    a[11] = 0;
    a[12] = c[0];
    a[13] = c[1];
    a[14] = c[2];
    a[15] = 1;
    return a
}
function getTranslation$1(a, b) {
    a[0] = b[12];
    a[1] = b[13];
    a[2] = b[14];
    return a
}
function getScaling(a, b) {
    var c = b[4],
        d = b[5],
        e = b[6],
        f = b[8],
        g = b[9],
        h = b[10];
    a[0] = Math.hypot(b[0], b[1], b[2]);
    a[1] = Math.hypot(c, d, e);
    a[2] = Math.hypot(f, g, h);
    return a
}
function getRotation(a, b) {
    var c = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(3);
    getScaling(c, b);
    var d = 1 / c[0],
        e = 1 / c[1],
        f = 1 / c[2],
        g = b[0] * d;
    c = b[1] * e;
    var h = b[2] * f,
        k = b[4] * d,
        l = b[5] * e,
        m = b[6] * f;
    d *= b[8];
    e *= b[9];
    b = b[10] * f;
    f = g + l + b;
    0 < f ? (g = 2 * Math.sqrt(f + 1), a[3] = .25 * g, a[0] = (m - e) / g, a[1] = (d - h) / g, a[2] = (c - k) / g) : g > l && g > b ? (g = 2 * Math.sqrt(1 + g - l - b), a[3] = (m - e) / g, a[0] = .25 * g, a[1] = (c + k) / g, a[2] = (d + h) / g) : l > b ? (g = 2 * Math.sqrt(1 + l - g - b), a[3] = (d - h) / g, a[0] = (c + k) / g, a[1] = .25 * g, a[2] = (m + e) / g) : (g = 2 * Math.sqrt(1 + b - g - l),
    a[3] = (c - k) / g, a[0] = (d + h) / g, a[1] = (m + e) / g, a[2] = .25 * g);
    return a
}
function perspectiveNO(a, b, c, d, e) {
    b = 1 / Math.tan(b / 2);
    a[0] = b / c;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = b;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[11] = -1;
    a[12] = 0;
    a[13] = 0;
    a[15] = 0;
    null != e && Infinity !== e ? (c = 1 / (d - e), a[10] = (e + d) * c, a[14] = 2 * e * d * c) : (a[10] = -1, a[14] = -2 * d);
    return a
}
var perspective$$module$content$working$237635295$scripts$c3runtime = perspectiveNO;
function orthoNO(a, b, c, d, e, f, g) {
    var h = 1 / (b - c),
        k = 1 / (d - e),
        l = 1 / (f - g);
    a[0] = -2 * h;
    a[1] = 0;
    a[2] = 0;
    a[3] = 0;
    a[4] = 0;
    a[5] = -2 * k;
    a[6] = 0;
    a[7] = 0;
    a[8] = 0;
    a[9] = 0;
    a[10] = 2 * l;
    a[11] = 0;
    a[12] = (b + c) * h;
    a[13] = (e + d) * k;
    a[14] = (g + f) * l;
    a[15] = 1;
    return a
}
var ortho$$module$content$working$237635295$scripts$c3runtime = orthoNO;
function subtract$3(a, b, c) {
    a[0] = b[0] - c[0];
    a[1] = b[1] - c[1];
    a[2] = b[2] - c[2];
    a[3] = b[3] - c[3];
    a[4] = b[4] - c[4];
    a[5] = b[5] - c[5];
    a[6] = b[6] - c[6];
    a[7] = b[7] - c[7];
    a[8] = b[8] - c[8];
    a[9] = b[9] - c[9];
    a[10] = b[10] - c[10];
    a[11] = b[11] - c[11];
    a[12] = b[12] - c[12];
    a[13] = b[13] - c[13];
    a[14] = b[14] - c[14];
    a[15] = b[15] - c[15];
    return a
}
var mul$5$$module$content$working$237635295$scripts$c3runtime = multiply$5,
    sub$3$$module$content$working$237635295$scripts$c3runtime = subtract$3,
    mat4$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: function() {
            var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(16);
            ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0);
            a[0] = 1;
            a[5] =
            1;
            a[10] = 1;
            a[15] = 1;
            return a
        },
        clone: function(a) {
            var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(16);
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            b[8] = a[8];
            b[9] = a[9];
            b[10] = a[10];
            b[11] = a[11];
            b[12] = a[12];
            b[13] = a[13];
            b[14] = a[14];
            b[15] = a[15];
            return b
        },
        copy: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[3];
            a[4] = b[4];
            a[5] = b[5];
            a[6] = b[6];
            a[7] = b[7];
            a[8] = b[8];
            a[9] = b[9];
            a[10] = b[10];
            a[11] = b[11];
            a[12] = b[12];
            a[13] = b[13];
            a[14] = b[14];
            a[15] = b[15];
            return a
        },
        fromValues: function(a, b, c, d, e, f, g, h, k, l, m, n, p, q, r, t) {
            var u = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(16);
            u[0] = a;
            u[1] = b;
            u[2] = c;
            u[3] = d;
            u[4] = e;
            u[5] = f;
            u[6] = g;
            u[7] = h;
            u[8] = k;
            u[9] = l;
            u[10] = m;
            u[11] = n;
            u[12] = p;
            u[13] = q;
            u[14] = r;
            u[15] = t;
            return u
        },
        set: function(a, b, c, d, e, f, g, h, k, l, m, n, p, q, r, t, u) {
            a[0] = b;
            a[1] = c;
            a[2] = d;
            a[3] = e;
            a[4] = f;
            a[5] = g;
            a[6] = h;
            a[7] = k;
            a[8] = l;
            a[9] = m;
            a[10] = n;
            a[11] = p;
            a[12] = q;
            a[13] = r;
            a[14] = t;
            a[15] = u;
            return a
        },
        identity: identity$2,
        transpose: function(a, b) {
            if (a === b) {
                var c = b[1],
                    d =
                    b[2],
                    e = b[3],
                    f = b[6],
                    g = b[7],
                    h = b[11];
                a[1] = b[4];
                a[2] = b[8];
                a[3] = b[12];
                a[4] = c;
                a[6] = b[9];
                a[7] = b[13];
                a[8] = d;
                a[9] = f;
                a[11] = b[14];
                a[12] = e;
                a[13] = g;
                a[14] = h
            } else
                a[0] = b[0],
                a[1] = b[4],
                a[2] = b[8],
                a[3] = b[12],
                a[4] = b[1],
                a[5] = b[5],
                a[6] = b[9],
                a[7] = b[13],
                a[8] = b[2],
                a[9] = b[6],
                a[10] = b[10],
                a[11] = b[14],
                a[12] = b[3],
                a[13] = b[7],
                a[14] = b[11],
                a[15] = b[15];
            return a
        },
        invert: function(a, b) {
            var c = b[0],
                d = b[1],
                e = b[2],
                f = b[3],
                g = b[4],
                h = b[5],
                k = b[6],
                l = b[7],
                m = b[8],
                n = b[9],
                p = b[10],
                q = b[11],
                r = b[12],
                t = b[13],
                u = b[14];
            b = b[15];
            var v = c * h - d * g,
                w = c * k - e * g,
                x = c *
                l - f * g,
                y = d * k - e * h,
                z = d * l - f * h,
                A = e * l - f * k,
                B = m * t - n * r,
                C = m * u - p * r,
                D = m * b - q * r,
                F = n * u - p * t,
                G = n * b - q * t,
                H = p * b - q * u,
                E = v * H - w * G + x * F + y * D - z * C + A * B;
            if (!E)
                return null;
            E = 1 / E;
            a[0] = (h * H - k * G + l * F) * E;
            a[1] = (e * G - d * H - f * F) * E;
            a[2] = (t * A - u * z + b * y) * E;
            a[3] = (p * z - n * A - q * y) * E;
            a[4] = (k * D - g * H - l * C) * E;
            a[5] = (c * H - e * D + f * C) * E;
            a[6] = (u * x - r * A - b * w) * E;
            a[7] = (m * A - p * x + q * w) * E;
            a[8] = (g * G - h * D + l * B) * E;
            a[9] = (d * D - c * G - f * B) * E;
            a[10] = (r * z - t * x + b * v) * E;
            a[11] = (n * x - m * z - q * v) * E;
            a[12] = (h * C - g * F - k * B) * E;
            a[13] = (c * F - d * C + e * B) * E;
            a[14] = (t * w - r * y - u * v) * E;
            a[15] = (m * y - n * w + p * v) * E;
            return a
        },
        adjoint: function(a,
        b) {
            var c = b[0],
                d = b[1],
                e = b[2],
                f = b[3],
                g = b[4],
                h = b[5],
                k = b[6],
                l = b[7],
                m = b[8],
                n = b[9],
                p = b[10],
                q = b[11],
                r = b[12],
                t = b[13],
                u = b[14];
            b = b[15];
            var v = c * h - d * g,
                w = c * k - e * g,
                x = c * l - f * g,
                y = d * k - e * h,
                z = d * l - f * h,
                A = e * l - f * k,
                B = m * t - n * r,
                C = m * u - p * r,
                D = m * b - q * r,
                F = n * u - p * t,
                G = n * b - q * t,
                H = p * b - q * u;
            a[0] = h * H - k * G + l * F;
            a[1] = e * G - d * H - f * F;
            a[2] = t * A - u * z + b * y;
            a[3] = p * z - n * A - q * y;
            a[4] = k * D - g * H - l * C;
            a[5] = c * H - e * D + f * C;
            a[6] = u * x - r * A - b * w;
            a[7] = m * A - p * x + q * w;
            a[8] = g * G - h * D + l * B;
            a[9] = d * D - c * G - f * B;
            a[10] = r * z - t * x + b * v;
            a[11] = n * x - m * z - q * v;
            a[12] = h * C - g * F - k * B;
            a[13] = c * F - d * C + e * B;
            a[14] = t * w -
            r * y - u * v;
            a[15] = m * y - n * w + p * v;
            return a
        },
        determinant: function(a) {
            var b = a[0],
                c = a[1],
                d = a[2],
                e = a[4],
                f = a[5],
                g = a[6],
                h = a[8],
                k = a[9],
                l = a[10],
                m = a[12],
                n = a[13],
                p = a[14],
                q = b * f - c * e,
                r = b * g - d * e,
                t = c * g - d * f,
                u = h * n - k * m,
                v = h * p - l * m,
                w = k * p - l * n;
            return a[7] * (b * w - c * v + d * u) - a[3] * (e * w - f * v + g * u) + a[15] * (h * t - k * r + l * q) - a[11] * (m * t - n * r + p * q)
        },
        multiply: multiply$5,
        translate: function(a, b, c) {
            var d = c[0],
                e = c[1];
            c = c[2];
            if (b === a)
                a[12] = b[0] * d + b[4] * e + b[8] * c + b[12],
                a[13] = b[1] * d + b[5] * e + b[9] * c + b[13],
                a[14] = b[2] * d + b[6] * e + b[10] * c + b[14],
                a[15] = b[3] * d + b[7] * e + b[11] *
                c + b[15];
            else {
                var f = b[0];
                var g = b[1];
                var h = b[2];
                var k = b[3];
                var l = b[4];
                var m = b[5];
                var n = b[6];
                var p = b[7];
                var q = b[8];
                var r = b[9];
                var t = b[10];
                var u = b[11];
                a[0] = f;
                a[1] = g;
                a[2] = h;
                a[3] = k;
                a[4] = l;
                a[5] = m;
                a[6] = n;
                a[7] = p;
                a[8] = q;
                a[9] = r;
                a[10] = t;
                a[11] = u;
                a[12] = f * d + l * e + q * c + b[12];
                a[13] = g * d + m * e + r * c + b[13];
                a[14] = h * d + n * e + t * c + b[14];
                a[15] = k * d + p * e + u * c + b[15]
            }
            return a
        },
        scale: function(a, b, c) {
            var d = c[0],
                e = c[1];
            c = c[2];
            a[0] = b[0] * d;
            a[1] = b[1] * d;
            a[2] = b[2] * d;
            a[3] = b[3] * d;
            a[4] = b[4] * e;
            a[5] = b[5] * e;
            a[6] = b[6] * e;
            a[7] = b[7] * e;
            a[8] = b[8] * c;
            a[9] = b[9] *
            c;
            a[10] = b[10] * c;
            a[11] = b[11] * c;
            a[12] = b[12];
            a[13] = b[13];
            a[14] = b[14];
            a[15] = b[15];
            return a
        },
        rotate: function(a, b, c, d) {
            var e = d[0],
                f = d[1];
            d = d[2];
            var g = Math.hypot(e, f, d);
            if (g < EPSILON$$module$content$working$237635295$scripts$c3runtime)
                return null;
            g = 1 / g;
            e *= g;
            f *= g;
            d *= g;
            var h = Math.sin(c);
            var k = Math.cos(c);
            var l = 1 - k;
            c = b[0];
            g = b[1];
            var m = b[2];
            var n = b[3];
            var p = b[4];
            var q = b[5];
            var r = b[6];
            var t = b[7];
            var u = b[8];
            var v = b[9];
            var w = b[10];
            var x = b[11];
            var y = e * e * l + k;
            var z = f * e * l + d * h;
            var A = d * e * l - f * h;
            var B = e * f * l - d * h;
            var C = f *
            f * l + k;
            var D = d * f * l + e * h;
            var F = e * d * l + f * h;
            e = f * d * l - e * h;
            f = d * d * l + k;
            a[0] = c * y + p * z + u * A;
            a[1] = g * y + q * z + v * A;
            a[2] = m * y + r * z + w * A;
            a[3] = n * y + t * z + x * A;
            a[4] = c * B + p * C + u * D;
            a[5] = g * B + q * C + v * D;
            a[6] = m * B + r * C + w * D;
            a[7] = n * B + t * C + x * D;
            a[8] = c * F + p * e + u * f;
            a[9] = g * F + q * e + v * f;
            a[10] = m * F + r * e + w * f;
            a[11] = n * F + t * e + x * f;
            b !== a && (a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]);
            return a
        },
        rotateX: function(a, b, c) {
            var d = Math.sin(c);
            c = Math.cos(c);
            var e = b[4],
                f = b[5],
                g = b[6],
                h = b[7],
                k = b[8],
                l = b[9],
                m = b[10],
                n = b[11];
            b !== a && (a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[12] =
            b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]);
            a[4] = e * c + k * d;
            a[5] = f * c + l * d;
            a[6] = g * c + m * d;
            a[7] = h * c + n * d;
            a[8] = k * c - e * d;
            a[9] = l * c - f * d;
            a[10] = m * c - g * d;
            a[11] = n * c - h * d;
            return a
        },
        rotateY: function(a, b, c) {
            var d = Math.sin(c);
            c = Math.cos(c);
            var e = b[0],
                f = b[1],
                g = b[2],
                h = b[3],
                k = b[8],
                l = b[9],
                m = b[10],
                n = b[11];
            b !== a && (a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]);
            a[0] = e * c - k * d;
            a[1] = f * c - l * d;
            a[2] = g * c - m * d;
            a[3] = h * c - n * d;
            a[8] = e * d + k * c;
            a[9] = f * d + l * c;
            a[10] = g * d + m * c;
            a[11] = h * d + n * c;
            return a
        },
        rotateZ: function(a,
        b, c) {
            var d = Math.sin(c);
            c = Math.cos(c);
            var e = b[0],
                f = b[1],
                g = b[2],
                h = b[3],
                k = b[4],
                l = b[5],
                m = b[6],
                n = b[7];
            b !== a && (a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] = b[13], a[14] = b[14], a[15] = b[15]);
            a[0] = e * c + k * d;
            a[1] = f * c + l * d;
            a[2] = g * c + m * d;
            a[3] = h * c + n * d;
            a[4] = k * c - e * d;
            a[5] = l * c - f * d;
            a[6] = m * c - g * d;
            a[7] = n * c - h * d;
            return a
        },
        fromTranslation: function(a, b) {
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = 1;
            a[6] = 0;
            a[7] = 0;
            a[8] = 0;
            a[9] = 0;
            a[10] = 1;
            a[11] = 0;
            a[12] = b[0];
            a[13] = b[1];
            a[14] = b[2];
            a[15] = 1;
            return a
        },
        fromScaling: function(a,
        b) {
            a[0] = b[0];
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = b[1];
            a[6] = 0;
            a[7] = 0;
            a[8] = 0;
            a[9] = 0;
            a[10] = b[2];
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return a
        },
        fromRotation: function(a, b, c) {
            var d = c[0],
                e = c[1];
            c = c[2];
            var f = Math.hypot(d, e, c);
            if (f < EPSILON$$module$content$working$237635295$scripts$c3runtime)
                return null;
            f = 1 / f;
            d *= f;
            e *= f;
            c *= f;
            f = Math.sin(b);
            b = Math.cos(b);
            var g = 1 - b;
            a[0] = d * d * g + b;
            a[1] = e * d * g + c * f;
            a[2] = c * d * g - e * f;
            a[3] = 0;
            a[4] = d * e * g - c * f;
            a[5] = e * e * g + b;
            a[6] = c * e * g + d * f;
            a[7] = 0;
            a[8] = d * c * g + e * f;
            a[9] = e * c * g - d * f;
            a[10] = c * c * g + b;
            a[11] =
            0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return a
        },
        fromXRotation: function(a, b) {
            var c = Math.sin(b);
            b = Math.cos(b);
            a[0] = 1;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = b;
            a[6] = c;
            a[7] = 0;
            a[8] = 0;
            a[9] = -c;
            a[10] = b;
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return a
        },
        fromYRotation: function(a, b) {
            var c = Math.sin(b);
            b = Math.cos(b);
            a[0] = b;
            a[1] = 0;
            a[2] = -c;
            a[3] = 0;
            a[4] = 0;
            a[5] = 1;
            a[6] = 0;
            a[7] = 0;
            a[8] = c;
            a[9] = 0;
            a[10] = b;
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return a
        },
        fromZRotation: function(a, b) {
            var c = Math.sin(b);
            b = Math.cos(b);
            a[0] = b;
            a[1] = c;
            a[2] =
            0;
            a[3] = 0;
            a[4] = -c;
            a[5] = b;
            a[6] = 0;
            a[7] = 0;
            a[8] = 0;
            a[9] = 0;
            a[10] = 1;
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return a
        },
        fromRotationTranslation: fromRotationTranslation$1,
        fromQuat2: function(a, b) {
            var c = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(3),
                d = -b[0],
                e = -b[1],
                f = -b[2],
                g = b[3],
                h = b[4],
                k = b[5],
                l = b[6],
                m = b[7],
                n = d * d + e * e + f * f + g * g;
            0 < n ? (c[0] = 2 * (h * g + m * d + k * f - l * e) / n, c[1] = 2 * (k * g + m * e + l * d - h * f) / n, c[2] = 2 * (l * g + m * f + h * e - k * d) / n) : (c[0] = 2 * (h * g + m * d + k * f - l * e), c[1] = 2 * (k * g + m * e + l * d - h * f), c[2] = 2 * (l * g + m * f + h * e - k * d));
            fromRotationTranslation$1(a, b, c);
            return a
        },
        getTranslation: getTranslation$1,
        getScaling,
        getRotation,
        decompose: function(a, b, c, d) {
            b[0] = d[12];
            b[1] = d[13];
            b[2] = d[14];
            var e = d[0],
                f = d[1],
                g = d[2],
                h = d[4],
                k = d[5],
                l = d[6],
                m = d[8];
            b = d[9];
            d = d[10];
            c[0] = Math.hypot(e, f, g);
            c[1] = Math.hypot(h, k, l);
            c[2] = Math.hypot(m, b, d);
            var n = 1 / c[0],
                p = 1 / c[1],
                q = 1 / c[2];
            c = e * n;
            f *= p;
            g *= q;
            h *= n;
            k *= p;
            l *= q;
            m *= n;
            b *= p;
            d *= q;
            p = c + k + d;
            0 < p ? (d = 2 * Math.sqrt(p + 1), a[3] = .25 * d, a[0] = (l - b) / d, a[1] = (m - g) / d, a[2] = (f - h) / d) : c > k && c > d ? (d = 2 * Math.sqrt(1 + c - k - d), a[3] = (l - b) / d,
            a[0] = .25 * d, a[1] = (f + h) / d, a[2] = (m + g) / d) : k > d ? (d = 2 * Math.sqrt(1 + k - c - d), a[3] = (m - g) / d, a[0] = (f + h) / d, a[1] = .25 * d, a[2] = (l + b) / d) : (d = 2 * Math.sqrt(1 + d - c - k), a[3] = (f - h) / d, a[0] = (m + g) / d, a[1] = (l + b) / d, a[2] = .25 * d);
            return a
        },
        fromRotationTranslationScale: function(a, b, c, d) {
            var e = b[0],
                f = b[1],
                g = b[2],
                h = b[3],
                k = e + e,
                l = f + f,
                m = g + g;
            b = e * k;
            var n = e * l;
            e *= m;
            var p = f * l;
            f *= m;
            g *= m;
            k *= h;
            l *= h;
            h *= m;
            m = d[0];
            var q = d[1];
            d = d[2];
            a[0] = (1 - (p + g)) * m;
            a[1] = (n + h) * m;
            a[2] = (e - l) * m;
            a[3] = 0;
            a[4] = (n - h) * q;
            a[5] = (1 - (b + g)) * q;
            a[6] = (f + k) * q;
            a[7] = 0;
            a[8] = (e + l) * d;
            a[9] = (f -
            k) * d;
            a[10] = (1 - (b + p)) * d;
            a[11] = 0;
            a[12] = c[0];
            a[13] = c[1];
            a[14] = c[2];
            a[15] = 1;
            return a
        },
        fromRotationTranslationScaleOrigin: function(a, b, c, d, e) {
            var f = b[0],
                g = b[1],
                h = b[2],
                k = b[3],
                l = f + f,
                m = g + g,
                n = h + h;
            b = f * l;
            var p = f * m,
                q = f * n;
            f = g * m;
            g *= n;
            var r = h * n;
            h = k * l;
            m *= k;
            var t = k * n,
                u = d[0],
                v = d[1];
            n = d[2];
            d = e[0];
            k = e[1];
            e = e[2];
            l = (1 - (f + r)) * u;
            var w = (p + t) * u;
            u *= q - m;
            p = (p - t) * v;
            r = (1 - (b + r)) * v;
            v *= g + h;
            q = (q + m) * n;
            g = (g - h) * n;
            b = (1 - (b + f)) * n;
            a[0] = l;
            a[1] = w;
            a[2] = u;
            a[3] = 0;
            a[4] = p;
            a[5] = r;
            a[6] = v;
            a[7] = 0;
            a[8] = q;
            a[9] = g;
            a[10] = b;
            a[11] = 0;
            a[12] = c[0] + d - (l * d + p * k +
            q * e);
            a[13] = c[1] + k - (w * d + r * k + g * e);
            a[14] = c[2] + e - (u * d + v * k + b * e);
            a[15] = 1;
            return a
        },
        fromQuat: function(a, b) {
            var c = b[0],
                d = b[1],
                e = b[2];
            b = b[3];
            var f = c + c,
                g = d + d,
                h = e + e;
            c *= f;
            var k = d * f;
            d *= g;
            var l = e * f,
                m = e * g;
            e *= h;
            f *= b;
            g *= b;
            b *= h;
            a[0] = 1 - d - e;
            a[1] = k + b;
            a[2] = l - g;
            a[3] = 0;
            a[4] = k - b;
            a[5] = 1 - c - e;
            a[6] = m + f;
            a[7] = 0;
            a[8] = l + g;
            a[9] = m - f;
            a[10] = 1 - c - d;
            a[11] = 0;
            a[12] = 0;
            a[13] = 0;
            a[14] = 0;
            a[15] = 1;
            return a
        },
        frustum: function(a, b, c, d, e, f, g) {
            var h = 1 / (c - b),
                k = 1 / (e - d),
                l = 1 / (f - g);
            a[0] = 2 * f * h;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = 2 * f * k;
            a[6] = 0;
            a[7] = 0;
            a[8] = (c + b) *
            h;
            a[9] = (e + d) * k;
            a[10] = (g + f) * l;
            a[11] = -1;
            a[12] = 0;
            a[13] = 0;
            a[14] = g * f * 2 * l;
            a[15] = 0;
            return a
        },
        perspectiveNO,
        perspective: perspective$$module$content$working$237635295$scripts$c3runtime,
        perspectiveZO: function(a, b, c, d, e) {
            b = 1 / Math.tan(b / 2);
            a[0] = b / c;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = b;
            a[6] = 0;
            a[7] = 0;
            a[8] = 0;
            a[9] = 0;
            a[11] = -1;
            a[12] = 0;
            a[13] = 0;
            a[15] = 0;
            null != e && Infinity !== e ? (c = 1 / (d - e), a[10] = e * c, a[14] = e * d * c) : (a[10] = -1, a[14] = -d);
            return a
        },
        perspectiveFromFieldOfView: function(a, b, c, d) {
            var e = Math.tan(b.upDegrees * Math.PI / 180),
                f = Math.tan(b.downDegrees * Math.PI / 180),
                g = Math.tan(b.leftDegrees * Math.PI / 180);
            b = Math.tan(b.rightDegrees * Math.PI / 180);
            var h = 2 / (g + b),
                k = 2 / (e + f);
            a[0] = h;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = k;
            a[6] = 0;
            a[7] = 0;
            a[8] = -((g - b) * h * .5);
            a[9] = (e - f) * k * .5;
            a[10] = d / (c - d);
            a[11] = -1;
            a[12] = 0;
            a[13] = 0;
            a[14] = d * c / (c - d);
            a[15] = 0;
            return a
        },
        orthoNO,
        ortho: ortho$$module$content$working$237635295$scripts$c3runtime,
        orthoZO: function(a, b, c, d, e, f, g) {
            var h = 1 / (b - c),
                k = 1 / (d - e);
            g = 1 / (f - g);
            a[0] = -2 * h;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            a[4] = 0;
            a[5] = -2 * k;
            a[6] = 0;
            a[7] =
            0;
            a[8] = 0;
            a[9] = 0;
            a[10] = g;
            a[11] = 0;
            a[12] = (b + c) * h;
            a[13] = (e + d) * k;
            a[14] = f * g;
            a[15] = 1;
            return a
        },
        lookAt: function(a, b, c, d) {
            var e = b[0],
                f = b[1];
            b = b[2];
            var g = d[0];
            var h = d[1];
            var k = d[2];
            var l = c[0];
            d = c[1];
            var m = c[2];
            if (Math.abs(e - l) < EPSILON$$module$content$working$237635295$scripts$c3runtime && Math.abs(f - d) < EPSILON$$module$content$working$237635295$scripts$c3runtime && Math.abs(b - m) < EPSILON$$module$content$working$237635295$scripts$c3runtime)
                return identity$2(a);
            c = e - l;
            d = f - d;
            l = b - m;
            var n = 1 / Math.hypot(c, d, l);
            c *= n;
            d *= n;
            l *= n;
            m = h * l - k * d;
            k = k * c - g * l;
            g = g * d - h * c;
            (n = Math.hypot(m, k, g)) ? (n = 1 / n, m *= n, k *= n, g *= n) : g = k = m = 0;
            h = d * g - l * k;
            var p = l * m - c * g;
            var q = c * k - d * m;
            (n = Math.hypot(h, p, q)) ? (n = 1 / n, h *= n, p *= n, q *= n) : q = p = h = 0;
            a[0] = m;
            a[1] = h;
            a[2] = c;
            a[3] = 0;
            a[4] = k;
            a[5] = p;
            a[6] = d;
            a[7] = 0;
            a[8] = g;
            a[9] = q;
            a[10] = l;
            a[11] = 0;
            a[12] = -(m * e + k * f + g * b);
            a[13] = -(h * e + p * f + q * b);
            a[14] = -(c * e + d * f + l * b);
            a[15] = 1;
            return a
        },
        targetTo: function(a, b, c, d) {
            var e = b[0],
                f = b[1];
            b = b[2];
            var g = d[0],
                h = d[1],
                k = d[2];
            d = e - c[0];
            var l = f - c[1];
            c = b - c[2];
            var m = d * d + l * l + c * c;
            0 < m && (m = 1 / Math.sqrt(m), d *= m, l *=
            m, c *= m);
            var n = h * c - k * l;
            k = k * d - g * c;
            g = g * l - h * d;
            m = n * n + k * k + g * g;
            0 < m && (m = 1 / Math.sqrt(m), n *= m, k *= m, g *= m);
            a[0] = n;
            a[1] = k;
            a[2] = g;
            a[3] = 0;
            a[4] = l * g - c * k;
            a[5] = c * n - d * g;
            a[6] = d * k - l * n;
            a[7] = 0;
            a[8] = d;
            a[9] = l;
            a[10] = c;
            a[11] = 0;
            a[12] = e;
            a[13] = f;
            a[14] = b;
            a[15] = 1;
            return a
        },
        str: function(a) {
            return "mat4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ", " + a[8] + ", " + a[9] + ", " + a[10] + ", " + a[11] + ", " + a[12] + ", " + a[13] + ", " + a[14] + ", " + a[15] + ")"
        },
        frob: function(a) {
            return Math.hypot(a[0], a[1], a[2], a[3], a[4], a[5],
            a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15])
        },
        add: function(a, b, c) {
            a[0] = b[0] + c[0];
            a[1] = b[1] + c[1];
            a[2] = b[2] + c[2];
            a[3] = b[3] + c[3];
            a[4] = b[4] + c[4];
            a[5] = b[5] + c[5];
            a[6] = b[6] + c[6];
            a[7] = b[7] + c[7];
            a[8] = b[8] + c[8];
            a[9] = b[9] + c[9];
            a[10] = b[10] + c[10];
            a[11] = b[11] + c[11];
            a[12] = b[12] + c[12];
            a[13] = b[13] + c[13];
            a[14] = b[14] + c[14];
            a[15] = b[15] + c[15];
            return a
        },
        subtract: subtract$3,
        multiplyScalar: function(a, b, c) {
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            a[2] = b[2] * c;
            a[3] = b[3] * c;
            a[4] = b[4] * c;
            a[5] = b[5] * c;
            a[6] = b[6] * c;
            a[7] = b[7] * c;
            a[8] = b[8] *
            c;
            a[9] = b[9] * c;
            a[10] = b[10] * c;
            a[11] = b[11] * c;
            a[12] = b[12] * c;
            a[13] = b[13] * c;
            a[14] = b[14] * c;
            a[15] = b[15] * c;
            return a
        },
        multiplyScalarAndAdd: function(a, b, c, d) {
            a[0] = b[0] + c[0] * d;
            a[1] = b[1] + c[1] * d;
            a[2] = b[2] + c[2] * d;
            a[3] = b[3] + c[3] * d;
            a[4] = b[4] + c[4] * d;
            a[5] = b[5] + c[5] * d;
            a[6] = b[6] + c[6] * d;
            a[7] = b[7] + c[7] * d;
            a[8] = b[8] + c[8] * d;
            a[9] = b[9] + c[9] * d;
            a[10] = b[10] + c[10] * d;
            a[11] = b[11] + c[11] * d;
            a[12] = b[12] + c[12] * d;
            a[13] = b[13] + c[13] * d;
            a[14] = b[14] + c[14] * d;
            a[15] = b[15] + c[15] * d;
            return a
        },
        exactEquals: function(a, b) {
            return a[0] === b[0] && a[1] === b[1] &&
                a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15]
        },
        equals: function(a, b) {
            var c = a[0],
                d = a[1],
                e = a[2],
                f = a[3],
                g = a[4],
                h = a[5],
                k = a[6],
                l = a[7],
                m = a[8],
                n = a[9],
                p = a[10],
                q = a[11],
                r = a[12],
                t = a[13],
                u = a[14];
            a = a[15];
            var v = b[0],
                w = b[1],
                x = b[2],
                y = b[3],
                z = b[4],
                A = b[5],
                B = b[6],
                C = b[7],
                D = b[8],
                F = b[9],
                G = b[10],
                H = b[11],
                E = b[12],
                I = b[13],
                J = b[14];
            b = b[15];
            return Math.abs(c - v) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(c), Math.abs(v)) && Math.abs(d - w) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(d), Math.abs(w)) && Math.abs(e - x) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(e), Math.abs(x)) && Math.abs(f - y) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(f), Math.abs(y)) && Math.abs(g - z) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(g), Math.abs(z)) && Math.abs(h - A) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(h), Math.abs(A)) && Math.abs(k - B) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(k), Math.abs(B)) && Math.abs(l - C) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(l), Math.abs(C)) && Math.abs(m - D) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(m), Math.abs(D)) && Math.abs(n - F) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(n), Math.abs(F)) && Math.abs(p - G) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(p), Math.abs(G)) && Math.abs(q - H) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(q), Math.abs(H)) && Math.abs(r - E) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(r), Math.abs(E)) && Math.abs(t - I) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(t), Math.abs(I)) && Math.abs(u - J) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(u), Math.abs(J)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(a), Math.abs(b))
        },
        mul: mul$5$$module$content$working$237635295$scripts$c3runtime,
        sub: sub$3$$module$content$working$237635295$scripts$c3runtime
    });
function create$4() {
    var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(3);
    ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0);
    return a
}
function length$4(a) {
    return Math.hypot(a[0], a[1], a[2])
}
function fromValues$4(a, b, c) {
    var d = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(3);
    d[0] = a;
    d[1] = b;
    d[2] = c;
    return d
}
function subtract$2(a, b, c) {
    a[0] = b[0] - c[0];
    a[1] = b[1] - c[1];
    a[2] = b[2] - c[2];
    return a
}
function multiply$4(a, b, c) {
    a[0] = b[0] * c[0];
    a[1] = b[1] * c[1];
    a[2] = b[2] * c[2];
    return a
}
function divide$2(a, b, c) {
    a[0] = b[0] / c[0];
    a[1] = b[1] / c[1];
    a[2] = b[2] / c[2];
    return a
}
function distance$2(a, b) {
    return Math.hypot(b[0] - a[0], b[1] - a[1], b[2] - a[2])
}
function squaredDistance$2(a, b) {
    var c = b[0] - a[0],
        d = b[1] - a[1];
    a = b[2] - a[2];
    return c * c + d * d + a * a
}
function squaredLength$4(a) {
    var b = a[0],
        c = a[1];
    a = a[2];
    return b * b + c * c + a * a
}
function normalize$4(a, b) {
    var c = b[0],
        d = b[1],
        e = b[2];
    c = c * c + d * d + e * e;
    0 < c && (c = 1 / Math.sqrt(c));
    a[0] = b[0] * c;
    a[1] = b[1] * c;
    a[2] = b[2] * c;
    return a
}
function dot$4(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}
function cross$2(a, b, c) {
    var d = b[0],
        e = b[1];
    b = b[2];
    var f = c[0],
        g = c[1];
    c = c[2];
    a[0] = e * c - b * g;
    a[1] = b * f - d * c;
    a[2] = d * g - e * f;
    return a
}
var sub$2$$module$content$working$237635295$scripts$c3runtime = subtract$2,
    mul$4$$module$content$working$237635295$scripts$c3runtime = multiply$4,
    div$2$$module$content$working$237635295$scripts$c3runtime = divide$2,
    dist$2$$module$content$working$237635295$scripts$c3runtime = distance$2,
    sqrDist$2$$module$content$working$237635295$scripts$c3runtime = squaredDistance$2,
    len$4$$module$content$working$237635295$scripts$c3runtime = length$4,
    sqrLen$4$$module$content$working$237635295$scripts$c3runtime = squaredLength$4,
    forEach$2$$module$content$working$237635295$scripts$c3runtime = function() {
        var a = create$4();
        return function(b, c, d, e, f, g) {
            c || (c = 3);
            d || (d = 0);
            for (e = e ? Math.min(e * c + d, b.length) : b.length; d < e; d += c)
                a[0] = b[d],
                a[1] = b[d + 1],
                a[2] = b[d + 2],
                f(a, a, g),
                b[d] = a[0],
                b[d + 1] = a[1],
                b[d + 2] = a[2];
            return b
        }
    }(),
    vec3$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: create$4,
        clone: function(a) {
            var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(3);
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            return b
        },
        length: length$4,
        fromValues: fromValues$4,
        copy: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            return a
        },
        set: function(a, b, c, d) {
            a[0] = b;
            a[1] = c;
            a[2] = d;
            return a
        },
        add: function(a, b, c) {
            a[0] = b[0] + c[0];
            a[1] = b[1] + c[1];
            a[2] = b[2] + c[2];
            return a
        },
        subtract: subtract$2,
        multiply: multiply$4,
        divide: divide$2,
        ceil: function(a, b) {
            a[0] = Math.ceil(b[0]);
            a[1] = Math.ceil(b[1]);
            a[2] = Math.ceil(b[2]);
            return a
        },
        floor: function(a, b) {
            a[0] = Math.floor(b[0]);
            a[1] = Math.floor(b[1]);
            a[2] = Math.floor(b[2]);
            return a
        },
        min: function(a, b, c) {
            a[0] =
            Math.min(b[0], c[0]);
            a[1] = Math.min(b[1], c[1]);
            a[2] = Math.min(b[2], c[2]);
            return a
        },
        max: function(a, b, c) {
            a[0] = Math.max(b[0], c[0]);
            a[1] = Math.max(b[1], c[1]);
            a[2] = Math.max(b[2], c[2]);
            return a
        },
        round: function(a, b) {
            a[0] = Math.round(b[0]);
            a[1] = Math.round(b[1]);
            a[2] = Math.round(b[2]);
            return a
        },
        scale: function(a, b, c) {
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            a[2] = b[2] * c;
            return a
        },
        scaleAndAdd: function(a, b, c, d) {
            a[0] = b[0] + c[0] * d;
            a[1] = b[1] + c[1] * d;
            a[2] = b[2] + c[2] * d;
            return a
        },
        distance: distance$2,
        squaredDistance: squaredDistance$2,
        squaredLength: squaredLength$4,
        negate: function(a, b) {
            a[0] = -b[0];
            a[1] = -b[1];
            a[2] = -b[2];
            return a
        },
        inverse: function(a, b) {
            a[0] = 1 / b[0];
            a[1] = 1 / b[1];
            a[2] = 1 / b[2];
            return a
        },
        normalize: normalize$4,
        dot: dot$4,
        cross: cross$2,
        lerp: function(a, b, c, d) {
            var e = b[0],
                f = b[1];
            b = b[2];
            a[0] = e + d * (c[0] - e);
            a[1] = f + d * (c[1] - f);
            a[2] = b + d * (c[2] - b);
            return a
        },
        slerp: function(a, b, c, d) {
            var e = Math.acos(Math.min(Math.max(dot$4(b, c), -1), 1)),
                f = Math.sin(e),
                g = Math.sin((1 - d) * e) / f;
            d = Math.sin(d * e) / f;
            a[0] = g * b[0] + d * c[0];
            a[1] = g * b[1] + d * c[1];
            a[2] = g * b[2] + d * c[2];
            return a
        },
        hermite: function(a,
        b, c, d, e, f) {
            var g = f * f,
                h = g * (2 * f - 3) + 1,
                k = g * (f - 2) + f,
                l = g * (f - 1);
            f = g * (3 - 2 * f);
            a[0] = b[0] * h + c[0] * k + d[0] * l + e[0] * f;
            a[1] = b[1] * h + c[1] * k + d[1] * l + e[1] * f;
            a[2] = b[2] * h + c[2] * k + d[2] * l + e[2] * f;
            return a
        },
        bezier: function(a, b, c, d, e, f) {
            var g = 1 - f,
                h = g * g,
                k = f * f,
                l = h * g;
            h *= 3 * f;
            g *= 3 * k;
            f *= k;
            a[0] = b[0] * l + c[0] * h + d[0] * g + e[0] * f;
            a[1] = b[1] * l + c[1] * h + d[1] * g + e[1] * f;
            a[2] = b[2] * l + c[2] * h + d[2] * g + e[2] * f;
            return a
        },
        random: function(a, b) {
            b = b || 1;
            var c = 2 * RANDOM$$module$content$working$237635295$scripts$c3runtime() * Math.PI,
                d = 2 * RANDOM$$module$content$working$237635295$scripts$c3runtime() -
                1,
                e = Math.sqrt(1 - d * d) * b;
            a[0] = Math.cos(c) * e;
            a[1] = Math.sin(c) * e;
            a[2] = d * b;
            return a
        },
        transformMat4: function(a, b, c) {
            var d = b[0],
                e = b[1];
            b = b[2];
            var f = c[3] * d + c[7] * e + c[11] * b + c[15];
            f = f || 1;
            a[0] = (c[0] * d + c[4] * e + c[8] * b + c[12]) / f;
            a[1] = (c[1] * d + c[5] * e + c[9] * b + c[13]) / f;
            a[2] = (c[2] * d + c[6] * e + c[10] * b + c[14]) / f;
            return a
        },
        transformMat3: function(a, b, c) {
            var d = b[0],
                e = b[1];
            b = b[2];
            a[0] = d * c[0] + e * c[3] + b * c[6];
            a[1] = d * c[1] + e * c[4] + b * c[7];
            a[2] = d * c[2] + e * c[5] + b * c[8];
            return a
        },
        transformQuat: function(a, b, c) {
            var d = c[0],
                e = c[1],
                f = c[2],
                g = b[0],
                h =
                b[1];
            b = b[2];
            var k = e * b - f * h,
                l = f * g - d * b,
                m = d * h - e * g;
            c = 2 * c[3];
            a[0] = g + k * c + 2 * (e * m - f * l);
            a[1] = h + l * c + 2 * (f * k - d * m);
            a[2] = b + m * c + 2 * (d * l - e * k);
            return a
        },
        rotateX: function(a, b, c, d) {
            var e = [],
                f = [];
            e[0] = b[0] - c[0];
            e[1] = b[1] - c[1];
            e[2] = b[2] - c[2];
            f[0] = e[0];
            f[1] = e[1] * Math.cos(d) - e[2] * Math.sin(d);
            f[2] = e[1] * Math.sin(d) + e[2] * Math.cos(d);
            a[0] = f[0] + c[0];
            a[1] = f[1] + c[1];
            a[2] = f[2] + c[2];
            return a
        },
        rotateY: function(a, b, c, d) {
            var e = [],
                f = [];
            e[0] = b[0] - c[0];
            e[1] = b[1] - c[1];
            e[2] = b[2] - c[2];
            f[0] = e[2] * Math.sin(d) + e[0] * Math.cos(d);
            f[1] = e[1];
            f[2] =
            e[2] * Math.cos(d) - e[0] * Math.sin(d);
            a[0] = f[0] + c[0];
            a[1] = f[1] + c[1];
            a[2] = f[2] + c[2];
            return a
        },
        rotateZ: function(a, b, c, d) {
            var e = [],
                f = [];
            e[0] = b[0] - c[0];
            e[1] = b[1] - c[1];
            e[2] = b[2] - c[2];
            f[0] = e[0] * Math.cos(d) - e[1] * Math.sin(d);
            f[1] = e[0] * Math.sin(d) + e[1] * Math.cos(d);
            f[2] = e[2];
            a[0] = f[0] + c[0];
            a[1] = f[1] + c[1];
            a[2] = f[2] + c[2];
            return a
        },
        angle: function(a, b) {
            var c = a[0],
                d = a[1],
                e = a[2],
                f = b[0],
                g = b[1],
                h = b[2];
            a = (c = Math.sqrt((c * c + d * d + e * e) * (f * f + g * g + h * h))) && dot$4(a, b) / c;
            return Math.acos(Math.min(Math.max(a, -1), 1))
        },
        zero: function(a) {
            a[0] =
            0;
            a[1] = 0;
            a[2] = 0;
            return a
        },
        str: function(a) {
            return "vec3(" + a[0] + ", " + a[1] + ", " + a[2] + ")"
        },
        exactEquals: function(a, b) {
            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
        },
        equals: function(a, b) {
            var c = a[0],
                d = a[1];
            a = a[2];
            var e = b[0],
                f = b[1];
            b = b[2];
            return Math.abs(c - e) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(c), Math.abs(e)) && Math.abs(d - f) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(d), Math.abs(f)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(a), Math.abs(b))
        },
        sub: sub$2$$module$content$working$237635295$scripts$c3runtime,
        mul: mul$4$$module$content$working$237635295$scripts$c3runtime,
        div: div$2$$module$content$working$237635295$scripts$c3runtime,
        dist: dist$2$$module$content$working$237635295$scripts$c3runtime,
        sqrDist: sqrDist$2$$module$content$working$237635295$scripts$c3runtime,
        len: len$4$$module$content$working$237635295$scripts$c3runtime,
        sqrLen: sqrLen$4$$module$content$working$237635295$scripts$c3runtime,
        forEach: forEach$2$$module$content$working$237635295$scripts$c3runtime
    });
function create$3() {
    var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(4);
    ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0);
    return a
}
function clone$3(a) {
    var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(4);
    b[0] = a[0];
    b[1] = a[1];
    b[2] = a[2];
    b[3] = a[3];
    return b
}
function fromValues$3(a, b, c, d) {
    var e = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(4);
    e[0] = a;
    e[1] = b;
    e[2] = c;
    e[3] = d;
    return e
}
function copy$3(a, b) {
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    return a
}
function set$3(a, b, c, d, e) {
    a[0] = b;
    a[1] = c;
    a[2] = d;
    a[3] = e;
    return a
}
function add$3(a, b, c) {
    a[0] = b[0] + c[0];
    a[1] = b[1] + c[1];
    a[2] = b[2] + c[2];
    a[3] = b[3] + c[3];
    return a
}
function subtract$1(a, b, c) {
    a[0] = b[0] - c[0];
    a[1] = b[1] - c[1];
    a[2] = b[2] - c[2];
    a[3] = b[3] - c[3];
    return a
}
function multiply$3(a, b, c) {
    a[0] = b[0] * c[0];
    a[1] = b[1] * c[1];
    a[2] = b[2] * c[2];
    a[3] = b[3] * c[3];
    return a
}
function divide$1(a, b, c) {
    a[0] = b[0] / c[0];
    a[1] = b[1] / c[1];
    a[2] = b[2] / c[2];
    a[3] = b[3] / c[3];
    return a
}
function scale$3(a, b, c) {
    a[0] = b[0] * c;
    a[1] = b[1] * c;
    a[2] = b[2] * c;
    a[3] = b[3] * c;
    return a
}
function distance$1(a, b) {
    return Math.hypot(b[0] - a[0], b[1] - a[1], b[2] - a[2], b[3] - a[3])
}
function squaredDistance$1(a, b) {
    var c = b[0] - a[0],
        d = b[1] - a[1],
        e = b[2] - a[2];
    a = b[3] - a[3];
    return c * c + d * d + e * e + a * a
}
function length$3(a) {
    return Math.hypot(a[0], a[1], a[2], a[3])
}
function squaredLength$3(a) {
    var b = a[0],
        c = a[1],
        d = a[2];
    a = a[3];
    return b * b + c * c + d * d + a * a
}
function normalize$3(a, b) {
    var c = b[0],
        d = b[1],
        e = b[2];
    b = b[3];
    var f = c * c + d * d + e * e + b * b;
    0 < f && (f = 1 / Math.sqrt(f));
    a[0] = c * f;
    a[1] = d * f;
    a[2] = e * f;
    a[3] = b * f;
    return a
}
function dot$3(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]
}
function lerp$3(a, b, c, d) {
    var e = b[0],
        f = b[1],
        g = b[2];
    b = b[3];
    a[0] = e + d * (c[0] - e);
    a[1] = f + d * (c[1] - f);
    a[2] = g + d * (c[2] - g);
    a[3] = b + d * (c[3] - b);
    return a
}
function exactEquals$3(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3]
}
var sub$1$$module$content$working$237635295$scripts$c3runtime = subtract$1,
    mul$3$$module$content$working$237635295$scripts$c3runtime = multiply$3,
    div$1$$module$content$working$237635295$scripts$c3runtime = divide$1,
    dist$1$$module$content$working$237635295$scripts$c3runtime = distance$1,
    sqrDist$1$$module$content$working$237635295$scripts$c3runtime = squaredDistance$1,
    len$3$$module$content$working$237635295$scripts$c3runtime = length$3,
    sqrLen$3$$module$content$working$237635295$scripts$c3runtime = squaredLength$3,
    forEach$1$$module$content$working$237635295$scripts$c3runtime = function() {
        var a = create$3();
        return function(b, c, d, e, f, g) {
            c || (c = 4);
            d || (d = 0);
            for (e = e ? Math.min(e * c + d, b.length) : b.length; d < e; d += c)
                a[0] = b[d],
                a[1] = b[d + 1],
                a[2] = b[d + 2],
                a[3] = b[d + 3],
                f(a, a, g),
                b[d] = a[0],
                b[d + 1] = a[1],
                b[d + 2] = a[2],
                b[d + 3] = a[3];
            return b
        }
    }(),
    vec4$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: create$3,
        clone: clone$3,
        fromValues: fromValues$3,
        copy: copy$3,
        set: set$3,
        add: add$3,
        subtract: subtract$1,
        multiply: multiply$3,
        divide: divide$1,
        ceil: function(a, b) {
            a[0] = Math.ceil(b[0]);
            a[1] = Math.ceil(b[1]);
            a[2] = Math.ceil(b[2]);
            a[3] = Math.ceil(b[3]);
            return a
        },
        floor: function(a, b) {
            a[0] = Math.floor(b[0]);
            a[1] = Math.floor(b[1]);
            a[2] = Math.floor(b[2]);
            a[3] = Math.floor(b[3]);
            return a
        },
        min: function(a, b, c) {
            a[0] = Math.min(b[0], c[0]);
            a[1] = Math.min(b[1], c[1]);
            a[2] = Math.min(b[2], c[2]);
            a[3] = Math.min(b[3], c[3]);
            return a
        },
        max: function(a, b, c) {
            a[0] = Math.max(b[0], c[0]);
            a[1] = Math.max(b[1], c[1]);
            a[2] = Math.max(b[2], c[2]);
            a[3] = Math.max(b[3], c[3]);
            return a
        },
        round: function(a, b) {
            a[0] = Math.round(b[0]);
            a[1] = Math.round(b[1]);
            a[2] = Math.round(b[2]);
            a[3] = Math.round(b[3]);
            return a
        },
        scale: scale$3,
        scaleAndAdd: function(a, b, c, d) {
            a[0] = b[0] + c[0] * d;
            a[1] = b[1] + c[1] * d;
            a[2] = b[2] + c[2] * d;
            a[3] = b[3] + c[3] * d;
            return a
        },
        distance: distance$1,
        squaredDistance: squaredDistance$1,
        length: length$3,
        squaredLength: squaredLength$3,
        negate: function(a, b) {
            a[0] = -b[0];
            a[1] = -b[1];
            a[2] = -b[2];
            a[3] = -b[3];
            return a
        },
        inverse: function(a, b) {
            a[0] = 1 / b[0];
            a[1] = 1 / b[1];
            a[2] = 1 / b[2];
            a[3] = 1 / b[3];
            return a
        },
        normalize: normalize$3,
        dot: dot$3,
        cross: function(a, b, c, d) {
            var e = c[0] * d[1] - c[1] * d[0],
                f = c[0] * d[2] - c[2] * d[0],
                g = c[0] * d[3] - c[3] * d[0],
                h = c[1] * d[2] - c[2] * d[1],
                k = c[1] * d[3] - c[3] * d[1];
            c = c[2] * d[3] - c[3] * d[2];
            d = b[0];
            var l = b[1],
                m = b[2];
            b = b[3];
            a[0] = l * c - m * k + b * h;
            a[1] = -(d * c) + m * g - b * f;
            a[2] = d * k - l * g + b * e;
            a[3] = -(d * h) + l * f - m * e;
            return a
        },
        lerp: lerp$3,
        random: function(a, b) {
            b = b || 1;
            do {
                var c = 2 * RANDOM$$module$content$working$237635295$scripts$c3runtime() - 1;
                var d = 2 * RANDOM$$module$content$working$237635295$scripts$c3runtime() - 1;
                var e = c * c + d * d
            } while (1 <= e);
            do {
                var f =
                2 * RANDOM$$module$content$working$237635295$scripts$c3runtime() - 1;
                var g = 2 * RANDOM$$module$content$working$237635295$scripts$c3runtime() - 1;
                var h = f * f + g * g
            } while (1 <= h);
            e = Math.sqrt((1 - e) / h);
            a[0] = b * c;
            a[1] = b * d;
            a[2] = b * f * e;
            a[3] = b * g * e;
            return a
        },
        transformMat4: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2];
            b = b[3];
            a[0] = c[0] * d + c[4] * e + c[8] * f + c[12] * b;
            a[1] = c[1] * d + c[5] * e + c[9] * f + c[13] * b;
            a[2] = c[2] * d + c[6] * e + c[10] * f + c[14] * b;
            a[3] = c[3] * d + c[7] * e + c[11] * f + c[15] * b;
            return a
        },
        transformQuat: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2],
                g = c[0],
                h = c[1],
                k = c[2];
            c = c[3];
            var l = c * d + h * f - k * e,
                m = c * e + k * d - g * f,
                n = c * f + g * e - h * d;
            d = -g * d - h * e - k * f;
            a[0] = l * c + d * -g + m * -k - n * -h;
            a[1] = m * c + d * -h + n * -g - l * -k;
            a[2] = n * c + d * -k + l * -h - m * -g;
            a[3] = b[3];
            return a
        },
        zero: function(a) {
            a[0] = 0;
            a[1] = 0;
            a[2] = 0;
            a[3] = 0;
            return a
        },
        str: function(a) {
            return "vec4(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")"
        },
        exactEquals: exactEquals$3,
        equals: function(a, b) {
            var c = a[0],
                d = a[1],
                e = a[2];
            a = a[3];
            var f = b[0],
                g = b[1],
                h = b[2];
            b = b[3];
            return Math.abs(c - f) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1,
                Math.abs(c), Math.abs(f)) && Math.abs(d - g) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(d), Math.abs(g)) && Math.abs(e - h) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(e), Math.abs(h)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(a), Math.abs(b))
        },
        sub: sub$1$$module$content$working$237635295$scripts$c3runtime,
        mul: mul$3$$module$content$working$237635295$scripts$c3runtime,
        div: div$1$$module$content$working$237635295$scripts$c3runtime,
        dist: dist$1$$module$content$working$237635295$scripts$c3runtime,
        sqrDist: sqrDist$1$$module$content$working$237635295$scripts$c3runtime,
        len: len$3$$module$content$working$237635295$scripts$c3runtime,
        sqrLen: sqrLen$3$$module$content$working$237635295$scripts$c3runtime,
        forEach: forEach$1$$module$content$working$237635295$scripts$c3runtime
    });
function create$2() {
    var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(4);
    ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0);
    a[3] = 1;
    return a
}
function setAxisAngle(a, b, c) {
    c *= .5;
    var d = Math.sin(c);
    a[0] = d * b[0];
    a[1] = d * b[1];
    a[2] = d * b[2];
    a[3] = Math.cos(c);
    return a
}
function multiply$2(a, b, c) {
    var d = b[0],
        e = b[1],
        f = b[2];
    b = b[3];
    var g = c[0],
        h = c[1],
        k = c[2];
    c = c[3];
    a[0] = d * c + b * g + e * k - f * h;
    a[1] = e * c + b * h + f * g - d * k;
    a[2] = f * c + b * k + d * h - e * g;
    a[3] = b * c - d * g - e * h - f * k;
    return a
}
function rotateX$1(a, b, c) {
    c *= .5;
    var d = b[0],
        e = b[1],
        f = b[2];
    b = b[3];
    var g = Math.sin(c);
    c = Math.cos(c);
    a[0] = d * c + b * g;
    a[1] = e * c + f * g;
    a[2] = f * c - e * g;
    a[3] = b * c - d * g;
    return a
}
function rotateY$1(a, b, c) {
    c *= .5;
    var d = b[0],
        e = b[1],
        f = b[2];
    b = b[3];
    var g = Math.sin(c);
    c = Math.cos(c);
    a[0] = d * c - f * g;
    a[1] = e * c + b * g;
    a[2] = f * c + d * g;
    a[3] = b * c - e * g;
    return a
}
function rotateZ$1(a, b, c) {
    c *= .5;
    var d = b[0],
        e = b[1],
        f = b[2];
    b = b[3];
    var g = Math.sin(c);
    c = Math.cos(c);
    a[0] = d * c + e * g;
    a[1] = e * c - d * g;
    a[2] = f * c + b * g;
    a[3] = b * c - f * g;
    return a
}
function exp(a, b) {
    var c = b[0],
        d = b[1],
        e = b[2],
        f = Math.sqrt(c * c + d * d + e * e);
    b = Math.exp(b[3]);
    var g = 0 < f ? b * Math.sin(f) / f : 0;
    a[0] = c * g;
    a[1] = d * g;
    a[2] = e * g;
    a[3] = b * Math.cos(f);
    return a
}
function ln(a, b) {
    var c = b[0],
        d = b[1],
        e = b[2];
    b = b[3];
    var f = Math.sqrt(c * c + d * d + e * e);
    f = 0 < f ? Math.atan2(f, b) / f : 0;
    a[0] = c * f;
    a[1] = d * f;
    a[2] = e * f;
    a[3] = .5 * Math.log(c * c + d * d + e * e + b * b);
    return a
}
function slerp(a, b, c, d) {
    var e = b[0],
        f = b[1],
        g = b[2];
    b = b[3];
    var h = c[0],
        k = c[1],
        l = c[2];
    c = c[3];
    var m = e * h + f * k + g * l + b * c;
    0 > m && (m = -m, h = -h, k = -k, l = -l, c = -c);
    if (1 - m > EPSILON$$module$content$working$237635295$scripts$c3runtime) {
        var n = Math.acos(m);
        var p = Math.sin(n);
        m = Math.sin((1 - d) * n) / p;
        d = Math.sin(d * n) / p
    } else
        m = 1 - d;
    a[0] = m * e + d * h;
    a[1] = m * f + d * k;
    a[2] = m * g + d * l;
    a[3] = m * b + d * c;
    return a
}
function fromMat3(a, b) {
    var c = b[0] + b[4] + b[8];
    if (0 < c)
        c = Math.sqrt(c + 1),
        a[3] = .5 * c,
        c = .5 / c,
        a[0] = (b[5] - b[7]) * c,
        a[1] = (b[6] - b[2]) * c,
        a[2] = (b[1] - b[3]) * c;
    else {
        var d = 0;
        b[4] > b[0] && (d = 1);
        b[8] > b[3 * d + d] && (d = 2);
        var e = (d + 1) % 3,
            f = (d + 2) % 3;
        c = Math.sqrt(b[3 * d + d] - b[3 * e + e] - b[3 * f + f] + 1);
        a[d] = .5 * c;
        c = .5 / c;
        a[3] = (b[3 * e + f] - b[3 * f + e]) * c;
        a[e] = (b[3 * e + d] + b[3 * d + e]) * c;
        a[f] = (b[3 * f + d] + b[3 * d + f]) * c
    }
    return a
}
var clone$2$$module$content$working$237635295$scripts$c3runtime = clone$3,
    fromValues$2$$module$content$working$237635295$scripts$c3runtime = fromValues$3,
    copy$2$$module$content$working$237635295$scripts$c3runtime = copy$3,
    set$2$$module$content$working$237635295$scripts$c3runtime = set$3,
    add$2$$module$content$working$237635295$scripts$c3runtime = add$3,
    mul$2$$module$content$working$237635295$scripts$c3runtime = multiply$2,
    scale$2$$module$content$working$237635295$scripts$c3runtime = scale$3,
    dot$2$$module$content$working$237635295$scripts$c3runtime =
    dot$3,
    lerp$2$$module$content$working$237635295$scripts$c3runtime = lerp$3,
    length$2$$module$content$working$237635295$scripts$c3runtime = length$3,
    len$2$$module$content$working$237635295$scripts$c3runtime = length$2$$module$content$working$237635295$scripts$c3runtime,
    squaredLength$2$$module$content$working$237635295$scripts$c3runtime = squaredLength$3,
    sqrLen$2$$module$content$working$237635295$scripts$c3runtime = squaredLength$2$$module$content$working$237635295$scripts$c3runtime,
    normalize$2$$module$content$working$237635295$scripts$c3runtime =
    normalize$3,
    exactEquals$2$$module$content$working$237635295$scripts$c3runtime = exactEquals$3,
    rotationTo$$module$content$working$237635295$scripts$c3runtime = function() {
        var a = create$4(),
            b = fromValues$4(1, 0, 0),
            c = fromValues$4(0, 1, 0);
        return function(d, e, f) {
            var g = dot$4(e, f);
            if (-.999999 > g)
                return cross$2(a, b, e), 1E-6 > len$4$$module$content$working$237635295$scripts$c3runtime(a) && cross$2(a, c, e), normalize$4(a, a), setAxisAngle(d, a, Math.PI), d;
            if (.999999 < g)
                return d[0] = 0, d[1] = 0, d[2] = 0, d[3] = 1, d;
            cross$2(a, e, f);
            d[0] = a[0];
            d[1] = a[1];
            d[2] = a[2];
            d[3] = 1 + g;
            return normalize$2$$module$content$working$237635295$scripts$c3runtime(d, d)
        }
    }(),
    sqlerp$$module$content$working$237635295$scripts$c3runtime = function() {
        var a = create$2(),
            b = create$2();
        return function(c, d, e, f, g, h) {
            slerp(a, d, g, h);
            slerp(b, e, f, h);
            slerp(c, a, b, 2 * h * (1 - h));
            return c
        }
    }(),
    setAxes$$module$content$working$237635295$scripts$c3runtime = function() {
        var a = create$6();
        return function(b, c, d, e) {
            a[0] = d[0];
            a[3] = d[1];
            a[6] = d[2];
            a[1] = e[0];
            a[4] = e[1];
            a[7] = e[2];
            a[2] = -c[0];
            a[5] = -c[1];
            a[8] =
            -c[2];
            return normalize$2$$module$content$working$237635295$scripts$c3runtime(b, fromMat3(b, a))
        }
    }(),
    quat$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: create$2,
        identity: function(a) {
            a[0] = 0;
            a[1] = 0;
            a[2] = 0;
            a[3] = 1;
            return a
        },
        setAxisAngle,
        getAxisAngle: function(a, b) {
            var c = 2 * Math.acos(b[3]),
                d = Math.sin(c / 2);
            d > EPSILON$$module$content$working$237635295$scripts$c3runtime ? (a[0] = b[0] / d, a[1] = b[1] / d, a[2] = b[2] / d) : (a[0] = 1, a[1] = 0, a[2] = 0);
            return c
        },
        getAngle: function(a, b) {
            a = dot$2$$module$content$working$237635295$scripts$c3runtime(a,
            b);
            return Math.acos(2 * a * a - 1)
        },
        multiply: multiply$2,
        rotateX: rotateX$1,
        rotateY: rotateY$1,
        rotateZ: rotateZ$1,
        calculateW: function(a, b) {
            var c = b[0],
                d = b[1];
            b = b[2];
            a[0] = c;
            a[1] = d;
            a[2] = b;
            a[3] = Math.sqrt(Math.abs(1 - c * c - d * d - b * b));
            return a
        },
        exp,
        ln,
        pow: function(a, b, c) {
            ln(a, b);
            scale$2$$module$content$working$237635295$scripts$c3runtime(a, a, c);
            exp(a, a);
            return a
        },
        slerp,
        random: function(a) {
            var b = RANDOM$$module$content$working$237635295$scripts$c3runtime(),
                c = RANDOM$$module$content$working$237635295$scripts$c3runtime(),
                d = RANDOM$$module$content$working$237635295$scripts$c3runtime(),
                e = Math.sqrt(1 - b);
            b = Math.sqrt(b);
            a[0] = e * Math.sin(2 * Math.PI * c);
            a[1] = e * Math.cos(2 * Math.PI * c);
            a[2] = b * Math.sin(2 * Math.PI * d);
            a[3] = b * Math.cos(2 * Math.PI * d);
            return a
        },
        invert: function(a, b) {
            var c = b[0],
                d = b[1],
                e = b[2];
            b = b[3];
            var f = c * c + d * d + e * e + b * b;
            f = f ? 1 / f : 0;
            a[0] = -c * f;
            a[1] = -d * f;
            a[2] = -e * f;
            a[3] = b * f;
            return a
        },
        conjugate: function(a, b) {
            a[0] = -b[0];
            a[1] = -b[1];
            a[2] = -b[2];
            a[3] = b[3];
            return a
        },
        fromMat3,
        fromEuler: function(a, b, c, d) {
            var e = 4 < arguments.length && void 0 !==
                arguments[4] ? arguments[4] : ANGLE_ORDER$$module$content$working$237635295$scripts$c3runtime,
                f = Math.PI / 360;
            b *= f;
            d *= f;
            c *= f;
            f = Math.sin(b);
            var g = Math.cos(b),
                h = Math.sin(c),
                k = Math.cos(c),
                l = Math.sin(d),
                m = Math.cos(d);
            switch (e) {
            case "xyz":
                a[0] = f * k * m + g * h * l;
                a[1] = g * h * m - f * k * l;
                a[2] = g * k * l + f * h * m;
                a[3] = g * k * m - f * h * l;
                break;
            case "xzy":
                a[0] = f * k * m - g * h * l;
                a[1] = g * h * m - f * k * l;
                a[2] = g * k * l + f * h * m;
                a[3] = g * k * m + f * h * l;
                break;
            case "yxz":
                a[0] = f * k * m + g * h * l;
                a[1] = g * h * m - f * k * l;
                a[2] = g * k * l - f * h * m;
                a[3] = g * k * m + f * h * l;
                break;
            case "yzx":
                a[0] = f * k * m + g * h * l;
                a[1] =
                g * h * m + f * k * l;
                a[2] = g * k * l - f * h * m;
                a[3] = g * k * m - f * h * l;
                break;
            case "zxy":
                a[0] = f * k * m - g * h * l;
                a[1] = g * h * m + f * k * l;
                a[2] = g * k * l + f * h * m;
                a[3] = g * k * m - f * h * l;
                break;
            case "zyx":
                a[0] = f * k * m - g * h * l;
                a[1] = g * h * m + f * k * l;
                a[2] = g * k * l - f * h * m;
                a[3] = g * k * m + f * h * l;
                break;
            default:
                throw Error("Unknown angle order " + e);
            }
            return a
        },
        str: function(a) {
            return "quat(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ")"
        },
        clone: clone$2$$module$content$working$237635295$scripts$c3runtime,
        fromValues: fromValues$2$$module$content$working$237635295$scripts$c3runtime,
        copy: copy$2$$module$content$working$237635295$scripts$c3runtime,
        set: set$2$$module$content$working$237635295$scripts$c3runtime,
        add: add$2$$module$content$working$237635295$scripts$c3runtime,
        mul: mul$2$$module$content$working$237635295$scripts$c3runtime,
        scale: scale$2$$module$content$working$237635295$scripts$c3runtime,
        dot: dot$2$$module$content$working$237635295$scripts$c3runtime,
        lerp: lerp$2$$module$content$working$237635295$scripts$c3runtime,
        length: length$2$$module$content$working$237635295$scripts$c3runtime,
        len: len$2$$module$content$working$237635295$scripts$c3runtime,
        squaredLength: squaredLength$2$$module$content$working$237635295$scripts$c3runtime,
        sqrLen: sqrLen$2$$module$content$working$237635295$scripts$c3runtime,
        normalize: normalize$2$$module$content$working$237635295$scripts$c3runtime,
        exactEquals: exactEquals$2$$module$content$working$237635295$scripts$c3runtime,
        equals: function(a, b) {
            return Math.abs(dot$3(a, b)) >= 1 - EPSILON$$module$content$working$237635295$scripts$c3runtime
        },
        rotationTo: rotationTo$$module$content$working$237635295$scripts$c3runtime,
        sqlerp: sqlerp$$module$content$working$237635295$scripts$c3runtime,
        setAxes: setAxes$$module$content$working$237635295$scripts$c3runtime
    });
function fromRotationTranslation(a, b, c) {
    var d = .5 * c[0],
        e = .5 * c[1];
    c = .5 * c[2];
    var f = b[0],
        g = b[1],
        h = b[2];
    b = b[3];
    a[0] = f;
    a[1] = g;
    a[2] = h;
    a[3] = b;
    a[4] = d * b + e * h - c * g;
    a[5] = e * b + c * f - d * h;
    a[6] = c * b + d * g - e * f;
    a[7] = -d * f - e * g - c * h;
    return a
}
function copy$1(a, b) {
    a[0] = b[0];
    a[1] = b[1];
    a[2] = b[2];
    a[3] = b[3];
    a[4] = b[4];
    a[5] = b[5];
    a[6] = b[6];
    a[7] = b[7];
    return a
}
var getReal$$module$content$working$237635295$scripts$c3runtime = copy$2$$module$content$working$237635295$scripts$c3runtime,
    setReal$$module$content$working$237635295$scripts$c3runtime = copy$2$$module$content$working$237635295$scripts$c3runtime;
function multiply$1(a, b, c) {
    var d = b[0],
        e = b[1],
        f = b[2],
        g = b[3],
        h = c[4],
        k = c[5],
        l = c[6],
        m = c[7],
        n = b[4],
        p = b[5],
        q = b[6];
    b = b[7];
    var r = c[0],
        t = c[1],
        u = c[2];
    c = c[3];
    a[0] = d * c + g * r + e * u - f * t;
    a[1] = e * c + g * t + f * r - d * u;
    a[2] = f * c + g * u + d * t - e * r;
    a[3] = g * c - d * r - e * t - f * u;
    a[4] = d * m + g * h + e * l - f * k + n * c + b * r + p * u - q * t;
    a[5] = e * m + g * k + f * h - d * l + p * c + b * t + q * r - n * u;
    a[6] = f * m + g * l + d * k - e * h + q * c + b * u + n * t - p * r;
    a[7] = g * m - d * h - e * k - f * l + b * c - n * r - p * t - q * u;
    return a
}
var mul$1$$module$content$working$237635295$scripts$c3runtime = multiply$1,
    dot$1$$module$content$working$237635295$scripts$c3runtime = dot$2$$module$content$working$237635295$scripts$c3runtime,
    length$1$$module$content$working$237635295$scripts$c3runtime = length$2$$module$content$working$237635295$scripts$c3runtime,
    len$1$$module$content$working$237635295$scripts$c3runtime = length$1$$module$content$working$237635295$scripts$c3runtime,
    squaredLength$1$$module$content$working$237635295$scripts$c3runtime = squaredLength$2$$module$content$working$237635295$scripts$c3runtime,
    sqrLen$1$$module$content$working$237635295$scripts$c3runtime = squaredLength$1$$module$content$working$237635295$scripts$c3runtime,
    quat2$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create: function() {
            var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(8);
            ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0, a[4] = 0, a[5] = 0, a[6] = 0, a[7] = 0);
            a[3] = 1;
            return a
        },
        clone: function(a) {
            var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(8);
            b[0] = a[0];
            b[1] = a[1];
            b[2] = a[2];
            b[3] = a[3];
            b[4] = a[4];
            b[5] = a[5];
            b[6] = a[6];
            b[7] = a[7];
            return b
        },
        fromValues: function(a, b, c, d, e, f, g, h) {
            var k = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(8);
            k[0] = a;
            k[1] = b;
            k[2] = c;
            k[3] = d;
            k[4] = e;
            k[5] = f;
            k[6] = g;
            k[7] = h;
            return k
        },
        fromRotationTranslationValues: function(a, b, c, d, e, f, g) {
            var h = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(8);
            h[0] = a;
            h[1] = b;
            h[2] = c;
            h[3] = d;
            e *= .5;
            f *= .5;
            g *= .5;
            h[4] = e * d + f * c - g * b;
            h[5] = f * d + g * a - e * c;
            h[6] = g * d + e * b - f * a;
            h[7] =
            -e * a - f * b - g * c;
            return h
        },
        fromRotationTranslation,
        fromTranslation: function(a, b) {
            a[0] = 0;
            a[1] = 0;
            a[2] = 0;
            a[3] = 1;
            a[4] = .5 * b[0];
            a[5] = .5 * b[1];
            a[6] = .5 * b[2];
            a[7] = 0;
            return a
        },
        fromRotation: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            a[2] = b[2];
            a[3] = b[3];
            a[4] = 0;
            a[5] = 0;
            a[6] = 0;
            a[7] = 0;
            return a
        },
        fromMat4: function(a, b) {
            var c = create$2();
            getRotation(c, b);
            var d = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(3);
            getTranslation$1(d, b);
            fromRotationTranslation(a, c, d);
            return a
        },
        copy: copy$1,
        identity: function(a) {
            a[0] = 0;
            a[1] = 0;
            a[2] = 0;
            a[3] = 1;
            a[4] = 0;
            a[5] = 0;
            a[6] = 0;
            a[7] = 0;
            return a
        },
        set: function(a, b, c, d, e, f, g, h, k) {
            a[0] = b;
            a[1] = c;
            a[2] = d;
            a[3] = e;
            a[4] = f;
            a[5] = g;
            a[6] = h;
            a[7] = k;
            return a
        },
        getReal: getReal$$module$content$working$237635295$scripts$c3runtime,
        getDual: function(a, b) {
            a[0] = b[4];
            a[1] = b[5];
            a[2] = b[6];
            a[3] = b[7];
            return a
        },
        setReal: setReal$$module$content$working$237635295$scripts$c3runtime,
        setDual: function(a, b) {
            a[4] = b[0];
            a[5] = b[1];
            a[6] = b[2];
            a[7] = b[3];
            return a
        },
        getTranslation: function(a, b) {
            var c = b[4],
                d = b[5],
                e = b[6],
                f = b[7],
                g = -b[0],
                h = -b[1],
                k = -b[2];
            b = b[3];
            a[0] = 2 * (c * b + f * g + d * k - e * h);
            a[1] = 2 * (d * b + f * h + e * g - c * k);
            a[2] = 2 * (e * b + f * k + c * h - d * g);
            return a
        },
        translate: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2],
                g = b[3],
                h = .5 * c[0],
                k = .5 * c[1];
            c = .5 * c[2];
            var l = b[4],
                m = b[5],
                n = b[6];
            b = b[7];
            a[0] = d;
            a[1] = e;
            a[2] = f;
            a[3] = g;
            a[4] = g * h + e * c - f * k + l;
            a[5] = g * k + f * h - d * c + m;
            a[6] = g * c + d * k - e * h + n;
            a[7] = -d * h - e * k - f * c + b;
            return a
        },
        rotateX: function(a, b, c) {
            var d = -b[0],
                e = -b[1],
                f = -b[2],
                g = b[3],
                h = b[4],
                k = b[5],
                l = b[6],
                m = b[7],
                n = h * g + m * d + k * f - l * e,
                p = k * g + m * e + l * d - h * f,
                q = l * g + m * f + h * e - k * d;
            h = m * g - h * d - k * e - l * f;
            rotateX$1(a, b, c);
            d = a[0];
            e = a[1];
            f = a[2];
            g = a[3];
            a[4] = n * g + h * d + p * f - q * e;
            a[5] = p * g + h * e + q * d - n * f;
            a[6] = q * g + h * f + n * e - p * d;
            a[7] = h * g - n * d - p * e - q * f;
            return a
        },
        rotateY: function(a, b, c) {
            var d = -b[0],
                e = -b[1],
                f = -b[2],
                g = b[3],
                h = b[4],
                k = b[5],
                l = b[6],
                m = b[7],
                n = h * g + m * d + k * f - l * e,
                p = k * g + m * e + l * d - h * f,
                q = l * g + m * f + h * e - k * d;
            h = m * g - h * d - k * e - l * f;
            rotateY$1(a, b, c);
            d = a[0];
            e = a[1];
            f = a[2];
            g = a[3];
            a[4] = n * g + h * d + p * f - q * e;
            a[5] = p * g + h * e + q * d - n * f;
            a[6] = q * g + h * f + n * e - p * d;
            a[7] = h * g - n * d - p * e - q * f;
            return a
        },
        rotateZ: function(a, b, c) {
            var d = -b[0],
                e = -b[1],
                f = -b[2],
                g = b[3],
                h = b[4],
                k = b[5],
                l = b[6],
                m = b[7],
                n = h * g + m * d + k * f - l * e,
                p = k * g + m * e + l * d - h * f,
                q = l * g + m * f + h * e - k * d;
            h = m * g - h * d - k * e - l * f;
            rotateZ$1(a, b, c);
            d = a[0];
            e = a[1];
            f = a[2];
            g = a[3];
            a[4] = n * g + h * d + p * f - q * e;
            a[5] = p * g + h * e + q * d - n * f;
            a[6] = q * g + h * f + n * e - p * d;
            a[7] = h * g - n * d - p * e - q * f;
            return a
        },
        rotateByQuatAppend: function(a, b, c) {
            var d = c[0],
                e = c[1],
                f = c[2];
            c = c[3];
            var g = b[0],
                h = b[1],
                k = b[2],
                l = b[3];
            a[0] = g * c + l * d + h * f - k * e;
            a[1] = h * c + l * e + k * d - g * f;
            a[2] = k * c + l * f + g * e - h * d;
            a[3] = l * c - g * d - h * e - k * f;
            g = b[4];
            h = b[5];
            k = b[6];
            l = b[7];
            a[4] = g * c + l * d + h * f - k * e;
            a[5] = h * c + l * e + k * d - g * f;
            a[6] = k * c + l * f + g * e -
            h * d;
            a[7] = l * c - g * d - h * e - k * f;
            return a
        },
        rotateByQuatPrepend: function(a, b, c) {
            var d = b[0],
                e = b[1],
                f = b[2];
            b = b[3];
            var g = c[0],
                h = c[1],
                k = c[2],
                l = c[3];
            a[0] = d * l + b * g + e * k - f * h;
            a[1] = e * l + b * h + f * g - d * k;
            a[2] = f * l + b * k + d * h - e * g;
            a[3] = b * l - d * g - e * h - f * k;
            g = c[4];
            h = c[5];
            k = c[6];
            l = c[7];
            a[4] = d * l + b * g + e * k - f * h;
            a[5] = e * l + b * h + f * g - d * k;
            a[6] = f * l + b * k + d * h - e * g;
            a[7] = b * l - d * g - e * h - f * k;
            return a
        },
        rotateAroundAxis: function(a, b, c, d) {
            if (Math.abs(d) < EPSILON$$module$content$working$237635295$scripts$c3runtime)
                return copy$1(a, b);
            var e = Math.hypot(c[0], c[1], c[2]);
            d *= .5;
            var f = Math.sin(d),
                g = f * c[0] / e,
                h = f * c[1] / e;
            c = f * c[2] / e;
            d = Math.cos(d);
            e = b[0];
            f = b[1];
            var k = b[2],
                l = b[3];
            a[0] = e * d + l * g + f * c - k * h;
            a[1] = f * d + l * h + k * g - e * c;
            a[2] = k * d + l * c + e * h - f * g;
            a[3] = l * d - e * g - f * h - k * c;
            e = b[4];
            f = b[5];
            k = b[6];
            b = b[7];
            a[4] = e * d + b * g + f * c - k * h;
            a[5] = f * d + b * h + k * g - e * c;
            a[6] = k * d + b * c + e * h - f * g;
            a[7] = b * d - e * g - f * h - k * c;
            return a
        },
        add: function(a, b, c) {
            a[0] = b[0] + c[0];
            a[1] = b[1] + c[1];
            a[2] = b[2] + c[2];
            a[3] = b[3] + c[3];
            a[4] = b[4] + c[4];
            a[5] = b[5] + c[5];
            a[6] = b[6] + c[6];
            a[7] = b[7] + c[7];
            return a
        },
        multiply: multiply$1,
        mul: mul$1$$module$content$working$237635295$scripts$c3runtime,
        scale: function(a, b, c) {
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            a[2] = b[2] * c;
            a[3] = b[3] * c;
            a[4] = b[4] * c;
            a[5] = b[5] * c;
            a[6] = b[6] * c;
            a[7] = b[7] * c;
            return a
        },
        dot: dot$1$$module$content$working$237635295$scripts$c3runtime,
        lerp: function(a, b, c, d) {
            var e = 1 - d;
            0 > dot$1$$module$content$working$237635295$scripts$c3runtime(b, c) && (d = -d);
            a[0] = b[0] * e + c[0] * d;
            a[1] = b[1] * e + c[1] * d;
            a[2] = b[2] * e + c[2] * d;
            a[3] = b[3] * e + c[3] * d;
            a[4] = b[4] * e + c[4] * d;
            a[5] = b[5] * e + c[5] * d;
            a[6] = b[6] * e + c[6] * d;
            a[7] = b[7] * e + c[7] * d;
            return a
        },
        invert: function(a, b) {
            var c = squaredLength$1$$module$content$working$237635295$scripts$c3runtime(b);
            a[0] = -b[0] / c;
            a[1] = -b[1] / c;
            a[2] = -b[2] / c;
            a[3] = b[3] / c;
            a[4] = -b[4] / c;
            a[5] = -b[5] / c;
            a[6] = -b[6] / c;
            a[7] = b[7] / c;
            return a
        },
        conjugate: function(a, b) {
            a[0] = -b[0];
            a[1] = -b[1];
            a[2] = -b[2];
            a[3] = b[3];
            a[4] = -b[4];
            a[5] = -b[5];
            a[6] = -b[6];
            a[7] = b[7];
            return a
        },
        length: length$1$$module$content$working$237635295$scripts$c3runtime,
        len: len$1$$module$content$working$237635295$scripts$c3runtime,
        squaredLength: squaredLength$1$$module$content$working$237635295$scripts$c3runtime,
        sqrLen: sqrLen$1$$module$content$working$237635295$scripts$c3runtime,
        normalize: function(a, b) {
            var c = squaredLength$1$$module$content$working$237635295$scripts$c3runtime(b);
            if (0 < c) {
                c = Math.sqrt(c);
                var d = b[0] / c,
                    e = b[1] / c,
                    f = b[2] / c,
                    g = b[3] / c,
                    h = b[4],
                    k = b[5],
                    l = b[6];
                b = b[7];
                var m = d * h + e * k + f * l + g * b;
                a[0] = d;
                a[1] = e;
                a[2] = f;
                a[3] = g;
                a[4] = (h - d * m) / c;
                a[5] = (k - e * m) / c;
                a[6] = (l - f * m) / c;
                a[7] = (b - g * m) / c
            }
            return a
        },
        str: function(a) {
            return "quat2(" + a[0] + ", " + a[1] + ", " + a[2] + ", " + a[3] + ", " + a[4] + ", " + a[5] + ", " + a[6] + ", " + a[7] + ")"
        },
        exactEquals: function(a, b) {
            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] ===
                b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7]
        },
        equals: function(a, b) {
            var c = a[0],
                d = a[1],
                e = a[2],
                f = a[3],
                g = a[4],
                h = a[5],
                k = a[6];
            a = a[7];
            var l = b[0],
                m = b[1],
                n = b[2],
                p = b[3],
                q = b[4],
                r = b[5],
                t = b[6];
            b = b[7];
            return Math.abs(c - l) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(c), Math.abs(l)) && Math.abs(d - m) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(d), Math.abs(m)) && Math.abs(e - n) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(e), Math.abs(n)) && Math.abs(f - p) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(f), Math.abs(p)) && Math.abs(g - q) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(g), Math.abs(q)) && Math.abs(h - r) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(h), Math.abs(r)) && Math.abs(k - t) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(k), Math.abs(t)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime *
                Math.max(1, Math.abs(a), Math.abs(b))
        }
    });
function create() {
    var a = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(2);
    ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime != Float32Array && (a[0] = 0, a[1] = 0);
    return a
}
function subtract(a, b, c) {
    a[0] = b[0] - c[0];
    a[1] = b[1] - c[1];
    return a
}
function multiply(a, b, c) {
    a[0] = b[0] * c[0];
    a[1] = b[1] * c[1];
    return a
}
function divide(a, b, c) {
    a[0] = b[0] / c[0];
    a[1] = b[1] / c[1];
    return a
}
function distance(a, b) {
    return Math.hypot(b[0] - a[0], b[1] - a[1])
}
function squaredDistance(a, b) {
    var c = b[0] - a[0];
    a = b[1] - a[1];
    return c * c + a * a
}
function length$jscomp$16(a) {
    return Math.hypot(a[0], a[1])
}
function squaredLength(a) {
    var b = a[0];
    a = a[1];
    return b * b + a * a
}
var len$$module$content$working$237635295$scripts$c3runtime = length$jscomp$16,
    sub$$module$content$working$237635295$scripts$c3runtime = subtract,
    mul$$module$content$working$237635295$scripts$c3runtime = multiply,
    div$$module$content$working$237635295$scripts$c3runtime = divide,
    dist$$module$content$working$237635295$scripts$c3runtime = distance,
    sqrDist$$module$content$working$237635295$scripts$c3runtime = squaredDistance,
    sqrLen$$module$content$working$237635295$scripts$c3runtime = squaredLength,
    forEach$$module$content$working$237635295$scripts$c3runtime =
    function() {
        var a = create();
        return function(b, c, d, e, f, g) {
            c || (c = 2);
            d || (d = 0);
            for (e = e ? Math.min(e * c + d, b.length) : b.length; d < e; d += c)
                a[0] = b[d],
                a[1] = b[d + 1],
                f(a, a, g),
                b[d] = a[0],
                b[d + 1] = a[1];
            return b
        }
    }(),
    vec2$$module$content$working$237635295$scripts$c3runtime = Object.freeze({
        __proto__: null,
        create,
        clone: function(a) {
            var b = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(2);
            b[0] = a[0];
            b[1] = a[1];
            return b
        },
        fromValues: function(a, b) {
            var c = new ARRAY_TYPE$$module$content$working$237635295$scripts$c3runtime(2);
            c[0] = a;
            c[1] = b;
            return c
        },
        copy: function(a, b) {
            a[0] = b[0];
            a[1] = b[1];
            return a
        },
        set: function(a, b, c) {
            a[0] = b;
            a[1] = c;
            return a
        },
        add: function(a, b, c) {
            a[0] = b[0] + c[0];
            a[1] = b[1] + c[1];
            return a
        },
        subtract,
        multiply,
        divide,
        ceil: function(a, b) {
            a[0] = Math.ceil(b[0]);
            a[1] = Math.ceil(b[1]);
            return a
        },
        floor: function(a, b) {
            a[0] = Math.floor(b[0]);
            a[1] = Math.floor(b[1]);
            return a
        },
        min: function(a, b, c) {
            a[0] = Math.min(b[0], c[0]);
            a[1] = Math.min(b[1], c[1]);
            return a
        },
        max: function(a, b, c) {
            a[0] = Math.max(b[0], c[0]);
            a[1] = Math.max(b[1], c[1]);
            return a
        },
        round: function(a, b) {
            a[0] = Math.round(b[0]);
            a[1] = Math.round(b[1]);
            return a
        },
        scale: function(a, b, c) {
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            return a
        },
        scaleAndAdd: function(a, b, c, d) {
            a[0] = b[0] + c[0] * d;
            a[1] = b[1] + c[1] * d;
            return a
        },
        distance,
        squaredDistance,
        length: length$jscomp$16,
        squaredLength,
        negate: function(a, b) {
            a[0] = -b[0];
            a[1] = -b[1];
            return a
        },
        inverse: function(a, b) {
            a[0] = 1 / b[0];
            a[1] = 1 / b[1];
            return a
        },
        normalize: function(a, b) {
            var c = b[0],
                d = b[1];
            c = c * c + d * d;
            0 < c && (c = 1 / Math.sqrt(c));
            a[0] = b[0] * c;
            a[1] = b[1] * c;
            return a
        },
        dot: function(a,
        b) {
            return a[0] * b[0] + a[1] * b[1]
        },
        cross: function(a, b, c) {
            b = b[0] * c[1] - b[1] * c[0];
            a[0] = a[1] = 0;
            a[2] = b;
            return a
        },
        lerp: function(a, b, c, d) {
            var e = b[0];
            b = b[1];
            a[0] = e + d * (c[0] - e);
            a[1] = b + d * (c[1] - b);
            return a
        },
        random: function(a, b) {
            b = b || 1;
            var c = 2 * RANDOM$$module$content$working$237635295$scripts$c3runtime() * Math.PI;
            a[0] = Math.cos(c) * b;
            a[1] = Math.sin(c) * b;
            return a
        },
        transformMat2: function(a, b, c) {
            var d = b[0];
            b = b[1];
            a[0] = c[0] * d + c[2] * b;
            a[1] = c[1] * d + c[3] * b;
            return a
        },
        transformMat2d: function(a, b, c) {
            var d = b[0];
            b = b[1];
            a[0] = c[0] * d +
            c[2] * b + c[4];
            a[1] = c[1] * d + c[3] * b + c[5];
            return a
        },
        transformMat3: function(a, b, c) {
            var d = b[0];
            b = b[1];
            a[0] = c[0] * d + c[3] * b + c[6];
            a[1] = c[1] * d + c[4] * b + c[7];
            return a
        },
        transformMat4: function(a, b, c) {
            var d = b[0];
            b = b[1];
            a[0] = c[0] * d + c[4] * b + c[12];
            a[1] = c[1] * d + c[5] * b + c[13];
            return a
        },
        rotate: function(a, b, c, d) {
            var e = b[0] - c[0];
            b = b[1] - c[1];
            var f = Math.sin(d);
            d = Math.cos(d);
            a[0] = e * d - b * f + c[0];
            a[1] = e * f + b * d + c[1];
            return a
        },
        angle: function(a, b) {
            var c = a[0];
            a = a[1];
            var d = b[0];
            b = b[1];
            var e = Math.sqrt((c * c + a * a) * (d * d + b * b));
            return Math.acos(Math.min(Math.max(e &&
            (c * d + a * b) / e, -1), 1))
        },
        zero: function(a) {
            a[0] = 0;
            a[1] = 0;
            return a
        },
        str: function(a) {
            return "vec2(" + a[0] + ", " + a[1] + ")"
        },
        exactEquals: function(a, b) {
            return a[0] === b[0] && a[1] === b[1]
        },
        equals: function(a, b) {
            var c = a[0];
            a = a[1];
            var d = b[0];
            b = b[1];
            return Math.abs(c - d) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(c), Math.abs(d)) && Math.abs(a - b) <= EPSILON$$module$content$working$237635295$scripts$c3runtime * Math.max(1, Math.abs(a), Math.abs(b))
        },
        len: len$$module$content$working$237635295$scripts$c3runtime,
        sub: sub$$module$content$working$237635295$scripts$c3runtime,
        mul: mul$$module$content$working$237635295$scripts$c3runtime,
        div: div$$module$content$working$237635295$scripts$c3runtime,
        dist: dist$$module$content$working$237635295$scripts$c3runtime,
        sqrDist: sqrDist$$module$content$working$237635295$scripts$c3runtime,
        sqrLen: sqrLen$$module$content$working$237635295$scripts$c3runtime,
        forEach: forEach$$module$content$working$237635295$scripts$c3runtime
    });
globalThis.glMatrix = common$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.mat2 = mat2$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.mat2d = mat2d$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.mat3 = mat3$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.mat4 = mat4$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.quat = quat$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.quat2 = quat2$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.vec2 = vec2$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.vec3 = vec3$$module$content$working$237635295$scripts$c3runtime;
globalThis.glMatrix.vec4 = vec4$$module$content$working$237635295$scripts$c3runtime;
self.GraphemeSplitter = function() {
    function a(d, e) {
        void 0 === e && (e = 0);
        var f = d.charCodeAt(e);
        if (55296 <= f && 56319 >= f && e < d.length - 1) {
            var g = f;
            d = d.charCodeAt(e + 1);
            return 56320 <= d && 57343 >= d ? 1024 * (g - 55296) + (d - 56320) + 65536 : g
        }
        return 56320 <= f && 57343 >= f && 1 <= e ? (g = d.charCodeAt(e - 1), d = f, 55296 <= g && 56319 >= g ? 1024 * (g - 55296) + (d - 56320) + 65536 : d) : f
    }
    function b(d, e, f) {
        var g = [d].concat(e).concat([f]),
            h = g[g.length - 2],
            k = g.lastIndexOf(14);
        if (1 < k && g.slice(1, k).every(function(l) {
            return 3 == l
        }) && -1 == [3, 13, 17].indexOf(d))
            return 2;
        d =
        g.lastIndexOf(4);
        if (0 < d && g.slice(1, d).every(function(l) {
            return 4 == l
        }) && -1 == [12, 4].indexOf(h))
            return 1 == g.filter(function(l) {
                return 4 == l
            }).length % 2 ? 3 : 4;
        if (0 == h && 1 == f)
            return 0;
        if (2 == h || 0 == h || 1 == h)
            return 14 == f && e.every(function(l) {
                return 3 == l
            }) ? 2 : 1;
        if (2 == f || 0 == f || 1 == f)
            return 1;
        if (6 != h || 6 != f && 7 != f && 9 != f && 10 != f)
            if (9 != h && 7 != h || 7 != f && 8 != f)
                if (10 != h && 8 != h || 8 != f) {
                    if (3 == f || 15 == f || 5 == f || 12 == h)
                        return 0
                } else
                    return 0;
            else
                return 0;
        else
            return 0;
        d = -1 != g.indexOf(3) ? g.lastIndexOf(3) - 1 : g.length - 2;
        return -1 != [13, 17].indexOf(g[d]) &&
        g.slice(d + 1, -1).every(function(l) {
            return 3 == l
        }) && 14 == f || 15 == h && -1 != [16, 17].indexOf(f) ? 0 : -1 != e.indexOf(4) ? 2 : 4 == h && 4 == f ? 0 : 1
    }
    function c(d) {
        return 1536 <= d && 1541 >= d || 1757 == d || 1807 == d || 2274 == d || 3406 == d || 69821 == d || 70082 <= d && 70083 >= d || 72250 == d || 72326 <= d && 72329 >= d || 73030 == d ? 12 : 13 == d ? 0 : 10 == d ? 1 : 0 <= d && 9 >= d || 11 <= d && 12 >= d || 14 <= d && 31 >= d || 127 <= d && 159 >= d || 173 == d || 1564 == d || 6158 == d || 8203 == d || 8206 <= d && 8207 >= d || 8232 == d || 8233 == d || 8234 <= d && 8238 >= d || 8288 <= d && 8292 >= d || 8293 == d || 8294 <= d && 8303 >= d || 55296 <= d && 57343 >= d || 65279 ==
        d || 65520 <= d && 65528 >= d || 65529 <= d && 65531 >= d || 113824 <= d && 113827 >= d || 119155 <= d && 119162 >= d || 917504 == d || 917505 == d || 917506 <= d && 917535 >= d || 917632 <= d && 917759 >= d || 918E3 <= d && 921599 >= d ? 2 : 768 <= d && 879 >= d || 1155 <= d && 1159 >= d || 1160 <= d && 1161 >= d || 1425 <= d && 1469 >= d || 1471 == d || 1473 <= d && 1474 >= d || 1476 <= d && 1477 >= d || 1479 == d || 1552 <= d && 1562 >= d || 1611 <= d && 1631 >= d || 1648 == d || 1750 <= d && 1756 >= d || 1759 <= d && 1764 >= d || 1767 <= d && 1768 >= d || 1770 <= d && 1773 >= d || 1809 == d || 1840 <= d && 1866 >= d || 1958 <= d && 1968 >= d || 2027 <= d && 2035 >= d || 2070 <= d && 2073 >= d || 2075 <=
        d && 2083 >= d || 2085 <= d && 2087 >= d || 2089 <= d && 2093 >= d || 2137 <= d && 2139 >= d || 2260 <= d && 2273 >= d || 2275 <= d && 2306 >= d || 2362 == d || 2364 == d || 2369 <= d && 2376 >= d || 2381 == d || 2385 <= d && 2391 >= d || 2402 <= d && 2403 >= d || 2433 == d || 2492 == d || 2494 == d || 2497 <= d && 2500 >= d || 2509 == d || 2519 == d || 2530 <= d && 2531 >= d || 2561 <= d && 2562 >= d || 2620 == d || 2625 <= d && 2626 >= d || 2631 <= d && 2632 >= d || 2635 <= d && 2637 >= d || 2641 == d || 2672 <= d && 2673 >= d || 2677 == d || 2689 <= d && 2690 >= d || 2748 == d || 2753 <= d && 2757 >= d || 2759 <= d && 2760 >= d || 2765 == d || 2786 <= d && 2787 >= d || 2810 <= d && 2815 >= d || 2817 == d || 2876 ==
        d || 2878 == d || 2879 == d || 2881 <= d && 2884 >= d || 2893 == d || 2902 == d || 2903 == d || 2914 <= d && 2915 >= d || 2946 == d || 3006 == d || 3008 == d || 3021 == d || 3031 == d || 3072 == d || 3134 <= d && 3136 >= d || 3142 <= d && 3144 >= d || 3146 <= d && 3149 >= d || 3157 <= d && 3158 >= d || 3170 <= d && 3171 >= d || 3201 == d || 3260 == d || 3263 == d || 3266 == d || 3270 == d || 3276 <= d && 3277 >= d || 3285 <= d && 3286 >= d || 3298 <= d && 3299 >= d || 3328 <= d && 3329 >= d || 3387 <= d && 3388 >= d || 3390 == d || 3393 <= d && 3396 >= d || 3405 == d || 3415 == d || 3426 <= d && 3427 >= d || 3530 == d || 3535 == d || 3538 <= d && 3540 >= d || 3542 == d || 3551 == d || 3633 == d || 3636 <= d && 3642 >=
        d || 3655 <= d && 3662 >= d || 3761 == d || 3764 <= d && 3769 >= d || 3771 <= d && 3772 >= d || 3784 <= d && 3789 >= d || 3864 <= d && 3865 >= d || 3893 == d || 3895 == d || 3897 == d || 3953 <= d && 3966 >= d || 3968 <= d && 3972 >= d || 3974 <= d && 3975 >= d || 3981 <= d && 3991 >= d || 3993 <= d && 4028 >= d || 4038 == d || 4141 <= d && 4144 >= d || 4146 <= d && 4151 >= d || 4153 <= d && 4154 >= d || 4157 <= d && 4158 >= d || 4184 <= d && 4185 >= d || 4190 <= d && 4192 >= d || 4209 <= d && 4212 >= d || 4226 == d || 4229 <= d && 4230 >= d || 4237 == d || 4253 == d || 4957 <= d && 4959 >= d || 5906 <= d && 5908 >= d || 5938 <= d && 5940 >= d || 5970 <= d && 5971 >= d || 6002 <= d && 6003 >= d || 6068 <= d && 6069 >=
        d || 6071 <= d && 6077 >= d || 6086 == d || 6089 <= d && 6099 >= d || 6109 == d || 6155 <= d && 6157 >= d || 6277 <= d && 6278 >= d || 6313 == d || 6432 <= d && 6434 >= d || 6439 <= d && 6440 >= d || 6450 == d || 6457 <= d && 6459 >= d || 6679 <= d && 6680 >= d || 6683 == d || 6742 == d || 6744 <= d && 6750 >= d || 6752 == d || 6754 == d || 6757 <= d && 6764 >= d || 6771 <= d && 6780 >= d || 6783 == d || 6832 <= d && 6845 >= d || 6846 == d || 6912 <= d && 6915 >= d || 6964 == d || 6966 <= d && 6970 >= d || 6972 == d || 6978 == d || 7019 <= d && 7027 >= d || 7040 <= d && 7041 >= d || 7074 <= d && 7077 >= d || 7080 <= d && 7081 >= d || 7083 <= d && 7085 >= d || 7142 == d || 7144 <= d && 7145 >= d || 7149 == d || 7151 <=
        d && 7153 >= d || 7212 <= d && 7219 >= d || 7222 <= d && 7223 >= d || 7376 <= d && 7378 >= d || 7380 <= d && 7392 >= d || 7394 <= d && 7400 >= d || 7405 == d || 7412 == d || 7416 <= d && 7417 >= d || 7616 <= d && 7673 >= d || 7675 <= d && 7679 >= d || 8204 == d || 8400 <= d && 8412 >= d || 8413 <= d && 8416 >= d || 8417 == d || 8418 <= d && 8420 >= d || 8421 <= d && 8432 >= d || 11503 <= d && 11505 >= d || 11647 == d || 11744 <= d && 11775 >= d || 12330 <= d && 12333 >= d || 12334 <= d && 12335 >= d || 12441 <= d && 12442 >= d || 42607 == d || 42608 <= d && 42610 >= d || 42612 <= d && 42621 >= d || 42654 <= d && 42655 >= d || 42736 <= d && 42737 >= d || 43010 == d || 43014 == d || 43019 == d || 43045 <=
        d && 43046 >= d || 43204 <= d && 43205 >= d || 43232 <= d && 43249 >= d || 43302 <= d && 43309 >= d || 43335 <= d && 43345 >= d || 43392 <= d && 43394 >= d || 43443 == d || 43446 <= d && 43449 >= d || 43452 == d || 43493 == d || 43561 <= d && 43566 >= d || 43569 <= d && 43570 >= d || 43573 <= d && 43574 >= d || 43587 == d || 43596 == d || 43644 == d || 43696 == d || 43698 <= d && 43700 >= d || 43703 <= d && 43704 >= d || 43710 <= d && 43711 >= d || 43713 == d || 43756 <= d && 43757 >= d || 43766 == d || 44005 == d || 44008 == d || 44013 == d || 64286 == d || 65024 <= d && 65039 >= d || 65056 <= d && 65071 >= d || 65438 <= d && 65439 >= d || 66045 == d || 66272 == d || 66422 <= d && 66426 >= d ||
        68097 <= d && 68099 >= d || 68101 <= d && 68102 >= d || 68108 <= d && 68111 >= d || 68152 <= d && 68154 >= d || 68159 == d || 68325 <= d && 68326 >= d || 69633 == d || 69688 <= d && 69702 >= d || 69759 <= d && 69761 >= d || 69811 <= d && 69814 >= d || 69817 <= d && 69818 >= d || 69888 <= d && 69890 >= d || 69927 <= d && 69931 >= d || 69933 <= d && 69940 >= d || 70003 == d || 70016 <= d && 70017 >= d || 70070 <= d && 70078 >= d || 70090 <= d && 70092 >= d || 70191 <= d && 70193 >= d || 70196 == d || 70198 <= d && 70199 >= d || 70206 == d || 70367 == d || 70371 <= d && 70378 >= d || 70400 <= d && 70401 >= d || 70460 == d || 70462 == d || 70464 == d || 70487 == d || 70502 <= d && 70508 >= d || 70512 <=
        d && 70516 >= d || 70712 <= d && 70719 >= d || 70722 <= d && 70724 >= d || 70726 == d || 70832 == d || 70835 <= d && 70840 >= d || 70842 == d || 70845 == d || 70847 <= d && 70848 >= d || 70850 <= d && 70851 >= d || 71087 == d || 71090 <= d && 71093 >= d || 71100 <= d && 71101 >= d || 71103 <= d && 71104 >= d || 71132 <= d && 71133 >= d || 71219 <= d && 71226 >= d || 71229 == d || 71231 <= d && 71232 >= d || 71339 == d || 71341 == d || 71344 <= d && 71349 >= d || 71351 == d || 71453 <= d && 71455 >= d || 71458 <= d && 71461 >= d || 71463 <= d && 71467 >= d || 72193 <= d && 72198 >= d || 72201 <= d && 72202 >= d || 72243 <= d && 72248 >= d || 72251 <= d && 72254 >= d || 72263 == d || 72273 <= d &&
        72278 >= d || 72281 <= d && 72283 >= d || 72330 <= d && 72342 >= d || 72344 <= d && 72345 >= d || 72752 <= d && 72758 >= d || 72760 <= d && 72765 >= d || 72767 == d || 72850 <= d && 72871 >= d || 72874 <= d && 72880 >= d || 72882 <= d && 72883 >= d || 72885 <= d && 72886 >= d || 73009 <= d && 73014 >= d || 73018 == d || 73020 <= d && 73021 >= d || 73023 <= d && 73029 >= d || 73031 == d || 92912 <= d && 92916 >= d || 92976 <= d && 92982 >= d || 94095 <= d && 94098 >= d || 113821 <= d && 113822 >= d || 119141 == d || 119143 <= d && 119145 >= d || 119150 <= d && 119154 >= d || 119163 <= d && 119170 >= d || 119173 <= d && 119179 >= d || 119210 <= d && 119213 >= d || 119362 <= d && 119364 >=
        d || 121344 <= d && 121398 >= d || 121403 <= d && 121452 >= d || 121461 == d || 121476 == d || 121499 <= d && 121503 >= d || 121505 <= d && 121519 >= d || 122880 <= d && 122886 >= d || 122888 <= d && 122904 >= d || 122907 <= d && 122913 >= d || 122915 <= d && 122916 >= d || 122918 <= d && 122922 >= d || 125136 <= d && 125142 >= d || 125252 <= d && 125258 >= d || 917536 <= d && 917631 >= d || 917760 <= d && 917999 >= d ? 3 : 127462 <= d && 127487 >= d ? 4 : 2307 == d || 2363 == d || 2366 <= d && 2368 >= d || 2377 <= d && 2380 >= d || 2382 <= d && 2383 >= d || 2434 <= d && 2435 >= d || 2495 <= d && 2496 >= d || 2503 <= d && 2504 >= d || 2507 <= d && 2508 >= d || 2563 == d || 2622 <= d && 2624 >=
        d || 2691 == d || 2750 <= d && 2752 >= d || 2761 == d || 2763 <= d && 2764 >= d || 2818 <= d && 2819 >= d || 2880 == d || 2887 <= d && 2888 >= d || 2891 <= d && 2892 >= d || 3007 == d || 3009 <= d && 3010 >= d || 3014 <= d && 3016 >= d || 3018 <= d && 3020 >= d || 3073 <= d && 3075 >= d || 3137 <= d && 3140 >= d || 3202 <= d && 3203 >= d || 3262 == d || 3264 <= d && 3265 >= d || 3267 <= d && 3268 >= d || 3271 <= d && 3272 >= d || 3274 <= d && 3275 >= d || 3330 <= d && 3331 >= d || 3391 <= d && 3392 >= d || 3398 <= d && 3400 >= d || 3402 <= d && 3404 >= d || 3458 <= d && 3459 >= d || 3536 <= d && 3537 >= d || 3544 <= d && 3550 >= d || 3570 <= d && 3571 >= d || 3635 == d || 3763 == d || 3902 <= d && 3903 >= d || 3967 ==
        d || 4145 == d || 4155 <= d && 4156 >= d || 4182 <= d && 4183 >= d || 4228 == d || 6070 == d || 6078 <= d && 6085 >= d || 6087 <= d && 6088 >= d || 6435 <= d && 6438 >= d || 6441 <= d && 6443 >= d || 6448 <= d && 6449 >= d || 6451 <= d && 6456 >= d || 6681 <= d && 6682 >= d || 6741 == d || 6743 == d || 6765 <= d && 6770 >= d || 6916 == d || 6965 == d || 6971 == d || 6973 <= d && 6977 >= d || 6979 <= d && 6980 >= d || 7042 == d || 7073 == d || 7078 <= d && 7079 >= d || 7082 == d || 7143 == d || 7146 <= d && 7148 >= d || 7150 == d || 7154 <= d && 7155 >= d || 7204 <= d && 7211 >= d || 7220 <= d && 7221 >= d || 7393 == d || 7410 <= d && 7411 >= d || 7415 == d || 43043 <= d && 43044 >= d || 43047 == d || 43136 <= d &&
        43137 >= d || 43188 <= d && 43203 >= d || 43346 <= d && 43347 >= d || 43395 == d || 43444 <= d && 43445 >= d || 43450 <= d && 43451 >= d || 43453 <= d && 43456 >= d || 43567 <= d && 43568 >= d || 43571 <= d && 43572 >= d || 43597 == d || 43755 == d || 43758 <= d && 43759 >= d || 43765 == d || 44003 <= d && 44004 >= d || 44006 <= d && 44007 >= d || 44009 <= d && 44010 >= d || 44012 == d || 69632 == d || 69634 == d || 69762 == d || 69808 <= d && 69810 >= d || 69815 <= d && 69816 >= d || 69932 == d || 70018 == d || 70067 <= d && 70069 >= d || 70079 <= d && 70080 >= d || 70188 <= d && 70190 >= d || 70194 <= d && 70195 >= d || 70197 == d || 70368 <= d && 70370 >= d || 70402 <= d && 70403 >= d || 70463 ==
        d || 70465 <= d && 70468 >= d || 70471 <= d && 70472 >= d || 70475 <= d && 70477 >= d || 70498 <= d && 70499 >= d || 70709 <= d && 70711 >= d || 70720 <= d && 70721 >= d || 70725 == d || 70833 <= d && 70834 >= d || 70841 == d || 70843 <= d && 70844 >= d || 70846 == d || 70849 == d || 71088 <= d && 71089 >= d || 71096 <= d && 71099 >= d || 71102 == d || 71216 <= d && 71218 >= d || 71227 <= d && 71228 >= d || 71230 == d || 71340 == d || 71342 <= d && 71343 >= d || 71350 == d || 71456 <= d && 71457 >= d || 71462 == d || 72199 <= d && 72200 >= d || 72249 == d || 72279 <= d && 72280 >= d || 72343 == d || 72751 == d || 72766 == d || 72873 == d || 72881 == d || 72884 == d || 94033 <= d && 94078 >= d ||
        119142 == d || 119149 == d ? 5 : 4352 <= d && 4447 >= d || 43360 <= d && 43388 >= d ? 6 : 4448 <= d && 4519 >= d || 55216 <= d && 55238 >= d ? 7 : 4520 <= d && 4607 >= d || 55243 <= d && 55291 >= d ? 8 : 44032 == d || 44060 == d || 44088 == d || 44116 == d || 44144 == d || 44172 == d || 44200 == d || 44228 == d || 44256 == d || 44284 == d || 44312 == d || 44340 == d || 44368 == d || 44396 == d || 44424 == d || 44452 == d || 44480 == d || 44508 == d || 44536 == d || 44564 == d || 44592 == d || 44620 == d || 44648 == d || 44676 == d || 44704 == d || 44732 == d || 44760 == d || 44788 == d || 44816 == d || 44844 == d || 44872 == d || 44900 == d || 44928 == d || 44956 == d || 44984 == d || 45012 == d || 45040 ==
        d || 45068 == d || 45096 == d || 45124 == d || 45152 == d || 45180 == d || 45208 == d || 45236 == d || 45264 == d || 45292 == d || 45320 == d || 45348 == d || 45376 == d || 45404 == d || 45432 == d || 45460 == d || 45488 == d || 45516 == d || 45544 == d || 45572 == d || 45600 == d || 45628 == d || 45656 == d || 45684 == d || 45712 == d || 45740 == d || 45768 == d || 45796 == d || 45824 == d || 45852 == d || 45880 == d || 45908 == d || 45936 == d || 45964 == d || 45992 == d || 46020 == d || 46048 == d || 46076 == d || 46104 == d || 46132 == d || 46160 == d || 46188 == d || 46216 == d || 46244 == d || 46272 == d || 46300 == d || 46328 == d || 46356 == d || 46384 == d || 46412 == d || 46440 == d ||
        46468 == d || 46496 == d || 46524 == d || 46552 == d || 46580 == d || 46608 == d || 46636 == d || 46664 == d || 46692 == d || 46720 == d || 46748 == d || 46776 == d || 46804 == d || 46832 == d || 46860 == d || 46888 == d || 46916 == d || 46944 == d || 46972 == d || 47E3 == d || 47028 == d || 47056 == d || 47084 == d || 47112 == d || 47140 == d || 47168 == d || 47196 == d || 47224 == d || 47252 == d || 47280 == d || 47308 == d || 47336 == d || 47364 == d || 47392 == d || 47420 == d || 47448 == d || 47476 == d || 47504 == d || 47532 == d || 47560 == d || 47588 == d || 47616 == d || 47644 == d || 47672 == d || 47700 == d || 47728 == d || 47756 == d || 47784 == d || 47812 == d || 47840 == d || 47868 ==
        d || 47896 == d || 47924 == d || 47952 == d || 47980 == d || 48008 == d || 48036 == d || 48064 == d || 48092 == d || 48120 == d || 48148 == d || 48176 == d || 48204 == d || 48232 == d || 48260 == d || 48288 == d || 48316 == d || 48344 == d || 48372 == d || 48400 == d || 48428 == d || 48456 == d || 48484 == d || 48512 == d || 48540 == d || 48568 == d || 48596 == d || 48624 == d || 48652 == d || 48680 == d || 48708 == d || 48736 == d || 48764 == d || 48792 == d || 48820 == d || 48848 == d || 48876 == d || 48904 == d || 48932 == d || 48960 == d || 48988 == d || 49016 == d || 49044 == d || 49072 == d || 49100 == d || 49128 == d || 49156 == d || 49184 == d || 49212 == d || 49240 == d || 49268 == d ||
        49296 == d || 49324 == d || 49352 == d || 49380 == d || 49408 == d || 49436 == d || 49464 == d || 49492 == d || 49520 == d || 49548 == d || 49576 == d || 49604 == d || 49632 == d || 49660 == d || 49688 == d || 49716 == d || 49744 == d || 49772 == d || 49800 == d || 49828 == d || 49856 == d || 49884 == d || 49912 == d || 49940 == d || 49968 == d || 49996 == d || 50024 == d || 50052 == d || 50080 == d || 50108 == d || 50136 == d || 50164 == d || 50192 == d || 50220 == d || 50248 == d || 50276 == d || 50304 == d || 50332 == d || 50360 == d || 50388 == d || 50416 == d || 50444 == d || 50472 == d || 50500 == d || 50528 == d || 50556 == d || 50584 == d || 50612 == d || 50640 == d || 50668 == d || 50696 ==
        d || 50724 == d || 50752 == d || 50780 == d || 50808 == d || 50836 == d || 50864 == d || 50892 == d || 50920 == d || 50948 == d || 50976 == d || 51004 == d || 51032 == d || 51060 == d || 51088 == d || 51116 == d || 51144 == d || 51172 == d || 51200 == d || 51228 == d || 51256 == d || 51284 == d || 51312 == d || 51340 == d || 51368 == d || 51396 == d || 51424 == d || 51452 == d || 51480 == d || 51508 == d || 51536 == d || 51564 == d || 51592 == d || 51620 == d || 51648 == d || 51676 == d || 51704 == d || 51732 == d || 51760 == d || 51788 == d || 51816 == d || 51844 == d || 51872 == d || 51900 == d || 51928 == d || 51956 == d || 51984 == d || 52012 == d || 52040 == d || 52068 == d || 52096 == d ||
        52124 == d || 52152 == d || 52180 == d || 52208 == d || 52236 == d || 52264 == d || 52292 == d || 52320 == d || 52348 == d || 52376 == d || 52404 == d || 52432 == d || 52460 == d || 52488 == d || 52516 == d || 52544 == d || 52572 == d || 52600 == d || 52628 == d || 52656 == d || 52684 == d || 52712 == d || 52740 == d || 52768 == d || 52796 == d || 52824 == d || 52852 == d || 52880 == d || 52908 == d || 52936 == d || 52964 == d || 52992 == d || 53020 == d || 53048 == d || 53076 == d || 53104 == d || 53132 == d || 53160 == d || 53188 == d || 53216 == d || 53244 == d || 53272 == d || 53300 == d || 53328 == d || 53356 == d || 53384 == d || 53412 == d || 53440 == d || 53468 == d || 53496 == d || 53524 ==
        d || 53552 == d || 53580 == d || 53608 == d || 53636 == d || 53664 == d || 53692 == d || 53720 == d || 53748 == d || 53776 == d || 53804 == d || 53832 == d || 53860 == d || 53888 == d || 53916 == d || 53944 == d || 53972 == d || 54E3 == d || 54028 == d || 54056 == d || 54084 == d || 54112 == d || 54140 == d || 54168 == d || 54196 == d || 54224 == d || 54252 == d || 54280 == d || 54308 == d || 54336 == d || 54364 == d || 54392 == d || 54420 == d || 54448 == d || 54476 == d || 54504 == d || 54532 == d || 54560 == d || 54588 == d || 54616 == d || 54644 == d || 54672 == d || 54700 == d || 54728 == d || 54756 == d || 54784 == d || 54812 == d || 54840 == d || 54868 == d || 54896 == d || 54924 == d ||
        54952 == d || 54980 == d || 55008 == d || 55036 == d || 55064 == d || 55092 == d || 55120 == d || 55148 == d || 55176 == d ? 9 : 44033 <= d && 44059 >= d || 44061 <= d && 44087 >= d || 44089 <= d && 44115 >= d || 44117 <= d && 44143 >= d || 44145 <= d && 44171 >= d || 44173 <= d && 44199 >= d || 44201 <= d && 44227 >= d || 44229 <= d && 44255 >= d || 44257 <= d && 44283 >= d || 44285 <= d && 44311 >= d || 44313 <= d && 44339 >= d || 44341 <= d && 44367 >= d || 44369 <= d && 44395 >= d || 44397 <= d && 44423 >= d || 44425 <= d && 44451 >= d || 44453 <= d && 44479 >= d || 44481 <= d && 44507 >= d || 44509 <= d && 44535 >= d || 44537 <= d && 44563 >= d || 44565 <= d && 44591 >= d || 44593 <= d &&
        44619 >= d || 44621 <= d && 44647 >= d || 44649 <= d && 44675 >= d || 44677 <= d && 44703 >= d || 44705 <= d && 44731 >= d || 44733 <= d && 44759 >= d || 44761 <= d && 44787 >= d || 44789 <= d && 44815 >= d || 44817 <= d && 44843 >= d || 44845 <= d && 44871 >= d || 44873 <= d && 44899 >= d || 44901 <= d && 44927 >= d || 44929 <= d && 44955 >= d || 44957 <= d && 44983 >= d || 44985 <= d && 45011 >= d || 45013 <= d && 45039 >= d || 45041 <= d && 45067 >= d || 45069 <= d && 45095 >= d || 45097 <= d && 45123 >= d || 45125 <= d && 45151 >= d || 45153 <= d && 45179 >= d || 45181 <= d && 45207 >= d || 45209 <= d && 45235 >= d || 45237 <= d && 45263 >= d || 45265 <= d && 45291 >= d || 45293 <= d && 45319 >=
        d || 45321 <= d && 45347 >= d || 45349 <= d && 45375 >= d || 45377 <= d && 45403 >= d || 45405 <= d && 45431 >= d || 45433 <= d && 45459 >= d || 45461 <= d && 45487 >= d || 45489 <= d && 45515 >= d || 45517 <= d && 45543 >= d || 45545 <= d && 45571 >= d || 45573 <= d && 45599 >= d || 45601 <= d && 45627 >= d || 45629 <= d && 45655 >= d || 45657 <= d && 45683 >= d || 45685 <= d && 45711 >= d || 45713 <= d && 45739 >= d || 45741 <= d && 45767 >= d || 45769 <= d && 45795 >= d || 45797 <= d && 45823 >= d || 45825 <= d && 45851 >= d || 45853 <= d && 45879 >= d || 45881 <= d && 45907 >= d || 45909 <= d && 45935 >= d || 45937 <= d && 45963 >= d || 45965 <= d && 45991 >= d || 45993 <= d && 46019 >= d ||
        46021 <= d && 46047 >= d || 46049 <= d && 46075 >= d || 46077 <= d && 46103 >= d || 46105 <= d && 46131 >= d || 46133 <= d && 46159 >= d || 46161 <= d && 46187 >= d || 46189 <= d && 46215 >= d || 46217 <= d && 46243 >= d || 46245 <= d && 46271 >= d || 46273 <= d && 46299 >= d || 46301 <= d && 46327 >= d || 46329 <= d && 46355 >= d || 46357 <= d && 46383 >= d || 46385 <= d && 46411 >= d || 46413 <= d && 46439 >= d || 46441 <= d && 46467 >= d || 46469 <= d && 46495 >= d || 46497 <= d && 46523 >= d || 46525 <= d && 46551 >= d || 46553 <= d && 46579 >= d || 46581 <= d && 46607 >= d || 46609 <= d && 46635 >= d || 46637 <= d && 46663 >= d || 46665 <= d && 46691 >= d || 46693 <= d && 46719 >= d || 46721 <=
        d && 46747 >= d || 46749 <= d && 46775 >= d || 46777 <= d && 46803 >= d || 46805 <= d && 46831 >= d || 46833 <= d && 46859 >= d || 46861 <= d && 46887 >= d || 46889 <= d && 46915 >= d || 46917 <= d && 46943 >= d || 46945 <= d && 46971 >= d || 46973 <= d && 46999 >= d || 47001 <= d && 47027 >= d || 47029 <= d && 47055 >= d || 47057 <= d && 47083 >= d || 47085 <= d && 47111 >= d || 47113 <= d && 47139 >= d || 47141 <= d && 47167 >= d || 47169 <= d && 47195 >= d || 47197 <= d && 47223 >= d || 47225 <= d && 47251 >= d || 47253 <= d && 47279 >= d || 47281 <= d && 47307 >= d || 47309 <= d && 47335 >= d || 47337 <= d && 47363 >= d || 47365 <= d && 47391 >= d || 47393 <= d && 47419 >= d || 47421 <= d &&
        47447 >= d || 47449 <= d && 47475 >= d || 47477 <= d && 47503 >= d || 47505 <= d && 47531 >= d || 47533 <= d && 47559 >= d || 47561 <= d && 47587 >= d || 47589 <= d && 47615 >= d || 47617 <= d && 47643 >= d || 47645 <= d && 47671 >= d || 47673 <= d && 47699 >= d || 47701 <= d && 47727 >= d || 47729 <= d && 47755 >= d || 47757 <= d && 47783 >= d || 47785 <= d && 47811 >= d || 47813 <= d && 47839 >= d || 47841 <= d && 47867 >= d || 47869 <= d && 47895 >= d || 47897 <= d && 47923 >= d || 47925 <= d && 47951 >= d || 47953 <= d && 47979 >= d || 47981 <= d && 48007 >= d || 48009 <= d && 48035 >= d || 48037 <= d && 48063 >= d || 48065 <= d && 48091 >= d || 48093 <= d && 48119 >= d || 48121 <= d && 48147 >=
        d || 48149 <= d && 48175 >= d || 48177 <= d && 48203 >= d || 48205 <= d && 48231 >= d || 48233 <= d && 48259 >= d || 48261 <= d && 48287 >= d || 48289 <= d && 48315 >= d || 48317 <= d && 48343 >= d || 48345 <= d && 48371 >= d || 48373 <= d && 48399 >= d || 48401 <= d && 48427 >= d || 48429 <= d && 48455 >= d || 48457 <= d && 48483 >= d || 48485 <= d && 48511 >= d || 48513 <= d && 48539 >= d || 48541 <= d && 48567 >= d || 48569 <= d && 48595 >= d || 48597 <= d && 48623 >= d || 48625 <= d && 48651 >= d || 48653 <= d && 48679 >= d || 48681 <= d && 48707 >= d || 48709 <= d && 48735 >= d || 48737 <= d && 48763 >= d || 48765 <= d && 48791 >= d || 48793 <= d && 48819 >= d || 48821 <= d && 48847 >= d ||
        48849 <= d && 48875 >= d || 48877 <= d && 48903 >= d || 48905 <= d && 48931 >= d || 48933 <= d && 48959 >= d || 48961 <= d && 48987 >= d || 48989 <= d && 49015 >= d || 49017 <= d && 49043 >= d || 49045 <= d && 49071 >= d || 49073 <= d && 49099 >= d || 49101 <= d && 49127 >= d || 49129 <= d && 49155 >= d || 49157 <= d && 49183 >= d || 49185 <= d && 49211 >= d || 49213 <= d && 49239 >= d || 49241 <= d && 49267 >= d || 49269 <= d && 49295 >= d || 49297 <= d && 49323 >= d || 49325 <= d && 49351 >= d || 49353 <= d && 49379 >= d || 49381 <= d && 49407 >= d || 49409 <= d && 49435 >= d || 49437 <= d && 49463 >= d || 49465 <= d && 49491 >= d || 49493 <= d && 49519 >= d || 49521 <= d && 49547 >= d || 49549 <=
        d && 49575 >= d || 49577 <= d && 49603 >= d || 49605 <= d && 49631 >= d || 49633 <= d && 49659 >= d || 49661 <= d && 49687 >= d || 49689 <= d && 49715 >= d || 49717 <= d && 49743 >= d || 49745 <= d && 49771 >= d || 49773 <= d && 49799 >= d || 49801 <= d && 49827 >= d || 49829 <= d && 49855 >= d || 49857 <= d && 49883 >= d || 49885 <= d && 49911 >= d || 49913 <= d && 49939 >= d || 49941 <= d && 49967 >= d || 49969 <= d && 49995 >= d || 49997 <= d && 50023 >= d || 50025 <= d && 50051 >= d || 50053 <= d && 50079 >= d || 50081 <= d && 50107 >= d || 50109 <= d && 50135 >= d || 50137 <= d && 50163 >= d || 50165 <= d && 50191 >= d || 50193 <= d && 50219 >= d || 50221 <= d && 50247 >= d || 50249 <= d &&
        50275 >= d || 50277 <= d && 50303 >= d || 50305 <= d && 50331 >= d || 50333 <= d && 50359 >= d || 50361 <= d && 50387 >= d || 50389 <= d && 50415 >= d || 50417 <= d && 50443 >= d || 50445 <= d && 50471 >= d || 50473 <= d && 50499 >= d || 50501 <= d && 50527 >= d || 50529 <= d && 50555 >= d || 50557 <= d && 50583 >= d || 50585 <= d && 50611 >= d || 50613 <= d && 50639 >= d || 50641 <= d && 50667 >= d || 50669 <= d && 50695 >= d || 50697 <= d && 50723 >= d || 50725 <= d && 50751 >= d || 50753 <= d && 50779 >= d || 50781 <= d && 50807 >= d || 50809 <= d && 50835 >= d || 50837 <= d && 50863 >= d || 50865 <= d && 50891 >= d || 50893 <= d && 50919 >= d || 50921 <= d && 50947 >= d || 50949 <= d && 50975 >=
        d || 50977 <= d && 51003 >= d || 51005 <= d && 51031 >= d || 51033 <= d && 51059 >= d || 51061 <= d && 51087 >= d || 51089 <= d && 51115 >= d || 51117 <= d && 51143 >= d || 51145 <= d && 51171 >= d || 51173 <= d && 51199 >= d || 51201 <= d && 51227 >= d || 51229 <= d && 51255 >= d || 51257 <= d && 51283 >= d || 51285 <= d && 51311 >= d || 51313 <= d && 51339 >= d || 51341 <= d && 51367 >= d || 51369 <= d && 51395 >= d || 51397 <= d && 51423 >= d || 51425 <= d && 51451 >= d || 51453 <= d && 51479 >= d || 51481 <= d && 51507 >= d || 51509 <= d && 51535 >= d || 51537 <= d && 51563 >= d || 51565 <= d && 51591 >= d || 51593 <= d && 51619 >= d || 51621 <= d && 51647 >= d || 51649 <= d && 51675 >= d ||
        51677 <= d && 51703 >= d || 51705 <= d && 51731 >= d || 51733 <= d && 51759 >= d || 51761 <= d && 51787 >= d || 51789 <= d && 51815 >= d || 51817 <= d && 51843 >= d || 51845 <= d && 51871 >= d || 51873 <= d && 51899 >= d || 51901 <= d && 51927 >= d || 51929 <= d && 51955 >= d || 51957 <= d && 51983 >= d || 51985 <= d && 52011 >= d || 52013 <= d && 52039 >= d || 52041 <= d && 52067 >= d || 52069 <= d && 52095 >= d || 52097 <= d && 52123 >= d || 52125 <= d && 52151 >= d || 52153 <= d && 52179 >= d || 52181 <= d && 52207 >= d || 52209 <= d && 52235 >= d || 52237 <= d && 52263 >= d || 52265 <= d && 52291 >= d || 52293 <= d && 52319 >= d || 52321 <= d && 52347 >= d || 52349 <= d && 52375 >= d || 52377 <=
        d && 52403 >= d || 52405 <= d && 52431 >= d || 52433 <= d && 52459 >= d || 52461 <= d && 52487 >= d || 52489 <= d && 52515 >= d || 52517 <= d && 52543 >= d || 52545 <= d && 52571 >= d || 52573 <= d && 52599 >= d || 52601 <= d && 52627 >= d || 52629 <= d && 52655 >= d || 52657 <= d && 52683 >= d || 52685 <= d && 52711 >= d || 52713 <= d && 52739 >= d || 52741 <= d && 52767 >= d || 52769 <= d && 52795 >= d || 52797 <= d && 52823 >= d || 52825 <= d && 52851 >= d || 52853 <= d && 52879 >= d || 52881 <= d && 52907 >= d || 52909 <= d && 52935 >= d || 52937 <= d && 52963 >= d || 52965 <= d && 52991 >= d || 52993 <= d && 53019 >= d || 53021 <= d && 53047 >= d || 53049 <= d && 53075 >= d || 53077 <= d &&
        53103 >= d || 53105 <= d && 53131 >= d || 53133 <= d && 53159 >= d || 53161 <= d && 53187 >= d || 53189 <= d && 53215 >= d || 53217 <= d && 53243 >= d || 53245 <= d && 53271 >= d || 53273 <= d && 53299 >= d || 53301 <= d && 53327 >= d || 53329 <= d && 53355 >= d || 53357 <= d && 53383 >= d || 53385 <= d && 53411 >= d || 53413 <= d && 53439 >= d || 53441 <= d && 53467 >= d || 53469 <= d && 53495 >= d || 53497 <= d && 53523 >= d || 53525 <= d && 53551 >= d || 53553 <= d && 53579 >= d || 53581 <= d && 53607 >= d || 53609 <= d && 53635 >= d || 53637 <= d && 53663 >= d || 53665 <= d && 53691 >= d || 53693 <= d && 53719 >= d || 53721 <= d && 53747 >= d || 53749 <= d && 53775 >= d || 53777 <= d && 53803 >=
        d || 53805 <= d && 53831 >= d || 53833 <= d && 53859 >= d || 53861 <= d && 53887 >= d || 53889 <= d && 53915 >= d || 53917 <= d && 53943 >= d || 53945 <= d && 53971 >= d || 53973 <= d && 53999 >= d || 54001 <= d && 54027 >= d || 54029 <= d && 54055 >= d || 54057 <= d && 54083 >= d || 54085 <= d && 54111 >= d || 54113 <= d && 54139 >= d || 54141 <= d && 54167 >= d || 54169 <= d && 54195 >= d || 54197 <= d && 54223 >= d || 54225 <= d && 54251 >= d || 54253 <= d && 54279 >= d || 54281 <= d && 54307 >= d || 54309 <= d && 54335 >= d || 54337 <= d && 54363 >= d || 54365 <= d && 54391 >= d || 54393 <= d && 54419 >= d || 54421 <= d && 54447 >= d || 54449 <= d && 54475 >= d || 54477 <= d && 54503 >= d ||
        54505 <= d && 54531 >= d || 54533 <= d && 54559 >= d || 54561 <= d && 54587 >= d || 54589 <= d && 54615 >= d || 54617 <= d && 54643 >= d || 54645 <= d && 54671 >= d || 54673 <= d && 54699 >= d || 54701 <= d && 54727 >= d || 54729 <= d && 54755 >= d || 54757 <= d && 54783 >= d || 54785 <= d && 54811 >= d || 54813 <= d && 54839 >= d || 54841 <= d && 54867 >= d || 54869 <= d && 54895 >= d || 54897 <= d && 54923 >= d || 54925 <= d && 54951 >= d || 54953 <= d && 54979 >= d || 54981 <= d && 55007 >= d || 55009 <= d && 55035 >= d || 55037 <= d && 55063 >= d || 55065 <= d && 55091 >= d || 55093 <= d && 55119 >= d || 55121 <= d && 55147 >= d || 55149 <= d && 55175 >= d || 55177 <= d && 55203 >= d ? 10 :
        9757 == d || 9977 == d || 9994 <= d && 9997 >= d || 127877 == d || 127938 <= d && 127940 >= d || 127943 == d || 127946 <= d && 127948 >= d || 128066 <= d && 128067 >= d || 128070 <= d && 128080 >= d || 128110 == d || 128112 <= d && 128120 >= d || 128124 == d || 128129 <= d && 128131 >= d || 128133 <= d && 128135 >= d || 128170 == d || 128372 <= d && 128373 >= d || 128378 == d || 128400 == d || 128405 <= d && 128406 >= d || 128581 <= d && 128583 >= d || 128587 <= d && 128591 >= d || 128675 == d || 128692 <= d && 128694 >= d || 128704 == d || 128716 == d || 129304 <= d && 129308 >= d || 129310 <= d && 129311 >= d || 129318 == d || 129328 <= d && 129337 >= d || 129341 <= d && 129342 >=
        d || 129489 <= d && 129501 >= d ? 13 : 127995 <= d && 127999 >= d ? 14 : 8205 == d ? 15 : 9792 == d || 9794 == d || 9877 <= d && 9878 >= d || 9992 == d || 10084 == d || 127752 == d || 127806 == d || 127859 == d || 127891 == d || 127908 == d || 127912 == d || 127979 == d || 127981 == d || 128139 == d || 128187 <= d && 128188 >= d || 128295 == d || 128300 == d || 128488 == d || 128640 == d || 128658 == d ? 16 : 128102 <= d && 128105 >= d ? 17 : 11
    }
    this.nextBreak = function(d, e) {
        void 0 === e && (e = 0);
        if (0 > e)
            return 0;
        if (e >= d.length - 1)
            return d.length;
        var f = c(a(d, e)),
            g = [];
        for (e += 1; e < d.length; e++) {
            var h = d,
                k = e - 1;
            if (!(55296 <= h.charCodeAt(k) &&
            56319 >= h.charCodeAt(k) && 56320 <= h.charCodeAt(k + 1) && 57343 >= h.charCodeAt(k + 1))) {
                h = c(a(d, e));
                if (b(f, g, h))
                    return e;
                g.push(h)
            }
        }
        return d.length
    };
    this.splitGraphemes = function(d) {
        for (var e = [], f = 0, g; (g = this.nextBreak(d, f)) < d.length;)
            e.push(d.slice(f, g)),
            f = g;
        f < d.length && e.push(d.slice(f));
        return e
    };
    this.iterateGraphemes = function(d) {
        var e = 0,
            f = {
                next: function() {
                    var g;
                    if ((g = this.nextBreak(d, e)) < d.length) {
                        var h = d.slice(e, g);
                        e = g;
                        return {
                            value: h,
                            done: !1
                        }
                    }
                    return e < d.length ? (h = d.slice(e), e = d.length, {
                        value: h,
                        done: !1
                    }) :
                    {
                        value: void 0,
                        done: !0
                    }
                }.bind(this)
            };
        "undefined" !== typeof Symbol && Symbol.iterator && (f[Symbol.iterator] = function() {
            return f
        });
        return f
    };
    this.countGraphemes = function(d) {
        for (var e = 0, f = 0, g; (g = this.nextBreak(d, f)) < d.length;)
            f = g,
            e++;
        f < d.length && e++;
        return e
    };
    return this
};
"use strict";
function lineInt(a, b, c) {
    var d = [0, 0];
    var e = a[1][1] - a[0][1];
    var f = a[0][0] - a[1][0];
    a = e * a[0][0] + f * a[0][1];
    var g = b[1][1] - b[0][1];
    var h = b[0][0] - b[1][0];
    b = g * b[0][0] + h * b[0][1];
    var k = e * h - g * f;
    scalar_eq(k, 0, c || 0) || (d[0] = (h * a - f * b) / k, d[1] = (e * b - g * a) / k);
    return d
}
function lineSegmentsIntersect(a, b, c, d) {
    var e = b[0] - a[0];
    b = b[1] - a[1];
    var f = d[0] - c[0],
        g = d[1] - c[1];
    if (0 === f * b - g * e)
        return !1;
    d = (e * (c[1] - a[1]) + b * (a[0] - c[0])) / (f * b - g * e);
    a = (f * (a[1] - c[1]) + g * (c[0] - a[0])) / (g * e - f * b);
    return 0 <= d && 1 >= d && 0 <= a && 1 >= a
}
function triangleArea(a, b, c) {
    return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1])
}
function isLeft(a, b, c) {
    return 0 < triangleArea(a, b, c)
}
function isLeftOn(a, b, c) {
    return 0 <= triangleArea(a, b, c)
}
function isRight(a, b, c) {
    return 0 > triangleArea(a, b, c)
}
function isRightOn(a, b, c) {
    return 0 >= triangleArea(a, b, c)
}
var tmpPoint1$$module$content$working$237635295$scripts$c3runtime = [],
    tmpPoint2$$module$content$working$237635295$scripts$c3runtime = [];
function collinear(a, b, c, d) {
    if (d) {
        var e = tmpPoint1$$module$content$working$237635295$scripts$c3runtime,
            f = tmpPoint2$$module$content$working$237635295$scripts$c3runtime;
        e[0] = b[0] - a[0];
        e[1] = b[1] - a[1];
        f[0] = c[0] - b[0];
        f[1] = c[1] - b[1];
        return Math.acos((e[0] * f[0] + e[1] * f[1]) / (Math.sqrt(e[0] * e[0] + e[1] * e[1]) * Math.sqrt(f[0] * f[0] + f[1] * f[1]))) < d
    }
    return 0 === triangleArea(a, b, c)
}
function sqdist(a, b) {
    var c = b[0] - a[0];
    a = b[1] - a[1];
    return c * c + a * a
}
function polygonAt(a, b) {
    var c = a.length;
    return a[0 > b ? b % c + c : b % c]
}
function polygonClear(a) {
    a.length = 0
}
function polygonAppend(a, b, c, d) {
    for (; c < d; c++)
        a.push(b[c])
}
function polygonReverse(a) {
    for (var b = [], c = a.length, d = 0; d !== c; d++)
        b.push(a.pop());
    for (d = 0; d !== c; d++)
        a[d] = b[d]
}
function polygonIsReflex(a, b) {
    return isRight(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, b + 1))
}
var tmpLine1$$module$content$working$237635295$scripts$c3runtime = [],
    tmpLine2$$module$content$working$237635295$scripts$c3runtime = [];
function polygonCanSee(a, b, c) {
    var d = tmpLine1$$module$content$working$237635295$scripts$c3runtime,
        e = tmpLine2$$module$content$working$237635295$scripts$c3runtime;
    if (isLeftOn(polygonAt(a, b + 1), polygonAt(a, b), polygonAt(a, c)) && isRightOn(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, c)))
        return !1;
    var f = sqdist(polygonAt(a, b), polygonAt(a, c));
    for (var g = 0; g !== a.length; ++g)
        if ((g + 1) % a.length !== b && g !== b && isLeftOn(polygonAt(a, b), polygonAt(a, c), polygonAt(a, g + 1)) && isRightOn(polygonAt(a, b), polygonAt(a, c), polygonAt(a,
        g))) {
            d[0] = polygonAt(a, b);
            d[1] = polygonAt(a, c);
            e[0] = polygonAt(a, g);
            e[1] = polygonAt(a, g + 1);
            var h = lineInt(d, e);
            if (sqdist(polygonAt(a, b), h) < f)
                return !1
        }
    return !0
}
function polygonCanSee2(a, b, c) {
    for (var d = 0; d !== a.length; ++d)
        if (d !== b && d !== c && (d + 1) % a.length !== b && (d + 1) % a.length !== c && lineSegmentsIntersect(polygonAt(a, b), polygonAt(a, c), polygonAt(a, d), polygonAt(a, d + 1)))
            return !1;
    return !0
}
function polygonCopy(a, b, c, d) {
    d = d || [];
    polygonClear(d);
    if (b < c)
        for (var e = b; e <= c; e++)
            d.push(a[e]);
    else {
        for (e = 0; e <= c; e++)
            d.push(a[e]);
        for (e = b; e < a.length; e++)
            d.push(a[e])
    }
    return d
}
function polygonGetCutEdges(a) {
    for (var b = [], c, d, e = [], f = Number.MAX_VALUE, g = 0; g < a.length; ++g)
        if (polygonIsReflex(a, g))
            for (var h = 0; h < a.length; ++h)
                if (polygonCanSee(a, g, h)) {
                    c = polygonGetCutEdges(polygonCopy(a, g, h, e));
                    d = polygonGetCutEdges(polygonCopy(a, h, g, e));
                    for (var k = 0; k < d.length; k++)
                        c.push(d[k]);
                    c.length < f && (b = c, f = c.length, b.push([polygonAt(a, g), polygonAt(a, h)]))
                }
    return b
}
function polygonSlice(a, b) {
    if (0 === b.length)
        return [a];
    if (b instanceof Array && b.length && b[0] instanceof Array && 2 === b[0].length && b[0][0] instanceof Array) {
        a = [a];
        for (var c = 0; c < b.length; c++)
            for (var d = b[c], e = 0; e < a.length; e++) {
                var f = polygonSlice(a[e], d);
                if (f) {
                    a.splice(e, 1);
                    a.push(f[0], f[1]);
                    break
                }
            }
        return a
    }
    d = b;
    c = a.indexOf(d[0]);
    e = a.indexOf(d[1]);
    return -1 !== c && -1 !== e ? [polygonCopy(a, c, e), polygonCopy(a, e, c)] : !1
}
function getIntersectionPoint(a, b, c, d, e) {
    var f = b[1] - a[1];
    b = a[0] - b[0];
    a = f * a[0] + b * a[1];
    var g = d[1] - c[1];
    d = c[0] - d[0];
    c = g * c[0] + d * c[1];
    var h = f * d - g * b;
    return scalar_eq(h, 0, e || 0) ? [0, 0] : [(d * a - b * c) / h, (f * c - g * a) / h]
}
function polygonQuickDecomp(a, b, c, d, e, f, g) {
    f = f || 100;
    g = g || 0;
    e = e || 25;
    b = "undefined" !== typeof b ? b : [];
    c = c || [];
    d = d || [];
    var h = [0, 0],
        k = [0, 0],
        l = [0, 0],
        m,
        n = 0,
        p = 0,
        q = 0,
        r = [],
        t = [];
    if (3 > a.length)
        return b;
    g++;
    if (g > f)
        return console.warn("quickDecomp: max level (" + f + ") reached."), b;
    for (var u = 0; u < a.length; ++u)
        if (polygonIsReflex(a, u)) {
            c.push(a[u]);
            var v = m = Number.MAX_VALUE;
            for (var w = 0; w < a.length; ++w) {
                if (isLeft(polygonAt(a, u - 1), polygonAt(a, u), polygonAt(a, w)) && isRightOn(polygonAt(a, u - 1), polygonAt(a, u), polygonAt(a, w - 1)) &&
                (l = getIntersectionPoint(polygonAt(a, u - 1), polygonAt(a, u), polygonAt(a, w), polygonAt(a, w - 1)), isRight(polygonAt(a, u + 1), polygonAt(a, u), l))) {
                    var x = sqdist(a[u], l);
                    x < m && (m = x, k = l, p = w)
                }
                isLeft(polygonAt(a, u + 1), polygonAt(a, u), polygonAt(a, w + 1)) && isRightOn(polygonAt(a, u + 1), polygonAt(a, u), polygonAt(a, w)) && (l = getIntersectionPoint(polygonAt(a, u + 1), polygonAt(a, u), polygonAt(a, w), polygonAt(a, w + 1)), isLeft(polygonAt(a, u - 1), polygonAt(a, u), l) && (x = sqdist(a[u], l), x < v && (v = x, h = l, n = w)))
            }
            if (p === (n + 1) % a.length)
                l[0] = (k[0] + h[0]) /
                2,
                l[1] = (k[1] + h[1]) / 2,
                d.push(l),
                u < n ? (polygonAppend(r, a, u, n + 1), r.push(l), t.push(l), 0 !== p && polygonAppend(t, a, p, a.length), polygonAppend(t, a, 0, u + 1)) : (0 !== u && polygonAppend(r, a, u, a.length), polygonAppend(r, a, 0, n + 1), r.push(l), t.push(l), polygonAppend(t, a, p, u + 1));
            else {
                p > n && (n += a.length);
                h = Number.MAX_VALUE;
                if (n < p)
                    return b;
                for (w = p; w <= n; ++w)
                    isLeftOn(polygonAt(a, u - 1), polygonAt(a, u), polygonAt(a, w)) && isRightOn(polygonAt(a, u + 1), polygonAt(a, u), polygonAt(a, w)) && (x = sqdist(polygonAt(a, u), polygonAt(a, w)), x < h && polygonCanSee2(a,
                    u, w) && (h = x, q = w % a.length));
                u < q ? (polygonAppend(r, a, u, q + 1), 0 !== q && polygonAppend(t, a, q, a.length), polygonAppend(t, a, 0, u + 1)) : (0 !== u && polygonAppend(r, a, u, a.length), polygonAppend(r, a, 0, q + 1), polygonAppend(t, a, q, u + 1))
            }
            r.length < t.length ? (polygonQuickDecomp(r, b, c, d, e, f, g), polygonQuickDecomp(t, b, c, d, e, f, g)) : (polygonQuickDecomp(t, b, c, d, e, f, g), polygonQuickDecomp(r, b, c, d, e, f, g));
            return b
        }
    b.push(a);
    return b
}
function scalar_eq(a, b, c) {
    return Math.abs(a - b) <= (c || 0)
}
function points_eq(a, b, c) {
    return scalar_eq(a[0], b[0], c) && scalar_eq(a[1], b[1], c)
}
self.polyDecomp = {
    decomp: function(a) {
        var b = polygonGetCutEdges(a);
        return 0 < b.length ? polygonSlice(a, b) : [a]
    },
    quickDecomp: polygonQuickDecomp,
    isSimple: function(a) {
        var b;
        for (b = 0; b < a.length - 1; b++)
            for (var c = 0; c < b - 1; c++)
                if (lineSegmentsIntersect(a[b], a[b + 1], a[c], a[c + 1]))
                    return !1;
        for (b = 1; b < a.length - 2; b++)
            if (lineSegmentsIntersect(a[0], a[a.length - 1], a[b], a[b + 1]))
                return !1;
        return !0
    },
    removeCollinearPoints: function(a, b) {
        for (var c = 0, d = a.length - 1; 3 < a.length && 0 <= d; --d)
            collinear(polygonAt(a, d - 1), polygonAt(a, d), polygonAt(a,
            d + 1), b) && (a.splice(d % a.length, 1), c++);
        return c
    },
    removeDuplicatePoints: function(a, b) {
        for (var c = a.length - 1; 1 <= c; --c)
            for (var d = a[c], e = c - 1; 0 <= e; --e)
                points_eq(d, a[e], b) && a.splice(c, 1)
    },
    makeCCW: function(a) {
        for (var b = 0, c = 1; c < a.length; ++c)
            if (a[c][1] < a[b][1] || a[c][1] === a[b][1] && a[c][0] > a[b][0])
                b = c;
        if (isLeft(polygonAt(a, b - 1), polygonAt(a, b), polygonAt(a, b + 1)))
            return !1;
        polygonReverse(a);
        return !0
    }
};
"use strict";
let isReady = !1,
    hasAppStarted = !1,
    buildMode = "dev";
const internalApiToken = Symbol("Construct internal API token");
let internalApiTokenAccessesRemaining = 14;
const C3 = self.C3 = class {
    constructor()
    {
        throw TypeError("static class can't be instantiated");
    }
    static _GetInternalAPIToken()
    {
        if (0 >= internalApiTokenAccessesRemaining)
            throw Error("cannot obtain internal API token");
        --internalApiTokenAccessesRemaining;
        return internalApiToken
    }
    static SetReady()
    {
        isReady = !0
    }
    static IsReady()
    {
        return isReady
    }
    static SetAppStarted()
    {
        hasAppStarted = !0
    }
    static HasAppStarted()
    {
        return hasAppStarted
    }
    static SetBuildMode(a)
    {
        buildMode = a
    }
    static GetBuildMode()
    {
        return buildMode
    }
    static IsReleaseBuild()
    {
        return "final" === buildMode
    }
}
;
C3.isDebug = !1;
C3.isDebugDefend = !1;
C3.hardwareConcurrency = navigator.hardwareConcurrency || 2;
self.C3X = {};
"use strict";
const C3$jscomp$2 = self.C3;
C3$jscomp$2.QueryParser = class {
    constructor(a)
    {
        this._queryString = a;
        this._parameters = new Map;
        this._Parse()
    }
    _Parse()
    {
        var a = this._queryString;
        if (a.startsWith("?") || a.startsWith("#"))
            a = a.substr(1);
        a = a.split("&");
        for (const b of a)
            this._ParseParameter(b)
    }
    _ParseParameter(a)
    {
        if (a)
            if (a.includes("=")) {
                var b = a.indexOf("="),
                    c = decodeURIComponent(a.substring(0, b));
                a = decodeURIComponent(a.substring(b + 1));
                this._parameters.set(c, a)
            } else
                this._parameters.set(a, null)
    }
    LogAll()
    {
        for (const a of this._parameters)
            console.log("[QueryParser] Parameter '" +
            a[0] + "' = " + (null === a[1] ? "null" : "'" + a[1] + "'"))
    }
    Has(a)
    {
        return this._parameters.has(a)
    }
    Get(a)
    {
        a = this._parameters.get(a);
        return "undefined" === typeof a ? null : a
    }
    ClearHash()
    {
        history.replaceState("", document.title, location.pathname + location.search)
    }
    Reparse(a)
    {
        this._queryString = a;
        this._parameters.clear();
        this._Parse()
    }
}
;
C3$jscomp$2.QueryString = new C3$jscomp$2.QueryParser(location.search);
C3$jscomp$2.LocationHashString = new C3$jscomp$2.QueryParser(location.hash);
C3$jscomp$2.QueryString.Has("perf") && (C3$jscomp$2.isPerformanceProfiling = !0);
"dev" !== C3$jscomp$2.QueryString.Get("mode") && C3$jscomp$2.SetBuildMode("final");
"use strict";
const C3$jscomp$3 = self.C3;
C3$jscomp$3.Platform = {
    OS: "(unknown)",
    OSVersion: "(unknown)",
    Browser: "(unknown)",
    BrowserVersion: "(unknown)",
    BrowserVersionNumber: NaN,
    BrowserEngine: "(unknown)",
    Context: "browser",
    IsDesktop: !0,
    IsMobile: !1,
    IsAppleOS: !1,
    IsIpadOS: !1,
    GetDetailedInfo: async () => {}
};
const windowsNTVerMap = new Map([[5, "2000"], [5.1, "XP"], [5.2, "XP"], [6, "Vista"], [6.1, "7"], [6.2, "8"], [6.3, "8.1"], [10, "10"]]);
function GetWindowsNTVersionName(a) {
    const b = parseFloat(a),
        c = windowsNTVerMap.get(b);
    return c ? c : 13 <= b ? "11" : "NT " + a
}
const uaStr = navigator.userAgent,
    uaData = navigator.userAgentData;
if (uaData && 0 < uaData.brands.length) {
    C3$jscomp$3.Platform.OS = uaData.platform;
    C3$jscomp$3.Platform.IsMobile = uaData.mobile;
    C3$jscomp$3.Platform.IsDesktop = !C3$jscomp$3.Platform.IsMobile;
    const a = new Map([["Google Chrome", "Chrome"], ["Microsoft Edge", "Edge"], ["Opera", "Opera"], ["Opera GX", "Opera GX"], ["Mozilla Firefox", "Firefox"], ["Apple Safari", "Safari"], ["NW.js", "NW.js"]]),
        b = new Map([["Chromium", "Chromium"], ["Gecko", "Gecko"], ["WebKit", "WebKit"]]);
    function c(e) {
        let f = "",
            g = "",
            h = "",
            k = "";
        for (const l of e)
            e =
            a.get(l.brand),
            !f && e && (f = e, g = l.version),
            e = b.get(l.brand),
            !h && e && (h = e, k = l.version);
        f || "Chromium" !== h || (C3$jscomp$3.Platform.Browser = "Chromium", C3$jscomp$3.Platform.BrowserVersion = k);
        C3$jscomp$3.Platform.Browser = f || "(unknown)";
        C3$jscomp$3.Platform.BrowserVersion = g || "(unknown)";
        C3$jscomp$3.Platform.BrowserEngine = h || "(unknown)"
    }
    c(uaData.brands);
    let d = !1;
    C3$jscomp$3.Platform.GetDetailedInfo = async () => {
        if (!d)
            try {
                const e = await navigator.userAgentData.getHighEntropyValues(["platformVersion", "fullVersionList"]);
                c(e.fullVersionList);
                C3$jscomp$3.Platform.OSVersion = "Windows" === C3$jscomp$3.Platform.OS ? GetWindowsNTVersionName(e.platformVersion) : e.platformVersion;
                d = !0
            } catch (e) {
                console.warn("Failed to get detailed user agent information: ", e)
            }
    }
} else {
    function a(l, m) {
        l = Array.isArray(l) ? l : [l];
        for (const n of l)
            if (l = n.exec(uaStr)) {
                m(l);
                break
            }
    }
    a(/windows\s+nt\s+([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.OS = "Windows";
        C3$jscomp$3.Platform.OSVersion = GetWindowsNTVersionName(l[1])
    });
    a(/mac\s+os\s+x\s+([\d\._]+)/i, l => {
        C3$jscomp$3.Platform.OS =
        "macOS";
        C3$jscomp$3.Platform.OSVersion = l[1].replace(/_/g, ".")
    });
    a(/CrOS/, () => {
        C3$jscomp$3.Platform.OS = "Chrome OS"
    });
    a(/linux|openbsd|freebsd|netbsd/i, () => {
        C3$jscomp$3.Platform.OS = "Linux"
    });
    a(/android/i, () => {
        C3$jscomp$3.Platform.OS = "Android"
    });
    a(/android\s+([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.OS = "Android";
        C3$jscomp$3.Platform.OSVersion = l[1]
    });
    "(unknown)" === C3$jscomp$3.Platform.OS && (a(/(iphone|ipod|ipad)/i, l => {
        C3$jscomp$3.Platform.OS = "iOS"
    }), a([/iphone\s+os\s+([\d\._]+)/i, /ipad[^)]*os\s+([\d\._]+)/i],
    l => {
        C3$jscomp$3.Platform.OS = "iOS";
        C3$jscomp$3.Platform.OSVersion = l[1].replace(/_/g, ".")
    }));
    const b = /chrome\//i.test(uaStr),
        c = /chromium\//i.test(uaStr),
        d = /edg\//i.test(uaStr),
        e = /OPR\//.test(uaStr),
        f = /nwjs/i.test(uaStr),
        g = /safari\//i.test(uaStr),
        h = /webkit/i.test(uaStr);
    d || e || a(/chrome\/([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.Browser = "Chrome";
        C3$jscomp$3.Platform.BrowserVersion = l[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    });
    a(/edg\/([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.Browser = "Edge";
        C3$jscomp$3.Platform.BrowserVersion =
        l[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    });
    a(/OPR\/([\d\.]+)/, l => {
        C3$jscomp$3.Platform.Browser = "Opera";
        C3$jscomp$3.Platform.BrowserVersion = l[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    });
    a(/chromium\/([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.Browser = "Chromium";
        C3$jscomp$3.Platform.BrowserVersion = l[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium"
    });
    a(/nwjs\/[0-9.]+/i, l => {
        C3$jscomp$3.Platform.Browser = "NW.js";
        C3$jscomp$3.Platform.BrowserVersion = l[1];
        C3$jscomp$3.Platform.BrowserEngine = "Chromium";
        C3$jscomp$3.Platform.Context = "nwjs"
    });
    a(/firefox\/([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.Browser = "Firefox";
        C3$jscomp$3.Platform.BrowserVersion = l[1];
        C3$jscomp$3.Platform.BrowserEngine = "Gecko"
    });
    !g || b || c || d || e || f || (C3$jscomp$3.Platform.Browser = "Safari", C3$jscomp$3.Platform.BrowserEngine = "WebKit", a(/version\/([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.BrowserVersion = l[1]
    }), a(/crios\/([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.Browser = "Chrome for iOS";
        C3$jscomp$3.Platform.BrowserVersion = l[1]
    }), a(/fxios\/([\d\.]+)/i,
    l => {
        C3$jscomp$3.Platform.Browser = "Firefox for iOS";
        C3$jscomp$3.Platform.BrowserVersion = l[1]
    }), a(/edgios\/([\d\.]+)/i, l => {
        C3$jscomp$3.Platform.Browser = "Edge for iOS";
        C3$jscomp$3.Platform.BrowserVersion = l[1]
    }));
    "(unknown)" === C3$jscomp$3.Platform.BrowserEngine && h && (C3$jscomp$3.Platform.BrowserEngine = "WebKit");
    "Android" === C3$jscomp$3.Platform.OS && "Safari" === C3$jscomp$3.Platform.Browser && (C3$jscomp$3.Platform.Browser = "Stock");
    const k = (new Set(["Windows", "macOS", "Linux", "Chrome OS"])).has(C3$jscomp$3.Platform.OS) ||
    "nwjs" === C3$jscomp$3.Platform.Context;
    C3$jscomp$3.Platform.IsDesktop = k;
    C3$jscomp$3.Platform.IsMobile = !k
}
"Chrome" === C3$jscomp$3.Platform.Browser && "browser" === C3$jscomp$3.Platform.Context && /wv\)/.test(uaStr) && (C3$jscomp$3.Platform.Context = "webview");
"nwjs" !== C3$jscomp$3.Platform.Context && "undefined" !== typeof window && (window.matchMedia && window.matchMedia("(display-mode: standalone)").matches || navigator.standalone) && (C3$jscomp$3.Platform.Context = "webapp");
C3$jscomp$3.Platform.BrowserVersionNumber = parseFloat(C3$jscomp$3.Platform.BrowserVersion);
"macOS" === C3$jscomp$3.Platform.OS && navigator.maxTouchPoints && 2 < navigator.maxTouchPoints && (C3$jscomp$3.Platform.OS = "iOS", C3$jscomp$3.Platform.OSVersion = C3$jscomp$3.Platform.BrowserVersion, C3$jscomp$3.Platform.IsDesktop = !1, C3$jscomp$3.Platform.IsMobile = !0, C3$jscomp$3.Platform.IsIpadOS = !0);
C3$jscomp$3.Platform.IsAppleOS = "macOS" === C3$jscomp$3.Platform.OS || "iOS" === C3$jscomp$3.Platform.OS;
"use strict";
const DATABASE_PROMISE_MAP = new Map,
    SUPPORTS_GETALL = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAll,
    SUPPORTS_GETALLKEYS = "undefined" !== typeof IDBObjectStore && "function" === typeof IDBObjectStore.prototype.getAllKeys;
function asyncifyRequest(a) {
    return new Promise((b, c) => {
        a.onsuccess = () => b(a.result);
        a.onerror = () => c(a.error)
    })
}
function asyncifyTransaction(a) {
    return new Promise((b, c) => {
        a.oncomplete = () => b();
        a.onerror = () => c(a.error);
        a.onabort = () => c(a.error)
    })
}
function openReadOnlyTransaction(a, b) {
    return openTransaction(a, b)
}
function openWriteTransaction(a, b) {
    return openTransaction(a, b, !0)
}
async function openTransaction(a, b, c=!1, d=!0) {
    const e = await lazyOpenDatabase(a);
    try {
        const f = e.transaction(["keyvaluepairs"], c ? "readwrite" : "readonly");
        return b(f)
    } catch (f) {
        if (d && "InvalidStateError" === f.name)
            return DATABASE_PROMISE_MAP.delete(a), openTransaction(a, b, c, !1);
        throw f;
    }
}
function lazyOpenDatabase(a) {
    RequireString(a);
    let b = DATABASE_PROMISE_MAP.get(a);
    b instanceof Promise || (b = openDatabase$jscomp$1(a), DATABASE_PROMISE_MAP.set(a, b), b.catch(c => DATABASE_PROMISE_MAP.delete(a)));
    return b
}
async function openDatabase$jscomp$1(a) {
    RequireString(a);
    const b = indexedDB.open(a, 2);
    b.addEventListener("upgradeneeded", c => {
        try {
            c.target.result.createObjectStore("keyvaluepairs")
        } catch (d) {
            console.error(`Failed to create objectstore for database ${a}`, d)
        }
    });
    return asyncifyRequest(b)
}
function RequireString(a) {
    if ("string" !== typeof a)
        throw new TypeError("expected string");
}
function getEntriesFromCursor(a, b) {
    const c = a.objectStore("keyvaluepairs").openCursor();
    return new Promise(d => {
        const e = [];
        c.onsuccess = f => {
            if (f = f.target.result) {
                switch (b) {
                case "entries":
                    e.push([f.key, f.value]);
                    break;
                case "keys":
                    e.push(f.key);
                    break;
                case "values":
                    e.push(f.value)
                }
                f.continue()
            } else
                d(e)
        }
    })
}
class KVStorageContainer {
    constructor(a)
    {
        RequireString(a);
        this.name = a
    }
    async ready()
    {
        await lazyOpenDatabase(this.name)
    }
    set(a, b)
    {
        RequireString(a);
        return openWriteTransaction(this.name, async c => {
            var d = c.objectStore("keyvaluepairs").put(b, a);
            d = asyncifyRequest(d);
            c = asyncifyTransaction(c);
            await Promise.all([c, d])
        })
    }
    get(a)
    {
        RequireString(a);
        return openReadOnlyTransaction(this.name, async b => {
            var c = b.objectStore("keyvaluepairs").get(a);
            c = asyncifyRequest(c);
            b = asyncifyTransaction(b);
            [, b] = await Promise.all([b,
            c]);
            return b
        })
    }
    delete(a)
    {
        RequireString(a);
        return openWriteTransaction(this.name, async b => {
            var c = b.objectStore("keyvaluepairs").delete(a);
            c = asyncifyRequest(c);
            b = asyncifyTransaction(b);
            await Promise.all([b, c])
        })
    }
    clear()
    {
        return openWriteTransaction(this.name, async a => {
            var b = a.objectStore("keyvaluepairs").clear();
            b = asyncifyRequest(b);
            a = asyncifyTransaction(a);
            await Promise.all([a, b])
        })
    }
    keys()
    {
        return openReadOnlyTransaction(this.name, async a => {
            if (SUPPORTS_GETALLKEYS) {
                var b = a.objectStore("keyvaluepairs").getAllKeys();
                b = asyncifyRequest(b)
            } else
                b = getEntriesFromCursor(a, "keys");
            a = asyncifyTransaction(a);
            [, a] = await Promise.all([a, b]);
            return a
        })
    }
    values()
    {
        return openReadOnlyTransaction(this.name, async a => {
            if (SUPPORTS_GETALL) {
                var b = a.objectStore("keyvaluepairs").getAll();
                b = asyncifyRequest(b)
            } else
                b = getEntriesFromCursor(a, "values");
            a = asyncifyTransaction(a);
            [, a] = await Promise.all([a, b]);
            return a
        })
    }
    entries()
    {
        return openReadOnlyTransaction(this.name, async a => {
            var b = getEntriesFromCursor(a, "entries");
            a = asyncifyTransaction(a);
            [, b] = await Promise.all([a, b]);
            return b
        })
    }
}
self.KVStorageContainer = KVStorageContainer;
"use strict";
const KVStorageContainer$jscomp$1 = self.KVStorageContainer,
    CRITICAL_ERRORS = [/no available storage method found/i, /an attempt was made to break through the security policy of the user agent/i, /the user denied permission to access the database/i, /a mutation operation was attempted on a database that did not allow mutations/i, /idbfactory\.open\(\) called in an invalid security context/i],
    memoryStorage = new WeakMap;
let isInMemory = !1;
"undefined" === typeof indexedDB && (isInMemory = !0, console.warn("Unable to use local storage because indexedDB is not defined"));
function NOT_IMPLEMENTED(a) {
    throw Error(`"${a}" is not implemented`);
}
function DISALLOW_CALLBACK(a) {
    if ("function" === typeof a)
        throw Error("localforage callback API is not implemented; please use the promise API instead");
}
function StructuredClone(a) {
    return "object" === typeof a ? new Promise(b => {
        const {port1: c, port2: d} = new MessageChannel;
        d.onmessage = e => b(e.data);
        c.postMessage(a)
    }) : Promise.resolve(a)
}
class ForageAdaptor {
    constructor(a)
    {
        this._inst = a;
        memoryStorage.set(this, new Map)
    }
    _MaybeSwitchToMemoryFallback(a)
    {
        if (!isInMemory)
            for (const b of CRITICAL_ERRORS)
                if (a && b.test(a.message)) {
                    console.error("Unable to use local storage, reverting to in-memory store: ", a, a.message);
                    isInMemory = !0;
                    break
                }
    }
    async _getItemFallback(a)
    {
        a = memoryStorage.get(this).get(a);
        a = await StructuredClone(a);
        return "undefined" === typeof a ? null : a
    }
    async _setItemFallback(a, b)
    {
        b = await StructuredClone(b);
        memoryStorage.get(this).set(a, b)
    }
    _removeItemFallback(a)
    {
        memoryStorage.get(this).delete(a)
    }
    _clearFallback()
    {
        memoryStorage.get(this).clear()
    }
    _keysFallback()
    {
        return Array.from(memoryStorage.get(this).keys())
    }
    IsUsingFallback()
    {
        return isInMemory
    }
    async getItem(a,
    b)
    {
        DISALLOW_CALLBACK(b);
        if (isInMemory)
            return await this._getItemFallback(a);
        let c;
        try {
            c = await this._inst.get(a)
        } catch (d) {
            this._MaybeSwitchToMemoryFallback(d);
            if (isInMemory)
                return await this._getItemFallback(a);
            console.error(`Error reading '${a}' from storage, returning null: `, d);
            return null
        }
        return "undefined" === typeof c ? null : c
    }
    async setItem(a, b, c)
    {
        DISALLOW_CALLBACK(c);
        "undefined" === typeof b && (b = null);
        if (isInMemory)
            await this._setItemFallback(a, b);
        else
            try {
                await this._inst.set(a, b)
            } catch (d) {
                if (this._MaybeSwitchToMemoryFallback(d),
                isInMemory)
                    await this._setItemFallback(a, b);
                else
                    throw d;
            }
    }
    async removeItem(a, b)
    {
        DISALLOW_CALLBACK(b);
        if (isInMemory)
            this._removeItemFallback(a);
        else
            try {
                await this._inst.delete(a)
            } catch (c) {
                this._MaybeSwitchToMemoryFallback(c),
                isInMemory ? this._removeItemFallback(a) : console.error(`Error removing '${a}' from storage: `, c)
            }
    }
    async clear(a)
    {
        DISALLOW_CALLBACK(a);
        if (isInMemory)
            this._clearFallback();
        else
            try {
                await this._inst.clear()
            } catch (b) {
                this._MaybeSwitchToMemoryFallback(b),
                isInMemory ? this._clearFallback() :
                console.error("Error clearing storage: ", b)
            }
    }
    async keys(a)
    {
        DISALLOW_CALLBACK(a);
        if (isInMemory)
            return this._keysFallback();
        a = [];
        try {
            a = await this._inst.keys()
        } catch (b) {
            this._MaybeSwitchToMemoryFallback(b);
            if (isInMemory)
                return this._keysFallback();
            console.error("Error getting storage keys: ", b)
        }
        return a
    }
    ready(a)
    {
        DISALLOW_CALLBACK(a);
        return isInMemory ? Promise.resolve(!0) : this._inst.ready()
    }
    createInstance(a)
    {
        if ("object" !== typeof a)
            throw new TypeError("invalid options object");
        a = a.name;
        if ("string" !== typeof a)
            throw new TypeError("invalid store name");
        a = new KVStorageContainer$jscomp$1(a);
        return new ForageAdaptor(a)
    }
    length(a)
    {
        NOT_IMPLEMENTED("localforage.length()")
    }
    key(a, b)
    {
        NOT_IMPLEMENTED("localforage.key()")
    }
    iterate(a, b)
    {
        NOT_IMPLEMENTED("localforage.iterate()")
    }
    setDriver(a)
    {
        NOT_IMPLEMENTED("localforage.setDriver()")
    }
    config(a)
    {
        NOT_IMPLEMENTED("localforage.config()")
    }
    defineDriver(a)
    {
        NOT_IMPLEMENTED("localforage.defineDriver()")
    }
    driver()
    {
        NOT_IMPLEMENTED("localforage.driver()")
    }
    supports(a)
    {
        NOT_IMPLEMENTED("localforage.supports()")
    }
    dropInstance()
    {
        NOT_IMPLEMENTED("localforage.dropInstance()")
    }
    disableMemoryMode()
    {
        isInMemory =
        !1
    }
}
self.localforage = new ForageAdaptor(new KVStorageContainer$jscomp$1("localforage"));
"use strict";
const C3$jscomp$4 = self.C3;
C3$jscomp$4.Supports = {};
C3$jscomp$4.Supports.WebAnimations = (() => {
    try {
        if ("undefined" === typeof document)
            return !1;
        const a = document.createElement("div");
        return "undefined" === typeof a.animate ? !1 : "undefined" !== typeof a.animate([{
            opacity: "0"
        }, {
            opacity: "1"
        }], 1E3).reverse
    } catch (a) {
        return !1
    }
})();
C3$jscomp$4.Supports.DialogElement = "undefined" !== typeof HTMLDialogElement;
C3$jscomp$4.Supports.RequestIdleCallback = !!self.requestIdleCallback;
C3$jscomp$4.Supports.ImageBitmap = !!self.createImageBitmap;
C3$jscomp$4.Supports.ImageBitmapOptions = !1;
C3$jscomp$4.Supports.ImageBitmapOptionsResize = !1;
if (C3$jscomp$4.Supports.ImageBitmap) {
    try {
        self.createImageBitmap(new ImageData(32, 32), {
            premultiplyAlpha: "none"
        }).then(() => {
            C3$jscomp$4.Supports.ImageBitmapOptions = !0
        }).catch(() => {
            C3$jscomp$4.Supports.ImageBitmapOptions = !1
        })
    } catch (a) {
        C3$jscomp$4.Supports.ImageBitmapOptions = !1
    }
    try {
        self.createImageBitmap(new ImageData(32, 32), {
            resizeWidth: 10,
            resizeHeight: 10
        }).then(a => {
            C3$jscomp$4.Supports.ImageBitmapOptionsResize = 10 === a.width && 10 === a.height
        }).catch(() => {
            C3$jscomp$4.Supports.ImageBitmapOptionsResize = !1
        })
    } catch (a) {
        C3$jscomp$4.Supports.ImageBitmapOptionsResize =
        !1
    }
}
C3$jscomp$4.Supports.ClipboardReadText = !(!navigator.clipboard || !navigator.clipboard.readText);
C3$jscomp$4.Supports.PermissionsQuery = !(!navigator.permissions || !navigator.permissions.query);
C3$jscomp$4.Supports.ClipboardPermissionsQuery = !1;
C3$jscomp$4.Supports.PermissionsQuery && navigator.permissions.query({
    name: "clipboard-read"
}).then(() => {
    C3$jscomp$4.Supports.ClipboardPermissionsQuery = !0
}).catch(() => {
    C3$jscomp$4.Supports.ClipboardPermissionsQuery = !1
});
C3$jscomp$4.Supports.AsyncClipboardApi = !!(navigator.permissions && navigator.clipboard && self.ClipboardItem);
C3$jscomp$4.Supports.Proxies = "undefined" !== typeof Proxy;
C3$jscomp$4.Supports.DownloadAttribute = (() => "undefined" === typeof document ? !1 : "undefined" !== typeof document.createElement("a").download)();
C3$jscomp$4.Supports.Fetch = "function" === typeof fetch;
C3$jscomp$4.Supports.PersistentStorage = !!(self.isSecureContext && "Opera" !== C3$jscomp$4.Platform.Browser && navigator.storage && navigator.storage.persist);
C3$jscomp$4.Supports.StorageQuotaEstimate = !!(self.isSecureContext && navigator.storage && navigator.storage.estimate);
C3$jscomp$4.Supports.Fullscreen = (() => {
    if ("undefined" === typeof document || "iOS" === C3$jscomp$4.Platform.OS)
        return !1;
    const a = document.documentElement;
    return !!(a.requestFullscreen || a.msRequestFullscreen || a.mozRequestFullScreen || a.webkitRequestFullscreen)
})();
C3$jscomp$4.Supports.ImageDecoder = "undefined" !== typeof self.ImageDecoder;
C3$jscomp$4.Supports.WebCodecs = !!self.VideoEncoder;
C3$jscomp$4.Supports.NativeFileSystemAPI = !!self.showOpenFilePicker;
C3$jscomp$4.Supports.QueryLocalFonts = !!self.queryLocalFonts;
C3$jscomp$4.Supports.UserActivation = !!navigator.userActivation;
C3$jscomp$4.Supports.CanvasToBlobWebP = !1;
(async () => {
    let a;
    "undefined" === typeof document ? a = new OffscreenCanvas(32, 32) : (a = document.createElement("canvas"), a.width = 32, a.height = 32);
    var b = a.getContext("2d");
    b.fillStyle = "blue";
    b.fillRect(0, 0, 32, 32);
    b = null;
    try {
        a.convertToBlob ? b = await a.convertToBlob({
            type: "image/webp",
            quality: 1
        }) : a.toBlob && (b = await new Promise(c => a.toBlob(c, "image/webp", 1))),
        C3$jscomp$4.Supports.CanvasToBlobWebP = b && "image/webp" === b.type
    } catch (c) {
        C3$jscomp$4.Supports.CanvasToBlobWebP = !1
    }
})();
"use strict";
const C3$jscomp$5 = self.C3;
if (!String.prototype.trimStart) {
    const a = /^[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*/;
    String.prototype.trimStart = function() {
        return this.replace(a, "")
    }
}
if (!String.prototype.trimEnd) {
    const a = /[\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF]*$/;
    String.prototype.trimEnd = function() {
        return this.replace(a, "")
    }
}
String.prototype.replaceAll || (String.prototype.replaceAll = function(a, b) {
    return this.replace(new RegExp(C3$jscomp$5.EscapeRegex(a), "g"), b)
});
Array.prototype.values || (Array.prototype.values = function* () {
    for (const a of this)
        yield a
});
if (!Array.prototype.flat) {
    function a(b, c) {
        return b.reduce((d, e) => {
            0 < c && Array.isArray(e) ? Array.prototype.push.apply(d, a(e, c - 1)) : d.push(e);
            return d
        }, [])
    }
    Array.prototype.flat = function(b=1) {
        return a(this, b)
    }
}
Array.prototype.at || (Array.prototype.at = function(a) {
    a = Math.trunc(a) || 0;
    0 > a && (a += this.length);
    if (!(0 > a || a >= this.length))
        return this[a]
});
String.prototype.at || (String.prototype.at = function(a) {
    a = Math.trunc(a) || 0;
    0 > a && (a += this.length);
    if (!(0 > a || a >= this.length))
        return this[a]
});
RegExp.escape || (RegExp.escape = function(a) {
    return String(a).replace(/[\\^$*+?.()|[\]{}]/g, "\\$&")
});
Set.prototype.isSubsetOf || (Set.prototype.isSubsetOf = function(a) {
    if (!(a instanceof Set))
        throw new TypeError("argument must be a Set");
    for (const b of this)
        if (!a.has(b))
            return !1;
    return !0
});
navigator.storage && !navigator.storage.estimate && navigator.webkitTemporaryStorage && navigator.webkitTemporaryStorage.queryUsageAndQuota && (navigator.storage.estimate = function() {
    return new Promise((a, b) => navigator.webkitTemporaryStorage.queryUsageAndQuota((c, d) => a({
        usage: c,
        quota: d
    }), b))
});
"undefined" === typeof self.isSecureContext && (self.isSecureContext = "https:" === location.protocol);
"undefined" === typeof self.globalThis && (self.globalThis = self);
"use strict";
const C3$jscomp$6 = self.C3;
function assertFail(a) {
    let b = C3$jscomp$6.GetCallStack();
    console.error("Assertion failure: " + a + "\n\nStack trace:\n" + b)
}
self.assert = function(a, b) {
    a || assertFail(b)
};
"use strict";
const C3$jscomp$7 = self.C3,
    C3X = self.C3X;
C3$jscomp$7.IsNumber = function(a) {
    return "number" === typeof a
};
C3$jscomp$7.IsFiniteNumber = function(a) {
    return C3$jscomp$7.IsNumber(a) && isFinite(a)
};
C3$jscomp$7.RequireNumber = function(a) {
    if (!C3$jscomp$7.IsNumber(a))
        throw new TypeError("expected number");
};
C3$jscomp$7.RequireOptionalNumber = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireNumberInRange = function(a, b, c) {
    if (!C3$jscomp$7.IsNumber(a) || isNaN(a) || b > a || c < a)
        throw new RangeError("number outside of range");
};
C3$jscomp$7.RequireAllNumber = function(...a) {
    for (let b of a)
        ;
};
C3$jscomp$7.RequireFiniteNumber = function(a) {
    if (!C3$jscomp$7.IsFiniteNumber(a))
        throw new TypeError("expected finite number");
};
C3$jscomp$7.RequireOptionalFiniteNumber = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireAllFiniteNumber = function(...a) {
    for (let b of a)
        ;
};
C3$jscomp$7.IsString = function(a) {
    return "string" === typeof a
};
C3$jscomp$7.RequireString = function(a) {
    if (!C3$jscomp$7.IsString(a))
        throw new TypeError("expected string");
};
C3$jscomp$7.RequireOptionalString = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireAllString = function(...a) {
    for (let b of a)
        ;
};
C3$jscomp$7.IsSimpleObject = function(a) {
    return "object" !== typeof a || null === a ? !1 : (a = Object.getPrototypeOf(a)) ? a.constructor === Object : null === a
};
C3$jscomp$7.RequireSimpleObject = function(a) {
    if (!C3$jscomp$7.IsSimpleObject(a))
        throw new TypeError("expected simple object");
};
C3$jscomp$7.RequireOptionalSimpleObject = function(a) {
    if (!C3$jscomp$7.IsNullOrUndefined(a) && !C3$jscomp$7.IsSimpleObject(a))
        throw new TypeError("expected simple object");
};
C3$jscomp$7.IsObject = function(a) {
    return "object" === typeof a && null !== a && !Array.isArray(a)
};
C3$jscomp$7.RequireObject = function(a) {
    if (!C3$jscomp$7.IsObject(a))
        throw new TypeError("expected object");
};
C3$jscomp$7.RequireOptionalObject = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireAllObject = function(...a) {
    for (let b of a)
        ;
};
C3$jscomp$7.IsFileLike = function(a) {
    return C3$jscomp$7.WeakIsInstanceOf(a, Blob) && "string" === typeof a.name
};
C3$jscomp$7.RequireFileLike = function(a) {
    if (!C3$jscomp$7.IsFileLike(a))
        throw new TypeError("expected file");
};
C3$jscomp$7.RequireOptionalFileLike = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.IsArray = function(a) {
    return Array.isArray(a)
};
C3$jscomp$7.RequireArray = function(a) {
    if (!C3$jscomp$7.IsArray(a))
        throw new TypeError("expected array");
};
C3$jscomp$7.RequireOptionalArray = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireAllArray = function(...a) {
    for (let b of a)
        ;
};
C3$jscomp$7.Is2DArray = function(a) {
    return C3$jscomp$7.IsArray(a) ? a.length ? C3$jscomp$7.IsArray(a[0]) ? !0 : !1 : !0 : !1
};
C3$jscomp$7.Require2DArray = function(a) {
    if (!C3$jscomp$7.Is2DArray(a))
        throw new TypeError("expected 2d array");
    for (let b of a)
        if (!C3$jscomp$7.IsArray(b))
            throw new TypeError("expected 2d array");
};
C3$jscomp$7.RequireOptional2DArray = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.IsFunction = function(a) {
    return "function" === typeof a
};
C3$jscomp$7.RequireFunction = function(a, b) {
    if (!C3$jscomp$7.IsFunction(a))
        throw new TypeError("expected function");
    if (!C3$jscomp$7.IsNullOrUndefined(b) && a !== b)
        throw new TypeError("expected same function reference");
};
C3$jscomp$7.RequireOptionalFunction = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireAllFunction = function(...a) {
    for (let b of a)
        ;
};
C3$jscomp$7.RequireAnyFunction = function(a, ...b) {
    if (!C3$jscomp$7.IsFunction(a))
        throw new TypeError("expected function");
    if (!b.length)
        throw Error("missing comparison functions");
    for (let c of b)
        if (!C3$jscomp$7.IsNullOrUndefined(c) && a === c)
            return;
    throw new TypeError("expected same function reference");
};
C3$jscomp$7.RequireOptionalAllFunction = function(...a) {
    if (!C3$jscomp$7.IsNullOrUndefined(a))
        for (let b of a)
            ;
};
C3$jscomp$7.IsInstanceOf = function(a, b) {
    return a instanceof b
};
C3$jscomp$7.IsInstanceOfAny = function(a, ...b) {
    for (let c of b)
        if (C3$jscomp$7.IsInstanceOf(a, c))
            return !0;
    return !1
};
C3$jscomp$7.RequireInstanceOf = function(a, b) {
    if (!C3$jscomp$7.IsInstanceOf(a, b))
        throw new TypeError("unexpected type");
};
C3$jscomp$7.RequireOptionalInstanceOf = function(a, b) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireAllInstanceOf = function(a, ...b) {
    for (let c of b)
        ;
};
C3$jscomp$7.RequireAnyInstanceOf = function(a, ...b) {
    if (!C3$jscomp$7.IsInstanceOfAny(a, ...b))
        throw new TypeError("unexpected type");
};
C3$jscomp$7.RequireAnyOptionalInstanceOf = function(a, ...b) {
    if (!C3$jscomp$7.IsNullOrUndefined(a) && !C3$jscomp$7.IsInstanceOfAny(a, ...b))
        throw new TypeError("unexpected type");
};
C3$jscomp$7.IsArrayOf = function(a, b) {
    for (let c of a)
        if (!C3$jscomp$7.IsInstanceOf(c, b))
            return !1;
    return !0
};
C3$jscomp$7.IsArrayOfFiniteNumbers = function(a) {
    for (let b of a)
        if (!C3$jscomp$7.IsFiniteNumber(b))
            return !1;
    return !0
};
C3$jscomp$7.RequireArrayOf = function(a, b) {
    for (let c of a)
        ;
};
C3$jscomp$7.RequireOptionalArrayOf = function(a, b) {
    if (!C3$jscomp$7.IsNullOrUndefined(a))
        for (let c of a)
            ;
};
C3$jscomp$7.RequireOptionalArrayOfFunctions = function(a, b) {
    if (!C3$jscomp$7.IsNullOrUndefined(a))
        for (let c of a)
            ;
};
C3$jscomp$7.RequireArrayOfAny = function(a, ...b) {
    for (let c of a)
        ;
};
C3$jscomp$7.RequireOptionalArrayOfAny = function(a, ...b) {
    if (!C3$jscomp$7.IsNullOrUndefined(a))
        for (let c of a)
            ;
};
C3$jscomp$7.IsDOMNode = function(a, b) {
    return C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.nodeName) ? !1 : !b || C3$jscomp$7.equalsNoCase(a.nodeName, b)
};
C3$jscomp$7.RequireDOMNode = function(a, b) {
    if (C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.nodeName))
        throw new TypeError("expected DOM node");
    if (b && !C3$jscomp$7.equalsNoCase(a.nodeName, b))
        throw new TypeError(`expected DOM '${b}' node`);
};
C3$jscomp$7.RequireOptionalDOMNode = function(a, b) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.IsHTMLElement = function(a, b) {
    return C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.tagName) ? !1 : !b || C3$jscomp$7.equalsNoCase(a.tagName, b)
};
C3$jscomp$7.RequireHTMLElement = function(a, b) {
    if (C3$jscomp$7.IsNullOrUndefined(a) || !C3$jscomp$7.IsString(a.tagName))
        throw new TypeError("expected HTML element");
    if (b && !C3$jscomp$7.equalsNoCase(a.tagName, b))
        throw new TypeError(`expected HTML '${b}' element`);
};
C3$jscomp$7.RequireOptionalHTMLElement = function(a, b) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.IsDrawable = function(a) {
    return C3$jscomp$7.IsHTMLElement(a, "img") || C3$jscomp$7.IsHTMLElement(a, "canvas") || C3$jscomp$7.IsHTMLElement(a, "video") || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap
};
C3$jscomp$7.RequireDrawable = function(a) {
    if (!C3$jscomp$7.IsDrawable(a))
        throw new TypeError("expected drawable");
};
C3$jscomp$7.RequireOptionalDrawable = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.IsDrawableOrImageData = function(a) {
    return a instanceof ImageData ? !0 : C3$jscomp$7.IsDrawable(a)
};
C3$jscomp$7.RequireDrawableOrImageData = function(a) {
    if (!C3$jscomp$7.IsDrawableOrImageData(a))
        throw new TypeError("expected drawable or image data");
};
C3$jscomp$7.RequireOptionalDrawableOrImageData = function(a) {
    if (!C3$jscomp$7.IsNullOrUndefined(a) && !C3$jscomp$7.IsDrawableOrImageData(a))
        throw new TypeError("expected drawable or image data");
};
C3$jscomp$7.IsStringLike = function(a) {
    return "string" === typeof a || C3$jscomp$7.HtmlString && a instanceof C3$jscomp$7.HtmlString || a instanceof C3$jscomp$7.BBString
};
C3$jscomp$7.RequireStringLike = function(a) {
    if (!C3$jscomp$7.IsStringLike(a))
        throw new TypeError("expected string-like");
};
C3$jscomp$7.RequireOptionalStringLike = function(a) {
    C3$jscomp$7.IsNullOrUndefined(a)
};
C3$jscomp$7.RequireAllStringLike = function(...a) {
    for (let b of a)
        ;
};
C3$jscomp$7.RequireOverride = function() {
    throw Error("must be overridden");
};
C3$jscomp$7.NotYetImplemented = function() {
    throw Error("not yet implemented");
};
C3$jscomp$7.IsDefined = function(a, ...b) {
    if ("undefined" === typeof a)
        return !1;
    for (let c of b) {
        if ("undefined" === typeof a[c])
            return !1;
        a = a[c]
    }
    return !0
};
C3$jscomp$7.IsNullOrUndefined = function(a) {
    return "undefined" === typeof a || null === a
};
C3$jscomp$7.AreArrayElementsOfSameType = function(a) {
    let b = a[0].constructor;
    for (let c of a)
        if (c.constructor !== b)
            return !1;
    return b
};
C3$jscomp$7.AreArrayElementsOfType = function(a, b) {
    for (let c of a)
        if (!(c instanceof b))
            return !1;
    return !0
};
const TypedArray$jscomp$1 = Object.getPrototypeOf(Uint8Array);
C3$jscomp$7.IsTypedArray = function(a) {
    return C3$jscomp$7.IsInstanceOf(a, TypedArray$jscomp$1)
};
C3$jscomp$7.RequireTypedArray = function(a) {};
C3$jscomp$7.WeakRequireTypedArray = function(a) {
    C3$jscomp$7.WeakRequireInstanceOf(a, TypedArray$jscomp$1)
};
C3$jscomp$7.WeakRequireAnyInstanceOf = function(a, ...b) {
    if (!C3$jscomp$7.WeakIsAnyInstanceOf(a, ...b))
        throw new TypeError("unexpected type");
};
C3$jscomp$7.WeakIsAnyInstanceOf = function(a, ...b) {
    for (const c of b)
        if (C3$jscomp$7.WeakIsInstanceOf(a, c))
            return !0;
    return !1
};
C3$jscomp$7.WeakRequireInstanceOf = function(a, b) {
    if (!C3$jscomp$7.WeakIsInstanceOf(a, b))
        throw new TypeError("unexpected type");
};
C3$jscomp$7.WeakIsInstanceOf = function(a, b) {
    for (; a = Object.getPrototypeOf(a);)
        if (a.constructor.name === b.name)
            return !0;
    return !1
};
C3X.RequireNumber = C3$jscomp$7.RequireNumber;
C3X.RequireOptionalNumber = C3$jscomp$7.RequireOptionalNumber;
C3X.RequireFiniteNumber = C3$jscomp$7.RequireFiniteNumber;
C3X.RequireOptionalFiniteNumber = C3$jscomp$7.RequireOptionalFiniteNumber;
C3X.RequireString = C3$jscomp$7.RequireString;
C3X.RequireOptionalString = C3$jscomp$7.RequireOptionalString;
C3X.RequireObject = C3$jscomp$7.RequireObject;
C3X.RequireOptionalObject = C3$jscomp$7.RequireOptionalObject;
C3X.RequireArray = C3$jscomp$7.RequireArray;
C3X.RequireOptionalArray = C3$jscomp$7.RequireOptionalArray;
C3X.RequireFunction = C3$jscomp$7.RequireFunction;
C3X.RequireOptionalFunction = C3$jscomp$7.RequireOptionalFunction;
C3X.RequireInstanceOf = C3$jscomp$7.RequireInstanceOf;
C3X.RequireOptionalInstanceOf = C3$jscomp$7.RequireOptionalInstanceOf;
C3X.IsNullOrUndefined = C3$jscomp$7.IsNullOrUndefined;
"use strict";
const C3$jscomp$8 = self.C3,
    logRafIds = new Map;
C3$jscomp$8.ColorLog = function(a, b) {
    console.log(`%c${a}`, `font-weight: bold; color:${b}`)
};
C3$jscomp$8.RafLog = function(a, ...b) {
    logRafIds.has(a) || logRafIds.set(a, -1);
    -1 === logRafIds.get(a) && logRafIds.set(a, requestAnimationFrame(() => {
        console.log(`%c${a}`, "font-weight: bold", ...b);
        logRafIds.set(a, -1)
    }))
};
let measures;
C3$jscomp$8.StartMeasure = function(a) {
    performance.mark(a);
    measures || (measures = new Map);
    measures.has(a) || measures.set(a, {
        current: 0,
        total: 0,
        average: 0,
        calls: 1,
        toString: function() {
            return `${a} :: current => ${this.current.toPrecision(3)} :: average => ${this.average.toPrecision(3)} :: calls => ${this.calls}`
        }
    })
};
C3$jscomp$8.EndMeasure = function(a) {
    performance.measure(`measure-${a}`, a);
    const b = performance.getEntriesByName(`measure-${a}`)[0],
        c = measures.get(a);
    c.current = b.duration;
    c.total += c.current;
    c.average = c.total / c.calls;
    console.log(c.toString());
    c.calls++;
    performance.clearMarks(a);
    performance.clearMeasures(`measure-${a}`)
};
C3$jscomp$8.GetCallStack = function() {
    return Error().stack
};
C3$jscomp$8.Debugger = function() {
    debugger
};
C3$jscomp$8.cast = function(a, b) {
    return a && a instanceof b ? a : null
};
C3$jscomp$8.getName = function(a) {
    return "undefined" === typeof a ? "undefined" : null === a ? "null" : "boolean" === typeof a ? "<boolean>" : C3$jscomp$8.IsNumber(a) ? "<number>" : C3$jscomp$8.IsString(a) ? "<string>" : C3$jscomp$8.IsArray(a) ? "<array>" : "symbol" === typeof a ? "<" + a.toString() + ">" : C3$jscomp$8.IsFunction(a) ? a.name && "Function" !== a.name ? a.name : "<anonymous function>" : "object" === typeof a ? a.constructor && a.constructor.name && "Object" !== a.constructor.name ? a.constructor.name : "<anonymous object>" : "<unknown>"
};
C3$jscomp$8.getType = function(a) {
    return null === a ? "null" : Array.isArray(a) ? "array" : typeof a
};
C3$jscomp$8.range = function* (a, b) {
    if (!isFinite(Math.abs(a - b)))
        throw Error("Invalid parameters");
    if (a > b)
        for (--a; a >= b; a--)
            yield a;
    else
        for (; a < b; a++)
            yield a
};
function isValidTypeChange(a, b) {
    a = C3$jscomp$8.getType(a);
    b = C3$jscomp$8.getType(b);
    return "null" === a || "null" === b ? !0 : "undefined" === a || "undefined" === b ? !1 : a === b
}
let ctorObjectToProxy = new Map,
    ctorProxyToObject = new Map,
    proxyToObject = new WeakMap,
    releasedObjects = new WeakMap;
C3$jscomp$8.DefendHandler = {};
const VALID_GET_MISSING_KEYS = new Set(["then", "splice"]);
function logDefendedObjectWarning(a) {
    console.warn("[Defence] " + a + " @", C3$jscomp$8.GetCallStack())
}
C3$jscomp$8.DefendHandler.get = function(a, b) {
    b in a || "symbol" === typeof b || VALID_GET_MISSING_KEYS.has(b) || logDefendedObjectWarning(`Accessed missing property '${b}' from defended object '${C3$jscomp$8.getName(a)}', returning undefined`);
    releasedObjects.has(a) && "symbol" !== typeof b && !VALID_GET_MISSING_KEYS.has(b) && logDefendedObjectWarning(`Accessed property '${b}' on a released object '${C3$jscomp$8.getName(a)}'\nObject was originally released at: ${releasedObjects.get(a)})\nCall stack at access: `);
    return a[b]
};
C3$jscomp$8.DefendHandler.set = function(a, b, c) {
    b in a || ctorObjectToProxy.has(a) || logDefendedObjectWarning(`Set non-existent property '${b}' to '${c}' on defended object '${C3$jscomp$8.getName(a)}'`);
    isValidTypeChange(a[b], c) || ctorObjectToProxy.has(a) || logDefendedObjectWarning(`Set '${C3$jscomp$8.getType(a[b])}' property '${b}' to type '${C3$jscomp$8.getType(c)}' on defended object '${C3$jscomp$8.getName(a)}'`);
    releasedObjects.has(a) && logDefendedObjectWarning(`Set property '${b}' on a released object '${C3$jscomp$8.getName(a)}'\nObject was originally released at: ${releasedObjects.get(a)})\nCall stack at access: `);
    a[b] = c;
    return !0
};
C3$jscomp$8.DefendHandler.deleteProperty = function(a, b) {
    throw new ReferenceError(`Cannot delete property '${b}' from defended object '${C3$jscomp$8.getName(a)}'`);
};
C3$jscomp$8.DefendHandler.defineProperty = function(a, b, c) {
    throw new ReferenceError(`Cannot define property '${b}' on defended object '${C3$jscomp$8.getName(a)}'`);
};
C3$jscomp$8.DefendHandler.enumerate = function(a) {
    throw new ReferenceError(`Cannot enumerate defended object '${C3$jscomp$8.getName(a)}'`);
};
let checkRafId = -1;
function CheckDefendedObjectsUsedCorrectly() {
    checkRafId = -1;
    if (0 < ctorObjectToProxy.size || 0 < ctorProxyToObject.size) {
        let a = [...(new Set([...ctorObjectToProxy.keys()].map(b => C3$jscomp$8.getName(b))))].join();
        console.warn(`An object derived from DefendedBase was not protected with debugDefend(). This will disable some checks. See the coding guidelines! Possible affected class names: ${a}`);
        ctorObjectToProxy.clear();
        ctorProxyToObject.clear()
    }
}
C3$jscomp$8.DefendedBase = class {
    constructor()
    {
        if (C3$jscomp$8.isDebugDefend && C3$jscomp$8.Supports.Proxies) {
            var a = new.target;
            a = Object.create(a.prototype);
            var b = new Proxy(a, C3$jscomp$8.DefendHandler);
            ctorObjectToProxy.set(a, b);
            ctorProxyToObject.set(b, a);
            proxyToObject.set(b, a);
            -1 === checkRafId && (checkRafId = requestAnimationFrame(CheckDefendedObjectsUsedCorrectly));
            return b
        }
    }
}
;
C3$jscomp$8.debugDefend = function(a) {
    if (C3$jscomp$8.isDebugDefend && C3$jscomp$8.Supports.Proxies && a instanceof C3$jscomp$8.DefendedBase) {
        if (!ctorProxyToObject.has(a))
            return a;
        let b = ctorProxyToObject.get(a);
        ctorProxyToObject.delete(a);
        ctorObjectToProxy.delete(b);
        return a
    }
    return C3$jscomp$8.isDebug ? Object.seal(a) : a
};
C3$jscomp$8.New = function(a, ...b) {
    let c;
    try {
        c = new a(...b)
    } catch (d) {
        throw ctorProxyToObject.clear(), ctorObjectToProxy.clear(), d;
    }
    C3$jscomp$8.isDebugDefend && VerifyObjectPropertiesConsistent(a, c);
    return C3$jscomp$8.debugDefend(c)
};
C3$jscomp$8.Release = function(a) {
    (a = proxyToObject.get(a)) && releasedObjects.set(a, C3$jscomp$8.GetCallStack())
};
C3$jscomp$8.WasReleased = function(a) {
    return (a = proxyToObject.get(a)) ? !!releasedObjects.get(a) : !1
};
let typeProperties = new Map;
function getObjectPropertySet(a) {
    let b = new Set;
    for (let c in a)
        b.add(c);
    return b
}
function VerifyObjectPropertiesConsistent(a, b) {
    b = getObjectPropertySet(b);
    let c = typeProperties.get(a);
    if (c) {
        let d = [];
        for (let e of c.values())
            b.has(e) ? b.delete(e) : d.push(e);
        C3$jscomp$8.appendArray(d, [...b]);
        d.length && console.warn(`[Defence] '${C3$jscomp$8.getName(a)}' constructor creates inconsistent properties: ${d.join(", ")}`)
    } else
        typeProperties.set(a, b)
}
C3$jscomp$8.PerfMark = class {
    constructor(a)
    {
        this._name = "";
        a && this.start(a)
    }
    start(a)
    {
        C3$jscomp$8.isPerformanceProfiling && (this._name = a, performance.mark(this._name + "-Start"))
    }
    end()
    {
        C3$jscomp$8.isPerformanceProfiling && (performance.mark(this._name + "-End"), performance.measure(this._name, this._name + "-Start", this._name + "-End"))
    }
    next(a)
    {
        C3$jscomp$8.isPerformanceProfiling && (this.end(), this._name = a, performance.mark(this._name + "-Start"))
    }
}
;
"use strict";
const C3$jscomp$9 = self.C3,
    TWO_PI = 2 * Math.PI,
    D_TO_R = Math.PI / 180,
    R_TO_D = 180 / Math.PI;
C3$jscomp$9.wrap = function(a, b, c) {
    a = Math.floor(a);
    b = Math.floor(b);
    c = Math.floor(c);
    const d = c - b;
    return 0 === d ? c : a < b ? (a = c - (b - a) % d, a === c ? 0 : a) : b + (a - b) % d
};
C3$jscomp$9.mapToRange = function(a, b, c, d, e) {
    c -= b;
    return 0 === c && 0 === d ? a : (a - b) * (e - d) / c + d
};
C3$jscomp$9.normalize = function(a, b, c) {
    return 0 === b - c ? 1 : (a - b) / (c - b)
};
C3$jscomp$9.clamp = function(a, b, c) {
    return a < b ? b : a > c ? c : a
};
C3$jscomp$9.clampAngle = function(a) {
    a %= TWO_PI;
    0 > a && (a += TWO_PI);
    return a
};
C3$jscomp$9.toRadians = function(a) {
    return a * D_TO_R
};
C3$jscomp$9.toDegrees = function(a) {
    return a * R_TO_D
};
C3$jscomp$9.distanceTo = function(a, b, c, d) {
    return Math.hypot(c - a, d - b)
};
C3$jscomp$9.distanceSquared = function(a, b, c, d) {
    a = c - a;
    b = d - b;
    return a * a + b * b
};
C3$jscomp$9.angleTo = function(a, b, c, d) {
    return Math.atan2(d - b, c - a)
};
C3$jscomp$9.angleDiff = function(a, b) {
    if (a === b)
        return 0;
    a = Math.sin(a) * Math.sin(b) + Math.cos(a) * Math.cos(b);
    return 1 <= a ? 0 : -1 >= a ? Math.PI : Math.acos(a)
};
C3$jscomp$9.angleRotate = function(a, b, c) {
    let d = Math.sin(a),
        e = Math.cos(a),
        f = Math.sin(b),
        g = Math.cos(b);
    return Math.acos(d * f + e * g) > c ? 0 < e * f - d * g ? C3$jscomp$9.clampAngle(a + c) : C3$jscomp$9.clampAngle(a - c) : C3$jscomp$9.clampAngle(b)
};
C3$jscomp$9.angleClockwise = function(a, b) {
    return 0 >= Math.cos(a) * Math.sin(b) - Math.sin(a) * Math.cos(b)
};
C3$jscomp$9.angleLerp = function(a, b, c, d=0) {
    let e = C3$jscomp$9.angleDiff(a, b);
    d *= TWO_PI;
    return C3$jscomp$9.angleClockwise(b, a) ? C3$jscomp$9.clampAngle(a + (e + d) * c) : C3$jscomp$9.clampAngle(a - (e + d) * c)
};
C3$jscomp$9.angleLerpClockwise = function(a, b, c, d=0) {
    const e = C3$jscomp$9.angleDiff(a, b);
    d *= TWO_PI;
    return C3$jscomp$9.angleClockwise(b, a) ? C3$jscomp$9.clampAngle(a + (e + d) * c) : C3$jscomp$9.clampAngle(a + (TWO_PI - e + d) * c)
};
C3$jscomp$9.angleLerpAntiClockwise = function(a, b, c, d=0) {
    const e = C3$jscomp$9.angleDiff(a, b);
    d *= TWO_PI;
    return C3$jscomp$9.angleClockwise(b, a) ? C3$jscomp$9.clampAngle(a - (-TWO_PI + e - d) * c) : C3$jscomp$9.clampAngle(a - (e + d) * c)
};
C3$jscomp$9.angleReflect = function(a, b) {
    const c = C3$jscomp$9.angleDiff(a, b);
    return C3$jscomp$9.angleClockwise(a, b) ? C3$jscomp$9.clampAngle(b - c) : C3$jscomp$9.clampAngle(b + c)
};
C3$jscomp$9.lerp = function(a, b, c) {
    return a + c * (b - a)
};
C3$jscomp$9.unlerp = function(a, b, c) {
    return a === b ? 0 : (c - a) / (b - a)
};
C3$jscomp$9.relerp = function(a, b, c, d, e) {
    return C3$jscomp$9.lerp(d, e, C3$jscomp$9.unlerp(a, b, c))
};
C3$jscomp$9.qarp = function(a, b, c, d) {
    return C3$jscomp$9.lerp(C3$jscomp$9.lerp(a, b, d), C3$jscomp$9.lerp(b, c, d), d)
};
C3$jscomp$9.cubic = function(a, b, c, d, e) {
    return C3$jscomp$9.lerp(C3$jscomp$9.qarp(a, b, c, e), C3$jscomp$9.qarp(b, c, d, e), e)
};
C3$jscomp$9.cosp = function(a, b, c) {
    return (a + b + (a - b) * Math.cos(c * Math.PI)) / 2
};
C3$jscomp$9.isPOT = function(a) {
    return 0 < a && 0 === (a - 1 & a)
};
C3$jscomp$9.nextHighestPowerOfTwo = function(a) {
    --a;
    for (let b = 1; 32 > b; b <<= 1)
        a |= a >> b;
    return a + 1
};
C3$jscomp$9.roundToNearestFraction = function(a, b) {
    return Math.round(a * b) / b
};
C3$jscomp$9.floorToNearestFraction = function(a, b) {
    return Math.floor(a * b) / b
};
C3$jscomp$9.roundToDp = function(a, b) {
    b = Math.max(Math.floor(b), 0);
    b = Math.pow(10, b);
    return Math.round(a * b) / b
};
C3$jscomp$9.countDecimals = function(a) {
    return Math.floor(a) !== a ? a.toString().split(".")[1].length || 0 : 0
};
C3$jscomp$9.toFixed = function(a, b) {
    a = a.toFixed(b);
    for (b = a.length - 1; 0 <= b && "0" === a.charAt(b); --b)
        ;
    0 <= b && "." === a.charAt(b) && --b;
    return 0 > b ? a : a.substr(0, b + 1)
};
C3$jscomp$9.PackRGB = function(a, b, c) {
    return C3$jscomp$9.clamp(a, 0, 255) | C3$jscomp$9.clamp(b, 0, 255) << 8 | C3$jscomp$9.clamp(c, 0, 255) << 16
};
C3$jscomp$9.PackRGBAEx = function(a, b, c, d) {
    a = C3$jscomp$9.clamp(Math.floor(1024 * a), -8192, 8191);
    b = C3$jscomp$9.clamp(Math.floor(1024 * b), -8192, 8191);
    c = C3$jscomp$9.clamp(Math.floor(1024 * c), -8192, 8191);
    d = C3$jscomp$9.clamp(Math.floor(1023 * d), 0, 1023);
    0 > a && (a += 16384);
    0 > b && (b += 16384);
    0 > c && (c += 16384);
    return -(274877906944 * a + 16777216 * b + 1024 * c + d)
};
C3$jscomp$9.PackRGBEx = function(a, b, c) {
    return C3$jscomp$9.PackRGBAEx(a, b, c, 1)
};
function isNegativeZero(a) {
    return 0 === a && 0 > 1 / a
}
C3$jscomp$9.GetRValue = function(a) {
    if (0 <= a)
        return (a & 255) / 255;
    a = Math.floor(-a / 274877906944);
    8191 < a && (a -= 16384);
    return a / 1024
};
C3$jscomp$9.GetGValue = function(a) {
    if (0 <= a)
        return ((a & 65280) >> 8) / 255;
    a = Math.floor(-a % 274877906944 / 16777216);
    8191 < a && (a -= 16384);
    return a / 1024
};
C3$jscomp$9.GetBValue = function(a) {
    if (0 <= a)
        return ((a & 16711680) >> 16) / 255;
    a = Math.floor(-a % 16777216 / 1024);
    8191 < a && (a -= 16384);
    return a / 1024
};
C3$jscomp$9.GetAValue = function(a) {
    return isNegativeZero(a) ? 0 : 0 <= a ? 1 : Math.floor(-a % 1024) / 1023
};
C3$jscomp$9.greatestCommonDivisor = function(a, b) {
    a = Math.floor(a);
    for (b = Math.floor(b); 0 !== b;) {
        let c = b;
        b = a % b;
        a = c
    }
    return a
};
const COMMON_ASPECT_RATIOS = [[3, 2], [4, 3], [5, 4], [5, 3], [6, 5], [14, 9], [16, 9], [16, 10], [21, 9]];
C3$jscomp$9.getAspectRatio = function(a, b) {
    a = Math.floor(a);
    b = Math.floor(b);
    if (a === b)
        return [1, 1];
    for (var c of COMMON_ASPECT_RATIOS) {
        let d = a / c[0] * c[1];
        if (1 > Math.abs(b - d))
            return c.slice(0);
        d = a / c[1] * c[0];
        if (1 > Math.abs(b - d))
            return [c[1], c[0]]
    }
    c = C3$jscomp$9.greatestCommonDivisor(a, b);
    return [a / c, b / c]
};
C3$jscomp$9.segmentsIntersect = function(a, b, c, d, e, f, g, h) {
    var k = Math.min(a, c),
        l = Math.max(e, g);
    if (Math.max(a, c) < Math.min(e, g) || k > l)
        return !1;
    k = Math.min(b, d);
    l = Math.max(f, h);
    if (Math.max(b, d) < Math.min(f, h) || k > l)
        return !1;
    k = e - a + g - c;
    l = f - b + h - d;
    a = c - a;
    b = d - b;
    e = g - e;
    f = h - f;
    h = Math.abs(b * e - f * a);
    return Math.abs(e * l - f * k) > h ? !1 : Math.abs(a * l - b * k) <= h
};
C3$jscomp$9.segmentsIntersectPreCalc = function(a, b, c, d, e, f, g, h, k, l, m, n) {
    const p = Math.max(k, m);
    if (f < Math.min(k, m) || e > p)
        return !1;
    e = Math.max(l, n);
    if (h < Math.min(l, n) || g > e)
        return !1;
    g = k - a + m - c;
    h = l - b + n - d;
    a = c - a;
    b = d - b;
    k = m - k;
    l = n - l;
    n = Math.abs(b * k - l * a);
    return Math.abs(k * h - l * g) > n ? !1 : Math.abs(a * h - b * g) <= n
};
C3$jscomp$9.segmentIntersectsQuad = function(a, b, c, d, e) {
    const f = Math.min(a, c),
        g = Math.max(a, c),
        h = Math.min(b, d),
        k = Math.max(b, d),
        l = e.getTlx(),
        m = e.getTly(),
        n = e.getTrx(),
        p = e.getTry(),
        q = e.getBrx(),
        r = e.getBry(),
        t = e.getBlx();
    e = e.getBly();
    return C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, g, h, k, l, m, n, p) || C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, g, h, k, n, p, q, r) || C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, g, h, k, q, r, t, e) || C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, g, h, k, t, e, l, m)
};
C3$jscomp$9.segmentIntersectsAnyN = function(a, b, c, d, e) {
    const f = Math.min(a, c),
        g = Math.max(a, c),
        h = Math.min(b, d),
        k = Math.max(b, d);
    let l = 0;
    for (let m = e.length - 4; l <= m; l += 2)
        if (C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, g, h, k, e[l], e[l + 1], e[l + 2], e[l + 3]))
            return !0;
    return C3$jscomp$9.segmentsIntersectPreCalc(a, b, c, d, f, g, h, k, e[l], e[l + 1], e[0], e[1])
};
C3$jscomp$9.rayIntersect = function(a, b, c, d, e, f, g, h) {
    c -= a;
    f = h - f;
    const k = c * f - (d - b) * (g - e);
    if (0 === k)
        return 2;
    d = ((b - d) * (g - a) + c * (h - b)) / k;
    return 0 < d && 1.000001 > d ? (f * (g - a) + (e - g) * (h - b)) / k : 2
};
C3$jscomp$9.rayIntersectExtended = function(a, b, c, d, e, f, g, h, k) {
    const l = (g - e) * k;
    k *= h - f;
    return C3$jscomp$9.rayIntersect(a, b, c, d, e - l, f - k, g + l, h + k)
};
C3$jscomp$9.isPointInTriangleInclusive = function(a, b, c, d, e, f, g, h) {
    e -= c;
    f -= d;
    g -= c;
    h -= d;
    a -= c;
    c = b - d;
    b = e * e + f * f;
    d = e * g + f * h;
    e = e * a + f * c;
    f = g * g + h * h;
    g = g * a + h * c;
    h = 1 / (b * f - d * d);
    f = (f * e - d * g) * h;
    e = (b * g - d * e) * h;
    return 0 <= f && 0 <= e && 1 >= f + e
};
C3$jscomp$9.triangleCartesianToBarycentric = function(a, b, c, d, e, f, g, h) {
    e -= c;
    f -= d;
    g -= c;
    h -= d;
    a -= c;
    const k = b - d;
    b = e * e + f * f;
    d = e * g + f * h;
    c = g * g + h * h;
    e = a * e + k * f;
    f = a * g + k * h;
    g = b * c - d * d;
    h = (c * e - d * f) / g;
    e = (b * f - d * e) / g;
    return [1 - h - e, h, e]
};
C3$jscomp$9.triangleBarycentricToCartesian3d = function(a, b, c, d, e, f, g, h, k, l, m, n) {
    return [a * d + b * g + c * l, a * e + b * h + c * m, a * f + b * k + c * n]
};
"use strict";
const C3$jscomp$10 = self.C3;
let mainDocument = null,
    baseHref = "";
if ("undefined" !== typeof document) {
    mainDocument = document;
    const a = document.querySelector("base");
    if (baseHref = a && a.hasAttribute("href") ? a.getAttribute("href") : "")
        baseHref.startsWith("/") && (baseHref = baseHref.substr(1)),
        baseHref.endsWith("/") || (baseHref += "/")
}
C3$jscomp$10.GetBaseHref = function() {
    return baseHref
};
C3$jscomp$10.GetBaseURL = function() {
    if (!mainDocument)
        return "";
    const a = mainDocument.location;
    return C3$jscomp$10.GetPathFromURL(a.origin + a.pathname) + baseHref
};
C3$jscomp$10.GetPathFromURL = function(a) {
    if (!a.length || a.endsWith("/") || a.endsWith("\\"))
        return a;
    const b = Math.max(a.lastIndexOf("/"), a.lastIndexOf("\\"));
    return -1 === b ? "" : a.substr(0, b + 1)
};
C3$jscomp$10.GetFilenameFromURL = function(a) {
    if (!a.length)
        return a;
    if (a.endsWith("/") || a.endsWith("\\"))
        return "";
    const b = Math.max(a.lastIndexOf("/"), a.lastIndexOf("\\"));
    return -1 === b ? a : a.substr(b + 1)
};
C3$jscomp$10.GetFileExtension = function(a) {
    let b = a.lastIndexOf(".");
    return 1 > b ? "" : a.substr(b)
};
C3$jscomp$10.SetFileExtension = function(a, b) {
    const c = a.lastIndexOf(".");
    return -1 === c ? a + "." + b : a.substr(0, c + 1) + b
};
C3$jscomp$10.GetFileNamePart = function(a) {
    let b = a.lastIndexOf(".");
    return 1 > b ? a : a.substr(0, b)
};
C3$jscomp$10.NormalizeFileSeparator = function(a) {
    return a.replace(/\\/g, "/")
};
C3$jscomp$10.IsFileExtension = function(a, b) {
    a = a ? C3$jscomp$10.GetFileExtension(a).slice(1) : "";
    return b === a
};
C3$jscomp$10.FileNameEquals = function(a, b) {
    let c,
        d;
    C3$jscomp$10.IsFileLike(a) && (c = C3$jscomp$10.GetFileNamePart(a.name));
    C3$jscomp$10.IsString(a) && (c = C3$jscomp$10.GetFileNamePart(a));
    C3$jscomp$10.IsFileLike(b) && (d = C3$jscomp$10.GetFileNamePart(b.name));
    C3$jscomp$10.IsString(b) && (d = C3$jscomp$10.GetFileNamePart(b));
    return c === d
};
C3$jscomp$10.ParseFilePath = function(a) {
    a = C3$jscomp$10.NormalizeFileSeparator(a);
    let b = /^\w:\//.exec(a);
    b ? (b = b[0], a = a.slice(3), "/" !== a[0] && (a = "/" + a)) : b = "";
    a = a.replace(/\/{2,}/g, "/");
    1 < a.length && "/" === a.slice(-1) && (a = a.slice(0, -1));
    var c = a.lastIndexOf("/") + 1;
    let d = "",
        e = a,
        f = "";
    0 < c && (d = a.slice(0, c), e = a.slice(c));
    a = e;
    c = e.lastIndexOf(".");
    0 < c && (f = e.slice(c), a = e.slice(0, -f.length));
    return {
        dir: d,
        base: e,
        name: a,
        root: b,
        ext: f,
        full: b + d + e
    }
};
C3$jscomp$10.Wait = function(a, b) {
    return new Promise((c, d) => {
        self.setTimeout(c, a, b)
    })
};
C3$jscomp$10.swallowException = function(a) {
    try {
        a()
    } catch (b) {
        C3$jscomp$10.isDebug && console.warn("Swallowed exception: ", b)
    }
};
C3$jscomp$10.noop = function() {};
C3$jscomp$10.equalsNoCase = function(a, b) {
    return "string" !== typeof a || "string" !== typeof b ? !1 : a === b || a.normalize().toLowerCase() === b.normalize().toLowerCase()
};
C3$jscomp$10.equalsCase = function(a, b) {
    return "string" !== typeof a || "string" !== typeof b ? !1 : a === b ? !0 : a.normalize() === b.normalize()
};
C3$jscomp$10.typedArraySet16 = function(a, b, c) {
    a[c++] = b[0];
    a[c++] = b[1];
    a[c++] = b[2];
    a[c++] = b[3];
    a[c++] = b[4];
    a[c++] = b[5];
    a[c++] = b[6];
    a[c++] = b[7];
    a[c++] = b[8];
    a[c++] = b[9];
    a[c++] = b[10];
    a[c++] = b[11];
    a[c++] = b[12];
    a[c++] = b[13];
    a[c++] = b[14];
    a[c] = b[15]
};
C3$jscomp$10.truncateArray = function(a, b) {
    a.length = b
};
C3$jscomp$10.clearArray = function(a) {
    a && 0 !== a.length && C3$jscomp$10.truncateArray(a, 0)
};
C3$jscomp$10.clear2DArray = function(a) {
    if (a) {
        for (let b = 0; b < a.length; b++)
            C3$jscomp$10.truncateArray(a[b], 0);
        C3$jscomp$10.truncateArray(a, 0)
    }
};
C3$jscomp$10.extendArray = function(a, b, c) {
    b |= 0;
    var d = a.length;
    if (!(b <= d))
        for (; d < b; ++d)
            a.push(c)
};
C3$jscomp$10.resizeArray = function(a, b, c) {
    b |= 0;
    const d = a.length;
    b < d ? C3$jscomp$10.truncateArray(a, b) : b > d && C3$jscomp$10.extendArray(a, b, c)
};
C3$jscomp$10.shallowAssignArray = function(a, b) {
    C3$jscomp$10.clearArray(a);
    C3$jscomp$10.appendArray(a, b)
};
C3$jscomp$10.appendArray = function(a, b) {
    if (1E4 > b.length)
        a.push(...b);
    else
        for (let c = 0, d = b.length; c < d; ++c)
            a.push(b[c])
};
C3$jscomp$10.arrayRemove = function(a, b) {
    b = Math.floor(b);
    if (!(0 > b || b >= a.length)) {
        for (var c = a.length - 1; b < c; ++b)
            a[b] = a[b + 1];
        C3$jscomp$10.truncateArray(a, c)
    }
};
C3$jscomp$10.arrayFindRemove = function(a, b) {
    b = a.indexOf(b);
    0 <= b && a.splice(b, 1)
};
C3$jscomp$10.arraysEqual = function(a, b) {
    let c = a.length;
    if (b.length !== c)
        return !1;
    for (let d = 0; d < c; ++d)
        if (a[d] !== b[d])
            return !1;
    return !0
};
C3$jscomp$10.arrayFilterOut = function(a, b) {
    let c = [],
        d = 0;
    for (let e = 0, f = a.length; e < f; ++e) {
        let g = a[e];
        b(g) ? c.push(g) : (a[d] = g, ++d)
    }
    C3$jscomp$10.truncateArray(a, d);
    return c
};
C3$jscomp$10.arrayRemoveAllInSet = function(a, b) {
    const c = a.length;
    let d = 0;
    for (let e = 0, f = a.length; e < f; ++e) {
        let g = a[e];
        b.has(g) || (a[d++] = g)
    }
    C3$jscomp$10.truncateArray(a, d);
    return c - d
};
C3$jscomp$10.isArrayIndexInBounds = function(a, b) {
    return a !== Math.floor(a) ? !1 : 0 <= a && a < b.length
};
C3$jscomp$10.validateArrayIndex = function(a, b) {
    if (!C3$jscomp$10.isArrayIndexInBounds(a, b))
        throw new RangeError("array index out of bounds");
};
C3$jscomp$10.cloneArray = function(a) {
    return a.slice()
};
C3$jscomp$10.deepCloneArray = function(a, b) {
    let c = [];
    for (let d of a)
        if (C3$jscomp$10.IsObject(d)) {
            a = b(d);
            if (!a)
                throw Error("missing clone");
            if (a.constructor !== d.constructor)
                throw Error("object is not a clone");
            c.push(a)
        } else
            C3$jscomp$10.IsArray(d) ? c.push(C3$jscomp$10.deepCloneArray(d, b)) : c.push(d);
    return c
};
C3$jscomp$10.clone2DArray = function(a) {
    let b = [];
    for (let c of a)
        b.push(c.slice());
    return b
};
C3$jscomp$10.splitStringAndNormalize = function(a, b=" ") {
    return a ? a.split(b).map(c => c.trim()).filter(c => !!c) : []
};
C3$jscomp$10.filterSet = function(a, b, c) {
    const d = new Set;
    for (const e of a.values())
        b(e) && (c ? d.add(c(e)) : d.add(e));
    return d
};
C3$jscomp$10.mergeSets = function(a, b) {
    return a.union ? a.union(b) : new Set([...a, ...b])
};
C3$jscomp$10.mergeSetsInPlace = function(a, b) {
    for (const c of b)
        a.add(c);
    return a
};
C3$jscomp$10.first = function(a) {
    for (let b of a)
        return b;
    return null
};
C3$jscomp$10.xor = function(a, b) {
    return !a !== !b
};
C3$jscomp$10.compare = function(a, b, c) {
    switch (b) {
    case 0:
        return a === c;
    case 1:
        return a !== c;
    case 2:
        return a < c;
    case 3:
        return a <= c;
    case 4:
        return a > c;
    case 5:
        return a >= c;
    default:
        return !1
    }
};
C3$jscomp$10.hasAnyOwnProperty = function(a) {
    for (let b in a)
        if (a.hasOwnProperty(b))
            return !0;
    return !1
};
C3$jscomp$10.PromiseAllWithProgress = function(a, b) {
    return a.length ? new Promise((c, d) => {
        const e = [];
        let f = 0,
            g = !1;
        for (let h = 0, k = a.length; h < k; ++h)
            e.push(void 0),
            a[h].then(l => {
                g || (e[h] = l, ++f, f === a.length ? c(e) : b(f, a.length))
            }).catch(l => {
                g = !0;
                d(l)
            })
    }) : Promise.resolve([])
};
let memoryCallbacks = [];
C3$jscomp$10.AddLibraryMemoryCallback = function(a) {
    memoryCallbacks.push(a)
};
C3$jscomp$10.GetEstimatedLibraryMemoryUsage = function() {
    let a = 0;
    for (let b of memoryCallbacks) {
        let c = b();
        a += c
    }
    return Math.floor(a)
};
let nextTaskId = 1;
const activeTaskIds = new Map,
    taskMessageChannel = new MessageChannel;
taskMessageChannel.port2.onmessage = function(a) {
    a = a.data;
    const b = activeTaskIds.get(a);
    activeTaskIds.delete(a);
    b && b(performance.now())
};
C3$jscomp$10.RequestUnlimitedAnimationFrame = function(a) {
    const b = nextTaskId++;
    activeTaskIds.set(b, a);
    taskMessageChannel.port1.postMessage(b);
    return b
};
C3$jscomp$10.CancelUnlimitedAnimationFrame = function(a) {
    activeTaskIds.delete(a)
};
C3$jscomp$10.PostTask = C3$jscomp$10.RequestUnlimitedAnimationFrame;
C3$jscomp$10.WaitForNextTask = function() {
    return new Promise(a => C3$jscomp$10.PostTask(a))
};
const activeRPAFids = new Set;
C3$jscomp$10.RequestPostAnimationFrame = function(a) {
    const b = self.requestAnimationFrame(async c => {
        await C3$jscomp$10.WaitForNextTask();
        activeRPAFids.has(b) && (activeRPAFids.delete(b), a(c))
    });
    activeRPAFids.add(b);
    return b
};
C3$jscomp$10.CancelPostAnimationFrame = function(a) {
    activeRPAFids.has(a) && (self.cancelAnimationFrame(a), activeRPAFids.delete(a))
};
"use strict";
const C3$jscomp$11 = self.C3;
C3$jscomp$11.IsAbsoluteURL = function(a) {
    return /^(?:[a-z\-]+:)?\/\//.test(a) || "data:" === a.substr(0, 5) || "blob:" === a.substr(0, 5)
};
C3$jscomp$11.IsRelativeURL = function(a) {
    return !C3$jscomp$11.IsAbsoluteURL(a)
};
C3$jscomp$11.ThrowIfNotOk = function(a) {
    if (!a.ok)
        throw Error(`fetch '${a.url}' response returned ${a.status} ${a.statusText}`);
};
C3$jscomp$11.FetchOk = function(a, b) {
    return fetch(a, b).then(c => {
        C3$jscomp$11.ThrowIfNotOk(c);
        return c
    })
};
C3$jscomp$11.FetchText = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.text())
};
C3$jscomp$11.FetchJson = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.json())
};
C3$jscomp$11.FetchBlob = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.blob())
};
C3$jscomp$11.FetchArrayBuffer = function(a) {
    return C3$jscomp$11.FetchOk(a).then(b => b.arrayBuffer())
};
C3$jscomp$11.FetchImage = function(a) {
    return new Promise((b, c) => {
        const d = new Image;
        d.onload = () => b(d);
        d.onerror = e => c(e);
        d.src = a
    })
};
C3$jscomp$11.BlobToArrayBuffer = function(a) {
    return "function" === typeof a.arrayBuffer ? a.arrayBuffer() : new Promise((b, c) => {
        const d = new FileReader;
        d.onload = () => b(d.result);
        d.onerror = () => c(d.error);
        d.readAsArrayBuffer(a)
    })
};
C3$jscomp$11.BlobToString = function(a) {
    return "function" === typeof a.text ? a.text() : new Promise((b, c) => {
        const d = new FileReader;
        d.onload = () => b(d.result);
        d.onerror = () => c(d.error);
        d.readAsText(a)
    })
};
C3$jscomp$11.BlobToJson = function(a) {
    return C3$jscomp$11.BlobToString(a).then(b => JSON.parse(b))
};
C3$jscomp$11.BlobToImage = async function(a, b) {
    a = URL.createObjectURL(a);
    try {
        const c = await C3$jscomp$11.FetchImage(a);
        URL.revokeObjectURL(a);
        a = "";
        b && "function" === typeof c.decode && await c.decode();
        return c
    } finally {
        a && URL.revokeObjectURL(a)
    }
};
C3$jscomp$11.CreateCanvas = function(a, b) {
    if ("undefined" !== typeof document && "function" === typeof document.createElement) {
        const c = document.createElement("canvas");
        c.width = a;
        c.height = b;
        return c
    }
    return new OffscreenCanvas(a, b)
};
C3$jscomp$11.CanvasToBlob = function(a, b, c) {
    "number" !== typeof c && (c = 1);
    b = b || "image/png";
    c = C3$jscomp$11.clamp(c, 0, 1);
    if (a.convertToBlob)
        return a.convertToBlob({
            type: b,
            quality: c
        });
    if (a.toBlob)
        return new Promise(d => a.toBlob(d, b, c));
    throw Error("could not convert canvas to blob");
};
C3$jscomp$11.DrawableToBlob = function(a, b, c) {
    const d = C3$jscomp$11.CreateCanvas(a.width, a.height);
    d.getContext("2d").drawImage(a, 0, 0);
    return C3$jscomp$11.CanvasToBlob(d, b, c)
};
C3$jscomp$11.ImageDataToBlob = function(a, b, c) {
    if (C3$jscomp$11.Supports.ImageBitmapOptions)
        return createImageBitmap(a, {
            premultiplyAlpha: "none"
        }).then(e => C3$jscomp$11.DrawableToBlob(e, b, c));
    if (C3$jscomp$11.Supports.ImageBitmap)
        return createImageBitmap(a).then(e => C3$jscomp$11.DrawableToBlob(e, b, c));
    const d = C3$jscomp$11.CreateCanvas(a.width, a.height);
    d.getContext("2d").putImageData(a, 0, 0);
    return C3$jscomp$11.CanvasToBlob(d, b, c)
};
C3$jscomp$11.CopySet = function(a, b) {
    a.clear();
    for (const c of b)
        a.add(c)
};
C3$jscomp$11.MapToObject = function(a) {
    const b = Object.create(null);
    for (const [c, d] of a.entries())
        b[c] = d;
    return b
};
C3$jscomp$11.ObjectToMap = function(a, b) {
    b.clear();
    for (const [c, d] of Object.entries(a))
        b.set(c, d)
};
C3$jscomp$11.ToSuperJSON = function ToSuperJSON(a) {
    if ("object" === typeof a && null !== a) {
        if (a instanceof Set)
            return {
                _c3type_: "set",
                data: [...a].map(d => ToSuperJSON(d))
            };
        if (a instanceof Map)
            return {
                _c3type_: "map",
                data: [...a].map(d => [d[0], ToSuperJSON(d[1])])
            };
        const c = Object.create(null);
        for (const [d, e] of Object.entries(a))
            c[d] = ToSuperJSON(e);
        return c
    }
    return a
};
C3$jscomp$11.FromSuperJSON = function FromSuperJSON(a) {
    if ("object" === typeof a & null !== a) {
        if ("set" === a._c3type_)
            return new Set(a.data.map(d => FromSuperJSON(d)));
        if ("map" === a._c3type_)
            return new Map(a.data.map(d => [d[0], FromSuperJSON(d[1])]));
        const c = Object.create(null);
        for (const [d, e] of Object.entries(a))
            c[d] = FromSuperJSON(e);
        return c
    }
    return a
};
C3$jscomp$11.CSSToCamelCase = function(a) {
    if (a.startsWith("--"))
        return a;
    let b = "",
        c = !1,
        d = 0;
    for (const e of a)
        "-" === e ? 0 < d && (c = !0) : c ? (b += e.toUpperCase(), c = !1) : b += e,
        ++d;
    return b
};
C3$jscomp$11.IsIterator = function(a) {
    return "object" === typeof a && "function" === typeof a.next
};
C3$jscomp$11.MakeFilledArray = function(a, b) {
    const c = [];
    if ("function" === typeof b)
        for (var d = 0; d < a; ++d)
            c.push(b());
    else
        for (d = 0; d < a; ++d)
            c.push(b);
    return c
};
"use strict";
const C3$jscomp$12 = self.C3,
    HSL_TEST = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?/i,
    HSLA_TEST = /([0-9.]+),([0-9.]+)%?,([0-9.]+)%?,([0-9.])/i;
function padTwoDigits(a) {
    return 0 === a.length ? "00" : 1 === a.length ? "0" + a : a
}
function hueToRGB(a, b, c) {
    0 > c && (c += 1);
    1 < c && --c;
    return c < 1 / 6 ? a + 6 * (b - a) * c : .5 > c ? b : c < 2 / 3 ? a + (b - a) * (2 / 3 - c) * 6 : a
}
C3$jscomp$12.Color = class {
    constructor(a, b, c, d)
    {
        this._a = this._b = this._g = this._r = 0;
        a instanceof C3$jscomp$12.Color ? this.set(a) : this.setRgba(a || 0, b || 0, c || 0, d || 0)
    }
    setRgb(a, b, c)
    {
        this._r = +a;
        this._g = +b;
        this._b = +c;
        this.clamp();
        return this
    }
    setRgba(a, b, c, d)
    {
        this._r = +a;
        this._g = +b;
        this._b = +c;
        this._a = +d;
        this.clamp();
        return this
    }
    set(a)
    {
        this._r = a._r;
        this._g = a._g;
        this._b = a._b;
        this._a = a._a;
        return this
    }
    copy(a)
    {
        return this.set(a)
    }
    add(a)
    {
        this._r += a._r;
        this._g += a._g;
        this._b += a._b;
        this._a += a._a;
        this.clamp()
    }
    addRgb(a, b,
    c, d=0)
    {
        this._r += +a;
        this._g += +b;
        this._b += +c;
        this._a += +d;
        this.clamp()
    }
    diff(a)
    {
        this.setR(Math.max(this._r, a._r) - Math.min(this._r, a._r));
        this.setG(Math.max(this._g, a._g) - Math.min(this._g, a._g));
        this.setB(Math.max(this._b, a._b) - Math.min(this._b, a._b));
        this.setA(Math.max(this._a, a._a) - Math.min(this._a, a._a));
        this.clamp()
    }
    copyRgb(a)
    {
        this._r = a._r;
        this._g = a._g;
        this._b = a._b
    }
    setR(a)
    {
        this._r = C3$jscomp$12.clamp(+a, 0, 1)
    }
    getR()
    {
        return this._r
    }
    setG(a)
    {
        this._g = C3$jscomp$12.clamp(+a, 0, 1)
    }
    getG()
    {
        return this._g
    }
    setB(a)
    {
        this._b =
        C3$jscomp$12.clamp(+a, 0, 1)
    }
    getB()
    {
        return this._b
    }
    setA(a)
    {
        this._a = C3$jscomp$12.clamp(+a, 0, 1)
    }
    getA()
    {
        return this._a
    }
    clone()
    {
        return C3$jscomp$12.New(C3$jscomp$12.Color, this._r, this._g, this._b, this._a)
    }
    toArray()
    {
        return [this._r, this._g, this._b, this._a]
    }
    toTypedArray()
    {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a, b)
    {
        a[b++] = this._r;
        a[b++] = this._g;
        a[b++] = this._b;
        a[b] = this._a
    }
    writeRGBToTypedArray(a, b)
    {
        a[b++] = this._r;
        a[b++] = this._g;
        a[b] = this._b
    }
    equals(a)
    {
        return this._r === a._r && this._g === a._g &&
            this._b === a._b && this._a === a._a
    }
    equalsIgnoringAlpha(a)
    {
        return this._r === a._r && this._g === a._g && this._b === a._b
    }
    equalsRgb(a, b, c)
    {
        return this._r === a && this._g === b && this._b === c
    }
    equalsRgba(a, b, c, d)
    {
        return this._r === a && this._g === b && this._b === c && this._a === d
    }
    equalsF32Array(a, b)
    {
        return a[b] === Math.fround(this._r) && a[b + 1] === Math.fround(this._g) && a[b + 2] === Math.fround(this._b) && a[b + 3] === Math.fround(this._a)
    }
    equalsRGBF32Array(a, b)
    {
        return a[b] === Math.fround(this._r) && a[b + 1] === Math.fround(this._g) && a[b + 2] === Math.fround(this._b)
    }
    multiply(a)
    {
        this._r *=
        a._r;
        this._g *= a._g;
        this._b *= a._b;
        this._a *= a._a
    }
    multiplyAlpha(a)
    {
        this._r *= a;
        this._g *= a;
        this._b *= a;
        this._a *= a
    }
    premultiply()
    {
        this._r *= this._a;
        this._g *= this._a;
        this._b *= this._a;
        return this
    }
    unpremultiply()
    {
        this._r /= this._a;
        this._g /= this._a;
        this._b /= this._a;
        return this
    }
    clamp()
    {
        this._r = C3$jscomp$12.clamp(this._r, 0, 1);
        this._g = C3$jscomp$12.clamp(this._g, 0, 1);
        this._b = C3$jscomp$12.clamp(this._b, 0, 1);
        this._a = C3$jscomp$12.clamp(this._a, 0, 1);
        return this
    }
    setFromRgbValue(a)
    {
        this._r = C3$jscomp$12.GetRValue(a);
        this._g =
        C3$jscomp$12.GetGValue(a);
        this._b = C3$jscomp$12.GetBValue(a);
        this._a = C3$jscomp$12.GetAValue(a)
    }
    getCssRgb(a, b, c)
    {
        a = C3$jscomp$12.IsFiniteNumber(a) ? a : this.getR();
        b = C3$jscomp$12.IsFiniteNumber(b) ? b : this.getG();
        c = C3$jscomp$12.IsFiniteNumber(c) ? c : this.getB();
        return `rgb(${100 * a}%, ${100 * b}%, ${100 * c}%)`
    }
    getCssRgba(a, b, c, d)
    {
        a = C3$jscomp$12.IsFiniteNumber(a) ? a : this.getR();
        b = C3$jscomp$12.IsFiniteNumber(b) ? b : this.getG();
        c = C3$jscomp$12.IsFiniteNumber(c) ? c : this.getB();
        d = C3$jscomp$12.IsFiniteNumber(d) ? d : this.getA();
        return `rgba(${100 * a}%, ${100 * b}%, ${100 * c}%, ${d})`
    }
    toHexString()
    {
        const a = Math.round(255 * this.getR()),
            b = Math.round(255 * this.getG()),
            c = Math.round(255 * this.getB());
        return "#" + padTwoDigits(a.toString(16)) + padTwoDigits(b.toString(16)) + padTwoDigits(c.toString(16))
    }
    parseHexString(a)
    {
        if ("string" !== typeof a)
            return !1;
        a = a.trim();
        "#" === a.charAt(0) && (a = a.substr(1));
        let b,
            c;
        if (3 === a.length)
            b = parseInt(a[0], 16) / 15,
            c = parseInt(a[1], 16) / 15,
            a = parseInt(a[2], 16) / 15;
        else if (6 === a.length)
            b = parseInt(a.substr(0, 2), 16) / 255,
            c = parseInt(a.substr(2, 2), 16) / 255,
            a = parseInt(a.substr(4, 2), 16) / 255;
        else
            return !1;
        isFinite(b) && this.setR(b);
        isFinite(c) && this.setG(c);
        isFinite(a) && this.setB(a);
        this.setA(1);
        return !0
    }
    toCommaSeparatedRgb()
    {
        const a = Math.round(255 * this.getR()),
            b = Math.round(255 * this.getG()),
            c = Math.round(255 * this.getB());
        return `${a}, ${b}, ${c}`
    }
    toRgbArray()
    {
        const a = Math.round(255 * this.getR()),
            b = Math.round(255 * this.getG()),
            c = Math.round(255 * this.getB());
        return [a, b, c]
    }
    parseCommaSeparatedRgb(a)
    {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgb\(|\)|%/, "");
        var b = a.split(",");
        if (3 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 255;
        const c = parseInt(b[1].trim(), 10) / 255;
        b = parseInt(b[2].trim(), 10) / 255;
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(b) && this.setB(b);
        this.setA(1);
        return !0
    }
    parseCommaSeparatedPercentageRgb(a)
    {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgb\(|\)|%/, "");
        var b = a.split(",");
        if (3 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 100;
        const c = parseInt(b[1].trim(), 10) / 100;
        b = parseInt(b[2].trim(),
        10) / 100;
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(b) && this.setB(b);
        this.setA(1);
        return !0
    }
    parseCommaSeparatedRgba(a)
    {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/^rgba\(|\)|%/, "");
        var b = a.split(",");
        if (4 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 255;
        const c = parseInt(b[1].trim(), 10) / 255,
            d = parseInt(b[2].trim(), 10) / 255;
        b = parseFloat(b[3].trim());
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(d) && this.setB(d);
        isFinite(b) && this.setA(b);
        return !0
    }
    parseCommaSeparatedPercentageRgba(a)
    {
        if ("string" !==
        typeof a)
            return !1;
        a = a.replace(/^rgba\(|\)|%/, "");
        var b = a.split(",");
        if (4 > b.length)
            return !1;
        a = parseInt(b[0].trim(), 10) / 100;
        const c = parseInt(b[1].trim(), 10) / 100,
            d = parseInt(b[2].trim(), 10) / 100;
        b = parseFloat(b[3].trim());
        isFinite(a) && this.setR(a);
        isFinite(c) && this.setG(c);
        isFinite(d) && this.setB(d);
        isFinite(b) && this.setA(b);
        return !0
    }
    parseString(a)
    {
        if ("string" !== typeof a)
            return !1;
        a = a.replace(/\s+/, "");
        if (a.includes(",")) {
            if (a.startsWith("rgb("))
                return a.includes("%") ? this.parseCommaSeparatedPercentageRgb(a) :
                this.parseCommaSeparatedRgb(a);
            if (a.startsWith("rgba("))
                return a.includes("%") ? this.parseCommaSeparatedPercentageRgba(a) : this.parseCommaSeparatedRgba(a);
            if (a.startsWith("hsl(") || a.startsWith("hsla("))
                return this.parseHSLString(a);
            const b = a.split(",");
            if (a.includes("%")) {
                if (3 === b.length)
                    return this.parseCommaSeparatedPercentageRgb(a);
                if (4 === b.length)
                    return this.parseCommaSeparatedPercentageRgba(a)
            } else {
                if (3 === b.length)
                    return this.parseCommaSeparatedRgb(a);
                if (4 === b.length)
                    return this.parseCommaSeparatedRgba(a)
            }
            return !1
        }
        return this.parseHexString(a)
    }
    toJSON()
    {
        return [this._r,
        this._g, this._b, this._a]
    }
    setFromHSLA(a, b, c, d)
    {
        a %= 360;
        b = C3$jscomp$12.clamp(b, 0, 100);
        c = C3$jscomp$12.clamp(c, 0, 100);
        d = C3$jscomp$12.clamp(d, 0, 1);
        a /= 360;
        b /= 100;
        c /= 100;
        if (0 === b)
            c = b = a = c;
        else {
            const e = .5 > c ? c * (1 + b) : c + b - c * b,
                f = 2 * c - e;
            c = hueToRGB(f, e, a + 1 / 3);
            b = hueToRGB(f, e, a);
            a = hueToRGB(f, e, a - 1 / 3)
        }
        this.setR(c);
        this.setG(b);
        this.setB(a);
        this.setA(d);
        return this
    }
    parseHSLString(a)
    {
        var b = a.replace(/ |hsl|hsla|\(|\)|;/gi, "");
        a = HSL_TEST.exec(b);
        b = HSLA_TEST.exec(b);
        return a && 4 === a.length ? (this.setFromHSLA(+a[1], +a[2], +a[3],
        1), !0) : b && 5 === b.length ? (this.setFromHSLA(+a[1], +a[2], +a[3], +a[4]), !0) : !1
    }
    toHSLAString()
    {
        var a = this._r;
        const b = this._g,
            c = this._b,
            d = this._a,
            e = C3$jscomp$12.Color.GetHue(a, b, c),
            f = C3$jscomp$12.Color.GetSaturation(a, b, c);
        a = C3$jscomp$12.Color.GetLuminosity(a, b, c);
        return `hsla(${e}, ${f}%, ${a}%, ${d})`
    }
    toHSLAArray()
    {
        const a = this._r,
            b = this._g,
            c = this._b;
        return [C3$jscomp$12.Color.GetHue(a, b, c), C3$jscomp$12.Color.GetSaturation(a, b, c), C3$jscomp$12.Color.GetLuminosity(a, b, c), this._a]
    }
    setFromJSON(a)
    {
        !Array.isArray(a) ||
        3 > a.length || (this._r = a[0], this._g = a[1], this._b = a[2], this._a = 4 <= a.length ? a[3] : 1)
    }
    set r(a)
    {
        this.setR(a)
    }
    get r()
    {
        return this.getR()
    }
    set g(a)
    {
        this.setG(a)
    }
    get g()
    {
        return this.getG()
    }
    set b(a)
    {
        this.setB(a)
    }
    get b()
    {
        return this.getB()
    }
    set a(a)
    {
        this.setA(a)
    }
    get a()
    {
        return this.getA()
    }
    setAtIndex(a, b)
    {
        switch (a) {
        case 0:
            this.setR(b);
            break;
        case 1:
            this.setG(b);
            break;
        case 2:
            this.setB(b);
            break;
        case 3:
            this.setA(b);
            break;
        default:
            throw new RangeError("invalid color index");
        }
    }
    getAtIndex(a)
    {
        switch (a) {
        case 0:
            return this.getR();
        case 1:
            return this.getG();
        case 2:
            return this.getB();
        case 3:
            return this.getA();
        default:
            throw new RangeError("invalid color index");
        }
    }
    static Equals(a, b)
    {
        let c;
        if (Array.isArray(a))
            c = new C3$jscomp$12.Color,
            c.setFromJSON(a);
        else if (a instanceof C3$jscomp$12.Color)
            c = a;
        else
            throw Error("unexpected type");
        if (Array.isArray(b))
            a = new C3$jscomp$12.Color,
            a.setFromJSON(b);
        else if (b instanceof C3$jscomp$12.Color)
            a = b;
        else
            throw Error("unexpected type");
        return c.equals(a)
    }
    static DiffChannel(a, b)
    {
        return C3$jscomp$12.clamp(Math.max(a,
        b) - Math.min(a, b), 0, 1)
    }
    static Diff(a, b)
    {
        const c = new C3$jscomp$12.Color;
        c.setR(Math.max(a._r, b._r) - Math.min(a._r, b._r));
        c.setG(Math.max(a._g, b._g) - Math.min(a._g, b._g));
        c.setB(Math.max(a._b, b._b) - Math.min(a._b, b._b));
        c.setA(Math.max(a._a, b._a) - Math.min(a._a, b._a));
        return c
    }
    static DiffNoAlpha(a, b)
    {
        const c = new C3$jscomp$12.Color(0, 0, 0, 1);
        c.setR(Math.max(a._r, b._r) - Math.min(a._r, b._r));
        c.setG(Math.max(a._g, b._g) - Math.min(a._g, b._g));
        c.setB(Math.max(a._b, b._b) - Math.min(a._b, b._b));
        return c
    }
    static GetHue(a,
    b, c)
    {
        const d = Math.max(a, b, c),
            e = Math.min(a, b, c);
        if (d === e)
            return 0;
        let f = 0;
        switch (d) {
        case a:
            f = (b - c) / (d - e) + (b < c ? 6 : 0);
            break;
        case b:
            f = (c - a) / (d - e) + 2;
            break;
        case c:
            f = (a - b) / (d - e) + 4
        }
        return Math.round(f / 6 * 360)
    }
    static GetSaturation(a, b, c)
    {
        const d = Math.max(a, b, c);
        a = Math.min(a, b, c);
        if (d === a)
            return 0;
        b = d - a;
        return Math.round(100 * (.5 < (d + a) / 2 ? b / (2 - d - a) : b / (d + a)))
    }
    static GetLuminosity(a, b, c)
    {
        const d = Math.max(a, b, c);
        return d ? Math.round((d + Math.min(a, b, c)) / 2 * 100) : 0
    }
}
;
C3$jscomp$12.Color.White = Object.freeze(C3$jscomp$12.New(C3$jscomp$12.Color, 1, 1, 1, 1));
C3$jscomp$12.Color.Black = Object.freeze(C3$jscomp$12.New(C3$jscomp$12.Color, 0, 0, 0, 1));
C3$jscomp$12.Color.TransparentBlack = Object.freeze(C3$jscomp$12.New(C3$jscomp$12.Color, 0, 0, 0, 0));
"use strict";
const C3$jscomp$13 = self.C3;
C3$jscomp$13.Vector2 = class {
    constructor(a, b)
    {
        this._y = this._x = 0;
        a instanceof C3$jscomp$13.Vector2 ? this.copy(a) : this.set(a || 0, b || 0)
    }
    set(a, b)
    {
        this._x = +a;
        this._y = +b
    }
    copy(a)
    {
        this._x = a._x;
        this._y = a._y
    }
    equals(a)
    {
        return this._x === a._x && this._y === a._y
    }
    equalsValues(a, b)
    {
        return this._x === a && this._y === b
    }
    equalsF32Array(a, b)
    {
        return a[b] === Math.fround(this._x) && a[b + 1] === Math.fround(this._y)
    }
    setX(a)
    {
        this._x = +a
    }
    getX()
    {
        return this._x
    }
    setY(a)
    {
        this._y = +a
    }
    getY()
    {
        return this._y
    }
    toArray()
    {
        return [this._x, this._y]
    }
    toTypedArray()
    {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a,
    b)
    {
        a[b++] = this._x;
        a[b] = this._y
    }
    offset(a, b)
    {
        this._x += +a;
        this._y += +b
    }
    scale(a, b)
    {
        this._x *= a;
        this._y *= b
    }
    divide(a, b)
    {
        this._x /= a;
        this._y /= b
    }
    round()
    {
        this._x = Math.round(this._x);
        this._y = Math.round(this._y)
    }
    floor()
    {
        this._x = Math.floor(this._x);
        this._y = Math.floor(this._y)
    }
    ceil()
    {
        this._x = Math.ceil(this._x);
        this._y = Math.ceil(this._y)
    }
    angle()
    {
        return C3$jscomp$13.angleTo(0, 0, this._x, this._y)
    }
    lengthSquared()
    {
        return this._x * this._x + this._y * this._y
    }
    length()
    {
        return Math.hypot(this._x, this._y)
    }
    rotatePrecalc(a, b)
    {
        const c =
        this._x * b - this._y * a;
        this._y = this._y * b + this._x * a;
        this._x = c
    }
    rotate(a)
    {
        0 !== a && this.rotatePrecalc(Math.sin(a), Math.cos(a))
    }
    rotateAbout(a, b, c)
    {
        0 === a || b === this._x && c === this._y || (this._x -= b, this._y -= c, this.rotatePrecalc(Math.sin(a), Math.cos(a)), this._x += +b, this._y += +c)
    }
    move(a, b)
    {
        0 !== b && (this._x += Math.cos(a) * b, this._y += Math.sin(a) * b)
    }
    normalize()
    {
        const a = this.length();
        0 !== a && 1 !== a && (this._x /= a, this._y /= a)
    }
    clamp(a, b)
    {
        this._x = C3$jscomp$13.clamp(this._x, a, b);
        this._y = C3$jscomp$13.clamp(this._y, a, b)
    }
    dot(a)
    {
        return this._x *
        a._x + this._y * a._y
    }
    reverse()
    {
        this._x = -this._x;
        this._y = -this._y
    }
    perp()
    {
        let a = this._x;
        this._x = this._y;
        this._y = -a;
        return this
    }
}
;
"use strict";
const C3$jscomp$14 = self.C3;
C3$jscomp$14.Rect = class {
    constructor(a, b, c, d)
    {
        this._bottom = this._right = this._top = this._left = 0;
        a instanceof C3$jscomp$14.Rect ? this.copy(a) : this.set(a || 0, b || 0, c || 0, d || 0)
    }
    set(a, b, c, d)
    {
        this._left = +a;
        this._top = +b;
        this._right = +c;
        this._bottom = +d
    }
    setWH(a, b, c, d)
    {
        a = +a;
        b = +b;
        this._left = a;
        this._top = b;
        this._right = a + +c;
        this._bottom = b + +d
    }
    copy(a)
    {
        this._left = +a._left;
        this._top = +a._top;
        this._right = +a._right;
        this._bottom = +a._bottom
    }
    clone()
    {
        return new C3$jscomp$14.Rect(this._left, this._top, this._right, this._bottom)
    }
    static Merge(a,
    b)
    {
        const c = new C3$jscomp$14.Rect;
        c.setLeft(Math.min(a._left, b._left));
        c.setTop(Math.min(a._top, b._top));
        c.setRight(Math.max(a._right, b._right));
        c.setBottom(Math.max(a._bottom, b._bottom));
        return c
    }
    static FromObject(a)
    {
        return new C3$jscomp$14.Rect(a.left, a.top, a.right, a.bottom)
    }
    equals(a)
    {
        return this._left === a._left && this._top === a._top && this._right === a._right && this._bottom === a._bottom
    }
    equalsWH(a, b, c, d)
    {
        return this._left === a && this._top === b && this.width() === c && this.height() === d
    }
    equalsF32Array(a, b)
    {
        return a[b] ===
            Math.fround(this._left) && a[b + 1] === Math.fround(this._top) && a[b + 2] === Math.fround(this._right) && a[b + 3] === Math.fround(this._bottom)
    }
    setLeft(a)
    {
        this._left = +a
    }
    getLeft()
    {
        return this._left
    }
    setTop(a)
    {
        this._top = +a
    }
    getTop()
    {
        return this._top
    }
    setRight(a)
    {
        this._right = +a
    }
    getRight()
    {
        return this._right
    }
    setBottom(a)
    {
        this._bottom = +a
    }
    getBottom()
    {
        return this._bottom
    }
    toArray()
    {
        return [this._left, this._top, this._right, this._bottom]
    }
    toTypedArray()
    {
        return new Float64Array(this.toArray())
    }
    toDOMRect()
    {
        return new DOMRect(this._left,
        this._top, this.width(), this.height())
    }
    static fromDOMRect(a)
    {
        return C3$jscomp$14.New(C3$jscomp$14.Rect, a.left, a.top, a.right, a.bottom)
    }
    writeToTypedArray(a, b)
    {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b] = this._bottom
    }
    writeAsQuadToTypedArray(a, b)
    {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b++] = this._top;
        a[b++] = this._right;
        a[b++] = this._bottom;
        a[b++] = this._left;
        a[b] = this._bottom
    }
    writeAsQuadToTypedArray3D(a, b, c)
    {
        a[b++] = this._left;
        a[b++] = this._top;
        a[b++] = c;
        a[b++] = this._right;
        a[b++] =
        this._top;
        a[b++] = c;
        a[b++] = this._right;
        a[b++] = this._bottom;
        a[b++] = c;
        a[b++] = this._left;
        a[b++] = this._bottom;
        a[b] = c
    }
    width()
    {
        return this._right - this._left
    }
    height()
    {
        return this._bottom - this._top
    }
    midX()
    {
        return (this._left + this._right) / 2
    }
    midY()
    {
        return (this._top + this._bottom) / 2
    }
    offset(a, b)
    {
        a = +a;
        b = +b;
        this._left += a;
        this._top += b;
        this._right += a;
        this._bottom += b
    }
    offsetLeft(a)
    {
        this._left += +a
    }
    offsetTop(a)
    {
        this._top += +a
    }
    offsetRight(a)
    {
        this._right += +a
    }
    offsetBottom(a)
    {
        this._bottom += +a
    }
    toSquare(a)
    {
        if ("x" !== a)
            throw Error("invalid axis, only 'x' supported");
        this._bottom = this._top < this._bottom ? this._left < this._right ? this._top + this.width() : this._top - this.width() : this._left < this._right ? this._top - this.width() : this._top + this.width()
    }
    inflate(a, b)
    {
        a = +a;
        b = +b;
        this._left -= a;
        this._top -= b;
        this._right += a;
        this._bottom += b
    }
    deflate(a, b)
    {
        a = +a;
        b = +b;
        this._left += a;
        this._top += b;
        this._right -= a;
        this._bottom -= b
    }
    multiply(a, b)
    {
        this._left *= a;
        this._top *= b;
        this._right *= a;
        this._bottom *= b
    }
    divide(a, b)
    {
        this._left /= a;
        this._top /= b;
        this._right /= a;
        this._bottom /= b
    }
    mirrorAround(a)
    {
        this._left =
        +a - this._left;
        this._right = +a - this._right
    }
    flipAround(a)
    {
        this._top = +a - this._top;
        this._bottom = +a - this._bottom
    }
    rotate90DegreesAround(a, b)
    {
        const c = this.width(),
            d = this.height(),
            e = this.getLeft() + c * a,
            f = this.getTop() + d * b;
        this.setWH(e - d * b, f - c * a, d, c)
    }
    swapLeftRight()
    {
        const a = this._left;
        this._left = this._right;
        this._right = a
    }
    swapTopBottom()
    {
        const a = this._top;
        this._top = this._bottom;
        this._bottom = a
    }
    shuntY(a)
    {
        const b = this._top;
        this._top = +a - this._bottom;
        this._bottom = +a - b
    }
    round()
    {
        this._left = Math.round(this._left);
        this._top =
        Math.round(this._top);
        this._right = Math.round(this._right);
        this._bottom = Math.round(this._bottom)
    }
    roundInner()
    {
        this._left = Math.ceil(this._left);
        this._top = Math.ceil(this._top);
        this._right = Math.floor(this._right);
        this._bottom = Math.floor(this._bottom)
    }
    roundOuter()
    {
        this._left = Math.floor(this._left);
        this._top = Math.floor(this._top);
        this._right = Math.ceil(this._right);
        this._bottom = Math.ceil(this._bottom)
    }
    floor()
    {
        this._left = Math.floor(this._left);
        this._top = Math.floor(this._top);
        this._right = Math.floor(this._right);
        this._bottom = Math.floor(this._bottom)
    }
    ceil()
    {
        this._left = Math.ceil(this._left);
        this._top = Math.ceil(this._top);
        this._right = Math.ceil(this._right);
        this._bottom = Math.ceil(this._bottom)
    }
    clamp(a, b, c, d)
    {
        this._left = Math.max(this._left, +a);
        this._top = Math.max(this._top, +b);
        this._right = Math.min(this._right, +c);
        this._bottom = Math.min(this._bottom, +d)
    }
    clampBoth(a, b, c, d)
    {
        a = +a;
        b = +b;
        c = +c;
        d = +d;
        this._left = C3$jscomp$14.clamp(this._left, a, c);
        this._top = C3$jscomp$14.clamp(this._top, b, d);
        this._right = C3$jscomp$14.clamp(this._right,
        a, c);
        this._bottom = C3$jscomp$14.clamp(this._bottom, b, d)
    }
    normalize()
    {
        this._left > this._right && this.swapLeftRight();
        this._top > this._bottom && this.swapTopBottom()
    }
    intersectsRect(a)
    {
        return !(a._right < this._left || a._bottom < this._top || a._left > this._right || a._top > this._bottom)
    }
    intersectsRectOffset(a, b, c)
    {
        return !(a._right + b < this._left || a._bottom + c < this._top || a._left + b > this._right || a._top + c > this._bottom)
    }
    containsPoint(a, b)
    {
        return a >= this._left && a <= this._right && b >= this._top && b <= this._bottom
    }
    containsRect(a)
    {
        return a._left >=
            this._left && a._top >= this._top && a._right <= this._right && a._bottom <= this._bottom
    }
    expandToContain(a)
    {
        a._left < this._left && (this._left = +a._left);
        a._top < this._top && (this._top = +a._top);
        a._right > this._right && (this._right = +a._right);
        a._bottom > this._bottom && (this._bottom = +a._bottom)
    }
    lerpInto(a)
    {
        this._left = C3$jscomp$14.lerp(a._left, a._right, this._left);
        this._top = C3$jscomp$14.lerp(a._top, a._bottom, this._top);
        this._right = C3$jscomp$14.lerp(a._left, a._right, this._right);
        this._bottom = C3$jscomp$14.lerp(a._top, a._bottom,
        this._bottom)
    }
}
;
"use strict";
const C3$jscomp$15 = self.C3;
C3$jscomp$15.Quad = class {
    constructor(a, b, c, d, e, f, g, h)
    {
        this._bly = this._blx = this._bry = this._brx = this._try = this._trx = this._tly = this._tlx = 0;
        a instanceof C3$jscomp$15.Quad ? this.copy(a) : this.set(a || 0, b || 0, c || 0, d || 0, e || 0, f || 0, g || 0, h || 0)
    }
    set(a, b, c, d, e, f, g, h)
    {
        this._tlx = +a;
        this._tly = +b;
        this._trx = +c;
        this._try = +d;
        this._brx = +e;
        this._bry = +f;
        this._blx = +g;
        this._bly = +h
    }
    setRect(a, b, c, d)
    {
        this.set(a, b, c, b, c, d, a, d)
    }
    copy(a)
    {
        this._tlx = a._tlx;
        this._tly = a._tly;
        this._trx = a._trx;
        this._try = a._try;
        this._brx = a._brx;
        this._bry = a._bry;
        this._blx = a._blx;
        this._bly = a._bly
    }
    equals(a)
    {
        return this._tlx === a._tlx && this._tly === a._tly && this._trx === a._trx && this._try === a._try && this._brx === a._brx && this._bry === a._bry && this._blx === a._blx && this._bly === a._bly
    }
    setTlx(a)
    {
        this._tlx = +a
    }
    getTlx()
    {
        return this._tlx
    }
    setTly(a)
    {
        this._tly = +a
    }
    getTly()
    {
        return this._tly
    }
    setTrx(a)
    {
        this._trx = +a
    }
    getTrx()
    {
        return this._trx
    }
    setTry(a)
    {
        this._try = +a
    }
    getTry()
    {
        return this._try
    }
    setBrx(a)
    {
        this._brx = +a
    }
    getBrx()
    {
        return this._brx
    }
    setBry(a)
    {
        this._bry = +a
    }
    getBry()
    {
        return this._bry
    }
    setBlx(a)
    {
        this._blx =
        +a
    }
    getBlx()
    {
        return this._blx
    }
    setBly(a)
    {
        this._bly = +a
    }
    getBly()
    {
        return this._bly
    }
    toDOMQuad()
    {
        return new DOMQuad(new DOMPoint(this._tlx, this._tly), new DOMPoint(this._trx, this._try), new DOMPoint(this._brx, this._bry), new DOMPoint(this._blx, this._bly))
    }
    static fromDOMQuad(a)
    {
        return C3$jscomp$15.New(C3$jscomp$15.Quad, a.p1.x, a.p1.y, a.p2.x, a.p2.y, a.p3.x, a.p3.y, a.p4.x, a.p4.y)
    }
    toArray()
    {
        return [this._tlx, this._tly, this._trx, this._try, this._brx, this._bry, this._blx, this._bly]
    }
    toTypedArray()
    {
        return new Float64Array(this.toArray())
    }
    writeToTypedArray(a,
    b)
    {
        a[b++] = this._tlx;
        a[b++] = this._tly;
        a[b++] = this._trx;
        a[b++] = this._try;
        a[b++] = this._brx;
        a[b++] = this._bry;
        a[b++] = this._blx;
        a[b] = this._bly
    }
    writeToTypedArray3D(a, b, c)
    {
        a[b++] = this._tlx;
        a[b++] = this._tly;
        a[b++] = c;
        a[b++] = this._trx;
        a[b++] = this._try;
        a[b++] = c;
        a[b++] = this._brx;
        a[b++] = this._bry;
        a[b++] = c;
        a[b++] = this._blx;
        a[b++] = this._bly;
        a[b] = c
    }
    offset(a, b)
    {
        a = +a;
        b = +b;
        this._tlx += a;
        this._tly += b;
        this._trx += a;
        this._try += b;
        this._brx += a;
        this._bry += b;
        this._blx += a;
        this._bly += b
    }
    round()
    {
        this._tlx = Math.round(this._tlx);
        this._tly =
        Math.round(this._tly);
        this._trx = Math.round(this._trx);
        this._try = Math.round(this._try);
        this._brx = Math.round(this._brx);
        this._bry = Math.round(this._bry);
        this._blx = Math.round(this._blx);
        this._bly = Math.round(this._bly)
    }
    floor()
    {
        this._tlx = Math.floor(this._tlx);
        this._tly = Math.floor(this._tly);
        this._trx = Math.floor(this._trx);
        this._try = Math.floor(this._try);
        this._brx = Math.floor(this._brx);
        this._bry = Math.floor(this._bry);
        this._blx = Math.floor(this._blx);
        this._bly = Math.floor(this._bly)
    }
    ceil()
    {
        this._tlx = Math.ceil(this._tlx);
        this._tly = Math.ceil(this._tly);
        this._trx = Math.ceil(this._trx);
        this._try = Math.ceil(this._try);
        this._brx = Math.ceil(this._brx);
        this._bry = Math.ceil(this._bry);
        this._blx = Math.ceil(this._blx);
        this._bly = Math.ceil(this._bly)
    }
    setFromRect(a)
    {
        this._tlx = a._left;
        this._tly = a._top;
        this._trx = a._right;
        this._try = a._top;
        this._brx = a._right;
        this._bry = a._bottom;
        this._blx = a._left;
        this._bly = a._bottom
    }
    setFromRotatedRect(a, b)
    {
        0 === b ? this.setFromRect(a) : this.setFromRotatedRectPrecalc(a, Math.sin(b), Math.cos(b))
    }
    setFromRotatedRectPrecalc(a,
    b, c)
    {
        const d = a._left * b,
            e = a._top * b,
            f = a._right * b;
        b *= a._bottom;
        const g = a._left * c,
            h = a._top * c,
            k = a._right * c;
        a = a._bottom * c;
        this._tlx = g - e;
        this._tly = h + d;
        this._trx = k - e;
        this._try = h + f;
        this._brx = k - b;
        this._bry = a + f;
        this._blx = g - b;
        this._bly = a + d
    }
    getBoundingBox(a)
    {
        a.set(Math.min(this._tlx, this._trx, this._brx, this._blx), Math.min(this._tly, this._try, this._bry, this._bly), Math.max(this._tlx, this._trx, this._brx, this._blx), Math.max(this._tly, this._try, this._bry, this._bly))
    }
    containsPoint(a, b)
    {
        var c = this._trx - this._tlx,
            d = this._try -
            this._tly;
        const e = this._brx - this._tlx,
            f = this._bry - this._tly;
        a -= this._tlx;
        b -= this._tly;
        var g = c * c + d * d;
        let h = c * e + d * f;
        d = c * a + d * b;
        const k = e * e + f * f,
            l = e * a + f * b;
        let m = 1 / (g * k - h * h);
        c = (k * d - h * l) * m;
        g = (g * l - h * d) * m;
        if (0 <= c && 0 < g && 1 > c + g)
            return !0;
        c = this._blx - this._tlx;
        d = this._bly - this._tly;
        g = c * c + d * d;
        h = c * e + d * f;
        d = c * a + d * b;
        m = 1 / (g * k - h * h);
        c = (k * d - h * l) * m;
        g = (g * l - h * d) * m;
        return 0 <= c && 0 < g && 1 > c + g
    }
    midX()
    {
        return (this._tlx + this._trx + this._brx + this._blx) / 4
    }
    midY()
    {
        return (this._tly + this._try + this._bry + this._bly) / 4
    }
    intersectsSegment(a, b,
    c, d)
    {
        return this.containsPoint(a, b) || this.containsPoint(c, d) ? !0 : C3$jscomp$15.segmentIntersectsQuad(a, b, c, d, this)
    }
    intersectsQuad(a)
    {
        var b = a.midX(),
            c = a.midY();
        if (this.containsPoint(b, c))
            return !0;
        b = this.midX();
        c = this.midY();
        if (a.containsPoint(b, c))
            return !0;
        b = this._tlx;
        c = this._tly;
        const d = this._trx,
            e = this._try,
            f = this._brx,
            g = this._bry,
            h = this._blx,
            k = this._bly;
        return C3$jscomp$15.segmentIntersectsQuad(b, c, d, e, a) || C3$jscomp$15.segmentIntersectsQuad(d, e, f, g, a) || C3$jscomp$15.segmentIntersectsQuad(f, g, h, k, a) ||
            C3$jscomp$15.segmentIntersectsQuad(h, k, b, c, a)
    }
    rotatePointsAnticlockwise()
    {
        const a = this._tlx,
            b = this._tly;
        this._tlx = this._trx;
        this._tly = this._try;
        this._trx = this._brx;
        this._try = this._bry;
        this._brx = this._blx;
        this._bry = this._bly;
        this._blx = a;
        this._bly = b
    }
    mirror()
    {
        this._swap(0, 2);
        this._swap(1, 3);
        this._swap(6, 4);
        this._swap(7, 5)
    }
    flip()
    {
        this._swap(0, 6);
        this._swap(1, 7);
        this._swap(2, 4);
        this._swap(3, 5)
    }
    diag()
    {
        this._swap(2, 6);
        this._swap(3, 7)
    }
    _swap(a, b)
    {
        const c = this._getAtIndex(a);
        this._setAtIndex(a, this._getAtIndex(b));
        this._setAtIndex(b, c)
    }
    _getAtIndex(a)
    {
        switch (a) {
        case 0:
            return this._tlx;
        case 1:
            return this._tly;
        case 2:
            return this._trx;
        case 3:
            return this._try;
        case 4:
            return this._brx;
        case 5:
            return this._bry;
        case 6:
            return this._blx;
        case 7:
            return this._bly;
        default:
            throw new RangeError("invalid quad point index");
        }
    }
    _setAtIndex(a, b)
    {
        b = +b;
        switch (a) {
        case 0:
            this._tlx = b;
            break;
        case 1:
            this._tly = b;
            break;
        case 2:
            this._trx = b;
            break;
        case 3:
            this._try = b;
            break;
        case 4:
            this._brx = b;
            break;
        case 5:
            this._bry = b;
            break;
        case 6:
            this._blx = b;
            break;
        case 7:
            this._bly = b;
            break;
        default:
            throw new RangeError("invalid quad point index");
        }
    }
}
;
"use strict";
const C3$jscomp$16 = self.C3,
    DEFAULT_POLY_POINTS = [0, 0, 1, 0, 1, 1, 0, 1],
    tempQuad = C3$jscomp$16.New(C3$jscomp$16.Quad);
C3$jscomp$16.CollisionPoly = class  extends C3$jscomp$16.DefendedBase{
    constructor(a, b=!0)
    {
        super();
        a || (a = DEFAULT_POLY_POINTS);
        this._ptsArr = Float64Array.from(a);
        this._bbox = new C3$jscomp$16.Rect;
        this._isBboxChanged = !0;
        this._enabled = b
    }
    Release() {}
    pointsArr()
    {
        return this._ptsArr
    }
    pointCount()
    {
        return this._ptsArr.length / 2
    }
    setPoints(a)
    {
        this._ptsArr.length === a.length ? this._ptsArr.set(a) : this._ptsArr = Float64Array.from(a);
        this._isBboxChanged = !0
    }
    setDefaultPoints()
    {
        this.setPoints(DEFAULT_POLY_POINTS)
    }
    copy(a)
    {
        this.setPoints(a._ptsArr)
    }
    setBboxChanged()
    {
        this._isBboxChanged =
        !0
    }
    _updateBbox()
    {
        if (this._isBboxChanged) {
            var a = this._ptsArr,
                b = a[0],
                c = a[1],
                d = b,
                e = c;
            for (let f = 0, g = a.length; f < g; f += 2) {
                const h = a[f],
                    k = a[f + 1];
                h < b && (b = h);
                h > d && (d = h);
                k < c && (c = k);
                k > e && (e = k)
            }
            this._bbox.set(b, c, d, e);
            this._isBboxChanged = !1
        }
    }
    setFromRect(a, b, c)
    {
        let d = this._ptsArr;
        8 !== d.length && (this._ptsArr = d = new Float64Array(8));
        d[0] = a.getLeft() - b;
        d[1] = a.getTop() - c;
        d[2] = a.getRight() - b;
        d[3] = a.getTop() - c;
        d[4] = a.getRight() - b;
        d[5] = a.getBottom() - c;
        d[6] = a.getLeft() - b;
        d[7] = a.getBottom() - c;
        this._bbox.copy(a);
        0 === b && 0 ===
        c || this._bbox.offset(-b, -c);
        this._isBboxChanged = !1
    }
    setFromQuad(a, b, c)
    {
        tempQuad.copy(a);
        tempQuad.offset(b, c);
        this.setPoints(tempQuad.toArray());
        this._isBboxChanged = !0
    }
    transform(a, b, c)
    {
        let d = 0,
            e = 1;
        0 !== c && (d = Math.sin(c), e = Math.cos(c));
        this.transformPrecalc(a, b, d, e)
    }
    transformPrecalc(a, b, c, d)
    {
        const e = this._ptsArr;
        for (let f = 0, g = e.length; f < g; f += 2) {
            const h = f + 1,
                k = e[f] * a,
                l = e[h] * b;
            e[f] = k * d - l * c;
            e[h] = l * d + k * c
        }
        this._isBboxChanged = !0
    }
    offset(a, b)
    {
        const c = this._ptsArr;
        for (let d = 0, e = c.length; d < e; d += 2)
            c[d] += a,
            c[d + 1] +=
            b
    }
    containsPoint(a, b)
    {
        const c = this._ptsArr;
        if (a === c[0] && b === c[1])
            return !0;
        this._updateBbox();
        var d = this._bbox;
        const e = d.getLeft() - 110,
            f = d.getTop() - 101,
            g = d.getRight() + 131;
        d = d.getBottom() + 120;
        let h,
            k,
            l,
            m,
            n,
            p,
            q,
            r;
        e < a ? (h = e, l = a) : (h = a, l = e);
        f < b ? (k = f, m = b) : (k = b, m = f);
        g < a ? (n = g, q = a) : (n = a, q = g);
        d < b ? (p = d, r = b) : (p = b, r = d);
        let t = 0,
            u = 0;
        for (let w = 0, x = c.length; w < x; w += 2) {
            var v = (w + 2) % x;
            const y = c[w],
                z = c[w + 1],
                A = c[v];
            v = c[v + 1];
            C3$jscomp$16.segmentsIntersectPreCalc(e, f, a, b, h, l, k, m, y, z, A, v) && ++t;
            C3$jscomp$16.segmentsIntersectPreCalc(g,
            d, a, b, n, q, p, r, y, z, A, v) && ++u
        }
        return 1 === t % 2 || 1 === u % 2
    }
    intersectsPoly(a, b, c)
    {
        const d = a._ptsArr,
            e = this._ptsArr;
        if (this.containsPoint(d[0] + b, d[1] + c) || a.containsPoint(e[0] - b, e[1] - c))
            return !0;
        for (let g = 0, h = e.length; g < h; g += 2) {
            var f = (g + 2) % h;
            a = e[g];
            const k = e[g + 1],
                l = e[f];
            f = e[f + 1];
            let m,
                n,
                p,
                q;
            a < l ? (m = a, p = l) : (m = l, p = a);
            k < f ? (n = k, q = f) : (n = f, q = k);
            for (let r = 0, t = d.length; r < t; r += 2) {
                const u = (r + 2) % t;
                if (C3$jscomp$16.segmentsIntersectPreCalc(a, k, l, f, m, p, n, q, d[r] + b, d[r + 1] + c, d[u] + b, d[u + 1] + c))
                    return !0
            }
        }
        return !1
    }
    intersectsSegment(a,
    b, c, d, e, f)
    {
        if (this.containsPoint(c - a, d - b) || this.containsPoint(e - a, f - b))
            return !0;
        let g,
            h,
            k,
            l;
        c < e ? (g = c, k = e) : (g = e, k = c);
        d < f ? (h = d, l = f) : (h = f, l = d);
        const m = this._ptsArr;
        for (let n = 0, p = m.length; n < p; n += 2) {
            const q = (n + 2) % p;
            if (C3$jscomp$16.segmentsIntersectPreCalc(c, d, e, f, g, k, h, l, m[n] + a, m[n + 1] + b, m[q] + a, m[q + 1] + b))
                return !0
        }
        return !1
    }
    mirror(a)
    {
        const b = this._ptsArr;
        for (let c = 0, d = b.length; c < d; c += 2)
            b[c] = 2 * a - b[c];
        this._isBboxChanged = !0
    }
    flip(a)
    {
        const b = this._ptsArr;
        for (let c = 0, d = b.length; c < d; c += 2) {
            const e = c + 1;
            b[e] = 2 * a -
            b[e]
        }
        this._isBboxChanged = !0
    }
    diag()
    {
        const a = this._ptsArr;
        for (let b = 0, c = a.length; b < c; b += 2) {
            const d = b + 1,
                e = a[b];
            a[b] = a[d];
            a[d] = e
        }
        this._isBboxChanged = !0
    }
    GetMidX()
    {
        const a = this._ptsArr;
        let b = 0;
        for (let c = 0, d = a.length; c < d; c += 2)
            b += a[c];
        return b / this.pointCount()
    }
    GetMidY()
    {
        const a = this._ptsArr;
        let b = 0;
        for (let c = 0, d = a.length; c < d; c += 2)
            b += a[c + 1];
        return b / this.pointCount()
    }
    GetPointsArray()
    {
        return this._ptsArr
    }
    GetPointCount()
    {
        return this.pointCount()
    }
    IsEnabled()
    {
        return this._enabled
    }
}
;
"use strict";
const C3$jscomp$17 = self.C3;
C3$jscomp$17.PairMap = class  extends C3$jscomp$17.DefendedBase{
    constructor(a)
    {
        super();
        this._firstMap = new Map;
        if (a)
            for (const [b, c, d] of a)
                this.Set(b, c, d)
    }
    Release()
    {
        this.Clear();
        this._firstMap = null
    }
    IsEmpty()
    {
        return 0 === this._firstMap.size
    }
    Clear()
    {
        const a = this._firstMap;
        for (const b of a.values())
            b.clear();
        a.clear()
    }
    Set(a, b, c)
    {
        const d = this._firstMap;
        let e = d.get(a);
        e || (e = new Map, d.set(a, e));
        e.set(b, c)
    }
    Get(a, b)
    {
        return (a = this._firstMap.get(a)) ? a.get(b) : a
    }
    Has(a, b)
    {
        return (a = this._firstMap.get(a)) ? a.has(b) : !1
    }
    Delete(a,
    b)
    {
        const c = this._firstMap,
            d = c.get(a);
        if (!d)
            return !1;
        (b = d.delete(b)) && 0 === d.size && c.delete(a);
        return b
    }
    DeleteEither(a)
    {
        const b = this._firstMap,
            c = b.get(a);
        c && (c.clear(), b.delete(a));
        for (const [d, e] of b.entries())
            e.delete(a) && 0 === e.size && b.delete(d)
    }
    GetSize()
    {
        let a = 0;
        for (const b of this._firstMap.values())
            a += b.size;
        return a
    }
    *values()
    {
        for (const a of this._firstMap.values())
            yield *a.values()
    }
    *keyPairs()
    {
        for (const [a, b] of this._firstMap.entries())
            for (const c of b.keys())
                yield [a, c]
    }
    *entries()
    {
        for (const [a,
        b] of this._firstMap.entries())
            for (const [c, d] of b.entries())
                yield [a, c, d]
    }
}
;
"use strict";
const C3$jscomp$18 = self.C3;
C3$jscomp$18.ArraySet = class  extends C3$jscomp$18.DefendedBase{
    constructor()
    {
        super();
        this._set = new Set;
        this._arr = [];
        this._needToRebuildArray = !1
    }
    Release()
    {
        this.Clear()
    }
    Clear()
    {
        this._set.clear();
        C3$jscomp$18.clearArray(this._arr);
        this._needToRebuildArray = !1
    }
    Add(a)
    {
        this._set.has(a) || (this._set.add(a), this._needToRebuildArray || this._arr.push(a))
    }
    Has(a)
    {
        return this._set.has(a)
    }
    Delete(a)
    {
        this._set.delete(a) && (this._needToRebuildArray = !0)
    }
    GetSize()
    {
        return this._set.size
    }
    IsEmpty()
    {
        return 0 === this._set.size
    }
    GetArray()
    {
        this._needToRebuildArray &&
        (this._RebuildArray(), this._needToRebuildArray = !1);
        return this._arr
    }
    _RebuildArray()
    {
        const a = this._arr;
        C3$jscomp$18.clearArray(a);
        for (const b of this._set)
            a.push(b)
    }
}
;
"use strict";
const C3$jscomp$19 = self.C3,
    EASE_MAP = new Map,
    PREDEFINED_EASE_MAP = new Map,
    CUSTOM_EASE_EDITOR_MAP = new Map,
    CUSTOM_EASE_DATA_EDITOR_MAP = new Map,
    CUSTOM_EASE_RUNTIME_MAP = new Map,
    CUSTOM_EASE_DATA_RUNTIME_MAP = new Map,
    PRIVATE_EASE_MAP = new Map,
    BUILT_IN_TRANSITION_MAP = new Map,
    ALIAS_MAP = new Map;
ALIAS_MAP.set("linear", "noease");
ALIAS_MAP.set("default", "noease");
const EASE_TRANSLATION_KEYS = "default noease easeinquad easeoutquad easeinoutquad easeincubic easeoutcubic easeinoutcubic easeinquart easeoutquart easeinoutquart easeinquint easeoutquint easeinoutquint easeinsine easeoutsine easeinoutsine easeinexpo easeoutexpo easeinoutexpo easeincirc easeoutcirc easeinoutcirc easeinelastic easeoutelastic easeinoutelastic easeinback easeoutback easeinoutback easeinbounce easeoutbounce easeinoutbounce".split(" "),
    SHORT_EASE_TRANSLATION_KEYS = "default noease quad cubic quart quint sine expo circ elastic back bounce".split(" "),
    EASE_API2INTERNAL_NAMES = new Map([["linear", "noease"], ["in-sine", "easeinsine"], ["out-sine", "easeoutsine"], ["in-out-sine", "easeinoutsine"], ["in-elastic", "easeinelastic"], ["out-elastic", "easeoutelastic"], ["in-out-elastic", "easeinoutelastic"], ["in-back", "easeinback"], ["out-back", "easeoutback"], ["in-out-back", "easeinoutback"], ["in-bounce", "easeinbounce"], ["out-bounce", "easeoutbounce"], ["in-out-bounce", "easeinoutbounce"], ["in-cubic", "easeincubic"], ["out-cubic", "easeoutcubic"], ["in-out-cubic", "easeinoutcubic"],
    ["in-quadratic", "easeinquad"], ["out-quadratic", "easeoutquad"], ["in-out-quadratic", "easeinoutquad"], ["in-quartic", "easeinquart"], ["out-quartic", "easeoutquart"], ["in-out-quartic", "easeinoutquart"], ["in-quintic", "easeinquint"], ["out-quintic", "easeoutquint"], ["in-out-quintic", "easeinoutquint"], ["in-circular", "easeincirc"], ["out-circular", "easeoutcirc"], ["in-out-circular", "easeinoutcirc"], ["in-exponential", "easeinexpo"], ["out-exponential", "easeoutexpo"], ["in-out-exponential", "easeinoutexpo"]]);
self.Ease = class a {
    constructor() {}
    static InheritEase()
    {
        return "default"
    }
    static DefaultEase()
    {
        return "noease"
    }
    static ToInternal(b)
    {
        return EASE_API2INTERNAL_NAMES.get(b)
    }
    static GetEditorEaseNames(b, ...c)
    {
        this._CreateEaseMap();
        if (b) {
            CUSTOM_EASE_EDITOR_MAP.has(b) || CUSTOM_EASE_EDITOR_MAP.set(b, new Map);
            var d = CUSTOM_EASE_EDITOR_MAP.get(b);
            d = [...d.keys()].filter(e => a.GetEditorEaseData(e, b) ? a.GetEditorEaseData(e, b).transition.IsForAnyPurpose() : !0)
        } else
            d = CUSTOM_EASE_RUNTIME_MAP,
            d = [...d.keys()];
        d = d.sort();
        return [...PREDEFINED_EASE_MAP.keys()].concat(d).filter(e =>
        !c.includes(e))
    }
    static GetRuntimeEaseNames()
    {
        this._CreateEaseMap();
        const b = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
        b.sort();
        return [...PREDEFINED_EASE_MAP.keys()].concat(b)
    }
    static GetCustomRuntimeEaseNames()
    {
        this._CreateEaseMap();
        const b = [...CUSTOM_EASE_RUNTIME_MAP.keys()];
        b.sort();
        return b
    }
    static IsPredefinedTranslatedName(b)
    {
        for (const c of EASE_TRANSLATION_KEYS)
            if (self.lang(`ui.bars.timeline.eases.${c}`) === b)
                return !0;
        for (const c of SHORT_EASE_TRANSLATION_KEYS)
            if (self.lang(`ui.bars.timeline.short-eases.${c}`) ===
            b)
                return !0
    }
    static IsNamePredefined(b)
    {
        this._CreateEaseMap();
        return [...PREDEFINED_EASE_MAP.keys()].includes(b)
    }
    static _GetEase(b)
    {
        const c = ALIAS_MAP.get(b);
        if (c)
            return EASE_MAP.get(c);
        if (a.IsNamePredefined(b))
            return EASE_MAP.get(b);
        if (PRIVATE_EASE_MAP.has(b))
            return PRIVATE_EASE_MAP.get(b)
    }
    static GetBuiltInTransition(b)
    {
        this._CreateEaseMap();
        return BUILT_IN_TRANSITION_MAP.get(b)
    }
    static GetEditorEase(b, c)
    {
        this._CreateEaseMap();
        const d = a._GetEase(b);
        if (d)
            return d;
        if (!c)
            throw Error("missing ease function");
        return CUSTOM_EASE_EDITOR_MAP.get(c).get(b)
    }
    static GetEditorEaseData(b, c)
    {
        this._CreateEaseMap();
        if (c = CUSTOM_EASE_DATA_EDITOR_MAP.get(c))
            return c.get(b)
    }
    static HasEditorEase(b, c)
    {
        this._CreateEaseMap();
        return a._GetEase(b) ? !0 : !!CUSTOM_EASE_EDITOR_MAP.get(c).get(b)
    }
    static GetRuntimeEase(b)
    {
        this._CreateEaseMap();
        const c = a._GetEase(b);
        return c ? c : CUSTOM_EASE_RUNTIME_MAP.get(b)
    }
    static GetRuntimeEaseData(b)
    {
        this._CreateEaseMap();
        return CUSTOM_EASE_DATA_RUNTIME_MAP.get(b)
    }
    static GetEaseFromIndex(b)
    {
        this._CreateEaseMap();
        return this.GetRuntimeEaseNames()[b]
    }
    static GetIndexForEase(b, c)
    {
        this._CreateEaseMap();
        return this.GetEditorEaseNames(c).indexOf(b)
    }
    static GetIndexForEaseAtRuntime(b)
    {
        return this.GetIndexForEase(b)
    }
    static _CreateEaseMap()
    {
        0 === EASE_MAP.size && (this._AddPredifinedEase("default", () => {}), this._AddPredifinedEase("noease", [{
            x: 0,
            y: 0,
            sax: .336,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.336,
            eay: 0,
            se: !1,
            ee: !0
        }], !0), this._AddPredifinedEase("easeinsine", [{
            x: 0,
            y: 0,
            sax: .485,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.038,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutsine", [{
            x: 0,
            y: 0,
            sax: .038,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.485,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutsine", [{
            x: 0,
            y: 0,
            sax: .336,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.336,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinelastic", [{
            x: 0,
            y: 0,
            sax: .018,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .116,
            y: .002,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .266,
            y: -.005,
            sax: .024,
            say: 0,
            eax: -.021,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .416,
            y: .016,
            sax: .024,
            say: 0,
            eax: -.026,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .566,
            y: -.045,
            sax: .061,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .716,
            y: .132,
            sax: .072,
            say: -.004,
            eax: -.045,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .866,
            y: -.373,
            sax: .06,
            say: 0,
            eax: -.049,
            eay: -.002,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.038,
            eay: -.263,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutelastic", [{
            x: 0,
            y: 0,
            sax: .038,
            say: .263,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .136,
            y: 1.373,
            sax: .049,
            say: .002,
            eax: -.06,
            eay: 0,
            se: !0,
            ee: !0
        },
        {
            x: .286,
            y: .868,
            sax: .045,
            say: 0,
            eax: -.072,
            eay: .004,
            se: !0,
            ee: !0
        }, {
            x: .436,
            y: 1.045,
            sax: .025,
            say: 0,
            eax: -.061,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .586,
            y: .984,
            sax: .026,
            say: 0,
            eax: -.024,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .736,
            y: 1.005,
            sax: .021,
            say: 0,
            eax: -.024,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .886,
            y: .998,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.018,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutelastic", [{
            x: 0,
            y: 0,
            sax: .025,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .067,
            y: .001,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        },
        {
            x: .18,
            y: -.005,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .292,
            y: .025,
            sax: .053,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .405,
            y: -.118,
            sax: .069,
            say: 0,
            eax: -.027,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .597,
            y: 1.118,
            sax: .027,
            say: 0,
            eax: -.069,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .71,
            y: .975,
            sax: .025,
            say: 0,
            eax: -.053,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .822,
            y: 1.005,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .935,
            y: .999,
            sax: .025,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinback",
        [{
            x: 0,
            y: 0,
            sax: .35,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.34,
            eay: -1.579,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutback", [{
            x: 0,
            y: 0,
            sax: .34,
            say: 1.579,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.35,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutback", [{
            x: 0,
            y: 0,
            sax: .035,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .242,
            y: -.1,
            sax: .258,
            say: 0,
            eax: -.025,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: .76,
            y: 1.1,
            sax: .025,
            say: 0,
            eax: -.26,
            eay: 0,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.035,
            eay: 0,
            se: !1,
            ee: !0
        }]),
        this._AddPredifinedEase("easeinbounce", [{
            x: 0,
            y: 0,
            sax: .033,
            say: .025,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .092,
            y: 0,
            sax: .026,
            say: .078,
            eax: -.033,
            eay: .025,
            se: !0,
            ee: !0
        }, {
            x: .274,
            y: 0,
            sax: .097,
            say: .319,
            eax: -.026,
            eay: .078,
            se: !0,
            ee: !0
        }, {
            x: .637,
            y: 0,
            sax: .105,
            say: .625,
            eax: -.097,
            eay: .319,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.125,
            eay: -.004,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutbounce", [{
            x: 0,
            y: 0,
            sax: .125,
            say: .004,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .365,
            y: 1,
            sax: .097,
            say: -.319,
            eax: -.105,
            eay: -.625,
            se: !0,
            ee: !0
        }, {
            x: .728,
            y: 1,
            sax: .026,
            say: -.078,
            eax: -.097,
            eay: -.319,
            se: !0,
            ee: !0
        }, {
            x: .91,
            y: 1,
            sax: .033,
            say: -.025,
            eax: -.026,
            eay: -.078,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.033,
            eay: -.025,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutbounce", [{
            x: 0,
            y: 0,
            sax: .01,
            say: .006,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .046,
            y: 0,
            sax: .021,
            say: .038,
            eax: -.01,
            eay: .006,
            se: !0,
            ee: !0
        }, {
            x: .137,
            y: 0,
            sax: .059,
            say: .158,
            eax: -.021,
            eay: .038,
            se: !0,
            ee: !0
        }, {
            x: .319,
            y: 0,
            sax: .117,
            say: .744,
            eax: -.059,
            eay: .158,
            se: !0,
            ee: !0
        }, {
            x: .683,
            y: 1,
            sax: .059,
            say: -.158,
            eax: -.117,
            eay: -.744,
            se: !0,
            ee: !0
        }, {
            x: .865,
            y: 1,
            sax: .021,
            say: -.038,
            eax: -.059,
            eay: -.158,
            se: !0,
            ee: !0
        }, {
            x: .956,
            y: 1,
            sax: .01,
            say: -.006,
            eax: -.021,
            eay: -.038,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.01,
            eay: -.006,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeincubic", [{
            x: 0,
            y: 0,
            sax: .75,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.138,
            eay: -.321,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutcubic", [{
            x: 0,
            y: 0,
            sax: .138,
            say: .321,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.75,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutcubic",
        [{
            x: 0,
            y: 0,
            sax: .285,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .081,
            say: .272,
            eax: -.081,
            eay: -.272,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.285,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinquad", [{
            x: 0,
            y: 0,
            sax: .4,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.178,
            eay: -.392,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutquad", [{
            x: 0,
            y: 0,
            sax: .178,
            say: .392,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.4,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutquad", [{
            x: 0,
            y: 0,
            sax: .25,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .03,
            say: .065,
            eax: -.03,
            eay: -.065,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinquart", [{
            x: 0,
            y: 0,
            sax: .25,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.5,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutquart", [{
            x: 0,
            y: 0,
            sax: .5,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: -1,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutquart", [{
            x: 0,
            y: 0,
            sax: .765,
            say: .03,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.765,
            eay: -.03,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinquint", [{
            x: 0,
            y: 0,
            sax: .6,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.2,
            eay: -1,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutquint", [{
            x: 0,
            y: 0,
            sax: .2,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.6,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutquint", [{
            eax: 0,
            eay: 0,
            ee: !1,
            sax: .84,
            say: 0,
            se: !0,
            x: 0,
            y: 0
        }, {
            eax: -.84,
            eay: 0,
            ee: !0,
            sax: 0,
            say: 0,
            se: !1,
            x: 1,
            y: 1
        }]), this._AddPredifinedEase("easeincirc",
        [{
            x: 0,
            y: 0,
            sax: .25,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.024,
            eay: -.808,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutcirc", [{
            x: 0,
            y: 0,
            sax: .024,
            say: .808,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.25,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutcirc", [{
            x: 0,
            y: 0,
            sax: .125,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: .5,
            y: .5,
            sax: .02,
            say: .428,
            eax: -.02,
            eay: -.428,
            se: !0,
            ee: !0
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.125,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinexpo", [{
            x: 0,
            y: 0,
            sax: .66,
            say: 0,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.14,
            eay: -1,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeoutexpo", [{
            x: 0,
            y: 0,
            sax: .14,
            say: 1,
            eax: 0,
            eay: 0,
            se: !0,
            ee: !1
        }, {
            x: 1,
            y: 1,
            sax: 0,
            say: 0,
            eax: -.66,
            eay: 0,
            se: !1,
            ee: !0
        }]), this._AddPredifinedEase("easeinoutexpo", [{
            eax: 0,
            eay: 0,
            ee: !1,
            sax: .345,
            say: 0,
            se: !0,
            x: 0,
            y: 0
        }, {
            eax: -.06,
            eay: -.5,
            ee: !0,
            sax: .06,
            say: .5,
            se: !0,
            x: .5,
            y: .5
        }, {
            eax: -.335,
            eay: 0,
            ee: !0,
            sax: 0,
            say: 0,
            se: !1,
            x: 1,
            y: 1
        }]), this._AddPrivateCustomEase("cubicbezier", this.EaseCubicBezier), this._AddPrivateCustomEase("spline",
        this.EaseSpline))
    }
    static _AddPredifinedEase(b, c, d=!1)
    {
        if ("function" === typeof c)
            a._AddEase(b, c, "predefined");
        else if (C3$jscomp$19.IsArray(c))
            if (self.BuiltInTransition) {
                const e = C3$jscomp$19.New(self.BuiltInTransition, b, d);
                e.SetFromJson(c);
                a._AddEase(b, (f, g, h, k) => e.Interpolate(f, g, h, k), "predefined");
                BUILT_IN_TRANSITION_MAP.set(b, e)
            } else {
                const e = C3$jscomp$19.New(C3$jscomp$19.Transition, [b, c.map(f => [f.x, f.y, f.sax, f.say, f.eax, f.eay, f.se, f.ee])], !1);
                e.MakeLinear(d);
                a._AddEase(b, (f, g, h, k) => e.Interpolate(f,
                g, h, k), "predefined")
            }
        else
            throw Error("unexpected arguments");
    }
    static _AddPrivateCustomEase(b, c)
    {
        a._AddEase(b, c, "private")
    }
    static AddCustomEase(b, c, d, e)
    {
        this._CreateEaseMap();
        a._AddEase(b, c, "custom", d, e)
    }
    static RemoveCustomEase(b, c)
    {
        if (!this.IsNamePredefined(b) && ![...PRIVATE_EASE_MAP.keys()].includes(b)) {
            var d = CUSTOM_EASE_EDITOR_MAP.get(c);
            d && d.delete(b);
            (c = CUSTOM_EASE_DATA_EDITOR_MAP.get(c)) && c.delete(b)
        }
    }
    static _AddEase(b, c, d, e, f)
    {
        switch (d) {
        case "predefined":
            EASE_MAP.set(b, c);
            PREDEFINED_EASE_MAP.set(b,
            c);
            break;
        case "custom":
            e ? (CUSTOM_EASE_EDITOR_MAP.has(e) || CUSTOM_EASE_EDITOR_MAP.set(e, new Map), CUSTOM_EASE_DATA_EDITOR_MAP.has(e) || CUSTOM_EASE_DATA_EDITOR_MAP.set(e, new Map), CUSTOM_EASE_EDITOR_MAP.get(e).set(b, c), CUSTOM_EASE_DATA_EDITOR_MAP.get(e).set(b, f)) : (CUSTOM_EASE_RUNTIME_MAP.set(b, c), CUSTOM_EASE_DATA_RUNTIME_MAP.set(b, f));
            break;
        case "private":
            EASE_MAP.set(b, c);
            PRIVATE_EASE_MAP.set(b, c);
            break;
        default:
            throw Error("unexpected ease mode");
        }
    }
    static NoEase(b, c, d, e)
    {
        return 0 === e ? c : d * b / e + c
    }
    static EaseCubicBezier(b,
    c, d, e, f)
    {
        return c + 3 * b * (d - c) + 3 * b ** 2 * (c + e - 2 * d) + b ** 3 * (f - c + 3 * d - 3 * e)
    }
    static EaseSpline(b, c, d, e, f, g, h, k, l, m)
    {
        if (e === f && g === h)
            return b;
        b = get_t_for_x(b, c, e, g, k, m);
        c = a$jscomp$282(d, f, h, l);
        e = b$jscomp$151(d, f, h, l);
        d = c$jscomp$42(d, f, h, l);
        return calc_bezier(b, c, e, d)
    }
    static GetBezierSamples(b, c, d, e)
    {
        const f = [],
            g = a$jscomp$282(b, c, d, e),
            h = b$jscomp$151(b, c, d, e);
        b = c$jscomp$42(b, c, d, e);
        for (c = 0; 11 > c; ++c)
            d = calc_bezier(c * SAMPLE_STEP, g, h, b),
            f.push(d);
        return f
    }
}
;
const SAMPLE_STEP = .1,
    a$jscomp$282 = (a, b, c, d) => d - 3 * c + 3 * b - a,
    b$jscomp$151 = (a, b, c, d) => 3 * c - 6 * b + 3 * a,
    c$jscomp$42 = (a, b, c, d) => 3 * (b - a),
    calc_bezier = (a, b, c, d) => ((b * a + c) * a + d) * a,
    get_slope = (a, b, c, d) => 3 * b * a * a + 2 * c * a + d,
    get_t_for_x = (a, b, c, d, e, f) => {
        if (1 == a)
            return 1;
        for (var g = 0, h = 1, k = f[h]; 10 != h && k <= a;)
            h++,
            k = f[h],
            g += SAMPLE_STEP;
        h--;
        k = f[h];
        f = g + (a - k) / (f[h + 1] - k) * SAMPLE_STEP;
        h = a$jscomp$282(b, c, d, e);
        k = b$jscomp$151(b, c, d, e);
        b = c$jscomp$42(b, c, d, e);
        c = get_slope(f, h, k, b);
        if (0 !== c)
            if (.01 <= c)
                for (g = 0; 4 > g; ++g)
                    c = calc_bezier(f, h, k, b) -
                    a,
                    d = get_slope(f, h, k, b),
                    f -= c / d;
            else {
                c = g;
                g += SAMPLE_STEP;
                d = 0;
                let l;
                do f = c + (g - c) / 2,
                e = calc_bezier(f, h, k, b) - a,
                0 < e ? g = f : c = f,
                e = 1E-7 < Math.abs(e),
                l = 10 > ++d;
                while (e && l)
            }
        return f
    };
"use strict";
const C3$jscomp$20 = self.C3;
function RequireStringOrNumber(a) {
    C3$jscomp$20.IsString(a)
}
C3$jscomp$20.ProbabilityTable = class {
    constructor(a)
    {
        this._items = [];
        this._name = a || "";
        this._totalWeight = 0
    }
    Release()
    {
        this.Clear();
        this._items = null
    }
    GetName()
    {
        return this._name
    }
    Clear()
    {
        C3$jscomp$20.clear2DArray(this._items);
        this._totalWeight = 0
    }
    GetTotalWeight()
    {
        return this._totalWeight
    }
    Sample(a=Math.random() * this.GetTotalWeight())
    {
        let b = 0;
        for (const [c, d] of this._items)
            if (b += c, a < b)
                return d;
        return 0
    }
    AddItem(a, b)
    {
        RequireStringOrNumber(b);
        this._totalWeight += a;
        this._items.push([a, b])
    }
    RemoveItem(a, b)
    {
        RequireStringOrNumber(b);
        const c = 0 === a;
        for (let d = 0; d < this._items.length; d++) {
            const e = this._items[d],
                f = e[1] === b;
            if ((c || e[0] === a) && f) {
                this._items.splice(d, 1);
                this._totalWeight -= e[0];
                break
            }
        }
    }
    asJSON()
    {
        return JSON.stringify(this._items)
    }
    static fromJSON(a, b)
    {
        b = new C3$jscomp$20.ProbabilityTable(b);
        a = JSON.parse(a);
        for (const c of a)
            b.AddItem(c[0], c[1]);
        return b
    }
}
;
"use strict";
let nextId = 0;
self.C3.ScreenReaderText = class {
    constructor(a, b)
    {
        this._runtime = a;
        this._text = b;
        this._id = nextId++;
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "create",
            id: this._id,
            text: this._text
        })
    }
    Release()
    {
        this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "release",
            id: this._id
        });
        this._runtime = null;
        this._text = "";
        this._id = -1
    }
    SetText(a)
    {
        this._text !== a && (this._text = a, this._runtime.PostComponentMessageToDOM("runtime", "screen-reader-text", {
            type: "update",
            id: this._id,
            text: this._text
        }))
    }
}
;
"use strict";
self.C3.Event = class {
    constructor(a, b)
    {
        this.type = a;
        this.cancelable = !!b;
        this.isAsync = this.propagationStopped = this.defaultPrevented = !1
    }
    preventDefault()
    {
        if (!this.cancelable)
            throw Error(`event '${this.type}' is not cancelable`);
        this.defaultPrevented = !0
    }
    stopPropagation()
    {
        if (!this.cancelable)
            throw Error(`event '${this.type}' cannot be stopped`);
        if (this.isAsync)
            throw Error(`cannot stop async event '${this.type}' propagation`);
        this.propagationStopped = !0
    }
}
;
"use strict";
const C3$jscomp$23 = self.C3;
C3$jscomp$23.Event.Handler = class  extends C3$jscomp$23.DefendedBase{
    constructor(a)
    {
        super();
        this._type = a;
        this._captureListeners = [];
        this._captureListenersSet = new Set;
        this._listeners = [];
        this._listenersSet = new Set;
        this._fireDepth = 0;
        this._queueModifyListeners = []
    }
    Release()
    {
        0 < this._fireDepth || (C3$jscomp$23.clearArray(this._captureListeners), this._captureListenersSet.clear(), C3$jscomp$23.clearArray(this._listeners), this._listenersSet.clear(), C3$jscomp$23.clearArray(this._queueModifyListeners), C3$jscomp$23.Release(this))
    }
    _AddListener(a,
    b)
    {
        this._IsFiring() ? this._queueModifyListeners.push({
            op: "add",
            func: a,
            capture: b
        }) : b ? this._captureListenersSet.has(a) || (this._captureListeners.push(a), this._captureListenersSet.add(a)) : this._listenersSet.has(a) || (this._listeners.push(a), this._listenersSet.add(a))
    }
    _RemoveListener(a, b)
    {
        this._IsFiring() ? this._queueModifyListeners.push({
            op: "remove",
            func: a,
            capture: b
        }) : b ? this._captureListenersSet.has(a) && (this._captureListenersSet.delete(a), C3$jscomp$23.arrayFindRemove(this._captureListeners, a)) : this._listenersSet.has(a) &&
        (this._listenersSet.delete(a), C3$jscomp$23.arrayFindRemove(this._listeners, a))
    }
    _IsEmpty()
    {
        return !this._captureListeners.length && !this._listeners.length
    }
    _IsFiring()
    {
        return 0 < this._fireDepth
    }
    _ProcessQueuedListeners()
    {
        const a = new Set,
            b = new Set;
        for (const c of this._queueModifyListeners)
            if ("add" === c.op)
                this._AddListener(c.func, c.capture),
                c.capture ? b.delete(c.func) : a.delete(c.func);
            else if ("remove" === c.op)
                c.capture ? (this._captureListenersSet.delete(c.func), b.add(c.func)) : (this._listenersSet.delete(c.func),
                a.add(c.func));
            else
                throw Error("invalid op");
        C3$jscomp$23.arrayRemoveAllInSet(this._listeners, a);
        C3$jscomp$23.arrayRemoveAllInSet(this._captureListeners, b);
        C3$jscomp$23.clearArray(this._queueModifyListeners)
    }
    _FireCancellable(a)
    {
        this._IncreaseFireDepth();
        let b = !1;
        for (let c = 0, d = this._captureListeners.length; c < d; ++c)
            if (this._captureListeners[c](a), a.propagationStopped) {
                b = !0;
                break
            }
        if (!b)
            for (let c = 0, d = this._listeners.length; c < d && (this._listeners[c](a), !a.propagationStopped); ++c)
                ;
        this._DecreaseFireDepth();
        return !a.defaultPrevented
    }
    _FireNonCancellable(a)
    {
        this._IncreaseFireDepth();
        for (let b = 0, c = this._captureListeners.length; b < c; ++b)
            this._captureListeners[b](a);
        for (let b = 0, c = this._listeners.length; b < c; ++b)
            this._listeners[b](a);
        this._DecreaseFireDepth();
        return !0
    }
    _IncreaseFireDepth()
    {
        this._fireDepth++
    }
    _DecreaseFireDepth()
    {
        this._fireDepth--;
        0 === this._fireDepth && 0 < this._queueModifyListeners.length && this._ProcessQueuedListeners()
    }
    SetDelayRemoveEventsEnabled(a)
    {
        a ? this._IncreaseFireDepth() : this._DecreaseFireDepth()
    }
    _FireAsync(a)
    {
        let b =
        [];
        for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
            let e = this._captureListeners[c];
            b.push(C3$jscomp$23.Asyncify(() => e(a)))
        }
        for (let c = 0, d = this._listeners.length; c < d; ++c) {
            let e = this._listeners[c];
            b.push(C3$jscomp$23.Asyncify(() => e(a)))
        }
        return Promise.all(b).then(() => !a.defaultPrevented)
    }
    _FireAndWait_AsyncOptional(a)
    {
        const b = [];
        this._IncreaseFireDepth();
        for (let d = 0, e = this._captureListeners.length; d < e; ++d) {
            var c = this._captureListeners[d](a);
            c instanceof Promise && b.push(c)
        }
        for (let d = 0, e = this._listeners.length; d <
        e; ++d)
            c = this._listeners[d](a),
            c instanceof Promise && b.push(c);
        this._DecreaseFireDepth();
        return b.length ? Promise.all(b).then(() => !a.defaultPrevented) : !a.defaultPrevented
    }
    async _FireAndWaitAsync(a)
    {
        return await this._FireAndWait_AsyncOptional(a)
    }
    async _FireAndWaitAsyncSequential(a)
    {
        this._IncreaseFireDepth();
        for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
            var b = this._captureListeners[c](a);
            b instanceof Promise && await b
        }
        for (let c = 0, d = this._listeners.length; c < d; ++c)
            b = this._listeners[c](a),
            b instanceof
            Promise && await b;
        this._DecreaseFireDepth();
        return !a.defaultPrevented
    }
    *_FireAsGenerator(a)
    {
        this._IncreaseFireDepth();
        for (let c = 0, d = this._captureListeners.length; c < d; ++c) {
            var b = this._captureListeners[c](a);
            C3$jscomp$23.IsIterator(b) && (yield *b)
        }
        for (let c = 0, d = this._listeners.length; c < d; ++c)
            b = this._listeners[c](a),
            C3$jscomp$23.IsIterator(b) && (yield *b);
        this._DecreaseFireDepth()
    }
}
;
"use strict";
const C3$jscomp$24 = self.C3;
C3$jscomp$24.Event.Dispatcher = class  extends C3$jscomp$24.DefendedBase{
    constructor()
    {
        super();
        this._eventHandlers = new Map;
        this._dispatcherWasReleased = !1
    }
    Release()
    {
        if (this._dispatcherWasReleased)
            throw Error("already released");
        this.ClearEvents();
        this._dispatcherWasReleased = !0;
        C3$jscomp$24.Release(this)
    }
    WasReleased()
    {
        return this._dispatcherWasReleased
    }
    ClearEvents()
    {
        if (this._eventHandlers) {
            for (let a of this._eventHandlers.values())
                a.Release();
            this._eventHandlers.clear()
        }
    }
    _GetHandlerByType(a, b)
    {
        let c = this._eventHandlers.get(a);
        return c ? c : b ? (c = C3$jscomp$24.New(C3$jscomp$24.Event.Handler, a), this._eventHandlers.set(a, c), c) : null
    }
    HasAnyHandlerFor(a)
    {
        return this._eventHandlers.has(a)
    }
    addEventListener(a, b, c)
    {
        this._GetHandlerByType(a, !0)._AddListener(b, !!c)
    }
    removeEventListener(a, b, c)
    {
        let d = this._GetHandlerByType(a, !1);
        d && (d._RemoveListener(b, !!c), d._IsEmpty() && this._eventHandlers.delete(a))
    }
    dispatchEvent(a)
    {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? a.cancelable ? b._FireCancellable(a) : b._FireNonCancellable(a) : !0
    }
    dispatchEventAsync(a)
    {
        const b =
        this._GetHandlerByType(a.type, !1);
        if (!b)
            return Promise.resolve(!0);
        a.isAsync = !0;
        return b._FireAsync(a)
    }
    async dispatchEventAndClearAsync(a)
    {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return !0;
        this._eventHandlers.delete(a.type);
        a.isAsync = !0;
        a = await b._FireAsync(a);
        b.Release();
        return a
    }
    async dispatchEventAndWaitAsync(a)
    {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? await b._FireAndWaitAsync(a) : !0
    }
    dispatchEventAndWait_AsyncOptional(a)
    {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? b._FireAndWait_AsyncOptional(a) :
        !0
    }
    async dispatchEventAndWaitAsyncSequential(a)
    {
        const b = this._GetHandlerByType(a.type, !1);
        return b ? await b._FireAndWaitAsyncSequential(a) : !0
    }
    dispatchGeneratorEvent(a)
    {
        const b = this._GetHandlerByType(a.type, !1);
        if (!b)
            return null;
        if (a.cancelable)
            throw Error("not supported");
        return b._FireAsGenerator(a)
    }
    SetDelayRemoveEventsEnabled(a)
    {
        for (const b of this._eventHandlers.values())
            b.SetDelayRemoveEventsEnabled(a)
    }
}
;
"use strict";
const C3$jscomp$25 = self.C3,
    SUPPORTS_RIC = "undefined" !== typeof requestIdleCallback;
let workQueue = [],
    callbackId = -1,
    highThroughputMode = 0;
function SetNewCallback(a) {
    callbackId = SUPPORTS_RIC && 0 === highThroughputMode ? requestIdleCallback(DoAsyncifiedWork, {
        timeout: 35
    }) : setTimeout(DoAsyncifiedWork, 0 < highThroughputMode ? 1 : a)
}
function DoAsyncifiedWork(a) {
    callbackId = -1;
    if (workQueue.length) {
        var b = performance.now(),
            c = 0;
        do {
            DoNextAsyncifiedJob(workQueue.shift());
            var d = performance.now();
            ++c;
            var e = (d - b) / c * 1.1
        } while (workQueue.length && (SUPPORTS_RIC && 0 === highThroughputMode && "undefined" !== typeof a ? e < a.timeRemaining() : 12 > d - b + e));
        -1 === callbackId && workQueue.length && SetNewCallback(Math.max(16 - (d - b), 4))
    }
}
function DoNextAsyncifiedJob(a) {
    let b;
    try {
        b = a.func()
    } catch (c) {
        a.reject(c);
        return
    }
    a.resolve(b)
}
let asyncifyDisabled = C3$jscomp$25.QueryString.Has("disable-asyncify");
asyncifyDisabled && console.warn("[Asyncify] Asyncify has been disabled due to disable-asyncify in the query string. Some work will now be done synchronously.");
C3$jscomp$25.Asyncify = function(a) {
    let b = null;
    C3$jscomp$25.isDebug && (b = C3$jscomp$25.GetCallStack());
    return new Promise((c, d) => {
        workQueue.push({
            func: a,
            resolve: c,
            reject: d,
            stack: b
        });
        asyncifyDisabled ? DoNextAsyncifiedJob(workQueue.pop()) : -1 === callbackId && SetNewCallback(16)
    })
};
C3$jscomp$25.Asyncify.SetHighThroughputMode = function(a) {
    if (a)
        ++highThroughputMode;
    else if (--highThroughputMode, 0 > highThroughputMode)
        throw Error("already turned off high throughput mode");
};
"use strict";
const C3$jscomp$26 = self.C3;
let cachedNowTime = -1;
function ClearTimeCache() {
    cachedNowTime = -1
}
C3$jscomp$26.FastGetDateNow = function() {
    -1 === cachedNowTime && (cachedNowTime = Date.now(), self.setTimeout(ClearTimeCache, 16));
    return cachedNowTime
};
let timerId = -1,
    nextDeadline = -1,
    activeIdleTimeouts = new Set;
function CheckActiveIdleTimeouts() {
    nextDeadline = timerId = -1;
    let a = Date.now();
    for (let b of activeIdleTimeouts)
        if (b._CheckTimeout(a)) {
            let c = b._GetDeadline();
            if (-1 === nextDeadline || c < nextDeadline)
                nextDeadline = c
        } else
            activeIdleTimeouts.delete(b);
    -1 !== nextDeadline && (timerId = self.setTimeout(CheckActiveIdleTimeouts, Math.max(nextDeadline - a + 100, 1E3)))
}
C3$jscomp$26.IdleTimeout = class {
    constructor(a, b)
    {
        this._callback = a;
        this._timeout = 1E3 * b;
        this._deadline = 0;
        this._isActive = !1
    }
    Reset()
    {
        let a = C3$jscomp$26.FastGetDateNow();
        this._deadline = a + this._timeout;
        this._isActive || (activeIdleTimeouts.add(this), this._isActive = !0);
        -1 === timerId ? (nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts, this._timeout + 100)) : this._deadline < nextDeadline && nextDeadline > a + 1E3 && (self.clearTimeout(timerId), nextDeadline = this._deadline, timerId = self.setTimeout(CheckActiveIdleTimeouts,
        this._timeout + 100))
    }
    _CheckTimeout(a)
    {
        return a >= this._deadline ? this._callback() ? (this._deadline = a + this._timeout, !0) : this._isActive = !1 : !0
    }
    _GetDeadline()
    {
        return this._deadline
    }
    Cancel()
    {
        this._isActive && (activeIdleTimeouts.delete(this), this._isActive = !1, 0 === activeIdleTimeouts.size && -1 !== timerId && (self.clearTimeout(timerId), nextDeadline = timerId = -1))
    }
    Release()
    {
        this.Cancel();
        this._callback = null
    }
}
;
"use strict";
const C3$jscomp$27 = self.C3;
C3$jscomp$27.Disposable = class a {
    constructor(b)
    {
        this._disposed = !1;
        this._disposeAction = b
    }
    Dispose()
    {
        this._disposed || (this._disposed = !0, this._disposeAction && (this._disposeAction(), this._disposeAction = null))
    }
    IsDisposed()
    {
        return this._disposed
    }
    Release()
    {
        this.Dispose()
    }
    static Release(b)
    {
        return new a(() => b.Release())
    }
    static From(b, c, d, e, f)
    {
        if ("undefined" === typeof e || null === e)
            e = !1;
        else if ("boolean" !== typeof e && "object" !== typeof e)
            throw new TypeError("invalid event listener options");
        f && (d = d.bind(f));
        if (c.includes(" ")) {
            c =
            c.split(" ");
            f = new C3$jscomp$27.CompositeDisposable;
            for (let g of c)
                b.addEventListener(g, d, e),
                f.Add(C3$jscomp$27.New(C3$jscomp$27.Disposable, () => b.removeEventListener(g, d, e)));
            return f
        }
        b.addEventListener(c, d, e);
        return C3$jscomp$27.New(C3$jscomp$27.Disposable, () => b.removeEventListener(c, d, e))
    }
}
;
C3$jscomp$27.StubDisposable = class  extends C3$jscomp$27.Disposable{
    SetAction(a)
    {
        this._disposeAction = a
    }
}
;
C3$jscomp$27.CompositeDisposable = class  extends C3$jscomp$27.Disposable{
    constructor(...a)
    {
        super();
        this._disposables = new Set;
        for (let b of a)
            this.Add(b)
    }
    Add(...a)
    {
        if (this._disposed)
            throw Error("already disposed");
        for (let b of a)
            this._disposables.add(b)
    }
    Remove(a)
    {
        if (this._disposed)
            throw Error("already disposed");
        this._disposables.delete(a)
    }
    RemoveAll()
    {
        if (this._disposed)
            throw Error("already disposed");
        if (this._disposables) {
            for (let a of this._disposables)
                a.Dispose();
            this._disposables.clear()
        }
    }
    IsDisposed()
    {
        return this._disposed
    }
    Dispose()
    {
        if (this._disposed)
            throw Error("already disposed");
        this._disposed = !0;
        for (let a of this._disposables)
            a.Dispose();
        this._disposables.clear();
        this._disposables = null
    }
    Release()
    {
        this.Dispose()
    }
}
;
"use strict";
const C3$jscomp$28 = self.C3;
C3$jscomp$28.KahanSum = class  extends C3$jscomp$28.DefendedBase{
    constructor()
    {
        super();
        this._sum = this._t = this._y = this._c = 0
    }
    Add(a)
    {
        this._y = +a - this._c;
        this._t = this._sum + this._y;
        this._c = this._t - this._sum - this._y;
        this._sum = this._t
    }
    Subtract(a)
    {
        this._sum -= +a
    }
    Get()
    {
        return this._sum
    }
    Reset()
    {
        this._sum = this._t = this._y = this._c = 0
    }
    Set(a)
    {
        this._t = this._y = this._c = 0;
        this._sum = +a
    }
    Copy(a)
    {
        this._c = a._c;
        this._y = a._y;
        this._t = a._t;
        this._sum = a._sum
    }
    Release() {}
}
;
"use strict";
const C3$jscomp$29 = self.C3,
    js_cols = {
        RBnode: function(a) {
            this.tree = a;
            this.left = this.right = this.tree.sentinel;
            this.parent = null;
            this.color = !1;
            this.key = null
        },
        RedBlackSet: function(a) {
            this.size = 0;
            this.sentinel = new js_cols.RBnode(this);
            this.sentinel.color = !1;
            this.root = this.sentinel;
            this.root.parent = this.sentinel;
            this.compare = a || this.default_compare
        }
    };
js_cols.RedBlackSet.prototype.default_compare = function(a, b) {
    return a < b ? -1 : b < a ? 1 : 0
};
js_cols.RedBlackSet.prototype.clone = function() {
    var a = new js_cols.RedBlackSet(this.compare);
    a.insertAll(this);
    return a
};
js_cols.RedBlackSet.prototype.clear = function() {
    this.size = 0;
    this.sentinel = new js_cols.RBnode(this);
    this.sentinel.color = !1;
    this.root = this.sentinel;
    this.root.parent = this.sentinel
};
js_cols.RedBlackSet.prototype.leftRotate = function(a) {
    var b = a.right;
    a.right = b.left;
    b.left != this.sentinel && (b.left.parent = a);
    b.parent = a.parent;
    a.parent == this.sentinel ? this.root = b : a == a.parent.left ? a.parent.left = b : a.parent.right = b;
    b.left = a;
    a.parent = b
};
js_cols.RedBlackSet.prototype.rightRotate = function(a) {
    var b = a.left;
    a.left = b.right;
    b.right != this.sentinel && (b.right.parent = a);
    b.parent = a.parent;
    a.parent == this.sentinel ? this.root = b : a == a.parent.right ? a.parent.right = b : a.parent.left = b;
    b.right = a;
    a.parent = b
};
js_cols.RedBlackSet.prototype.insert = function(a) {
    if (this.contains(a))
        this.get_(a).key = a;
    else {
        var b = new js_cols.RBnode(this);
        b.key = a;
        a = this.sentinel;
        for (var c = this.root; c != this.sentinel;)
            a = c,
            c = 0 > this.compare(b.key, c.key) ? c.left : c.right;
        b.parent = a;
        a == this.sentinel ? this.root = b : 0 > this.compare(b.key, a.key) ? a.left = b : a.right = b;
        b.left = this.sentinel;
        b.right = this.sentinel;
        b.color = !0;
        this.insertFixup(b);
        this.size++
    }
};
js_cols.RedBlackSet.prototype.insertFixup = function(a) {
    for (; a != this.sentinel && a != this.root && 1 == a.parent.color;)
        if (a.parent == a.parent.parent.left) {
            var b = a.parent.parent.right;
            1 == b.color ? (a.parent.color = !1, b.color = !1, a.parent.parent.color = !0, a = a.parent.parent) : (a == a.parent.right && (a = a.parent, this.leftRotate(a)), a.parent.color = !1, a.parent.parent.color = !0, a.parent.parent != this.sentinel && this.rightRotate(a.parent.parent))
        } else
            b = a.parent.parent.left,
            1 == b.color ? (a.parent.color = !1, b.color = !1, a.parent.parent.color =
            !0, a = a.parent.parent) : (a == a.parent.left && (a = a.parent, this.rightRotate(a)), a.parent.color = !1, a.parent.parent.color = !0, a.parent.parent != this.sentinel && this.leftRotate(a.parent.parent));
    this.root.color = !1
};
js_cols.RedBlackSet.prototype.delete_ = function(a) {
    var b = a.left == this.sentinel || a.right == this.sentinel ? a : this.successor_(a);
    var c = b.left != this.sentinel ? b.left : b.right;
    c.parent = b.parent;
    b.parent == this.sentinel ? this.root = c : b == b.parent.left ? b.parent.left = c : b.parent.right = c;
    b != a && (a.key = b.key);
    0 == b.color && this.deleteFixup(c);
    this.size--
};
js_cols.RedBlackSet.prototype.deleteFixup = function(a) {
    for (; a != this.root && 0 == a.color;)
        if (a == a.parent.left) {
            var b = a.parent.right;
            1 == b.color && (b.color = !1, a.parent.color = !0, this.leftRotate(a.parent), b = a.parent.right);
            0 == b.left.color && 0 == b.right.color ? (b.color = !0, a = a.parent) : (0 == b.right.color && (b.left.color = !1, b.color = !0, this.rightRotate(b), b = a.parent.right), b.color = a.parent.color, a.parent.color = !1, b.right.color = !1, this.leftRotate(a.parent), a = this.root)
        } else
            b = a.parent.left,
            1 == b.color && (b.color = !1, a.parent.color =
            !0, this.rightRotate(a.parent), b = a.parent.left),
            0 == b.right.color && 0 == b.left.color ? (b.color = !0, a = a.parent) : (0 == b.left.color && (b.right.color = !1, b.color = !0, this.leftRotate(b), b = a.parent.left), b.color = a.parent.color, a.parent.color = !1, b.left.color = !1, this.rightRotate(a.parent), a = this.root);
    a.color = !1
};
js_cols.RedBlackSet.prototype.remove = function(a) {
    a = this.get_(a);
    if (a != this.sentinel) {
        var b = a.key;
        this.delete_(a);
        return b
    }
    return null
};
js_cols.RedBlackSet.prototype.removeSwapped = function(a, b) {
    this.remove(b)
};
js_cols.RedBlackSet.prototype.min = function(a) {
    for (; a.left != this.sentinel;)
        a = a.left;
    return a
};
js_cols.RedBlackSet.prototype.max = function(a) {
    for (; a.right != this.sentinel;)
        a = a.right;
    return a
};
js_cols.RedBlackSet.prototype.successor_ = function(a) {
    if (a.right != this.sentinel)
        return this.min(a.right);
    for (var b = a.parent; b != this.sentinel && a == b.right;)
        a = b,
        b = b.parent;
    return b
};
js_cols.RedBlackSet.prototype.predeccessor_ = function(a) {
    if (a.left != this.sentinel)
        return this.max(a.left);
    for (var b = a.parent; b != this.sentinel && a == b.left;)
        a = b,
        b = b.parent;
    return b
};
js_cols.RedBlackSet.prototype.successor = function(a) {
    if (0 < this.size) {
        a = this.get_(a);
        if (a == this.sentinel)
            return null;
        if (a.right != this.sentinel)
            return this.min(a.right).key;
        for (var b = a.parent; b != this.sentinel && a == b.right;)
            a = b,
            b = b.parent;
        return b != this.sentinel ? b.key : null
    }
    return null
};
js_cols.RedBlackSet.prototype.predecessor = function(a) {
    if (0 < this.size) {
        a = this.get_(a);
        if (a == this.sentinel)
            return null;
        if (a.left != this.sentinel)
            return this.max(a.left).key;
        for (var b = a.parent; b != this.sentinel && a == b.left;)
            a = b,
            b = b.parent;
        return b != this.sentinel ? b.key : null
    }
    return null
};
js_cols.RedBlackSet.prototype.getMin = function() {
    return this.min(this.root).key
};
js_cols.RedBlackSet.prototype.getMax = function() {
    return this.max(this.root).key
};
js_cols.RedBlackSet.prototype.get_ = function(a) {
    for (var b = this.root; b != this.sentinel && 0 != this.compare(b.key, a);)
        b = 0 > this.compare(a, b.key) ? b.left : b.right;
    return b
};
js_cols.RedBlackSet.prototype.contains = function(a) {
    return null != this.get_(a).key
};
js_cols.RedBlackSet.prototype.getValues = function() {
    var a = [];
    this.forEach(function(b) {
        a.push(b)
    });
    return a
};
js_cols.RedBlackSet.prototype.insertAll = function(a) {
    if ("array" == js_cols.typeOf(a))
        for (var b = 0; b < a.length; b++)
            this.insert(a[b]);
    else if ("function" == js_cols.typeOf(a.forEach))
        a.forEach(this.insert, this);
    else if ("function" == js_cols.typeOf(a.getValues))
        for (a = a.getValues(), b = 0; b < a.length; b++)
            this.insert(a[b]);
    else if ("object" == js_cols.typeOf(a))
        for (b in a)
            this.insert(a[b])
};
js_cols.RedBlackSet.prototype.removeAll = function(a) {
    if ("array" == js_cols.typeOf(a))
        for (var b = 0; b < a.length; b++)
            this.remove(a[b]);
    else if ("function" == js_cols.typeOf(a.forEach))
        a.forEach(this.removeSwapped, this);
    else if ("function" == js_cols.typeOf(a.getValues))
        for (a = a.getValues(), b = 0; b < a.length; b++)
            this.remove(a[b]);
    else if ("object" == js_cols.typeOf(a))
        for (b in a)
            this.remove(a[b])
};
js_cols.RedBlackSet.prototype.containsAll = function(a) {
    if ("array" == js_cols.typeOf(a)) {
        for (var b = 0; b < a.length; b++)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
    if ("function" == js_cols.typeOf(a.forEach))
        return a.every(this.contains, this);
    if ("function" == js_cols.typeOf(a.getValues)) {
        a = a.getValues();
        for (b = 0; b < a.length; b++)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
    if ("object" == js_cols.typeOf(a)) {
        for (b in a)
            if (!this.contains(a[b]))
                return !1;
        return !0
    }
};
js_cols.RedBlackSet.prototype.range = function(a, b) {
    var c = [];
    this.traverseFromTo(function(d) {
        c.push(d)
    }, a, b);
    return c
};
js_cols.RedBlackSet.prototype.traverse = function(a, b) {
    if (!this.isEmpty())
        for (var c = this.min(this.root); c != this.sentinel && !a.call(b, c.key, this);)
            c = this.successor_(c)
};
js_cols.RedBlackSet.prototype.traverseFrom = function(a, b, c) {
    if (!this.isEmpty())
        for (b = this.get_(b); b != this.sentinel && !a.call(c, b.key, this);)
            b = this.successor_(b)
};
js_cols.RedBlackSet.prototype.traverseTo = function(a, b, c) {
    if (!this.isEmpty()) {
        var d = this.min(this.root);
        for (b = this.get_(b); d != b && !a.call(c, d.key, this);)
            d = this.successor_(d)
    }
};
js_cols.RedBlackSet.prototype.traverseFromTo = function(a, b, c, d) {
    if (!this.isEmpty())
        for (b = this.get_(b), c = this.get_(c); b != c && !a.call(d, b.key, this);)
            b = this.successor_(b)
};
js_cols.RedBlackSet.prototype.traverseBackwards = function(a, b) {
    if (!this.isEmpty())
        for (var c = this.max(this.root); c != this.sentinel && !a.call(b, c.key, this);)
            c = this.predeccessor_(c)
};
js_cols.RedBlackSet.prototype.forEach = function(a, b) {
    if (!this.isEmpty())
        for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
            a.call(b, c.key, c.key, this)
};
js_cols.RedBlackSet.prototype.some = function(a, b) {
    if (this.isEmpty())
        return !1;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        if (a.call(b, c.key, c.key, this))
            return !0;
    return !1
};
js_cols.RedBlackSet.prototype.every = function(a, b) {
    if (this.isEmpty())
        return !1;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        if (!a.call(b, c.key, c.key, this))
            return !1;
    return !0
};
js_cols.RedBlackSet.prototype.map = function(a, b) {
    var c = [];
    if (this.isEmpty())
        return c;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        c.push(a.call(b, d.key, d.key, this));
    return c
};
js_cols.RedBlackSet.prototype.filter = function(a, b) {
    var c = [];
    if (this.isEmpty())
        return c;
    for (var d = this.min(this.root); d != this.sentinel; d = this.successor_(d))
        a.call(b, d.key, d.key, this) && c.push(d.key);
    return c
};
js_cols.RedBlackSet.prototype.getCount = function() {
    return this.size
};
js_cols.RedBlackSet.prototype.isEmpty = function() {
    return 0 == this.size
};
js_cols.RedBlackSet.prototype.isSubsetOf = function(a) {
    var b = js_cols.getCount(a);
    if (this.getCount() > b)
        return !1;
    b = 0;
    if (this.isEmpty())
        return !0;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        js_cols.contains.call(a, a, c.key) && b++;
    return b == this.getCount()
};
js_cols.RedBlackSet.prototype.intersection = function(a) {
    var b = new js_cols.RedBlackSet(this.compare);
    if (this.isEmpty())
        return b;
    for (var c = this.min(this.root); c != this.sentinel; c = this.successor_(c))
        a.contains.call(a, c.key, c.key, this) && b.insert(c.key);
    return b
};
C3$jscomp$29.RedBlackSet = class  extends C3$jscomp$29.DefendedBase{
    constructor(a)
    {
        super();
        this._rbSet = new js_cols.RedBlackSet(a);
        this._enableQueue = !1;
        this._queueInsert = new Set;
        this._queueRemove = new Set
    }
    Add(a)
    {
        this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.delete(a) : this._queueInsert.add(a) : this._rbSet.insert(a)
    }
    Remove(a)
    {
        this._enableQueue ? this._rbSet.contains(a) ? this._queueRemove.add(a) : this._queueInsert.delete(a) : this._rbSet.remove(a)
    }
    Has(a)
    {
        return this._enableQueue ? this._queueInsert.has(a) ?
        !0 : !this._queueRemove.has(a) && this._rbSet.contains(a) : this._rbSet.contains(a)
    }
    Clear()
    {
        this._rbSet.clear();
        this._queueInsert.clear();
        this._queueRemove.clear()
    }
    toArray()
    {
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        return this._rbSet.getValues()
    }
    GetSize()
    {
        return this._rbSet.getCount() + this._queueInsert.size - this._queueRemove.size
    }
    IsEmpty()
    {
        return 0 === this.GetSize()
    }
    Front()
    {
        if (this.IsEmpty())
            throw Error("empty set");
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        const a = this._rbSet;
        return a.min(a.root).key
    }
    Shift()
    {
        if (this.IsEmpty())
            throw Error("empty set");
        if (this._enableQueue)
            throw Error("cannot be used in queueing mode");
        const a = this.Front();
        this.Remove(a);
        return a
    }
    SetQueueingEnabled(a)
    {
        a = !!a;
        if (this._enableQueue !== a && (this._enableQueue = a, !a)) {
            for (const b of this._queueRemove)
                this._rbSet.remove(b);
            this._queueRemove.clear();
            for (const b of this._queueInsert)
                this._rbSet.insert(b);
            this._queueInsert.clear()
        }
    }
    ForEach(a)
    {
        this._rbSet.forEach(a)
    }
    *values()
    {
        if (!this.IsEmpty()) {
            var a =
            this._rbSet;
            for (let b = a.min(a.root); b != a.sentinel; b = a.successor_(b))
                yield b.key
        }
    }
    [Symbol.iterator]()
    {
        return this.values()
    }
}
;
"use strict";
const C3$jscomp$30 = self.C3;
C3$jscomp$30.PromiseThrottle = class {
    constructor(a=C3$jscomp$30.hardwareConcurrency)
    {
        this._maxParallel = a;
        this._queue = [];
        this._activeCount = 0
    }
    Add(a)
    {
        return new Promise((b, c) => {
            this._queue.push({
                func: a,
                resolve: b,
                reject: c
            });
            this._MaybeStartNext()
        })
    }
    _FindInQueue(a)
    {
        for (let b = 0, c = this._queue.length; b < c; ++b)
            if (this._queue[b].func === a)
                return b;
        return -1
    }
    RemoveAndResolve(a, b)
    {
        a = this._FindInQueue(a);
        if (-1 === a)
            throw Error("cannot find promise to resolve");
        this._queue[a].resolve(b);
        this._queue.splice(a, 1)
    }
    RemoveAndReject(a,
    b)
    {
        a = this._FindInQueue(a);
        if (-1 === a)
            throw Error("cannot find promise to reject");
        this._queue[a].reject(b);
        this._queue.splice(a, 1)
    }
    async _MaybeStartNext()
    {
        if (this._queue.length && !(this._activeCount >= this._maxParallel)) {
            this._activeCount++;
            var a = this._queue.shift();
            try {
                const b = await a.func();
                a.resolve(b)
            } catch (b) {
                a.reject(b)
            }
            this._activeCount--;
            this._MaybeStartNext()
        }
    }
    static async Batch(a, b)
    {
        const c = [];
        let d = !1;
        const e = async g => {
                for (; (g = b.pop()) && !d;)
                    try {
                        c.push(await g())
                    } catch (h) {
                        throw d = !0, h;
                    }
            },
            f =
            [];
        for (; a--;)
            f.push(e());
        await Promise.all(f);
        return c
    }
}
;
"use strict";
const C3$jscomp$31 = self.C3;
C3$jscomp$31.RateLimiter = class {
    constructor(a, b, c)
    {
        this._callback = a;
        this._interval = b;
        this._intervalOnBattery = c || 2 * b;
        this._timerId = -1;
        this._lastCallTime = -Infinity;
        this._timerCallFunc = () => this._OnTimer();
        this._canRunImmediate = this._ignoreReset = !1;
        this._callbackArguments = null
    }
    SetCanRunImmediate(a)
    {
        this._canRunImmediate = !!a
    }
    _GetInterval()
    {
        return "undefined" !== typeof C3$jscomp$31.Battery && C3$jscomp$31.Battery.IsOnBatteryPower() ? this._intervalOnBattery : this._interval
    }
    Call(...a)
    {
        if (-1 === this._timerId) {
            this._callbackArguments =
            a;
            a = C3$jscomp$31.FastGetDateNow();
            var b = a - this._lastCallTime,
                c = this._GetInterval();
            b >= c && this._canRunImmediate ? (this._lastCallTime = a, this._RunCallback()) : this._timerId = self.setTimeout(this._timerCallFunc, Math.max(c - b, 4))
        }
    }
    _RunCallback()
    {
        this._ignoreReset = !0;
        const a = this._callbackArguments;
        this._callbackArguments = null;
        a ? this._callback(...a) : this._callback();
        this._ignoreReset = !1
    }
    Reset()
    {
        this._ignoreReset || (this._CancelTimer(), this._callbackArguments = null, this._lastCallTime = C3$jscomp$31.FastGetDateNow())
    }
    _OnTimer()
    {
        this._timerId =
        -1;
        this._lastCallTime = C3$jscomp$31.FastGetDateNow();
        this._RunCallback()
    }
    _CancelTimer()
    {
        -1 !== this._timerId && (self.clearTimeout(this._timerId), this._timerId = -1)
    }
    Release()
    {
        this._CancelTimer();
        this._timerCallFunc = this._callbackArguments = this._callback = null
    }
}
;
"use strict";
const C3$jscomp$32 = self.C3;
C3$jscomp$32.SVGRasterManager = class {
    constructor()
    {
        this._images = new Map;
        this._allowNpotSurfaces = !1;
        this._redrawCallback = this._releaseResultCallback = this._rasterAtSizeCallback = this._getBaseSizeCallback = null
    }
    SetNpotSurfaceAllowed(a)
    {
        this._allowNpotSurfaces = !!a
    }
    IsNpotSurfaceAllowed()
    {
        return this._allowNpotSurfaces
    }
    SetGetBaseSizeCallback(a)
    {
        this._getBaseSizeCallback = a
    }
    GetBaseSize(a)
    {
        if (!this._getBaseSizeCallback)
            throw Error("no get base size callback set");
        return this._getBaseSizeCallback(a)
    }
    SetRasterAtSizeCallback(a)
    {
        this._rasterAtSizeCallback =
        a
    }
    RasterAtSize(a, b, c, d, e, f)
    {
        if (!this._rasterAtSizeCallback)
            throw Error("no raster at size callback set");
        return this._rasterAtSizeCallback(a, b, c, d, e, f)
    }
    SetReleaseResultCallback(a)
    {
        this._releaseResultCallback = a
    }
    ReleaseResult(a)
    {
        if (!this._releaseResultCallback)
            throw Error("no release result callback set");
        this._releaseResultCallback(a)
    }
    SetRedrawCallback(a)
    {
        this._redrawCallback = a
    }
    Redraw()
    {
        if (!this._redrawCallback)
            throw Error("no redraw callback set");
        this._redrawCallback()
    }
    AddImage(a)
    {
        let b = this._images.get(a);
        b || (b = C3$jscomp$32.New(C3$jscomp$32.SVGRasterImage, this, a), this._images.set(a, b));
        b.IncReference();
        return b
    }
    _RemoveImage(a)
    {
        this._images.delete(a.GetDataSource())
    }
    OnTexturesChanged()
    {
        for (const a of this._images.values())
            a.ReleaseRasterizedResult(),
            a.ForceRasterAgain()
    }
}
;
"use strict";
const C3$jscomp$33 = self.C3;
C3$jscomp$33.SVGRasterImage = class {
    constructor(a, b)
    {
        this._manager = a;
        this._dataSource = b;
        this._baseHeight = this._baseWidth = this._refCount = 0;
        this._getBaseSizePromise = this._manager.GetBaseSize(b).then(c => {
            this._manager && (this._baseWidth = c[0], this._baseHeight = c[1], this._manager.Redraw())
        }).catch(c => {
            console.error("[SVG] Error loading SVG: ", c);
            this._hadError = !0;
            this._manager && this._manager.Redraw()
        });
        this._rasterImageHeight = this._rasterImageWidth = this._rasterSurfaceHeight = this._rasterSurfaceWidth = 0;
        this._isRasterizing =
        !1;
        this._rasterizedResult = null;
        this._hadError = this._forceRaster = !1
    }
    Release()
    {
        if (0 >= this._refCount)
            throw Error("already released");
        this._refCount--;
        0 === this._refCount && this._Release()
    }
    ReleaseRasterizedResult()
    {
        this._rasterizedResult && (this._manager.ReleaseResult(this._rasterizedResult), this._rasterizedResult = null)
    }
    _Release()
    {
        this.ReleaseRasterizedResult();
        this._manager._RemoveImage(this);
        this._manager = null
    }
    GetDataSource()
    {
        return this._dataSource
    }
    IncReference()
    {
        this._refCount++
    }
    HasReferences()
    {
        return 0 <
        this._refCount
    }
    GetRasterizedResult()
    {
        return this._rasterizedResult
    }
    ForceRasterAgain()
    {
        this._forceRaster = !0
    }
    async StartRasterForSize(a, b, c)
    {
        if (0 !== b && 0 !== c && !this._hadError && !this._isRasterizing) {
            var d = C3$jscomp$33.nextHighestPowerOfTwo(Math.ceil(b)),
                e = C3$jscomp$33.nextHighestPowerOfTwo(Math.ceil(c)),
                f = Math.max(d, e);
            4096 < f && (f = 4096 / f, b *= f, c *= f, d = Math.min(Math.ceil(d * f), 4096), e = Math.min(Math.ceil(e * f), 4096));
            b < d && c < e && (c = b / c, d / e > c ? (b = e * c, c = e) : (b = d, c = d / c));
            this._manager.IsNpotSurfaceAllowed() && (d = Math.ceil(b),
            e = Math.ceil(c));
            d <= this._rasterSurfaceWidth && e <= this._rasterSurfaceHeight && !this._forceRaster || (this._isRasterizing = !0, this._rasterSurfaceWidth = d, this._rasterSurfaceHeight = e, a = await this._manager.RasterAtSize(this._dataSource, a, this._rasterSurfaceWidth, this._rasterSurfaceHeight, b, c), this._manager && (this.ReleaseRasterizedResult(), this._rasterizedResult = a, this._rasterImageWidth = b, this._rasterImageHeight = c, this._forceRaster = this._isRasterizing = !1, this._manager.Redraw()))
        }
    }
    WhenBaseSizeReady()
    {
        return this._getBaseSizePromise
    }
    GetBaseWidth()
    {
        return this._baseWidth
    }
    GetBaseHeight()
    {
        return this._baseHeight
    }
    GetRasterWidth()
    {
        return this._rasterImageWidth
    }
    GetRasterHeight()
    {
        return this._rasterImageHeight
    }
    HadError()
    {
        return this._hadError
    }
}
;
"use strict";
const C3$jscomp$34 = self.C3;
C3$jscomp$34.UTF8_BOM = "\ufeff";
const NUMERIC_CHARS = new Set("0123456789");
C3$jscomp$34.IsNumericChar = function(a) {
    return NUMERIC_CHARS.has(a)
};
const WHITESPACE_CHARS = new Set(" \t\n\r\u00a0\u0085\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u202f\u205f\u3000");
C3$jscomp$34.IsWhitespaceChar = function(a) {
    return WHITESPACE_CHARS.has(a)
};
C3$jscomp$34.FilterWhitespace = function(a) {
    return [...a].filter(b => !C3$jscomp$34.IsWhitespaceChar(b)).join("")
};
C3$jscomp$34.IsStringAllWhitespace = function(a) {
    for (const b of a)
        if (!C3$jscomp$34.IsWhitespaceChar(b))
            return !1;
    return !0
};
C3$jscomp$34.IsCharArrayAllWhitespace = function(a) {
    for (const b of a)
        if (!C3$jscomp$34.IsWhitespaceChar(b))
            return !1;
    return !0
};
C3$jscomp$34.IsUnprintableChar = function(a) {
    return 1 === a.length && 32 > a.charCodeAt(0)
};
C3$jscomp$34.FilterUnprintableChars = function(a) {
    return [...a].filter(b => !C3$jscomp$34.IsUnprintableChar(b)).join("")
};
const CJK_PUNCTUATION_REGEX = /\p{P}(?<=[\u3000-\u303F\uFF00-\uFFEF])/u;
C3$jscomp$34.IsCJKPunctuationChar = function(a) {
    return !C3$jscomp$34.IsWhitespaceChar(a) && CJK_PUNCTUATION_REGEX.test(a)
};
const NUMERIC_STRING_CHARS = new Set("0123456789.+-e");
C3$jscomp$34.IsStringNumber = function(a) {
    a = a.trim();
    if (!a.length)
        return !1;
    let b = a.charAt(0);
    if ("-" !== b && !NUMERIC_CHARS.has(b))
        return !1;
    for (let c of a)
        if (!NUMERIC_STRING_CHARS.has(c))
            return !1;
    return !0
};
C3$jscomp$34.RemoveTrailingDigits = function(a) {
    let b = a.length;
    for (; 0 < b;) {
        let c = a.charAt(b - 1);
        if (!C3$jscomp$34.IsNumericChar(c))
            break;
        --b
    }
    return a.substr(0, b)
};
C3$jscomp$34.IncrementNumberAtEndOf = function(a) {
    let b = C3$jscomp$34.RemoveTrailingDigits(a);
    a = (a = a.substr(b.length)) ? (parseInt(a, 10) + 1).toString() : "2";
    return b + a
};
const HTML_ENTITY_MAP = new Map([["&", "&amp;"], ["<", "&lt;"], [">", "&gt;"], ['"', "&quot;"], ["'", "&#39;"]]);
function lookupHtmlEntity(a) {
    return HTML_ENTITY_MAP.get(a)
}
const HTML_ENTITY_REGEX = /[&<>"']/g;
C3$jscomp$34.EscapeHTML = function(a) {
    return a.replace(HTML_ENTITY_REGEX, lookupHtmlEntity)
};
C3$jscomp$34.EscapeJS = function(a) {
    a = C3$jscomp$34.ReplaceAll(a, "\\", "\\\\");
    a = C3$jscomp$34.ReplaceAll(a, '"', '\\"');
    a = C3$jscomp$34.ReplaceAll(a, "\t", "\\t");
    a = C3$jscomp$34.ReplaceAll(a, "\r", "");
    return C3$jscomp$34.ReplaceAll(a, "\n", "\\n")
};
C3$jscomp$34.EscapeXML = function(a) {
    a = C3$jscomp$34.ReplaceAll(a, "&", "&amp;");
    a = C3$jscomp$34.ReplaceAll(a, "<", "&lt;");
    a = C3$jscomp$34.ReplaceAll(a, ">", "&gt;");
    return C3$jscomp$34.ReplaceAll(a, '"', "&quot;")
};
const ESCAPE_REGEX = /[-[\]{}()*+?.,\\^$|#\s]/g;
C3$jscomp$34.EscapeRegex = function(a) {
    return a.replace(ESCAPE_REGEX, "\\$&")
};
C3$jscomp$34.CountCharsInString = function(a, b) {
    let c = 0;
    for (const d of a)
        d === b && ++c;
    return c
};
C3$jscomp$34.FindAll = function(a, b, c=!1) {
    if (!b)
        return [];
    c || (a = a.toLowerCase(), b = b.toLowerCase());
    c = b.length;
    var d = 0;
    let e = [];
    for (; -1 < (d = a.indexOf(b, d));)
        e.push(d),
        d += c;
    return e
};
C3$jscomp$34.ReplaceAll = function(a, b, c) {
    return a.replaceAll(b, () => c)
};
C3$jscomp$34.ReplaceAllCaseInsensitive = function(a, b, c) {
    return a.replace(new RegExp(C3$jscomp$34.EscapeRegex(b), "gi"), () => c)
};
C3$jscomp$34.SetElementContent = function(a, b) {
    "string" === typeof b ? a.textContent = b : b.isPlainText() ? a.textContent = b.toString() : (a.innerHTML = b.toHTML(), b instanceof C3$jscomp$34.BBString && b.attachLinkHandlers(a))
};
C3$jscomp$34.StringLikeEquals = function(a, b) {
    return a instanceof C3$jscomp$34.HtmlString || a instanceof C3$jscomp$34.BBString ? a.equals(b) : b instanceof C3$jscomp$34.HtmlString || b instanceof C3$jscomp$34.BBString ? b.equals(a) : a === b
};
C3$jscomp$34.StringSubstitute = function(a, ...b) {
    let c = a;
    for (let d = 0, e = b.length; d < e; ++d) {
        const f = `{${d}}`;
        if (!a.includes(f))
            throw Error(`missing placeholder '${f}' in string substitution`);
        c = c.replace(f, b[d].toString())
    }
    return c
};
C3$jscomp$34.StringSubstituteAllowMissing = function(a, ...b) {
    let c = a,
        d = -1,
        e = -1;
    for (let f = 0, g = b.length; f < g; ++f) {
        const h = `{${f}}`;
        a.includes(h) ? (e = f, c = c.replace(h, b[f].toString())) : -1 === d && (d = f)
    }
    if (0 <= d && 0 <= e && d < e)
        throw Error(`missing placeholder '${d}' in string substitution`);
    return c
};
C3$jscomp$34.StringSubstituteMap = function(a, b) {
    for (let [c, d] of Object.entries(b))
        a = a.replaceAll(c, d.toString());
    return a
};
C3$jscomp$34.SortAZ = function(a, b) {
    return a > b ? 1 : a < b ? -1 : 0
};
C3$jscomp$34.SortAZCaseInsensitive = function(a, b) {
    a = a.toLowerCase();
    b = b.toLowerCase();
    return a > b ? 1 : a < b ? -1 : 0
};
let intlSegmenter = null,
    graphemeSplitter = null;
self.Intl && self.Intl.Segmenter ? intlSegmenter = new self.Intl.Segmenter : graphemeSplitter = new self.GraphemeSplitter;
C3$jscomp$34.SplitGraphemes = function(a) {
    if (intlSegmenter) {
        const b = [];
        for (const c of intlSegmenter.segment(a))
            b.push(c.segment);
        return b
    }
    return graphemeSplitter.splitGraphemes(a)
};
C3$jscomp$34.IterateGraphemes = function* (a) {
    if (intlSegmenter)
        for (const b of intlSegmenter.segment(a))
            yield b.segment;
    else
        yield *graphemeSplitter.iterateGraphemes(a)
};
C3$jscomp$34.CountGraphemes = function(a) {
    if (intlSegmenter) {
        let b = 0;
        for (const c of intlSegmenter.segment(a))
            ++b;
        return b
    }
    return graphemeSplitter.countGraphemes(a)
};
const MEGABYTE = 1048576,
    GIGABYTE = 1024 * MEGABYTE,
    TERABYTE = 1024 * GIGABYTE;
C3$jscomp$34.FormatDataSize = function(a, b) {
    b = "common." + (b ? "dataRates" : "dataSizes") + ".";
    const c = self.langSub;
    if (1024 > a)
        return c(b + "bytes", a);
    if (a < MEGABYTE)
        return a /= 1024, a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a), c(b + "kilobytes", a);
    if (a < GIGABYTE)
        return a /= MEGABYTE, a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a), c(b + "megabytes", a);
    if (a < TERABYTE)
        return a /= GIGABYTE, a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a), c(b + "gigabytes", a);
    a /= TERABYTE;
    a = 10 > a ? Math.round(10 * a) / 10 : Math.round(a);
    return c(b + "terabytes", a)
};
const DEFAULT_FORMATTIME_OPTS = {
    approximate: !1,
    days: !0,
    hours: !0,
    minutes: !0,
    seconds: !0
};
C3$jscomp$34.FormatTime = function(a, b) {
    b = Object.assign({}, DEFAULT_FORMATTIME_OPTS, b);
    C3$jscomp$34.Lang.PushContext("common.time");
    const c = [],
        d = self.lang,
        e = self.langPluralSub;
    if (b.days) {
        var f = Math.floor(a / 86400);
        0 < f && (a -= 86400 * f, c.push(e(".days", null, f)))
    }
    b.hours && (f = Math.floor(a / 3600), 0 < f || c.length) && (a -= 3600 * f, c.push(e(".hours", null, f)));
    b.minutes && (f = Math.floor(a / 60), 0 < f || c.length || !b.seconds) && (a -= 60 * f, c.push(e(".minutes", null, f)));
    b.seconds && c.push(e(".seconds", null, Math.floor(a % 60)));
    a = (b.approximate ?
    d(".approx-prefix") : "") + c.join(d(".separator"));
    C3$jscomp$34.Lang.PopContext();
    return a
};
C3$jscomp$34.ZeroPad = function(a, b) {
    let c = 0 > a ? "-" : "";
    a = Math.abs(a);
    a = a.toString();
    b -= a.length;
    for (let d = 0; d < b; ++d)
        c += "0";
    return c + a
};
C3$jscomp$34.StringToTitleCase = function(a) {
    return a.toLowerCase().replace(/\b\w/g, b => b.toUpperCase())
};
C3$jscomp$34.CompareVersionStrings = function(a, b) {
    a = a.split(".").map(c => c.trim());
    b = b.split(".").map(c => c.trim());
    C3$jscomp$34.resizeArray(a, 4, "0");
    C3$jscomp$34.resizeArray(b, 4, "0");
    a = a.map(c => parseInt(c, 10));
    b = b.map(c => parseInt(c, 10));
    for (let c = 0; 4 > c; ++c) {
        const d = a[c] - b[c];
        if (0 !== d)
            return 0 > d ? -1 : 1
    }
    return 0
};
C3$jscomp$34.CreateGUID = function() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, a => {
        const b = Math.floor(16 * Math.random());
        return ("x" === a ? b : b & 3 | 8).toString(16)
    })
};
C3$jscomp$34.StringHammingDistance = function(a, b) {
    if (a.length !== b.length)
        throw Error("strings must be same length");
    let c = 0;
    for (let d = 0, e = a.length; d < e; ++d)
        a.charAt(d) !== b.charAt(d) && ++c;
    return c
};
C3$jscomp$34.StringLevenshteinDistance = function(a, b) {
    if (0 === a.length)
        return b.length;
    if (0 === b.length)
        return a.length;
    let c,
        d,
        e,
        f;
    if (a.length > b.length) {
        var g = a;
        a = b;
        b = g
    }
    f = Array(a.length + 1);
    for (g = 0; g <= a.length; g++)
        f[g] = g;
    for (g = 1; g <= b.length; g++) {
        d = g;
        for (c = 1; c <= a.length; c++)
            e = b[g - 1] === a[c - 1] ? f[c - 1] : Math.min(f[c - 1] + 1, Math.min(d + 1, f[c] + 1)),
            f[c - 1] = d,
            d = e;
        f[a.length] = d
    }
    return f[a.length]
};
"use strict";
const C3$jscomp$35 = self.C3,
    BB_CODE_MAP = new Map([["b", "strong"], ["i", "em"], ["s", "s"], ["u", "u"], ["sub", "sub"], ["sup", "sup"], ["small", "small"], ["mark", "mark"], ["code", "code"], ["a1", "a"], ["a2", "a"], ["a3", "a"], ["a4", "a"], ["a5", "a"], ["a6", "a"], ["a7", "a"], ["a8", "a"], ["a9", "a"], ["tip1", "abbr"], ["tip2", "abbr"], ["tip3", "abbr"], ["tip4", "abbr"], ["tip5", "abbr"], ["tip6", "abbr"], ["tip7", "abbr"], ["tip8", "abbr"], ["tip9", "abbr"], ["bad", ["span", "bbCodeBad"]], ["good", ["span", "bbCodeGood"]], ["info", ["span", "bbCodeInfo"]],
    ["h1", ["span", "bbCodeH1"]], ["h2", ["span", "bbCodeH2"]], ["h3", ["span", "bbCodeH3"]], ["h4", ["span", "bbCodeH4"]], ["item", ["span", "bbCodeItem"]]]),
    SELF_CLOSING_TAGS = new Set(["icon"]),
    BBREGEX = /\[(\/?)([a-zA-Z0-9]+)\]/g,
    CUSTOM_BBREGEX = /\[(\/?)([^\[\n]*?)\]/g;
let linkActions = null,
    tipList = null,
    classIndex = 0;
function bbToHtmlReplacerFunc(a, b, c) {
    var d = BB_CODE_MAP.get(c);
    if (d) {
        if ("string" === typeof d) {
            if ("a" === d && 0 === linkActions.length || "abbr" === d && 0 === tipList.length)
                return a;
            if ("a" !== d || b) {
                if ("abbr" !== d || b)
                    return "<" + b + d + ">";
                b = parseInt(c.substring(3), 10) - 1;
                if (0 > b || b >= tipList.length)
                    throw Error("invalid bbcode tip substitution");
                b = tipList[b];
                d = "";
                "string" === typeof b ? d = b : "function" === typeof b && (d = b());
                if ("string" !== typeof d)
                    throw new TypeError("invalid bbcode tip");
                return `<abbr title="${C3$jscomp$35.ReplaceAll(d, '"', "&quot;")}">`
            }
            b = parseInt(c.substring(1), 10) - 1;
            if (0 > b || b >= linkActions.length)
                throw Error("invalid bbcode link substitution");
            d = linkActions[b];
            if ("string" === typeof d)
                return `<a href="${linkActions[b]}">`;
            if ("function" === typeof d)
                return `<a class="bblink${b}">`;
            throw new TypeError("invalid bbcode link action");
        }
        if (Array.isArray(d))
            return a = d[0], d = d[1], b ? "</" + a + ">" : `<${a} class="${d}">`
    } else
        return "class" === c ? b ? "</span>" : `<span class="bbclass${classIndex++}">` : a
}
const LINEBREAK_REGEX = /\n/g;
C3$jscomp$35.BBString = class {
    constructor(a, b)
    {
        this._bbstr = b && b.noEscape ? a : C3$jscomp$35.EscapeHTML(a);
        this._htmlstr = "";
        this._convertLineBreaks = !1;
        this._linkActions = [];
        this._tipList = [];
        if (b) {
            this._convertLineBreaks = !!b.convertLineBreaks;
            if (b.links) {
                if (9 < b.links.length)
                    throw Error("too many links");
                this._linkActions = b.links
            }
            if (b.tips) {
                if (9 < b.tips.length)
                    throw Error("too many tips");
                this._tipList = b.tips
            }
        }
        this._hasAnyBBtags = this._bbstr.includes("[");
        this._needsLineBreakConversion = this._convertLineBreaks &&
        this._bbstr.includes("\n");
        this._isPlain = !this._hasAnyBBtags && !this._needsLineBreakConversion && !this._bbstr.includes("&");
        this._hasParsedFragments = !1;
        this._fragments = []
    }
    toString()
    {
        return this._bbstr
    }
    valueOf()
    {
        return this._bbstr
    }
    isPlainText()
    {
        return this._isPlain
    }
    toPlainText()
    {
        return this._hasAnyBBtags ? this._bbstr.replace(BBREGEX, "") : this._bbstr
    }
    toHTML()
    {
        if (this._isPlain)
            return this._bbstr;
        if (!this._htmlstr && this._bbstr) {
            let a = this._bbstr;
            this._hasAnyBBtags && (classIndex = 0, linkActions = this._linkActions,
            tipList = this._tipList, a = a.replace(BBREGEX, bbToHtmlReplacerFunc), tipList = linkActions = null);
            this._needsLineBreakConversion && (a = a.replace(LINEBREAK_REGEX, "<br>"));
            this._htmlstr = a
        }
        return this._htmlstr
    }
    attachLinkHandlers(a)
    {
        if (this._linkActions.length)
            for (let b = 0, c = this._linkActions.length; b < c; ++b) {
                const d = this._linkActions[b];
                if ("function" !== typeof d)
                    continue;
                const e = a.querySelector(".bblink" + b);
                if (!e)
                    throw Error("unable to attach BBString link handler");
                e.onclick = d
            }
    }
    equals(a)
    {
        return a instanceof C3$jscomp$35.HtmlString ?
        this.toHTML() === a.toHTML() : a instanceof C3$jscomp$35.BBString ? this._bbstr === a._bbstr : this._bbstr === a
    }
    toFragmentList()
    {
        if (this._hasParsedFragments)
            return this._fragments;
        const a = [],
            b = this._bbstr,
            c = [];
        let d = CUSTOM_BBREGEX.lastIndex = 0;
        for (var e = null; null !== (e = CUSTOM_BBREGEX.exec(b));) {
            var f = e.index;
            if (0 < f && "\\" === b.charAt(f - 1))
                continue;
            var g = e[0],
                h = e[1];
            e = e[2];
            const k = b.substring(d, f);
            d = f + g.length;
            k && a.push({
                text: k,
                styles: c.slice(0)
            });
            if (e)
                if (h)
                    for (e = e.toLowerCase(), f = c.length - 1; 0 <= f; --f) {
                        if (c[f].tag ===
                        e) {
                            c.splice(f, 1);
                            break
                        }
                    }
                else if (f = e, g = null, h = e.indexOf("="), -1 !== h ? (f = e.substring(0, h).toLowerCase(), g = e.substring(h + 1)) : f = f.toLowerCase(), SELF_CLOSING_TAGS.has(f))
                    if ("icon" === f)
                        a.push({
                            icon: g,
                            styles: c.slice(0)
                        });
                    else
                        throw Error(`unknown self-closing tag ${f}`);
                else
                    c.push({
                        tag: f,
                        param: g
                    })
        }
        d < b.length && a.push({
            text: b.substring(d),
            styles: c.slice(0)
        });
        for (const k of a)
            k.text && (k.text = this._ProcessBBCodeEscapeSequences(k.text));
        this._fragments = a.map(k => k.icon ? C3$jscomp$35.New(C3$jscomp$35.IconFragment,
        {
            icon: k.icon,
            styles: k.styles
        }) : C3$jscomp$35.New(C3$jscomp$35.TextFragment, {
            chArr: C3$jscomp$35.SplitGraphemes(k.text),
            styles: k.styles
        }));
        this._hasParsedFragments = !0;
        return this._fragments
    }
    _ProcessBBCodeEscapeSequences(a)
    {
        a = C3$jscomp$35.ReplaceAll(a, "\\[", "[");
        return C3$jscomp$35.ReplaceAll(a, "\\\\", "\\")
    }
    static StripTags(a)
    {
        return C3$jscomp$35.New(C3$jscomp$35.BBString, a, {
            noEscape: !0
        }).toPlainText()
    }
    static StripAnyTags(a)
    {
        return a.replace(CUSTOM_BBREGEX, "")
    }
}
;
"use strict";
const C3$jscomp$36 = self.C3;
function IsWordBreakWhiteSpace(a) {
    return "\u00a0" === a || "\u202f" === a ? !1 : C3$jscomp$36.IsWhitespaceChar(a)
}
const CJK_OPEN_PUNCTUATION = new Set("\u3008\u300a\u300c\u300e\u3010\u3014\u3016\u3018\u301a\u301d");
function IsOpeningCJKPunctiationChar(a) {
    return CJK_OPEN_PUNCTUATION.has(a)
}
function IsContinuingCJKPunctuationChar(a) {
    return C3$jscomp$36.IsCJKPunctuationChar(a) && !IsOpeningCJKPunctiationChar(a)
}
function WordBreakTrimEnd(a) {
    for (; 0 < a.length && IsWordBreakWhiteSpace(a.at(-1));)
        a.pop()
}
function IsNewline(a) {
    return "\n" === a || "\r\n" === a
}
C3$jscomp$36.WordWrap = class {
    constructor()
    {
        this._lines = [];
        this._iconSet = null
    }
    GetLines()
    {
        return this._lines
    }
    GetLineCount()
    {
        return this._lines.length
    }
    SetIconSet(a)
    {
        this._iconSet = a
    }
    _MeasureLine(a, b)
    {
        let c = 0,
            d = 0,
            e = 0,
            f = 0,
            g = 0;
        for (const h of a)
            -1 === h.GetWidth() && (a = b(h), h.SetHeight(a.height), h.SetFontBoundingBoxAscent(a.fontBoundingBoxAscent || 0), h.SetFontBoundingBoxDescent(a.fontBoundingBoxDescent || 0), h.SetTopToAlphabeticDistance(a.topToAlphabeticDistance || 0), h.IsText() ? h.SetWidth(a.width) : h.IsIcon() && h.CalculateWidthFromHeight(this._iconSet)),
            c += h.GetWidth(),
            d = Math.max(d, h.GetHeight()),
            e = Math.max(e, h.GetFontBoundingBoxAscent()),
            f = Math.max(f, h.GetFontBoundingBoxDescent()),
            g = Math.max(g, h.GetTopToAlphabeticDistance());
        return {
            width: c,
            height: d,
            fontBoundingBoxAscent: e,
            fontBoundingBoxDescent: f,
            topToAlphabeticDistance: g
        }
    }
    _AddLine(a, b, c, d, e, f)
    {
        this._lines.push(C3$jscomp$36.New(C3$jscomp$36.WordWrap.Line, {
            fragments: a,
            width: b,
            height: c,
            fontBoundingBoxAscent: d,
            fontBoundingBoxDescent: e,
            topToAlphabeticDistance: f
        }))
    }
    WordWrap(a, b, c, d, e)
    {
        "string" === typeof a &&
        (a = [C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
            chArr: C3$jscomp$36.SplitGraphemes(a)
        })]);
        C3$jscomp$36.clearArray(this._lines);
        if (!(!a.length || 1 === a.length && a[0].IsText() && a[0].IsEmpty() || 2 > c)) {
            if (1 === a.length) {
                const f = a[0];
                if (f.IsText() && 100 >= f.GetLength() && !f.HasNewLine()) {
                    let {width: g, height: h, fontBoundingBoxAscent: k, fontBoundingBoxDescent: l, topToAlphabeticDistance: m} = b(f);
                    g += e;
                    f.SetWidth(g);
                    f.SetHeight(h);
                    f.SetFontBoundingBoxAscent(k || 0);
                    f.SetFontBoundingBoxDescent(l || 0);
                    f.SetTopToAlphabeticDistance(m ||
                    0);
                    if (g <= c) {
                        this._AddLine([f], g, h, k, l, m);
                        return
                    }
                }
            }
            a = "word" === d ? this._TokeniseByWord(a) : "cjk" === d ? this._TokeniseByCJK(a) : this._TokeniseByChar(a);
            this._WrapText(a, b, c, e)
        }
    }
    _TokeniseByWord(a)
    {
        const b = [];
        let c = [],
            d = !1;
        for (const f of a)
            if (a = f.GetStyles(), f.IsIcon())
                0 < c.length && b.push(c),
                b.push([f]),
                c = [];
            else
                for (const g of f.GetCharacterArray())
                    if (IsNewline(g))
                        0 < c.length && b.push(c),
                        b.push([C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                            chArr: ["\n"],
                            styles: a
                        })]),
                        c = [];
                    else if (0 === c.length)
                        c.push(C3$jscomp$36.New(C3$jscomp$36.TextFragment,
                        {
                            chArr: [g],
                            styles: a
                        })),
                        d = IsWordBreakWhiteSpace(g);
                    else {
                        var e = IsWordBreakWhiteSpace(g);
                        e === d ? (e = c.at(-1), e.GetStyles() === a ? e._AppendChar(g) : c.push(C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                            chArr: [g],
                            styles: a
                        }))) : (b.push(c), c = [C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                            chArr: [g],
                            styles: a
                        })], d = e)
                    }
        0 < c.length && b.push(c);
        return b
    }
    _TokeniseByCJK(a)
    {
        const b = [];
        let c = [];
        var d = !1;
        for (const e of a)
            if (a = e.GetStyles(), e.IsIcon())
                0 < c.length && b.push(c),
                b.push([e]),
                c = [];
            else
                for (const f of e.GetCharacterArray())
                    IsNewline(f) ?
                    (0 < c.length && b.push(c), b.push([C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                        chArr: ["\n"],
                        styles: a
                    })]), c = []) : (0 === c.length ? c.push(C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                        chArr: [f],
                        styles: a
                    })) : d || IsContinuingCJKPunctuationChar(f) ? (d = c.at(-1), d.GetStyles() === a ? d._AppendChar(f) : c.push(C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                        chArr: [f],
                        styles: a
                    }))) : (b.push(c), c = [C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                        chArr: [f],
                        styles: a
                    })]), d = IsOpeningCJKPunctiationChar(f));
        0 < c.length && b.push(c);
        return b
    }
    _TokeniseByChar(a)
    {
        const b =
        [];
        for (const c of a)
            c.IsText() ? (a = c.GetCharacterArray(), C3$jscomp$36.appendArray(b, a.map(d => [C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                chArr: [d],
                styles: c.GetStyles()
            })]))) : b.push([c]);
        return b
    }
    _CopyLine(a)
    {
        return a.map(b => b._Clone())
    }
    _AddWordToLine(a, b)
    {
        var c = a.length ? a.at(-1) : null;
        let d = 0;
        c && c.IsText() && b[0].IsText() && b[0].GetStyles() === c.GetStyles() && (c._Append(b[0].GetCharacterArray()), d = 1);
        for (c = b.length; d < c; ++d)
            a.push(b[d]._Clone())
    }
    _WrapText(a, b, c, d)
    {
        let e = [],
            f = 0;
        var g = 0;
        let h = 0,
            k = 0;
        var l =
        0;
        for (const m of a) {
            if (1 === m.length && m[0].IsText() && 1 === m[0].GetLength() && IsNewline(m[0].GetCharacterArray()[0])) {
                0 === g && (g = C3$jscomp$36.New(C3$jscomp$36.TextFragment, {
                    chArr: [" "],
                    styles: m[0].GetStyles()
                }), l = b(g), g = l.height, h = l.fontBoundingBoxAscent || 0, k = l.fontBoundingBoxDescent || 0, l = l.topToAlphabeticDistance || 0);
                this._AddLine(e, f, g, h, k, l);
                e = [];
                l = k = h = g = f = 0;
                continue
            }
            a = this._CopyLine(e);
            this._AddWordToLine(a, m);
            const n = this._MeasureLine(a, b),
                p = n.width;
            p >= c ? (0 < e.length && this._AddLine(e, f, g, h, k, l), e =
            [], m[0].IsText() && C3$jscomp$36.IsCharArrayAllWhitespace(m[0].GetCharacterArray()) ? l = k = h = g = f = 0 : (this._AddWordToLine(e, m), l = this._MeasureLine(e, b), f = l.width, g = l.height, h = l.fontBoundingBoxAscent, k = l.fontBoundingBoxDescent, l = l.topToAlphabeticDistance)) : (e = a, f = p, g = n.height, h = n.fontBoundingBoxAscent, k = n.fontBoundingBoxDescent, l = n.topToAlphabeticDistance)
        }
        0 < e.length && this._AddLine(e, f, g, h, k, l);
        this._TrimLinesTrailingWhitespace(b, d)
    }
    _TrimLinesTrailingWhitespace(a, b)
    {
        for (const e of this._lines) {
            const f = e._GetFragmentsArray();
            if (!f.length)
                continue;
            let g = f.at(-1);
            if (g.IsText()) {
                var c = g.GetCharacterArray(),
                    d = c.slice(0);
                WordBreakTrimEnd(d);
                0 === d.length ? (e.OffsetWidth(-g.GetWidth()), f.pop()) : d.length < c.length && (g.SetCharacterArray(d), c = a(g).width, d = g.GetWidth() - c, g.SetWidth(c), e.OffsetWidth(-d));
                0 !== b && 0 < f.length && (g = f.at(-1), g.OffsetWidth(b), e.OffsetWidth(b))
            }
        }
    }
    Clear()
    {
        C3$jscomp$36.clearArray(this._lines)
    }
    GetMaxLineWidth()
    {
        return this._lines.reduce((a, b) => Math.max(a, b.GetWidth()), 0)
    }
    GetTotalLineHeight()
    {
        return this._lines.reduce((a,
        b) => a + b.GetHeight(), 0)
    }
}
;
"use strict";
self.C3.WordWrap.Line = class {
    constructor(a)
    {
        this._fragments = a.fragments || [];
        this._width = a.width || -1;
        this._height = a.height || -1;
        this._fontBoundingBoxAscent = a.fontBoundingBoxAscent || -1;
        this._fontBoundingBoxDescent = a.fontBoundingBoxDescent || -1;
        this._topToAlphabeticDistance = a.topToAlphabeticDistance || -1;
        this._posY = this._posX = 0
    }
    fragments()
    {
        return this._fragments.values()
    }
    *fragmentsReverse()
    {
        const a = this._fragments;
        for (let b = a.length - 1; 0 <= b; --b)
            yield a[b]
    }
    _GetFragmentsArray()
    {
        return this._fragments
    }
    OffsetWidth(a)
    {
        this._width += a
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    GetFoundBoundingBoxAscent()
    {
        return this._fontBoundingBoxAscent
    }
    GetFontBoundingBoxDescent()
    {
        return this._fontBoundingBoxDescent
    }
    GetTopToAlphabeticDistance()
    {
        return this._topToAlphabeticDistance
    }
    SetPosX(a)
    {
        this._posX =
        a
    }
    GetPosX()
    {
        return this._posX
    }
    SetPosY(a)
    {
        this._posY = a
    }
    GetPosY()
    {
        return this._posY
    }
}
;
"use strict";
self.C3.FragmentBase = class {
    constructor(a)
    {
        this._styles = a.styles || [];
        this._width = a.width || -1;
        this._height = a.height || -1;
        this._fontBoundingBoxAscent = a.fontBoundingBoxAscent || -1;
        this._fontBoundingBoxDescent = a.fontBoundingBoxDescent || -1;
        this._topToAlphabeticDistance = a.topToAlphabeticDistance || -1;
        this._posY = this._posX = 0
    }
    IsText()
    {
        return !1
    }
    IsIcon()
    {
        return !1
    }
    GetStyles()
    {
        return this._styles
    }
    GetStyleTag(a)
    {
        const b = this._styles;
        for (let c = b.length - 1; 0 <= c; --c) {
            const d = b[c];
            if (d.tag === a)
                return d
        }
        return null
    }
    HasStyleTag(a)
    {
        return !!this.GetStyleTag(a)
    }
    GetStyleMap()
    {
        const a =
        new Map;
        for (const b of this._styles)
            a.set(b.tag, b.param);
        return a
    }
    OffsetWidth(a)
    {
        this._width += a
    }
    SetWidth(a)
    {
        this._width = a
    }
    GetWidth()
    {
        return this._width
    }
    SetHeight(a)
    {
        this._height = a
    }
    GetHeight()
    {
        return this._height
    }
    SetFontBoundingBoxAscent(a)
    {
        this._fontBoundingBoxAscent = a
    }
    GetFontBoundingBoxAscent()
    {
        return this._fontBoundingBoxAscent
    }
    SetFontBoundingBoxDescent(a)
    {
        this._fontBoundingBoxDescent = a
    }
    GetFontBoundingBoxDescent()
    {
        return this._fontBoundingBoxDescent
    }
    SetTopToAlphabeticDistance(a)
    {
        this._topToAlphabeticDistance =
        a
    }
    GetTopToAlphabeticDistance()
    {
        return this._topToAlphabeticDistance
    }
    SetPosX(a)
    {
        this._posX = a
    }
    GetPosX()
    {
        return this._posX
    }
    SetPosY(a)
    {
        this._posY = a
    }
    GetPosY()
    {
        return this._posY
    }
}
;
"use strict";
const C3$jscomp$39 = self.C3;
C3$jscomp$39.TextFragment = class  extends C3$jscomp$39.FragmentBase{
    constructor(a)
    {
        super(a);
        this._chArr = a.chArr
    }
    IsText()
    {
        return !0
    }
    _Append(a)
    {
        C3$jscomp$39.appendArray(this._chArr, a);
        this._topToAlphabeticDistance = this._fontBoundingBoxDescent = this._fontBoundingBoxAscent = this._height = this._width = -1
    }
    _AppendChar(a)
    {
        this._chArr.push(a)
    }
    _Clone()
    {
        return C3$jscomp$39.New(C3$jscomp$39.TextFragment, {
            chArr: this._chArr.slice(0),
            styles: this._styles,
            width: this._width,
            height: this._height,
            fontBoundingBoxAscent: this._fontBoundingBoxAscent,
            fontBoundingBoxDescent: this._fontBoundingBoxDescent,
            topToAlphabeticDistance: this._topToAlphabeticDistance
        })
    }
    GetCharacterArray()
    {
        return this._chArr
    }
    SetCharacterArray(a)
    {
        this._chArr = a
    }
    GetLength()
    {
        return this._chArr.length
    }
    IsEmpty()
    {
        return 0 === this._chArr.length
    }
    HasNewLine()
    {
        return this._chArr.includes("\n")
    }
}
;
"use strict";
const C3$jscomp$40 = self.C3;
C3$jscomp$40.IconFragment = class  extends C3$jscomp$40.FragmentBase{
    constructor(a)
    {
        super(a);
        this._icon = a.icon
    }
    IsIcon()
    {
        return !0
    }
    GetIconParameter()
    {
        return this._icon
    }
    _Clone()
    {
        return C3$jscomp$40.New(C3$jscomp$40.IconFragment, {
            icon: this._icon,
            styles: this._styles,
            width: this._width,
            height: this._height,
            fontBoundingBoxAscent: this._fontBoundingBoxAscent,
            fontBoundingBoxDescent: this._fontBoundingBoxDescent,
            topToAlphabeticDistance: this._topToAlphabeticDistance
        })
    }
    GetTextIcon(a)
    {
        if (!a)
            return null;
        let b = Number(this._icon);
        return String(b) === this._icon ? (b = Math.floor(b), a.GetTextIconByIndex(b)) : a.GetTextIconByTag(this._icon)
    }
    CalculateWidthFromHeight(a)
    {
        this._width = (a = this.GetTextIcon(a)) ? this._height * a.GetWidth() / a.GetHeight() : 0
    }
    GetDrawable(a)
    {
        return (a = this.GetTextIcon(a)) ? a.GetDrawable() : null
    }
    GetLength()
    {
        return 1
    }
}
;
"use strict";
const C3$jscomp$41 = self.C3;
C3$jscomp$41.TextIconManager = class {
    constructor(a)
    {
        this._iconSets = new Map;
        this._getIconSetMetaCallback = a.getIconSetMeta;
        this._getIconSetContentCallback = a.getIconSetContent
    }
    Release()
    {
        for (const a of this._iconSets.values())
            a.Release();
        this._iconSets.clear()
    }
    GetIconSet(a)
    {
        var b = this._iconSets.get(a);
        if (b)
            return b;
        b = this._getIconSetMetaCallback(a);
        b = C3$jscomp$41.New(C3$jscomp$41.TextIconSet, this, {
            source: a,
            iconMeta: b
        });
        this._iconSets.set(a, b);
        return b
    }
    HasIconSet(a)
    {
        return this._iconSets.has(a)
    }
    DeleteIconSet(a)
    {
        const b =
        this._iconSets.get(a);
        b && b.Release();
        this._iconSets.delete(a)
    }
    async _GetIconSetContent(a)
    {
        return await this._getIconSetContentCallback(a)
    }
}
;
"use strict";
const C3$jscomp$42 = self.C3;
C3$jscomp$42.TextIconSet = class {
    constructor(a, b)
    {
        this._textIconManager = a;
        this._source = b.source;
        this._iconsArray = [];
        this._iconsByTag = new Map;
        this._isLoading = this._hasStartedLoad = !1;
        this._loadPromise = null;
        a = b.iconMeta.icons;
        for (let c = 0, d = a.length; c < d; ++c) {
            b = a[c];
            const e = C3$jscomp$42.New(C3$jscomp$42.TextIcon, this, {
                index: c,
                tag: b.tag,
                source: b.source,
                width: b.width,
                height: b.height
            });
            this._iconsArray.push(e);
            b.tag && this._iconsByTag.set(b.tag.toLowerCase(), e)
        }
    }
    Release()
    {
        for (const a of this._iconsArray)
            a.Release();
        C3$jscomp$42.clearArray(this._iconsArray);
        this._iconsByTag.clear();
        this._source = this._textIconManager = null
    }
    HasLoaded()
    {
        return this._hasStartedLoad
    }
    IsLoading()
    {
        return this._isLoading
    }
    LoadContent()
    {
        this._loadPromise || (this._loadPromise = this._DoLoadContent());
        return this._loadPromise
    }
    async _DoLoadContent()
    {
        if (!this._hasStartedLoad) {
            this._isLoading = this._hasStartedLoad = !0;
            var a = await this._textIconManager._GetIconSetContent(this._source);
            if (this._textIconManager) {
                a = a.icons;
                for (let b = 0, c = Math.min(a.length,
                    this._iconsArray.length); b < c; ++b)
                    this._iconsArray[b]._SetDrawable(a[b].drawable);
                this._isLoading = !1
            }
        }
    }
    GetTextIconByIndex(a)
    {
        a = Math.floor(a);
        return 0 > a || a >= this._iconsArray.length ? null : this._iconsArray[a]
    }
    GetTextIconByTag(a)
    {
        return this._iconsByTag.get(a.toLowerCase()) || null
    }
}
;
"use strict";
self.C3.TextIcon = class {
    constructor(a, b)
    {
        this._textIconSet = a;
        this._source = b.source || null;
        this._index = b.index;
        this._tag = b.tag;
        this._width = b.width;
        this._height = b.height;
        this._drawable = null
    }
    Release()
    {
        this._height = this._width = 0;
        this._textIconSet = null
    }
    GetSource()
    {
        return this._source
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    _SetDrawable(a)
    {
        this._drawable = a
    }
    GetDrawable()
    {
        return this._drawable
    }
}
;
"use strict";
const C3$jscomp$44 = self.C3,
    glMatrix = self.glMatrix,
    vec3 = glMatrix.vec3,
    vec4 = glMatrix.vec4,
    mat4 = glMatrix.mat4,
    tempVec3a = vec3.create(),
    tempVec3b = vec3.create(),
    tempVec3c = vec3.create(),
    tempVec4 = vec4.create(),
    tempMat4 = mat4.create(),
    neartl = vec3.create(),
    neartr = vec3.create(),
    nearbl = vec3.create(),
    nearbr = vec3.create(),
    fartl = vec3.create(),
    fartr = vec3.create(),
    farbl = vec3.create(),
    farbr = vec3.create(),
    unitViewport = vec4.fromValues(0, 0, 1, 1);
C3$jscomp$44.Gfx = {
    Project(a, b, c, d, e, f, g) {
        const h = d[0] * a + d[4] * b + d[8] * c + d[12],
            k = d[1] * a + d[5] * b + d[9] * c + d[13],
            l = d[2] * a + d[6] * b + d[10] * c + d[14];
        d = d[3] * a + d[7] * b + d[11] * c + d[15];
        a = e[0] * h + e[4] * k + e[8] * l + e[12] * d;
        b = e[1] * h + e[5] * k + e[9] * l + e[13] * d;
        c = e[2] * h + e[6] * k + e[10] * l + e[14] * d;
        e = e[3] * h + e[7] * k + e[11] * l + e[15] * d;
        if (0 === e)
            return !1;
        e = 1 / e;
        g[0] = (a * e * .5 + .5) * f[2] + f[0];
        g[1] = (b * e * .5 + .5) * f[3] + f[1];
        g[2] = .5 * (1 + c * e);
        return !0
    },
    Unproject(a, b, c, d, e, f, g) {
        mat4.multiply(tempMat4, e, d);
        if (null === mat4.invert(tempMat4, tempMat4))
            return !1;
        tempVec4[0] =
        (a - f[0]) / f[2] * 2 - 1;
        tempVec4[1] = (b - f[1]) / f[3] * 2 - 1;
        tempVec4[2] = 2 * c - 1;
        tempVec4[3] = 1;
        vec4.transformMat4(tempVec4, tempVec4, tempMat4);
        if (0 === tempVec4[3])
            return !1;
        tempVec4[3] = 1 / tempVec4[3];
        g[0] = tempVec4[0] * tempVec4[3];
        g[1] = tempVec4[1] * tempVec4[3];
        g[2] = tempVec4[2] * tempVec4[3];
        return !0
    },
    UnprojectScreenToWorldZ(a, b, c, d, e, f, g) {
        if (!C3$jscomp$44.Gfx.Unproject(a, b, 0, d, e, f, tempVec3a) || !C3$jscomp$44.Gfx.Unproject(a, b, 1, d, e, f, tempVec3b))
            return !1;
        vec3.subtract(tempVec3b, tempVec3b, tempVec3a);
        vec3.set(tempVec3c, 0, 0, 1);
        a = -c;
        b = vec3.dot(tempVec3c, tempVec3b);
        c = 0;
        if (0 === b) {
            if (0 !== vec3.dot(tempVec3c, tempVec3a) + a)
                return !1
        } else if (c = -(vec3.dot(tempVec3a, tempVec3c) + a) / b, 0 > c)
            return !1;
        vec3.scaleAndAdd(g, tempVec3a, tempVec3b, c);
        return !0
    }
};
function PlaneFromPoints(a, b, c, d) {
    vec3.subtract(tempVec3a, c, b);
    vec3.subtract(tempVec3b, a, b);
    vec3.cross(tempVec3c, tempVec3a, tempVec3b);
    vec3.normalize(tempVec3c, tempVec3c);
    d.set(tempVec3c[0], tempVec3c[1], tempVec3c[2], vec3.dot(a, tempVec3c))
}
function IsInFrontOfPlane(a, b, c, d, e, f, g) {
    const h = g.x,
        k = g.y,
        l = g.z,
        m = g.w,
        n = g.xF,
        p = g.yF;
    g = g.zF;
    const q = 1 - n,
        r = 1 - p,
        t = 1 - g;
    return h * a * n + h * d * q + k * b * p + k * e * r + l * c * g + l * f * t >= m ? !0 : h * d * n + h * a * q + k * e * p + k * b * r + l * f * g + l * c * t > m
}
function IsPointInFrontOfPlane(a, b, c, d) {
    return d.x * a + d.y * b + d.z * c >= d.w
}
class Plane {
    constructor()
    {
        this.zF = this.yF = this.xF = this.w = this.z = this.y = this.x = NaN
    }
    set(a, b, c, d)
    {
        this.x = a;
        this.y = b;
        this.z = c;
        this.w = d;
        this.xF = 0 < a ? 1 : 0;
        this.yF = 0 < b ? 1 : 0;
        this.zF = 0 < c ? 1 : 0
    }
}
C3$jscomp$44.Gfx.ViewFrustum = class {
    constructor()
    {
        this._leftP = new Plane;
        this._topP = new Plane;
        this._rightP = new Plane;
        this._bottomP = new Plane;
        this._nearP = new Plane;
        this._farP = new Plane
    }
    CalculatePlanes(a, b)
    {
        C3$jscomp$44.Gfx.Unproject(0, 1, 0, a, b, unitViewport, neartl);
        C3$jscomp$44.Gfx.Unproject(1, 1, 0, a, b, unitViewport, neartr);
        C3$jscomp$44.Gfx.Unproject(0, 0, 0, a, b, unitViewport, nearbl);
        C3$jscomp$44.Gfx.Unproject(1, 0, 0, a, b, unitViewport, nearbr);
        C3$jscomp$44.Gfx.Unproject(0, 1, 1, a, b, unitViewport, fartl);
        C3$jscomp$44.Gfx.Unproject(1,
        1, 1, a, b, unitViewport, fartr);
        C3$jscomp$44.Gfx.Unproject(0, 0, 1, a, b, unitViewport, farbl);
        C3$jscomp$44.Gfx.Unproject(1, 0, 1, a, b, unitViewport, farbr);
        PlaneFromPoints(nearbl, neartl, fartl, this._leftP);
        PlaneFromPoints(neartl, neartr, fartr, this._topP);
        PlaneFromPoints(neartr, nearbr, farbr, this._rightP);
        PlaneFromPoints(nearbr, nearbl, farbl, this._bottomP);
        PlaneFromPoints(farbl, fartl, fartr, this._farP);
        PlaneFromPoints(nearbr, neartr, neartl, this._nearP)
    }
    ContainsAABB(a, b, c, d, e, f)
    {
        return IsInFrontOfPlane(a, b, c, d, e, f, this._leftP) &&
            IsInFrontOfPlane(a, b, c, d, e, f, this._topP) && IsInFrontOfPlane(a, b, c, d, e, f, this._rightP) && IsInFrontOfPlane(a, b, c, d, e, f, this._bottomP) && IsInFrontOfPlane(a, b, c, d, e, f, this._nearP) && IsInFrontOfPlane(a, b, c, d, e, f, this._farP)
    }
    IsBehindNearPlane(a, b, c)
    {
        return !IsPointInFrontOfPlane(a, b, c, this._nearP)
    }
}
;
"use strict";
const C3$jscomp$45 = self.C3,
    glMatrix$jscomp$1 = self.glMatrix,
    vec3$jscomp$1 = glMatrix$jscomp$1.vec3,
    vec4$jscomp$1 = glMatrix$jscomp$1.vec4,
    mat4$jscomp$1 = glMatrix$jscomp$1.mat4,
    tempMat4$jscomp$1 = mat4$jscomp$1.create(),
    tmpVec3a = vec3$jscomp$1.fromValues(0, 0, 0),
    tmpVec3b = vec3$jscomp$1.fromValues(0, 0, 0),
    tmpVec3c = vec3$jscomp$1.fromValues(0, 0, 0),
    defaultUpVector = vec3$jscomp$1.fromValues(0, 1, 0);
vec4$jscomp$1.fromValues(0, 0, 0, 0);
const tmpQuad = new C3$jscomp$45.Quad,
    tmpRect = new C3$jscomp$45.Rect,
    defaultTexCoordsQuad = new C3$jscomp$45.Quad(0, 0, 1, 0, 1, 1, 0, 1),
    DEFAULT_RENDERERBASE_OPTS = {
        nearZ: 1,
        farZ: 1E4
    },
    matWebGLtoWebGPU = mat4$jscomp$1.fromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, .5, 0, 0, 0, .5, 1);
C3$jscomp$45.Gfx.RendererBase = class {
    constructor(a)
    {
        a = Object.assign({}, DEFAULT_RENDERERBASE_OPTS, a);
        this._height = this._width = 0;
        this._fovY = C3$jscomp$45.toRadians(45);
        this._tan_fovY_2 = Math.tan(this._fovY / 2);
        this._matP = mat4$jscomp$1.create();
        this._matMV = mat4$jscomp$1.create();
        this._zAxisScale = !1;
        this._nearZ = a.nearZ;
        this._farZ = a.farZ;
        this._allShaderPrograms = [];
        this._shaderProgramsByName = new Map;
        this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill =
        this._spPenumbraFill = this._spLinearGradientFill = this._spColorFill = this._spTileRandomization = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
        this._stateGroups = new Map;
        this._currentStateGroup = null;
        this._blendModeTable = [];
        this._namedBlendModeMap = new Map;
        this._currentZ = this._baseZ = 0;
        this._lineWidth = 1;
        this._lineWidthStack = [this._lineWidth];
        this._lineCap = 1;
        this._lineCapStack = [this._lineCap];
        this._lineOffset = .5;
        this._lineOffsetStack = [this._lineOffset];
        this._frameNumber = 0;
        this._enableMipmaps =
        !0;
        this._hasMajorPerformanceCaveat = !1
    }
    FillIndexBufferData(a)
    {
        let b = 0,
            c = a.length,
            d = 0;
        for (; b < c;)
            a[b++] = d,
            a[b++] = d + 1,
            a[b++] = d + 2,
            a[b++] = d,
            a[b++] = d + 2,
            a[b++] = d + 3,
            d += 4
    }
    _ClearState()
    {
        this._currentZ = this._baseZ = 0;
        this._spSmoothLineFill = this._spSmoothEllipseOutline = this._spSmoothEllipseFill = this._spHardEllipseOutline = this._spHardEllipseFill = this._spPenumbraFill = this._spLinearGradientFill = this._spColorFill = this._spTileRandomization = this._spTilemapFill = this._spPoints = this._spTextureFill = null;
        this._ClearAllShaderPrograms()
    }
    InitState()
    {
        this._ClearState();
        this._currentStateGroup = null
    }
    OnDeviceOrContextLost()
    {
        for (const a of this._allShaderPrograms)
            a.Release();
        this._ClearState()
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    GetDefaultCameraZ(a)
    {
        return this.IsZAxisScaleNormalized() ? 100 : a / (2 * this._GetTanFovYDiv2())
    }
    GetZAxisScaleFactor(a)
    {
        return this.IsZAxisScaleNormalized() ? a / (2 * this._GetTanFovYDiv2()) / this.GetDefaultCameraZ(a) : 1
    }
    SetNearZ(a)
    {
        this._nearZ = a
    }
    GetNearZ()
    {
        return this._nearZ
    }
    SetFarZ(a)
    {
        this._farZ = a
    }
    GetFarZ()
    {
        return this._farZ
    }
    SetFovY(a)
    {
        this._fovY =
        a;
        this._tan_fovY_2 = Math.tan(this._fovY / 2)
    }
    GetFovY()
    {
        return this._fovY
    }
    _GetTanFovYDiv2()
    {
        return this._tan_fovY_2
    }
    SetZAxisScaleNormalized()
    {
        this._zAxisScale = !1
    }
    SetZAxisScaleRegular()
    {
        this._zAxisScale = !0
    }
    IsZAxisScaleNormalized()
    {
        return !this._zAxisScale
    }
    IsZAxisScaleRegular()
    {
        return this._zAxisScale
    }
    CalculatePerspectiveMatrix(a, b, c=.5, d=.5)
    {
        const e = this.GetNearZ(),
            f = this.GetFarZ();
        var g = this.GetFovY();
        if (.5 === c && .5 === d)
            this.IsWebGPU() ? mat4$jscomp$1.perspectiveZO(a, g, b, e, f) : mat4$jscomp$1.perspective(a,
            g, b, e, f);
        else {
            c = 1 - c;
            g = 2 * c - 2;
            c *= 2;
            const h = 2 * d - 2;
            d *= 2;
            const k = this._GetTanFovYDiv2() * e;
            b *= k;
            mat4$jscomp$1.frustum(a, g * b, c * b, h * k, d * k, e, f);
            this.IsWebGPU() && mat4$jscomp$1.mul(a, matWebGLtoWebGPU, a)
        }
    }
    CalculateOrthographicMatrix(a, b, c, d=1)
    {
        var e = self.devicePixelRatio;
        const f = 2 * this.GetDefaultCameraZ(c) * e * this._GetTanFovYDiv2() / c;
        b = b * f / (2 * e * d);
        c = c * f / (2 * e * d);
        d = -b;
        e = -c;
        this.IsWebGPU() ? mat4$jscomp$1.orthoZO(a, d, b, e, c, this.GetNearZ(), this.GetFarZ()) : mat4$jscomp$1.ortho(a, d, b, e, c, this.GetNearZ(), this.GetFarZ())
    }
    CalculateLookAtModelView(a,
    b, c, d, e, f=1)
    {
        let g = 1;
        this.IsZAxisScaleNormalized() && (g = 200 * this._GetTanFovYDiv2() / e);
        vec3$jscomp$1.set(tmpVec3c, g, -g, 1);
        vec3$jscomp$1.multiply(tmpVec3a, b, tmpVec3c);
        vec3$jscomp$1.multiply(tmpVec3b, c, tmpVec3c);
        mat4$jscomp$1.lookAt(a, tmpVec3a, tmpVec3b, d || defaultUpVector);
        tmpVec3c[2] = f;
        mat4$jscomp$1.scale(a, a, tmpVec3c)
    }
    CalculateLookAtModelView2(a, b, c, d, e, f, g, h)
    {
        vec3$jscomp$1.set(tmpVec3a, a, b, c);
        vec3$jscomp$1.set(tmpVec3b, d, e, f);
        this.CalculateLookAtModelView(tempMat4$jscomp$1, tmpVec3a, tmpVec3b, defaultUpVector,
        g, h);
        return tempMat4$jscomp$1
    }
    _AddShaderProgram(a)
    {
        this._allShaderPrograms.push(a);
        this._shaderProgramsByName.set(a.GetName(), a)
    }
    _RemoveShaderProgram(a)
    {
        const b = this._allShaderPrograms.indexOf(a);
        -1 !== b && this._allShaderPrograms.splice(b, 1);
        this._shaderProgramsByName.delete(a.GetName())
    }
    _ClearAllShaderPrograms()
    {
        C3$jscomp$45.clearArray(this._allShaderPrograms);
        this._shaderProgramsByName.clear()
    }
    GetShaderProgramByName(a)
    {
        return this._shaderProgramsByName.get(a) || null
    }
    GetTextureFillShaderProgram()
    {
        return this._spTextureFill
    }
    SetTextureFillMode()
    {
        this.SetProgram(this._spTextureFill)
    }
    GetPointsRenderingProgram()
    {
        return this._spPoints
    }
    SetPointsRenderingProgram()
    {
        this.SetProgram(this._spPoints)
    }
    SetTilemapFillMode()
    {
        this.SetProgram(this._spTilemapFill)
    }
    SetTileRandomizationMode()
    {
        this.SetProgram(this._spTileRandomization)
    }
    SetColorFillMode()
    {
        this.SetProgram(this._spColorFill)
    }
    SetLinearGradientFillMode()
    {
        this.SetProgram(this._spLinearGradientFill)
    }
    SetPenumbraFillMode()
    {
        this.SetProgram(this._spPenumbraFill)
    }
    SetHardEllipseFillMode()
    {
        this.SetProgram(this._spHardEllipseFill)
    }
    SetHardEllipseOutlineMode()
    {
        this.SetProgram(this._spHardEllipseOutline)
    }
    SetSmoothEllipseFillMode()
    {
        this.SetProgram(this._spSmoothEllipseFill)
    }
    SetSmoothEllipseOutlineMode()
    {
        this.SetProgram(this._spSmoothEllipseOutline)
    }
    SetSmoothLineFillMode()
    {
        this.SetProgram(this._spSmoothLineFill)
    }
    _SetCurrentStateGroup(a)
    {
        this._currentStateGroup =
        a
    }
    GetCurrentStateGroup()
    {
        return this._currentStateGroup
    }
    AcquireStateGroup(a, b, c, d)
    {
        const e = C3$jscomp$45.Gfx.StateGroup.MakeKey(a, b, c, d);
        let f = this._stateGroups.get(e);
        f || (f = C3$jscomp$45.New(C3$jscomp$45.Gfx.StateGroup, this, a, b, c, d), this._stateGroups.set(e, f));
        f.AddRef();
        return f
    }
    ReleaseStateGroup(a)
    {
        a.DecRef();
        0 === a._GetRefCount() && (this._currentStateGroup === a && (this._currentStateGroup = null), this._stateGroups.delete(a.GetKey()), a.Release())
    }
    _InitBlendModeData(a)
    {
        C3$jscomp$45.clearArray(this._blendModeTable);
        this._namedBlendModeMap.clear();
        let b = 0;
        for (const c of a) {
            a = c[0];
            const d = c[1],
                e = c[2];
            this._blendModeTable.push([d, e]);
            this._namedBlendModeMap.set(a, {
                number: b,
                srcBlend: d,
                destBlend: e
            });
            b++
        }
    }
    _GetBlendByIndex(a)
    {
        return this._blendModeTable[a]
    }
    GetSrcBlendByIndex(a)
    {
        return this._GetBlendByIndex(a)[0]
    }
    GetDestBlendByIndex(a)
    {
        return this._GetBlendByIndex(a)[1]
    }
    GetNamedBlend(a)
    {
        a = this._namedBlendModeMap.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid blend name");
        return a
    }
    NamedBlendToNumber(a)
    {
        a = this._namedBlendModeMap.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid blend name");
        return a.number
    }
    SetBaseZ(a)
    {
        this._baseZ = a
    }
    GetBaseZ()
    {
        return this._baseZ
    }
    SetCurrentZ(a)
    {
        this._currentZ = a;
        this._currentStateGroup = null
    }
    GetCurrentZ()
    {
        return this._currentZ
    }
    Line(a, b, c, d)
    {
        var e = C3$jscomp$45.angleTo(a, b, c, d),
            f = .5 * this._lineWidth;
        const g = Math.sin(e) * f;
        e = Math.cos(e) * f;
        f = this._lineCap;
        2 === f ? this.LinePreCalc_LineCap2(a, b, 0, c, d, 0, g, e) : 1 === f ? this.LinePreCalc_LineCap1(a, b, 0, c, d, 0, g, e) : this.LinePreCalc_LineCap0(a, b, 0, c, d, 0, g, e)
    }
    Line3D(a,
    b, c, d, e, f)
    {
        var g = C3$jscomp$45.angleTo(a, b, d, e),
            h = .5 * this._lineWidth;
        const k = Math.sin(g) * h;
        g = Math.cos(g) * h;
        h = this._lineCap;
        2 === h ? this.LinePreCalc_LineCap2(a, b, c, d, e, f, k, g) : 1 === h ? this.LinePreCalc_LineCap1(a, b, c, d, e, f, k, g) : this.LinePreCalc_LineCap0(a, b, c, d, e, f, k, g)
    }
    LinePreCalc_LineCap2(a, b, c, d, e, f, g, h)
    {
        var k = this._lineOffset;
        a = a + k - h;
        b = b + k - g;
        d = d + k + h;
        e = e + k + g;
        k = 2 * h;
        const l = 2 * g;
        this.Quad3D2(a + g, b - h, c, d + g, e - h, f, d - g - k, e + h - l, f, a - g + k, b + h + l, c, defaultTexCoordsQuad)
    }
    LinePreCalc_LineCap1(a, b, c, d, e, f, g, h)
    {
        const k =
        this._lineOffset;
        a = a + k - h;
        b = b + k - g;
        d = d + k + h;
        e = e + k + g;
        this.Quad3D2(a + g, b - h, c, d + g, e - h, f, d - g, e + h, f, a - g, b + h, c, defaultTexCoordsQuad)
    }
    LinePreCalc_LineCap0(a, b, c, d, e, f, g, h)
    {
        const k = this._lineOffset;
        a += k;
        b += k;
        d += k;
        e += k;
        this.Quad3D2(a + g, b - h, c, d + g, e - h, f, d - g, e + h, f, a - g, b + h, c, defaultTexCoordsQuad)
    }
    TexturedLine(a, b, c, d, e, f)
    {
        var g = C3$jscomp$45.angleTo(a, b, c, d),
            h = .5 * this._lineWidth;
        const k = Math.sin(g) * h;
        g = Math.cos(g) * h;
        h = this._lineCap;
        2 === h ? this.TexturedLinePreCalc_LineCap2(a, b, c, d, k, g, e, f) : 1 === h ? this.TexturedLinePreCalc_LineCap1(a,
        b, c, d, k, g, e, f) : this.TexturedLinePreCalc_LineCap0(a, b, c, d, k, g, e, f)
    }
    TexturedLinePreCalc_LineCap2(a, b, c, d, e, f, g, h)
    {
        var k = this._lineOffset;
        a = a + k - f;
        b = b + k - e;
        c = c + k + f;
        d = d + k + e;
        k = 2 * f;
        const l = 2 * e;
        tmpQuad.set(a + e, b - f, c + e, d - f, c - e - k, d + f - l, a - e + k, b + f + l);
        tmpRect.set(g, 0, h, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    TexturedLinePreCalc_LineCap1(a, b, c, d, e, f, g, h)
    {
        const k = this._lineOffset;
        a = a + k - f;
        b = b + k - e;
        c = c + k + f;
        d = d + k + e;
        tmpQuad.set(a + e, b - f, c + e, d - f, c - e, d + f, a - e, b + f);
        tmpRect.set(g, 0, h, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    TexturedLinePreCalc_LineCap0(a,
    b, c, d, e, f, g, h)
    {
        const k = this._lineOffset;
        a += k;
        b += k;
        c += k;
        d += k;
        tmpQuad.set(a + e, b - f, c + e, d - f, c - e, d + f, a - e, b + f);
        tmpRect.set(g, 0, h, 0);
        this.Quad3(tmpQuad, tmpRect)
    }
    LineRect(a, b, c, d)
    {
        const e = .5 * this._lineWidth,
            f = this._lineCap;
        2 === f ? this._LineRectPreCalc_LineCap2(a, b, c, d, e) : 1 === f ? this._LineRectPreCalc_LineCap1(a, b, c, d, e) : this._LineRectPreCalc_LineCap0(a, b, c, d, e)
    }
    _LineRectPreCalc_LineCap2(a, b, c, d, e)
    {
        this.LinePreCalc_LineCap2(a, b, 0, c, b, 0, 0, e);
        this.LinePreCalc_LineCap2(c, b, 0, c, d, 0, e, 0);
        this.LinePreCalc_LineCap2(c,
        d, 0, a, d, 0, 0, -e);
        this.LinePreCalc_LineCap2(a, d, 0, a, b, 0, -e, 0)
    }
    _LineRectPreCalc_LineCap1(a, b, c, d, e)
    {
        this.LinePreCalc_LineCap1(a, b, 0, c, b, 0, 0, e);
        this.LinePreCalc_LineCap1(c, b, 0, c, d, 0, e, 0);
        this.LinePreCalc_LineCap1(c, d, 0, a, d, 0, 0, -e);
        this.LinePreCalc_LineCap1(a, d, 0, a, b, 0, -e, 0)
    }
    _LineRectPreCalc_LineCap0(a, b, c, d, e)
    {
        this.LinePreCalc_LineCap0(a, b, 0, c, b, 0, 0, e);
        this.LinePreCalc_LineCap0(c, b, 0, c, d, 0, e, 0);
        this.LinePreCalc_LineCap0(c, d, 0, a, d, 0, 0, -e);
        this.LinePreCalc_LineCap0(a, d, 0, a, b, 0, -e, 0)
    }
    LineRect2(a)
    {
        this.LineRect(a.getLeft(),
        a.getTop(), a.getRight(), a.getBottom())
    }
    LineQuad(a)
    {
        var b = C3$jscomp$45.angleTo(a.getTlx(), a.getTly(), a.getTrx(), a.getTry()),
            c = .5 * this._lineWidth;
        const d = Math.sin(b) * c;
        b = Math.cos(b) * c;
        c = this._lineCap;
        2 === c ? this._LineQuadPreCalc_LineCap2(a, d, b) : 1 === c ? this._LineQuadPreCalc_LineCap1(a, d, b) : this._LineQuadPreCalc_LineCap0(a, d, b)
    }
    _LineQuadPreCalc_LineCap2(a, b, c)
    {
        this.LinePreCalc_LineCap2(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, c);
        this.LinePreCalc_LineCap2(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(),
        0, c, -b);
        this.LinePreCalc_LineCap2(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -c);
        this.LinePreCalc_LineCap2(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -c, b)
    }
    _LineQuadPreCalc_LineCap1(a, b, c)
    {
        this.LinePreCalc_LineCap1(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, c);
        this.LinePreCalc_LineCap1(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, c, -b);
        this.LinePreCalc_LineCap1(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -c);
        this.LinePreCalc_LineCap1(a.getBlx(), a.getBly(), 0, a.getTlx(),
        a.getTly(), 0, -c, b)
    }
    _LineQuadPreCalc_LineCap0(a, b, c)
    {
        this.LinePreCalc_LineCap0(a.getTlx(), a.getTly(), 0, a.getTrx(), a.getTry(), 0, b, c);
        this.LinePreCalc_LineCap0(a.getTrx(), a.getTry(), 0, a.getBrx(), a.getBry(), 0, c, -b);
        this.LinePreCalc_LineCap0(a.getBrx(), a.getBry(), 0, a.getBlx(), a.getBly(), 0, -b, -c);
        this.LinePreCalc_LineCap0(a.getBlx(), a.getBly(), 0, a.getTlx(), a.getTly(), 0, -c, b)
    }
    SetLineWidth(a)
    {
        this._lineWidth = a;
        this._lineWidthStack[this._lineWidthStack.length - 1] = a
    }
    GetLineWidth()
    {
        return this._lineWidth
    }
    PushLineWidth(a)
    {
        if (100 <=
        this._lineWidthStack.length)
            throw Error("pushed too many line widths - check push/pop pairs");
        this._lineWidthStack.push(a);
        this._lineWidth = a
    }
    PopLineWidth()
    {
        if (1 >= this._lineWidthStack.length)
            throw Error("cannot pop last line width - check push/pop pairs");
        this._lineWidthStack.pop();
        this._lineWidth = this._lineWidthStack.at(-1)
    }
    SetLineCapButt()
    {
        this._lineCap = 0;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapSquare()
    {
        this._lineCap = 1;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    SetLineCapZag()
    {
        this._lineCap =
        2;
        this._lineCapStack[this._lineCapStack.length - 1] = 0
    }
    PushLineCap(a)
    {
        if ("butt" === a)
            this.PushLineCapButt();
        else if ("square" === a)
            this.PushLineCapSquare();
        else if ("zag" === a)
            this.PushLineCapZag();
        else
            throw Error("invalid line cap");
    }
    PushLineCapButt()
    {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(0);
        this._lineCap = 0
    }
    PushLineCapSquare()
    {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(1);
        this._lineCap = 1
    }
    PushLineCapZag()
    {
        if (100 <= this._lineCapStack.length)
            throw Error("pushed too many line caps - check push/pop pairs");
        this._lineCapStack.push(2);
        this._lineCap = 2
    }
    PopLineCap()
    {
        if (1 >= this._lineCapStack.length)
            throw Error("cannot pop last line cap - check push/pop pairs");
        this._lineCapStack.pop();
        this._lineCap = this._lineCapStack.at(-1)
    }
    SetLineOffset(a)
    {
        this._lineOffset = a;
        this._lineOffsetStack[this._lineOffsetStack.length - 1] = a
    }
    GetLineOffset()
    {
        return this._lineOffset
    }
    PushLineOffset(a)
    {
        if (100 <=
        this._lineOffsetStack.length)
            throw Error("pushed too many line offsets - check push/pop pairs");
        this._lineOffsetStack.push(a);
        this._lineOffset = a
    }
    PopLineOffset()
    {
        if (1 >= this._lineOffsetStack.length)
            throw Error("cannot pop last line offset - check push/pop pairs");
        this._lineOffsetStack.pop();
        this._lineOffset = this._lineOffsetStack.at(-1)
    }
    ConvexPoly(a)
    {
        var b = a.length / 2;
        if (3 > b)
            throw Error("need at least 3 points");
        b -= 2;
        const c = b - 1,
            d = a[0],
            e = a[1];
        for (let f = 0; f < b; f += 2) {
            const g = 2 * f,
                h = a[g + 2],
                k = a[g + 3],
                l = a[g +
                4],
                m = a[g + 5];
            f === c ? this.Quad2(d, e, h, k, l, m, l, m) : this.Quad2(d, e, h, k, l, m, a[g + 6], a[g + 7])
        }
    }
    GetNumVertexComponents()
    {
        return 3
    }
    Finish()
    {
        this.EndBatch(!0);
        this._frameNumber++
    }
    GetFrameNumber()
    {
        return this._frameNumber
    }
    IncrementFrameNumber()
    {
        this._frameNumber++
    }
    SetMipmapsEnabled(a)
    {
        this._enableMipmaps = !!a
    }
    AreMipmapsEnabled()
    {
        return this._enableMipmaps
    }
    SetHasMajorPerformanceCaveat(a)
    {
        this._hasMajorPerformanceCaveat = !!a
    }
    HasMajorPerformanceCaveat()
    {
        return this._hasMajorPerformanceCaveat
    }
    IsWebGL()
    {
        return !1
    }
    IsWebGPU()
    {
        return !1
    }
    GetEstimatedBackBufferMemoryUsage() {}
    GetEstimatedRenderBufferMemoryUsage() {}
    GetEstimatedTextureMemoryUsage() {}
    GetEstimatedTotalMemoryUsage()
    {
        return this.GetEstimatedBackBufferMemoryUsage() +
        this.GetEstimatedRenderBufferMemoryUsage() + this.GetEstimatedTextureMemoryUsage()
    }
    CreateRendererText()
    {
        return C3$jscomp$45.New(C3$jscomp$45.Gfx.RendererText, this)
    }
}
;
"use strict";
self.C3.Gfx.ShaderProgramBase = class {
    constructor(a, b)
    {
        this._name = b.name;
        this._renderer = a;
        this._extendBoxHorizontal = b.extendBoxHorizontal || 0;
        this._extendBoxVertical = b.extendBoxVertical || 0;
        this._crossSampling = !!b.crossSampling;
        this._mustPreDraw = !!b.mustPreDraw;
        this._preservesOpaqueness = !!b.preservesOpaqueness;
        this._supports3dDirectRendering = !!b.supports3dDirectRendering;
        this._animated = !!b.animated;
        this._blendsBackground = !!b.blendsBackground;
        this._usesDepth = !!b.usesDepth;
        this._usesAnySrcRectOrPixelSize =
        !1;
        this._needsPostDrawOrExtendBox = this._crossSampling || this._blendsBackground || 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    Release()
    {
        this._renderer = null
    }
    GetRenderer()
    {
        return this._renderer
    }
    GetName()
    {
        return this._name
    }
    ExtendsBox()
    {
        return 0 !== this._extendBoxHorizontal || 0 !== this._extendBoxVertical
    }
    GetBoxExtendHorizontal()
    {
        return this._extendBoxHorizontal
    }
    GetBoxExtendVertical()
    {
        return this._extendBoxVertical
    }
    UsesCrossSampling()
    {
        return this._crossSampling
    }
    MustPreDraw()
    {
        return this._mustPreDraw
    }
    PreservesOpaqueness()
    {
        return this._preservesOpaqueness
    }
    Supports3DDirectRendering()
    {
        return this._supports3dDirectRendering
    }
    IsAnimated()
    {
        return this._animated
    }
    BlendsBackground()
    {
        return this._blendsBackground
    }
    UsesDepth()
    {
        return this._usesDepth
    }
    UsesAnySrcRectOrPixelSize()
    {
        return this._usesAnySrcRectOrPixelSize
    }
    NeedsPostDrawOrExtendsBox()
    {
        return this._needsPostDrawOrExtendBox
    }
    UsesIsSrcTexRotated()
    {
        return !1
    }
}
;
"use strict";
const C3$jscomp$47 = self.C3;
C3$jscomp$47.Gfx.StateGroup = class {
    constructor(a, b, c, d, e)
    {
        this._renderer = a;
        this._refCount = 0;
        this._shaderProgram = null;
        this._shaderProgramName = "";
        this._blendMode = c;
        this._color = C3$jscomp$47.New(C3$jscomp$47.Color);
        this._color.set(d);
        this._zElevation = e;
        "string" === typeof b ? this._shaderProgramName = b : (this._shaderProgram = b, this._shaderProgramName = this._shaderProgram.GetName())
    }
    Release()
    {
        if (0 < this._refCount)
            throw Error("releasing state group still in use");
        this._shaderProgram = this._renderer = null;
        this._shaderProgramName =
        ""
    }
    Apply()
    {
        const a = this._renderer;
        a.SetProgram(this._shaderProgram);
        a.SetBlendMode(this._blendMode);
        a.SetColor(this._color);
        a.SetCurrentZ(this._zElevation);
        a._SetCurrentStateGroup(this)
    }
    GetKey()
    {
        return C3$jscomp$47.Gfx.StateGroup.MakeKey(this._shaderProgramName, this._blendMode, this._color, this._zElevation)
    }
    AddRef()
    {
        ++this._refCount
    }
    DecRef()
    {
        --this._refCount
    }
    _GetRefCount()
    {
        return this._refCount
    }
    OnContextLost()
    {
        this._shaderProgram = null
    }
    OnContextRestored(a)
    {
        this._shaderProgram = a.GetShaderProgramByName(this._shaderProgramName);
        if (!this._shaderProgram)
            throw Error("failed to restore shader program");
    }
    static MakeKey(a, b, c, d)
    {
        return ("string" === typeof a ? a : a.GetName()) + "," + b + "," + c.getR() + "," + c.getG() + "," + c.getB() + "," + c.getA() + "," + d
    }
}
;
"use strict";
const C3$jscomp$48 = self.C3,
    tempQuadTex = C3$jscomp$48.New(C3$jscomp$48.Quad);
function interpolateQuad(a, b, c) {
    const d = c.getTlx(),
        e = c.getTly(),
        f = c.getTrx() - d,
        g = c.getTry() - e,
        h = c.getBlx() - d;
    c = c.getBly() - e;
    return [d + f * a + h * b, e + g * a + c * b]
}
C3$jscomp$48.Gfx.MeshPoint = class {
    constructor(a, b, c)
    {
        this._mesh = a;
        this._col = b;
        this._row = c;
        this._v = this._u = this._zElevation = this._y = this._x = 0
    }
    _Init(a, b, c, d)
    {
        this._x = a;
        this._y = b;
        this._u = c;
        this._v = d
    }
    GetX()
    {
        return this._x
    }
    SetX(a)
    {
        this._x !== a && (this._x = a, this._mesh._SetPointsChanged())
    }
    GetY()
    {
        return this._y
    }
    SetY(a)
    {
        this._y !== a && (this._y = a, this._mesh._SetPointsChanged())
    }
    GetZElevation()
    {
        return this._zElevation
    }
    SetZElevation(a)
    {
        this._zElevation !== a && (this._zElevation = Math.max(a, 0), this._mesh._SetPointsChanged())
    }
    GetU()
    {
        return this._u
    }
    SetU(a)
    {
        this._u =
        a
    }
    GetV()
    {
        return this._v
    }
    SetV(a)
    {
        this._v = a
    }
    _Interpolate_TexRect(a, b, c)
    {
        [this._x, this._y] = interpolateQuad(a._x, a._y, b);
        this._zElevation = a._zElevation;
        this._u = C3$jscomp$48.lerp(c.getLeft(), c.getRight(), a._u);
        this._v = C3$jscomp$48.lerp(c.getTop(), c.getBottom(), a._v)
    }
    _Interpolate_TexQuad(a, b, c)
    {
        [this._x, this._y] = interpolateQuad(a._x, a._y, b);
        this._zElevation = a._zElevation;
        [this._u, this._v] = interpolateQuad(a._u, a._v, c)
    }
    SaveToJson()
    {
        return {
            x: this.GetX(),
            y: this.GetY(),
            z: this.GetZElevation(),
            u: this.GetU(),
            v: this.GetV()
        }
    }
    LoadFromJson(a)
    {
        this.SetX(a.x);
        this.SetY(a.y);
        a.hasOwnProperty("z") && this.SetZElevation(a.z);
        this.SetU(a.u);
        this.SetV(a.v)
    }
    GetMesh()
    {
        return this._mesh
    }
    GetColumn()
    {
        return this._col
    }
    GetRow()
    {
        return this._row
    }
}
;
C3$jscomp$48.Gfx.Mesh = class {
    constructor(a, b, c)
    {
        if (2 > a || 2 > b)
            throw Error("invalid mesh size");
        this._hsize = a;
        this._vsize = b;
        this._owner = c || null;
        this._pts = [];
        this._minY = this._minX = 0;
        this._maxY = this._maxX = 1;
        this._maxZ = 0;
        this._pointsChanged = !1;
        c = a - 1;
        const d = b - 1;
        for (let e = 0; e < b; ++e) {
            const f = [];
            for (let g = 0; g < a; ++g) {
                const h = C3$jscomp$48.New(C3$jscomp$48.Gfx.MeshPoint, this, g, e),
                    k = g / c,
                    l = e / d;
                h._Init(k, l, k, l);
                f.push(h)
            }
            this._pts.push(f)
        }
    }
    Release()
    {
        C3$jscomp$48.clearArray(this._pts)
    }
    GetHSize()
    {
        return this._hsize
    }
    GetVSize()
    {
        return this._vsize
    }
    GetOwner()
    {
        return this._owner
    }
    _GetPoints()
    {
        return this._pts
    }
    _SetPointsChanged()
    {
        this._pointsChanged =
        !0
    }
    _MaybeComputeBounds()
    {
        if (this._pointsChanged) {
            var a = Infinity,
                b = Infinity,
                c = -Infinity,
                d = -Infinity,
                e = 0;
            for (const f of this._pts)
                for (const g of f) {
                    const h = g.GetX(),
                        k = g.GetY();
                    a = Math.min(a, h);
                    b = Math.min(b, k);
                    c = Math.max(c, h);
                    d = Math.max(d, k);
                    e = Math.max(e, g.GetZElevation())
                }
            this._minX = a;
            this._minY = b;
            this._maxX = c;
            this._maxY = d;
            this._maxZ = e;
            this._pointsChanged = !1
        }
    }
    GetMinX()
    {
        this._MaybeComputeBounds();
        return this._minX
    }
    GetMinY()
    {
        this._MaybeComputeBounds();
        return this._minY
    }
    GetMaxX()
    {
        this._MaybeComputeBounds();
        return this._maxX
    }
    GetMaxY()
    {
        this._MaybeComputeBounds();
        return this._maxY
    }
    GetMaxZ()
    {
        this._MaybeComputeBounds();
        return this._maxZ
    }
    HasAnyZElevation()
    {
        return 0 < this.GetMaxZ()
    }
    GetMeshPointAt(a, b)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        return 0 > a || a >= this._hsize || 0 > b || b >= this._vsize ? null : this._pts[b][a]
    }
    CalculateTransformedMesh(a, b, c)
    {
        const d = c instanceof C3$jscomp$48.Rect;
        if (a.GetHSize() !== this.GetHSize() || a.GetVSize() !== this.GetVSize())
            throw Error("source mesh wrong size");
        a = a._pts;
        const e = this._pts;
        for (let f =
            0, g = e.length; f < g; ++f) {
            const h = a[f],
                k = e[f];
            for (let l = 0, m = k.length; l < m; ++l) {
                const n = h[l],
                    p = k[l];
                d ? p._Interpolate_TexRect(n, b, c) : p._Interpolate_TexQuad(n, b, c)
            }
        }
    }
    Draw(a)
    {
        const b = this._pts;
        let c = b[0];
        for (let d = 1, e = b.length; d < e; ++d) {
            const f = b[d];
            let g = c[0],
                h = f[0];
            for (let k = 1, l = f.length; k < l; ++k) {
                const m = c[k],
                    n = f[k];
                tempQuadTex.set(g.GetU(), g.GetV(), m.GetU(), m.GetV(), n.GetU(), n.GetV(), h.GetU(), h.GetV());
                a.Quad3D2(g.GetX(), g.GetY(), g.GetZElevation(), m.GetX(), m.GetY(), m.GetZElevation(), n.GetX(), n.GetY(), n.GetZElevation(),
                h.GetX(), h.GetY(), h.GetZElevation(), tempQuadTex);
                g = m;
                h = n
            }
            c = f
        }
    }
    Outline(a, b)
    {
        b || (b = (e, f, g) => [e, f, g]);
        const c = this._pts;
        let d = c[0];
        for (let e = 1, f = c.length; e < f; ++e) {
            const g = c[e];
            let h = d[0],
                k = g[0];
            for (let l = 1, m = g.length; l < m; ++l) {
                const n = d[l],
                    p = g[l],
                    [q, r, t] = b(h.GetX(), h.GetY(), h.GetZElevation()),
                    [u, v, w] = b(n.GetX(), n.GetY(), n.GetZElevation()),
                    [x, y, z] = b(p.GetX(), p.GetY(), p.GetZElevation()),
                    [A, B, C] = b(k.GetX(), k.GetY(), k.GetZElevation());
                a.Line3D(q, r, t, u, v, w);
                a.Line3D(q, r, t, x, y, z);
                a.Line3D(q, r, t, A, B, C);
                l ===
                m - 1 && a.Line3D(u, v, w, x, y, z);
                e === f - 1 && a.Line3D(A, B, C, x, y, z);
                h = n;
                k = p
            }
            d = g
        }
    }
    InsertPolyMeshVertices(a)
    {
        a = a.pointsArr();
        const b = [],
            c = this.GetHSize() - 1,
            d = this.GetVSize() - 1,
            e = 1 / c,
            f = 1 / d,
            g = c - 1,
            h = d - 1;
        let k = a[0],
            l = a[1],
            m = C3$jscomp$48.clamp(Math.floor(k * c), 0, g),
            n = C3$jscomp$48.clamp(Math.floor(l * d), 0, h),
            p = 0,
            q = 0,
            r = 0;
        var t = -1;
        const u = () => {
            k = C3$jscomp$48.clamp(C3$jscomp$48.lerp(k, p, r), 0, 1);
            l = C3$jscomp$48.clamp(C3$jscomp$48.lerp(l, q, r), 0, 1);
            b.push(k, l)
        };
        for (let v = 0, w = a.length; v < w; v += 2)
            for (k = a[v], l = a[v + 1], b.push(k, l),
            m = C3$jscomp$48.clamp(Math.floor(k * c), 0, g), n = C3$jscomp$48.clamp(Math.floor(l * d), 0, h), t = (v + 2) % w, p = a[t], q = a[t + 1], t = -1;;) {
                if (1E6 < b.length)
                    throw Error("Too many mesh poly points");
                const x = m * e,
                    y = n * f,
                    z = (m + 1) * e,
                    A = (n + 1) * f;
                C3$jscomp$48.isPointInTriangleInclusive(k, l, x, y, z, y, z, A);
                if (0 !== t && (r = C3$jscomp$48.rayIntersectExtended(k, l, p, q, x, y, z, A, -.001), 0 <= r && .99999999 >= r)) {
                    u();
                    t = 0;
                    continue
                }
                if (0 < n && 2 !== t && (r = C3$jscomp$48.rayIntersectExtended(k, l, p, q, x, y, z, y, .001), 0 <= r && .99999999 >= r)) {
                    u();
                    n--;
                    t = 4;
                    continue
                }
                if (m < g &&
                3 !== t && (r = C3$jscomp$48.rayIntersectExtended(k, l, p, q, z, y, z, A, .001), 0 <= r && .99999999 >= r)) {
                    u();
                    m++;
                    t = 1;
                    continue
                }
                if (0 < m && 1 !== t && (r = C3$jscomp$48.rayIntersectExtended(k, l, p, q, x, y, x, A, .001), 0 <= r && .99999999 >= r)) {
                    u();
                    m--;
                    t = 3;
                    continue
                }
                if (n < h && 4 !== t && (r = C3$jscomp$48.rayIntersectExtended(k, l, p, q, x, A, z, A, .001), 0 <= r && .99999999 >= r)) {
                    u();
                    n++;
                    t = 2;
                    continue
                }
                break
            }
        return C3$jscomp$48.New(C3$jscomp$48.CollisionPoly, b)
    }
    TransformCollisionPoly(a, b)
    {
        a = this._TransformPolyPoints(a);
        this._SimplifyPoly(a);
        b.setPoints(a)
    }
    _TransformPolyPoints(a)
    {
        const b =
        [];
        a = a.pointsArr();
        for (let c = 0, d = a.length; c < d; c += 2) {
            const [e, f] = this.TransformPoint(a[c], a[c + 1]);
            b.push(e, f)
        }
        return b
    }
    TransformPoint(a, b)
    {
        var c = this.GetHSize() - 1,
            d = this.GetVSize() - 1,
            e = 1 / c,
            f = 1 / d;
        c = C3$jscomp$48.clamp(Math.floor(a * c), 0, c - 1);
        const g = C3$jscomp$48.clamp(Math.floor(b * d), 0, d - 1);
        d = c * e;
        const h = g * f,
            k = (c + 1) * e,
            l = (g + 1) * f,
            m = this.GetMeshPointAt(c, g),
            n = this.GetMeshPointAt(c + 1, g + 1),
            p = C3$jscomp$48.isPointInTriangleInclusive(a, b, d, h, k, h, k, l);
        e = p ? d + e : d;
        f = p ? h : h + f;
        c = this.GetMeshPointAt(c + (p ? 1 : 0), g + (p ? 0 :
        1));
        const [q, r, t] = C3$jscomp$48.triangleCartesianToBarycentric(a, b, d, h, e, f, k, l);
        return C3$jscomp$48.triangleBarycentricToCartesian3d(q, r, t, m.GetX(), m.GetY(), m.GetZElevation(), c.GetX(), c.GetY(), c.GetZElevation(), n.GetX(), n.GetY(), n.GetZElevation())
    }
    _SimplifyPoly(a)
    {
        const b = [];
        let c = a[0],
            d = a[1],
            e = c - a.at(-2),
            f = d - a.at(-1);
        for (let h = 0, k = a.length; h < k; h += 2) {
            var g = (h + 2) % k;
            const l = a[g];
            g = a[g + 1];
            const m = l - c,
                n = g - d,
                p = 1E-7 > Math.abs(n) && 1E-7 > Math.abs(f) && Math.sign(m) === Math.sign(e);
            (!(1E-7 > Math.abs(m) && 1E-7 > Math.abs(e) &&
            Math.sign(n) === Math.sign(f) || p) && .001 < Math.abs(m / e - n / f) || 0 == m && 0 === n) && b.push(c, d);
            c = l;
            d = g;
            e = m;
            f = n
        }
        6 <= b.length && b.length < a.length && C3$jscomp$48.shallowAssignArray(a, b)
    }
    SaveToJson()
    {
        return {
            cols: this.GetHSize(),
            rows: this.GetVSize(),
            points: this._pts.map(a => a.map(b => b.SaveToJson()))
        }
    }
    LoadFromJson(a)
    {
        const b = this.GetHSize(),
            c = this.GetVSize();
        if (a.cols !== b || a.rows !== c)
            throw Error("mesh data wrong size");
        a = a.points;
        for (let d = 0; d < c; ++d) {
            const e = a[d];
            for (let f = 0; f < b; ++f)
                this.GetMeshPointAt(f, d).LoadFromJson(e[f])
        }
    }
}
;
"use strict";
const C3$jscomp$49 = self.C3,
    VALID_PIXEL_FORMATS = new Set(["rgba8", "rgb8", "rgba4", "rgb5_a1", "rgb565"]),
    VALID_SAMPLINGS = new Set(["nearest", "bilinear", "trilinear"]),
    VALID_MIPMAP_QUALITIES = new Set(["default", "low", "high"]),
    VALID_WRAP_MODES = new Set(["clamp-to-edge", "repeat", "mirror-repeat"]);
function GetFormatSpecifiers(a, b) {
    let c,
        d;
    switch (a) {
    case "rgba8":
        a = b.RGBA8;
        d = c = b.RGBA;
        b = b.UNSIGNED_BYTE;
        break;
    case "rgb8":
        a = b.RGB8;
        d = c = b.RGB;
        b = b.UNSIGNED_BYTE;
        break;
    case "rgba4":
        a = b.RGBA4;
        d = c = b.RGBA;
        b = b.UNSIGNED_SHORT_4_4_4_4;
        break;
    case "rgb5_a1":
        a = b.RGB5_A1;
        d = c = b.RGBA;
        b = b.UNSIGNED_SHORT_5_5_5_1;
        break;
    case "rgb565":
        a = b.RGB565;
        d = c = b.RGB;
        b = b.UNSIGNED_SHORT_5_6_5;
        break;
    default:
        throw Error("invalid pixel format");
    }
    return {
        sizedinternalformat: a,
        internalformat: c,
        format: d,
        type: b
    }
}
const CREATEFROM_DEFAULT_OPTIONS = {
        wrapX: "clamp-to-edge",
        wrapY: "clamp-to-edge",
        sampling: "trilinear",
        anisotropy: 0,
        pixelFormat: "rgba8",
        mipMap: !0,
        mipMapQuality: "default",
        premultiplyAlpha: !0,
        isSvg: !1,
        width: -1,
        height: -1
    },
    UPDATE_DEFAULT_OPTIONS = {
        premultiplyAlpha: !0,
        flipY: !1
    },
    allTextures = new Set;
C3$jscomp$49.Gfx.WebGLRendererTexture = class {
    constructor(a)
    {
        this._renderer = a;
        this._texture = null;
        this._height = this._width = 0;
        this._isStatic = !0;
        this._wrapY = this._wrapX = "clamp-to-edge";
        this._sampling = "trilinear";
        this._anisotropy = 0;
        this._pixelFormat = "rgba8";
        this._isMipMapped = !1;
        this._mipMapQuality = "default";
        this._refCount = 0
    }
    _CreateStatic(a, b)
    {
        if (!("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap &&
        a instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || a instanceof ImageData || a instanceof ArrayBuffer) && null !== a)
            throw Error("invalid texture source");
        b = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, b);
        if (this._texture)
            throw Error("already created texture");
        this._wrapX = b.wrapX;
        this._wrapY = b.wrapY;
        this._sampling = b.sampling;
        this._anisotropy = b.anisotropy;
        this._pixelFormat = b.pixelFormat;
        this._isMipMapped = !!b.mipMap && this._renderer.AreMipmapsEnabled();
        this._mipMapQuality =
        b.mipMapQuality;
        if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))
            throw Error("invalid wrap mode");
        if (!VALID_SAMPLINGS.has(this._sampling))
            throw Error("invalid sampling");
        if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))
            throw Error("invalid pixel format");
        if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))
            throw Error("invalid mipmap quality");
        this._isStatic = !0;
        if (a instanceof ArrayBuffer || null === a || b.isSvg) {
            if (this._width = b.width, this._height = b.height, a instanceof ArrayBuffer &&
            a.byteLength !== this._width * this._height * 4)
                throw Error("ArrayBuffer wrong size");
        } else
            this._width = a.width,
            this._height = a.height;
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid texture data size");
        if (b.isSvg) {
            var c = C3$jscomp$49.CreateCanvas(this._width, this._height);
            c.getContext("2d").drawImage(a, 0, 0, this._width, this._height);
            a = c
        }
        var d = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
        c = this._renderer.GetMaxTextureSize();
        if (this._width > c || this._height > c)
            throw Error("texture data exceeds maximum texture size");
        c = this._renderer.GetContext();
        var e = this._renderer.GetWebGLVersionNumber();
        this._texture = c.createTexture();
        c.bindTexture(c.TEXTURE_2D, this._texture);
        c.pixelStorei(c.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
        c.pixelStorei(c.UNPACK_FLIP_Y_WEBGL, !1);
        b = GetFormatSpecifiers(this._pixelFormat, c);
        if (this._renderer.SupportsNPOTTextures() || d || !this._IsTiled())
            2 <= e ? (c.texStorage2D(c.TEXTURE_2D, this._isMipMapped ? Math.floor(Math.log2(Math.max(this._width, this._height)) + 1) : 1, b.sizedinternalformat, this._width,
            this._height), a instanceof ArrayBuffer ? c.texSubImage2D(c.TEXTURE_2D, 0, 0, 0, this._width, this._height, b.format, b.type, new Uint8Array(a)) : null !== a && c.texSubImage2D(c.TEXTURE_2D, 0, 0, 0, b.format, b.type, a)) : a instanceof ArrayBuffer ? c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, this._width, this._height, 0, b.format, b.type, new Uint8Array(a)) : null === a ? c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, this._width, this._height, 0, b.format, b.type, null) : c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, b.format, b.type, a);
        else {
            if (null ===
            a)
                throw Error("cannot pass null data when creating a NPOT tiled texture without NPOT support");
            a instanceof ArrayBuffer && (a = new ImageData(new Uint8ClampedArray(a), this._width, this._height));
            a instanceof ImageData && (d = C3$jscomp$49.CreateCanvas(this._width, this._height), d.getContext("2d").putImageData(a, 0, 0), a = d);
            d = C3$jscomp$49.CreateCanvas(C3$jscomp$49.nextHighestPowerOfTwo(this._width), C3$jscomp$49.nextHighestPowerOfTwo(this._height));
            e = d.getContext("2d");
            e.imageSmoothingEnabled = "nearest" !== this._sampling;
            e.drawImage(a, 0, 0, this._width, this._height, 0, 0, d.width, d.height);
            c.texImage2D(c.TEXTURE_2D, 0, b.internalformat, b.format, b.type, d)
        }
        null !== a && this._SetTextureParameters(c);
        c.bindTexture(c.TEXTURE_2D, null);
        this._renderer._ResetLastTexture();
        this._refCount = 1;
        allTextures.add(this)
    }
    _CreateDynamic(a, b, c)
    {
        c = Object.assign({}, CREATEFROM_DEFAULT_OPTIONS, c);
        if (this._texture)
            throw Error("already created texture");
        this._wrapX = c.wrapX;
        this._wrapY = c.wrapY;
        this._sampling = c.sampling;
        this._pixelFormat = c.pixelFormat;
        this._isMipMapped = !!c.mipMap && this._renderer.AreMipmapsEnabled();
        this._mipMapQuality = c.mipMapQuality;
        if (!VALID_WRAP_MODES.has(this._wrapX) || !VALID_WRAP_MODES.has(this._wrapY))
            throw Error("invalid wrap mode");
        if (!VALID_SAMPLINGS.has(this._sampling))
            throw Error("invalid sampling");
        if (!VALID_PIXEL_FORMATS.has(this._pixelFormat))
            throw Error("invalid pixel format");
        if (!VALID_MIPMAP_QUALITIES.has(this._mipMapQuality))
            throw Error("invalid mipmap quality");
        this._isStatic = !1;
        this._width = Math.floor(a);
        this._height =
        Math.floor(b);
        a = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
        b = this._renderer.GetMaxTextureSize();
        if (0 >= this._width || 0 >= this._height)
            throw Error("invalid texture size");
        if (this._width > b || this._height > b)
            throw Error("texture exceeds maximum texture size");
        if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !a)
            throw Error("non-power-of-two tiled textures not supported");
        a = this._renderer.GetContext();
        b = this._renderer.GetWebGLVersionNumber();
        this._texture = a.createTexture();
        a.bindTexture(a.TEXTURE_2D, this._texture);
        a.pixelStorei(a.UNPACK_PREMULTIPLY_ALPHA_WEBGL, c.premultiplyAlpha);
        a.pixelStorei(a.UNPACK_FLIP_Y_WEBGL, !1);
        c = GetFormatSpecifiers(this._pixelFormat, a);
        a.texImage2D(a.TEXTURE_2D, 0, 2 <= b ? c.sizedinternalformat : c.internalformat, this._width, this._height, 0, c.format, c.type, null);
        this._SetTextureParameters(a);
        a.bindTexture(a.TEXTURE_2D, null);
        this._renderer._ResetLastTexture();
        this._refCount = 1;
        allTextures.add(this)
    }
    _GetMipMapHint(a)
    {
        if ("default" === this._mipMapQuality)
            return this._isStatic ?
            a.NICEST : a.FASTEST;
        if ("low" === this._mipMapQuality)
            return a.FASTEST;
        if ("high" === this._mipMapQuality)
            return a.NICEST;
        throw Error("invalid mipmap quality");
    }
    _IsTiled()
    {
        return "clamp-to-edge" !== this._wrapX || "clamp-to-edge" !== this._wrapY
    }
    _GetTextureWrapMode(a, b)
    {
        if ("clamp-to-edge" === b)
            return a.CLAMP_TO_EDGE;
        if ("repeat" === b)
            return a.REPEAT;
        if ("mirror-repeat" === b)
            return a.MIRRORED_REPEAT;
        throw Error("invalid wrap mode");
    }
    _SetTextureParameters(a)
    {
        var b = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, this._GetTextureWrapMode(a, this._wrapX));
        a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, this._GetTextureWrapMode(a, this._wrapY));
        "nearest" === this._sampling ? (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.NEAREST), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.NEAREST), this._isMipMapped = !1) : (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MAG_FILTER, a.LINEAR), (b || this._renderer.SupportsNPOTTextures()) && this._isMipMapped ? (a.hint(a.GENERATE_MIPMAP_HINT, this._GetMipMapHint(a)),
        a.generateMipmap(a.TEXTURE_2D), b = "trilinear" === this._sampling && !this._renderer.HasMajorPerformanceCaveat(), a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, b ? a.LINEAR_MIPMAP_LINEAR : a.LINEAR_MIPMAP_NEAREST)) : (a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR), this._isMipMapped = !1));
        (b = this._renderer._GetAnisotropicExtension()) && 0 < this._anisotropy && "nearest" !== this._sampling && a.texParameterf(a.TEXTURE_2D, b.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(this._anisotropy, this._renderer._GetMaxAnisotropy()))
    }
    _Update(a,
    b)
    {
        if (!("undefined" !== typeof HTMLImageElement && a instanceof HTMLImageElement || "undefined" !== typeof HTMLVideoElement && a instanceof HTMLVideoElement || "undefined" !== typeof HTMLCanvasElement && a instanceof HTMLCanvasElement || "undefined" !== typeof ImageBitmap && a instanceof ImageBitmap || "undefined" !== typeof OffscreenCanvas && a instanceof OffscreenCanvas || a instanceof ImageData))
            throw Error("invalid texture source");
        if (!this._texture || 0 >= this._refCount)
            throw Error("texture not created");
        if (this._isStatic)
            throw Error("cannot update static texture");
        b = Object.assign({}, UPDATE_DEFAULT_OPTIONS, b);
        const c = a.width || a.videoWidth,
            d = a.height || a.videoHeight;
        var e = this._renderer.GetWebGLVersionNumber();
        const f = this._renderer.GetContext();
        f.bindTexture(f.TEXTURE_2D, this._texture);
        f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, b.premultiplyAlpha);
        f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, !!b.flipY);
        b = GetFormatSpecifiers(this._pixelFormat, f);
        e = 2 <= e ? b.sizedinternalformat : b.internalformat;
        try {
            if (this._width === c && this._height === d) {
                const g = C3$jscomp$49.isPOT(this._width) &&
                C3$jscomp$49.isPOT(this._height);
                f.texSubImage2D(f.TEXTURE_2D, 0, 0, 0, b.format, b.type, a);
                (g || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (f.hint(f.GENERATE_MIPMAP_HINT, this._GetMipMapHint(f)), f.generateMipmap(f.TEXTURE_2D))
            } else {
                this._width = c;
                this._height = d;
                const g = C3$jscomp$49.isPOT(this._width) && C3$jscomp$49.isPOT(this._height);
                if (!this._renderer.SupportsNPOTTextures() && this._IsTiled() && !g)
                    throw Error("non-power-of-two tiled textures not supported");
                f.texImage2D(f.TEXTURE_2D, 0, e, b.format,
                b.type, a);
                (g || this._renderer.SupportsNPOTTextures()) && this._isMipMapped && (f.hint(f.GENERATE_MIPMAP_HINT, this._GetMipMapHint(f)), f.generateMipmap(f.TEXTURE_2D))
            }
        } catch (g) {
            console.error("Error updating WebGL texture: ", g)
        }
        f.bindTexture(f.TEXTURE_2D, null);
        this._renderer._ResetLastTexture()
    }
    _Delete()
    {
        if (0 < this._refCount)
            throw Error("texture still has references");
        if (!this._texture)
            throw Error("already deleted texture");
        allTextures.delete(this);
        this._renderer.GetContext().deleteTexture(this._texture);
        this._texture = null
    }
    IsValid()
    {
        return !!this._texture
    }
    _GetTexture()
    {
        return this._texture
    }
    GetRenderer()
    {
        return this._renderer
    }
    AddReference()
    {
        this._refCount++
    }
    SubtractReference()
    {
        if (0 >= this._refCount)
            throw Error("no more references");
        this._refCount--
    }
    GetReferenceCount()
    {
        return this._refCount
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    IsStatic()
    {
        return this._isStatic
    }
    GetEstimatedMemoryUsage()
    {
        let a = this._width * this._height;
        switch (this._pixelFormat) {
        case "rgba8":
            a *= 4;
            break;
        case "rgb8":
            a *=
            3;
            break;
        case "rgba4":
        case "rgb5_a1":
        case "rgb565":
            a *= 2
        }
        this._isMipMapped && (a += Math.floor(a / 3));
        return a
    }
    static OnContextLost()
    {
        allTextures.clear()
    }
    static allTextures()
    {
        return allTextures.values()
    }
}
;
"use strict";
const C3$jscomp$50 = self.C3,
    glMatrix$jscomp$2 = self.glMatrix,
    mat4$jscomp$2 = glMatrix$jscomp$2.mat4,
    VALID_SAMPLINGS$jscomp$1 = new Set(["nearest", "bilinear", "trilinear"]),
    DEFAULT_RENDERTARGET_OPTIONS = {
        sampling: "trilinear",
        alpha: !0,
        depth: !1,
        isSampled: !0,
        isDefaultSize: !0,
        multisampling: 0
    },
    allRenderTargets = new Set;
C3$jscomp$50.Gfx.WebGLRenderTarget = class {
    constructor(a)
    {
        this._renderer = a;
        this._renderBuffer = this._texture = this._frameBufferNoDepth = this._frameBuffer = null;
        this._height = this._width = 0;
        this._isDefaultSize = !0;
        this._sampling = "trilinear";
        this._alpha = !0;
        this._depth = !1;
        this._isSampled = !0;
        this._multisampling = 0;
        this._projectionMatrix = mat4$jscomp$2.create();
        this._lastFarZ = this._lastNearZ = this._lastFov = 0
    }
    _Create(a, b, c)
    {
        c = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, c);
        const d = this._renderer.GetWebGLVersionNumber();
        if (this._texture || this._renderBuffer)
            throw Error("already created render target");
        this._sampling = c.sampling;
        this._alpha = !!c.alpha;
        this._depth = !!c.depth;
        this._isSampled = !!c.isSampled;
        this._isDefaultSize = !!c.isDefaultSize;
        this._multisampling = c.multisampling;
        if (!VALID_SAMPLINGS$jscomp$1.has(this._sampling))
            throw Error("invalid sampling");
        if (0 < this._multisampling && (2 > d || this._isSampled))
            throw Error("invalid use of multisampling");
        2 > d && (this._isSampled = !0);
        this._width = a;
        this._height = b;
        if (0 >= this._width ||
        0 >= this._height)
            throw Error("invalid render target size");
        this._CalculateProjection();
        a = this._renderer.GetContext();
        this._frameBuffer = a.createFramebuffer();
        this._depth && (this._frameBufferNoDepth = a.createFramebuffer());
        this._isSampled ? (this._texture = this._renderer.CreateDynamicTexture(this._width, this._height, {
            sampling: this._sampling,
            pixelFormat: this._alpha ? "rgba8" : "rgb8",
            mipMap: !1
        }), b = this._texture._GetTexture(), a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer), a.framebufferTexture2D(a.FRAMEBUFFER,
        a.COLOR_ATTACHMENT0, a.TEXTURE_2D, b, 0), this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, b, 0))) : (this._renderBuffer = a.createRenderbuffer(), a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer), b = this._alpha ? a.RGBA8 : a.RGB8, 0 < this._multisampling && ((c = a.getInternalformatParameter(a.RENDERBUFFER, b, a.SAMPLES)) && c[0] ? (c = c[0], this._multisampling > c && (this._multisampling = c)) : this._multisampling = 0), 0 === this._multisampling ?
        a.renderbufferStorage(a.RENDERBUFFER, b, this._width, this._height) : a.renderbufferStorageMultisample(a.RENDERBUFFER, this._multisampling, b, this._width, this._height), a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, this._renderBuffer), this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, this._renderBuffer)), a.bindRenderbuffer(a.RENDERBUFFER,
        null));
        b = this._renderer._GetDepthBuffer();
        this._depth && b && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer), this._renderer._CanSampleDepth() ? a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, b, 0) : a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b));
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        allRenderTargets.add(this)
    }
    _Resize(a, b)
    {
        if (this._width !== a || this._height !== b)
            this._width = a,
            this._height = b,
            this._CalculateProjection(),
            a = this._renderer.GetContext(),
            a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer),
            this._texture ? this._texture._Update(new ImageData(this._width, this._height)) : (a.bindRenderbuffer(a.RENDERBUFFER, this._renderBuffer), a.renderbufferStorage(a.RENDERBUFFER, this._alpha ? a.RGBA8 : a.RGB8, this._width, this._height), a.bindRenderbuffer(a.RENDERBUFFER, null)),
            b = this._renderer._GetDepthBuffer(),
            this._depth && b && (this._renderer._CanSampleDepth() ? a.framebufferTexture2D(a.FRAMEBUFFER, a.DEPTH_STENCIL_ATTACHMENT, a.TEXTURE_2D, b, 0) : a.framebufferRenderbuffer(a.FRAMEBUFFER,
            a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b)),
            a.bindFramebuffer(a.FRAMEBUFFER, null)
    }
    _Delete()
    {
        if (!this._texture && !this._renderBuffer)
            throw Error("already deleted render target");
        allRenderTargets.delete(this);
        var a = this._renderer.GetContext();
        this._texture ? (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, null, 0), this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth), a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0,
        a.TEXTURE_2D, null, 0)), this._renderer.DeleteTexture(this._texture), this._texture = null) : this._renderBuffer && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBuffer), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, null), this._depth && (a.bindFramebuffer(a.FRAMEBUFFER, this._frameBufferNoDepth), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.RENDERBUFFER, null)), a.deleteRenderbuffer(this._renderBuffer), this._renderBuffer = null);
        a.bindFramebuffer(a.FRAMEBUFFER, null);
        2 <= this._renderer.GetWebGLVersionNumber() &&
        (a.bindFramebuffer(a.READ_FRAMEBUFFER, null), a.bindFramebuffer(a.DRAW_FRAMEBUFFER, null));
        a.deleteFramebuffer(this._frameBuffer);
        this._depth && a.deleteFramebuffer(this._frameBufferNoDepth);
        a = this._renderer.GetBatchState();
        a.currentFramebuffer = null;
        this._frameBuffer = a.currentFramebufferNoDepth = null
    }
    _CalculateProjection()
    {
        this._renderer.CalculatePerspectiveMatrix(this._projectionMatrix, this._width / this._height);
        this._lastFov = this._renderer.GetFovY();
        this._lastNearZ = this._renderer.GetNearZ();
        this._lastFarZ =
        this._renderer.GetFarZ()
    }
    _GetFramebuffer()
    {
        return this._frameBuffer
    }
    _GetFramebufferNoDepth()
    {
        return this._frameBufferNoDepth
    }
    GetRenderer()
    {
        return this._renderer
    }
    GetTexture()
    {
        return this._texture
    }
    GetProjectionMatrix()
    {
        this._renderer.GetFovY() === this._lastFov && this._renderer.GetNearZ() === this._lastNearZ && this._renderer.GetFarZ() === this._lastFarZ || this._CalculateProjection();
        return this._projectionMatrix
    }
    IsLinearSampling()
    {
        return "nearest" !== this._sampling
    }
    HasAlpha()
    {
        return this._alpha
    }
    IsSampled()
    {
        return this._isSampled
    }
    HasDepthBuffer()
    {
        return this._depth
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    IsDefaultSize()
    {
        return this._isDefaultSize
    }
    GetMultisampling()
    {
        return this._multisampling
    }
    GetOptions()
    {
        const a =
        {
            sampling: this._sampling,
            alpha: this._alpha,
            isSampled: this._isSampled
        };
        this._isDefaultSize || (a.width = this._width, a.height = this._height);
        return a
    }
    IsCompatibleWithOptions(a)
    {
        a = Object.assign({}, DEFAULT_RENDERTARGET_OPTIONS, a);
        return "nearest" !== a.sampling !== this.IsLinearSampling() || !!a.alpha !== this.HasAlpha() || !!a.depth !== this.HasDepthBuffer() || 2 <= this._renderer.GetWebGLVersionNumber() && !!a.isSampled !== this.IsSampled() ? !1 : "number" === typeof a.width || "number" === typeof a.height ? !this.IsDefaultSize() && this.GetWidth() ===
        Math.floor(a.width) && this.GetHeight() === Math.floor(a.height) : this.IsDefaultSize()
    }
    _GetWebGLTexture()
    {
        return this._texture ? this._texture._GetTexture() : null
    }
    GetEstimatedMemoryUsage()
    {
        return this._texture ? this._texture.GetEstimatedMemoryUsage() : this._width * this._height * (this._alpha ? 4 : 3)
    }
    static async DebugReadPixelsToBlob(a, b)
    {
        a = await a.ReadBackRenderTargetToImageData(b, !0);
        return await C3$jscomp$50.ImageDataToBlob(a)
    }
    static OnContextLost()
    {
        allRenderTargets.clear()
    }
    static allRenderTargets()
    {
        return allRenderTargets.values()
    }
    static ResizeAll(a,
    b)
    {
        for (const c of allRenderTargets)
            c.IsDefaultSize() && c._Resize(a, b)
    }
}
;
"use strict";
const C3$jscomp$51 = self.C3,
    RESERVED_UNIFORM_NAMES = new Set("aPos aTex aPoints matP matMV samplerFront samplerBack samplerDepth destStart destEnd srcStart srcEnd srcOriginStart srcOriginEnd pixelSize seconds devicePixelRatio layerScale layerAngle layoutStart layoutEnd color color2_ pointTexStart pointTexEnd zElevation tileSize tileSpacing outlineThickness zNear zFar".split(" "));
C3$jscomp$51.Gfx.WebGLShaderProgram = class  extends C3$jscomp$51.Gfx.ShaderProgramBase{
    static async Compile(a, b)
    {
        const c = a.GetContext();
        var d = b.src;
        const e = b.vertexSrc,
            f = b.name;
        b = c.createShader(c.FRAGMENT_SHADER);
        c.shaderSource(b, d);
        c.compileShader(b);
        d = c.createShader(c.VERTEX_SHADER);
        c.shaderSource(d, e);
        c.compileShader(d);
        const g = c.createProgram();
        c.attachShader(g, b);
        c.attachShader(g, d);
        c.bindAttribLocation(g, 0, "aPos");
        c.bindAttribLocation(g, 1, "aTex");
        c.bindAttribLocation(g, 2, "aPoints");
        c.linkProgram(g);
        const h = a._GetParallelShaderCompileExtension();
        h ? await a._WaitForObjectReady(() => c.getProgramParameter(g, h.COMPLETION_STATUS_KHR)) : await C3$jscomp$51.Wait(5);
        if (!c.getShaderParameter(b, c.COMPILE_STATUS))
            throw a = c.getShaderInfoLog(b), c.deleteShader(b), c.deleteShader(d), c.deleteProgram(g), Error("Error compiling fragment shader: " + a);
        if (!c.getShaderParameter(d, c.COMPILE_STATUS))
            throw a = c.getShaderInfoLog(d), c.deleteShader(b), c.deleteShader(d), c.deleteProgram(g), Error("Error compiling vertex shader: " +
            a);
        if (!c.getProgramParameter(g, c.LINK_STATUS))
            throw a = c.getProgramInfoLog(g), c.deleteShader(b), c.deleteShader(d), c.deleteProgram(g), Error("Error linking shader program: " + a);
        (a = C3$jscomp$51.FilterUnprintableChars(c.getProgramInfoLog(g) || "").trim()) && !C3$jscomp$51.IsStringAllWhitespace(a) && console.info(`[WebGL] Shader program '${f}' compilation log: `, a);
        c.deleteShader(b);
        c.deleteShader(d);
        return g
    }
    static async Create(a, b)
    {
        const c = await C3$jscomp$51.Gfx.WebGLShaderProgram.Compile(a, b);
        return new C3$jscomp$51.Gfx.WebGLShaderProgram(a,
        c, b)
    }
    constructor(a, b, c)
    {
        super(a, c);
        const d = a.GetContext();
        var e = a.GetBatchState();
        a.EndBatch();
        d.useProgram(b);
        this._gl = d;
        this._shaderProgram = b;
        this._isDeviceTransform = "<default-device-transform>" === c.name;
        const f = d.getAttribLocation(b, "aPos"),
            g = d.getAttribLocation(b, "aTex");
        this._locAPoints = d.getAttribLocation(b, "aPoints");
        -1 !== f && (d.bindBuffer(d.ARRAY_BUFFER, a._vertexBuffer), d.vertexAttribPointer(f, a.GetNumVertexComponents(), d.FLOAT, !1, 0, 0), d.enableVertexAttribArray(f));
        -1 !== g && (d.bindBuffer(d.ARRAY_BUFFER,
        a._texcoordBuffer), d.vertexAttribPointer(g, 2, d.FLOAT, !1, 0, 0), d.enableVertexAttribArray(g));
        -1 !== this._locAPoints && (d.bindBuffer(d.ARRAY_BUFFER, a._pointBuffer), d.vertexAttribPointer(this._locAPoints, 4, d.FLOAT, !1, 0, 0), d.enableVertexAttribArray(this._locAPoints));
        d.bindBuffer(d.ARRAY_BUFFER, null);
        this._uMatP = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "matP", "mat4");
        this._uMatMV = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "matMV", "mat4");
        this._uColor = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "color",
        "vec4");
        this._uSamplerFront = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "samplerFront", "sampler");
        this._uPointTexStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "pointTexStart", "vec2");
        this._uPointTexEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "pointTexEnd", "vec2");
        this._uZElevation = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "zElevation", "float");
        this._uTileSize = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "tileSize", "vec2");
        this._uTileSpacing = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,
        "tileSpacing", "vec2");
        this._uColor2 = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "color2_", "vec4");
        this._uOutlineThickness = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "outlineThickness", "float");
        this._uSamplerBack = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "samplerBack", "sampler");
        this._uSamplerDepth = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "samplerDepth", "sampler");
        this._uDestStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "destStart", "vec2");
        this._uDestEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,
        "destEnd", "vec2");
        this._uSrcStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "srcStart", "vec2");
        this._uSrcEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "srcEnd", "vec2");
        this._uSrcOriginStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "srcOriginStart", "vec2");
        this._uSrcOriginEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "srcOriginEnd", "vec2");
        this._uPixelSize = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "pixelSize", "vec2");
        this._uSeconds = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "seconds",
        "float");
        this._uDevicePixelRatio = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "devicePixelRatio", "float");
        this._uLayerScale = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "layerScale", "float");
        this._uLayerAngle = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "layerAngle", "float");
        this._uLayoutStart = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "layoutStart", "vec2");
        this._uLayoutEnd = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "layoutEnd", "vec2");
        this._uZNear = new C3$jscomp$51.Gfx.WebGLShaderUniform(this,
        "zNear", "float");
        this._uZFar = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, "zFar", "float");
        this._hasAnyOptionalUniforms = !!(this._uPixelSize.IsUsed() || this._uSeconds.IsUsed() || this._uSamplerBack.IsUsed() || this._uDestStart.IsUsed() || this._uDestEnd.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed() || this._uDevicePixelRatio.IsUsed() || this._uLayerScale.IsUsed() || this._uLayerAngle.IsUsed() || this._uLayoutStart.IsUsed() || this._uLayoutEnd.IsUsed());
        b = c.parameters || [];
        this._uCustomParameters = [];
        this._usesAnySrcRectOrPixelSize = this._uPixelSize.IsUsed() || this._uSrcStart.IsUsed() || this._uSrcEnd.IsUsed() || this._uSrcOriginStart.IsUsed() || this._uSrcOriginEnd.IsUsed();
        this._hasCurrentMatMV = this._hasCurrentMatP = !1;
        this._uColor.Init4f(1, 1, 1, 1);
        this._uColor2.Init4f(1, 1, 1, 1);
        this._uSamplerFront.Init1i(0);
        this._uSamplerBack.Init1i(1);
        this._uSamplerDepth.Init1i(2);
        this._uPointTexStart.Init2f(0, 0);
        this._uPointTexEnd.Init2f(1, 1);
        this._uZElevation.Init1f(0);
        this._uTileSize.Init2f(0, 0);
        this._uTileSpacing.Init2f(0, 0);
        this._uDestStart.Init2f(0, 0);
        this._uDestEnd.Init2f(1, 1);
        this._uSrcStart.Init2f(0, 0);
        this._uSrcEnd.Init2f(0, 0);
        this._uSrcOriginStart.Init2f(0, 0);
        this._uSrcOriginEnd.Init2f(0, 0);
        this._uPixelSize.Init2f(0, 0);
        this._uDevicePixelRatio.Init1f(1);
        this._uZNear.Init1f(a.GetNearZ());
        this._uZFar.Init1f(a.GetFarZ());
        this._uLayerScale.Init1f(1);
        this._uLayerAngle.Init1f(0);
        this._uSeconds.Init1f(0);
        this._uLayoutStart.Init2f(0, 0);
        this._uLayoutEnd.Init2f(0,
        0);
        this._uOutlineThickness.Init1f(1);
        for (const h of b)
            a = h[2],
            b = new C3$jscomp$51.Gfx.WebGLShaderUniform(this, h[0], a),
            "color" === a ? b.Init3f(0, 0, 0) : b.Init1f(0),
            this._uCustomParameters.push(b);
        this._isDeviceTransform ? this._UpdateDeviceTransformUniforms(e.currentMatP) : (this.UpdateMatP(e.currentMatP, !0), this.UpdateMatMV(e.currentMV, !0));
        e = e.currentShader;
        d.useProgram(e ? e._shaderProgram : null)
    }
    Release()
    {
        this._gl.deleteProgram(this._shaderProgram);
        this._shaderProgram = null;
        this._renderer._RemoveShaderProgram(this);
        this._gl = null;
        super.Release()
    }
    GetWebGLContext()
    {
        return this._gl
    }
    GetShaderProgram()
    {
        return this._shaderProgram
    }
    GetParameterCount()
    {
        return this._uCustomParameters.length
    }
    GetParameterType(a)
    {
        return 0 > a || a >= this._uCustomParameters.length ? null : this._uCustomParameters[a].GetType()
    }
    AreCustomParametersAlreadySetInBatch(a)
    {
        for (let b = 0, c = a.length; b < c; ++b)
            if (!this._uCustomParameters[b].IsSetToCustomInBatch(a[b]))
                return !1;
        return !0
    }
    SetCustomParametersInBatch(a)
    {
        for (let b = 0, c = a.length; b < c; ++b)
            this._uCustomParameters[b].SetBatchValueCustom(a[b])
    }
    AreOptionalUniformsAlreadySetInBatch(a,
    b, c, d, e, f, g, h, k, l)
    {
        return this._uSamplerBack.IsUsed() || this._uPixelSize.IsUsed() && !this._uPixelSize.IsSetTo2InBatch(e, f) || this._uDestStart.IsUsed() && !this._uDestStart.IsSetTo2InBatch(a.getLeft(), a.getTop()) || this._uDestEnd.IsUsed() && !this._uDestEnd.IsSetTo2InBatch(a.getRight(), a.getBottom()) || this._uDevicePixelRatio.IsUsed() && !this._uDevicePixelRatio.IsSetTo1InBatch(g) || this._uLayerScale.IsUsed() && !this._uLayerScale.IsSetTo1InBatch(h) || this._uLayerAngle.IsUsed() && !this._uLayerAngle.IsSetTo1InBatch(k) ||
        this._uSrcStart.IsUsed() && !this._uSrcStart.IsSetTo2InBatch(b.getLeft(), b.getTop()) || this._uSrcEnd.IsUsed() && !this._uSrcEnd.IsSetTo2InBatch(b.getRight(), b.getBottom()) || this._uSrcOriginStart.IsUsed() && !this._uSrcOriginStart.IsSetTo2InBatch(c.getLeft(), c.getTop()) || this._uSrcOriginEnd.IsUsed() && !this._uSrcOriginEnd.IsSetTo2InBatch(c.getRight(), c.getBottom()) || this._uLayoutStart.IsUsed() && !this._uLayoutStart.IsSetTo2InBatch(d.getLeft(), d.getTop()) || this._uLayoutEnd.IsUsed() && !this._uLayoutEnd.IsSetTo2InBatch(d.getTop(),
        d.getBottom()) || this._uSeconds.IsUsed() && !this._uSeconds.IsSetTo1InBatch(l) ? !1 : !0
    }
    SetOptionalUniformsInBatch(a, b, c, d, e, f, g, h, k, l)
    {
        this._uSamplerBack.IsUsed() || (this._uPixelSize.IsUsed() && this._uPixelSize.SetBatch2(e, f), this._uDestStart.IsUsed() && this._uDestStart.SetBatch2(a.getLeft(), a.getTop()), this._uDestEnd.IsUsed() && this._uDestEnd.SetBatch2(a.getRight(), a.getBottom()), this._uDevicePixelRatio.IsUsed() && this._uDevicePixelRatio.SetBatch1(g), this._uLayerScale.IsUsed() && this._uLayerScale.SetBatch1(h),
        this._uLayerAngle.IsUsed() && this._uLayerAngle.SetBatch1(k), this._uSrcStart.IsUsed() && this._uSrcStart.SetBatch2(b.getLeft(), b.getTop()), this._uSrcEnd.IsUsed() && this._uSrcEnd.SetBatch2(b.getRight(), b.getBottom()), this._uSrcOriginStart.IsUsed() && this._uSrcOriginStart.SetBatch2(c.getLeft(), c.getTop()), this._uSrcOriginEnd.IsUsed() && this._uSrcOriginEnd.SetBatch2(c.getRight(), c.getBottom()), this._uLayoutStart.IsUsed() && this._uLayoutStart.SetBatch2(d.getLeft(), d.getTop()), this._uLayoutEnd.IsUsed() && this._uLayoutEnd.SetBatch2(d.getTop(),
        d.getBottom()), this._uSeconds.IsUsed() && this._uSeconds.SetBatch1(l))
    }
    UpdateMatP(a, b)
    {
        this._hasCurrentMatP && !b || this._isDeviceTransform || (this._uMatP.IsUsed() && this._uMatP.UpdateMatrix4fv(a), this._hasCurrentMatP = !0)
    }
    SetMatPStale()
    {
        this._hasCurrentMatP = !1
    }
    UpdateMatMV(a, b)
    {
        this._hasCurrentMatMV && !b || this._isDeviceTransform || (this._uMatMV.IsUsed() && this._uMatMV.UpdateMatrix4fv(a), this._hasCurrentMatMV = !0)
    }
    SetMatMVStale()
    {
        this._hasCurrentMatMV = !1
    }
    _UpdateDeviceTransformUniforms(a)
    {
        if (!this._isDeviceTransform)
            throw Error("not device transform shader");
        this._uMatP.UpdateMatrix4fv(a);
        a = this._renderer;
        const b = a.GetWidth() / 2,
            c = a.GetHeight() / 2;
        a = a.CalculateLookAtModelView2(b, c, a.GetDefaultCameraZ(a.GetHeight()), b, c, 0, a.GetHeight());
        this._uMatMV.UpdateMatrix4fv(a)
    }
    UpdateColor(a)
    {
        this._uColor.IsUsed() && this._uColor.Update4f(a[0], a[1], a[2], a[3])
    }
    static GetReservedUniformNames()
    {
        return RESERVED_UNIFORM_NAMES
    }
    static GetDefaultVertexShaderSource(a)
    {
        a = a ? "highmedp" : "mediump";
        return ["#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nattribute highp vec3 aPos;",
        `attribute ${a} vec2 aTex;`, `varying ${a} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"].join("\n")
    }
    static GetDefaultVertexShaderSource_WebGL2(a)
    {
        a = a ? "highp" : "mediump";
        return ["#version 300 es\nin highp vec3 aPos;", `in ${a} vec2 aTex;`, `out ${a} vec2 vTex;`, "uniform highp mat4 matP;\nuniform highp mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPos, 1.0);\n\tvTex = aTex;\n}"].join("\n")
    }
    static GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth()
    {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n}"
    }
    static GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT()
    {
        return "#extension GL_EXT_frag_depth : enable\nvarying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\tgl_FragColor = texture2D(samplerFront, vTex) * color;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTextureFillFragmentShaderSource_WebGL2()
    {
        return "#version 300 es\nin mediump vec2 vTex;\nout lowp vec4 outColor;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nvoid main(void) {\n\toutColor = texture(samplerFront, vTex) * color;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL1_NoFragDepth()
    {
        return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT()
    {
        return "#extension GL_EXT_frag_depth : enable\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nvarying highmedp vec2 vTex;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highmedp vec2 srcStart;\nuniform highmedp vec2 pixelSize;\nuniform highmedp vec2 tileSize;\nuniform highmedp vec2 tileSpacing;\nvoid main(void) {\n\thighmedp vec2 tile = floor(vTex);\n\thighmedp vec2 tex = fract(vTex);\n\thighmedp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighmedp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighmedp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\tgl_FragColor = texture2D(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTilemapFragmentShaderSource_WebGL2()
    {
        return "#version 300 es\nin highp vec2 vTex;\nout lowp vec4 outColor;\nuniform lowp vec4 color;\nuniform lowp sampler2D samplerFront;\nuniform highp vec2 srcStart;\nuniform highp vec2 pixelSize;\nuniform highp vec2 tileSize;\nuniform highp vec2 tileSpacing;\nvoid main(void) {\n\thighp vec2 tile = floor(vTex);\n\thighp vec2 tex = fract(vTex);\n\thighp vec2 tileOrigin = srcStart + tile * (tileSize + tileSpacing);\n\thighp vec2 lowerBound = tileOrigin + pixelSize / 2.0;\n\thighp vec2 upperBound = tileOrigin + tileSize - pixelSize / 2.0;\n\toutColor = texture(samplerFront, clamp(tex, lowerBound, upperBound), -16.0) * color;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetTileRandomizationFragmentShaderSource(a,
    b, c)
    {
        let d = "";
        2 <= a ? d = "#version 300 es\n" : (b && (d = "#extension GL_EXT_frag_depth : enable\n"), c && (d += "#extension GL_EXT_shader_texture_lod : enable\n#extension GL_OES_standard_derivatives : enable\n"));
        return d + `
#ifdef GL_FRAGMENT_PRECISION_HIGH
#define highmedp highp
#else
#define highmedp mediump
#endif
precision highmedp float;
${





        2 <= a ? "in" : "varying"} vec2 vTex;
${2 <= a ? "out lowp vec4 outColor;" : ""}
uniform lowp vec4 color;
uniform lowp sampler2D samplerFront;
uniform vec2 pixelSize;

uniform vec2 tileSize;
uniform vec2 tileSpacing;
uniform float outlineThickness;

const float PI = 3.1415926;

lowp vec4 cospVec4(lowp vec4 a, lowp vec4 b, float x)
{
    return (a + b + (a - b) * cos(x * PI)) / 2.0;
}

vec3 randVec3(vec2 seed)
{
    return vec3(fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(12.9898,78.233))) * 43758.5453),
                fract(sin(dot(seed.yx + vec2(0.1, 0.1), vec2(12.9898,-78.233))) * 43758.5453),
                fract(sin(dot(seed.xy + vec2(0.1, 0.1), vec2(-12.9898,-78.233))) * 43758.5453));
}

lowp vec4 sampleTile(vec2 tile, vec2 uv, vec2 ddx, vec2 ddy)
{
    vec2 posRandom = tileSize;
    float angleRandom = outlineThickness;
    
    vec3 rand = (randVec3(floor(tile + 0.5)) - 0.5) * 2.0;
    
    float angle = angleRandom * rand.z * PI;
    float sin_a = sin(angle);
    float cos_a = cos(angle);
    float aspect = pixelSize.x / pixelSize.y;

    vec2 mid = tile + vec2(0.5, 0.5);
    vec2 dp = uv - mid;
    dp.x /= aspect;
    vec2 r = vec2(dp.x * cos_a - dp.y * sin_a,
                  dp.y * cos_a + dp.x * sin_a);
    r.x *= aspect;

    vec2 p = mid + r + (posRandom * rand.xy / 2.0);
    
    ${










































        2 <= a ? "return textureGrad(samplerFront, p, ddx, ddy);" : ""}
    ${2 > a && c ? "return texture2DGradEXT(samplerFront, p, ddx, ddy);" : ""}
    ${2 > a && !c ? "return texture2D(samplerFront, p);" : ""}
}

void main(void) {
    
    ${



        2 > a ? "lowp vec4 outColor;" : ""}
    
    float blendMarginX = tileSpacing.x;
    float blendMarginY = tileSpacing.y;
    
    vec2 tile = floor(vTex);
    vec2 tex = fract(vTex);
    vec2 ddx = ${





        2 <= a || c ? "dFdx(vTex)" : "vec2(0.0, 0.0)"};
    vec2 ddy = ${2 <= a || c ? "dFdy(vTex)" : "vec2(0.0, 0.0)"};
    
    vec4 curTile = sampleTile(tile, vTex, ddx, ddy);
    
    bool inLeftMargin = (tex.x < blendMarginX);
    bool inRightMargin = (tex.x > 1.0 - blendMarginX);
    bool inTopMargin = (tex.y < blendMarginY);
    bool inBottomMargin = (tex.y > 1.0 - blendMarginY);
    
    if (inLeftMargin)
    {
        lowp vec4 leftTile = sampleTile(tile + vec2(-1.0, 0.0), vTex, ddx, ddy);
        float leftMix = (tex.x / (blendMarginX * 2.0)) + 0.5;
        lowp vec4 leftMixedTile = cospVec4(leftTile, curTile, leftMix);
        
        if (inTopMargin)
        {
            lowp vec4 topTile =     sampleTile(tile + vec2(0.0,  -1.0), vTex, ddx, ddy);
            lowp vec4 topLeftTile = sampleTile(tile + vec2(-1.0, -1.0), vTex, ddx, ddy);
            lowp vec4 topLeftMixedTile = cospVec4(topLeftTile, topTile, leftMix);
            
            outColor = cospVec4(topLeftMixedTile, leftMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
        }
        else if (inBottomMargin)
        {
            lowp vec4 bottomTile =     sampleTile(tile + vec2(0.0,  1.0), vTex, ddx, ddy);
            lowp vec4 bottomLeftTile = sampleTile(tile + vec2(-1.0, 1.0), vTex, ddx, ddy);
            lowp vec4 bottomLeftMixedTile = cospVec4(bottomLeftTile, bottomTile, leftMix);
            
            outColor = cospVec4(leftMixedTile, bottomLeftMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
        }
        else
        {
            outColor = leftMixedTile;
        }
    }
    else if (inRightMargin)
    {
        lowp vec4 rightTile = sampleTile(tile + vec2(1.0, 0.0), vTex, ddx, ddy);
        float rightMix = (tex.x - (1.0 - blendMarginX)) / (blendMarginX * 2.0);
        lowp vec4 rightMixedTile = cospVec4(curTile, rightTile, rightMix);
        
        if (inTopMargin)
        {
            lowp vec4 topTile =      sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
            lowp vec4 topRightTile = sampleTile(tile + vec2(1.0, -1.0), vTex, ddx, ddy);
            lowp vec4 topRightMixedTile = cospVec4(topTile, topRightTile, rightMix);
            
            outColor = cospVec4(topRightMixedTile, rightMixedTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
        }
        else if (inBottomMargin)
        {
            lowp vec4 bottomTile =      sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
            lowp vec4 bottomRightTile = sampleTile(tile + vec2(1.0, 1.0), vTex, ddx, ddy);
            lowp vec4 bottomRightMixedTile = cospVec4(bottomTile, bottomRightTile, rightMix);
            
            outColor = cospVec4(rightMixedTile, bottomRightMixedTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
        }
        else
        {
            outColor = rightMixedTile;
        }
    }
    else if (inTopMargin)
    {
        lowp vec4 topTile = sampleTile(tile + vec2(0.0, -1.0), vTex, ddx, ddy);
        outColor = cospVec4(topTile, curTile, (tex.y / (blendMarginY * 2.0)) + 0.5);
    }
    else if (inBottomMargin)
    {
        lowp vec4 bottomTile = sampleTile(tile + vec2(0.0, 1.0), vTex, ddx, ddy);
        outColor = cospVec4(curTile, bottomTile, (tex.y - (1.0 - blendMarginY)) / (blendMarginY * 2.0));
    }
    else
    {
        outColor = curTile;
    }
    
    outColor *= color;
    ${













































































        2 > a ? "gl_FragColor = outColor;" : ""}
    ${2 <= a ? "gl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
    ${2 > a && b ? "gl_FragDepthEXT = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);" : ""}
}
`

    }
    static GetPointVertexShaderSource_WebGL1()
    {
        return "attribute vec4 aPoints;\nvarying float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
    }
    static GetPointVertexShaderSource_WebGL2()
    {
        return "#version 300 es\nin vec4 aPoints;\nout float pointOpacity;\nuniform float zElevation;\nuniform mat4 matP;\nuniform mat4 matMV;\nvoid main(void) {\n\tgl_Position = matP * matMV * vec4(aPoints.xy, zElevation, 1.0);\n\tgl_PointSize = aPoints.z;\n\tpointOpacity = aPoints.w;\n}"
    }
    static GetPointFragmentShaderSource_WebGL1_NoFragDepth()
    {
        return "uniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n}"
    }
    static GetPointFragmentShaderSource_WebGL1_FragDepthEXT()
    {
        return "#extension GL_EXT_frag_depth : enable\nuniform lowp sampler2D samplerFront;\nvarying lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\tgl_FragColor = texture2D(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n\tgl_FragDepthEXT = (gl_FragColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetPointFragmentShaderSource_WebGL2()
    {
        return "#version 300 es\nuniform lowp sampler2D samplerFront;\nin lowp float pointOpacity;\nuniform mediump vec2 pointTexStart;\nuniform mediump vec2 pointTexEnd;\nuniform lowp vec4 color;\nout lowp vec4 outColor;\nvoid main(void) {\n\tmediump vec2 pointTexMin = min(pointTexStart, pointTexEnd);\n\tmediump vec2 pointTexMax = max(pointTexStart, pointTexEnd);\n\tmediump vec2 pointCoord = (pointTexEnd.x > pointTexStart.x ? gl_PointCoord : vec2(1.0 - gl_PointCoord.y, gl_PointCoord.x));\n\toutColor = texture(samplerFront, mix(pointTexMin, pointTexMax, pointCoord)) * color * pointOpacity;\n\tgl_FragDepth = (outColor.a == 0.0 ? 1.0 : gl_FragCoord.z);\n}"
    }
    static GetColorFillFragmentShaderSource()
    {
        return "uniform lowp vec4 color;\nvoid main(void) {\n\tgl_FragColor = color;\n}"
    }
    static GetLinearGradientFillFragmentShaderSource()
    {
        return "precision lowp float;\nvarying mediump vec2 vTex;\nuniform vec4 color;\nuniform vec4 color2_;\nvec3 fromLinear(vec3 linearRGB)\n{\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055) * pow(abs(linearRGB), vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvec3 toLinear(vec3 sRGB)\n{\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow(abs((sRGB + vec3(0.055))/vec3(1.055)), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, vec3(cutoff));\n}\nvoid main(void) {\n\tvec3 linearGrad = mix(toLinear(color.rgb), toLinear(color2_.rgb), vTex.x);\n\tfloat a = mix(color.a, color2_.a, vTex.x);\n\tgl_FragColor = vec4(fromLinear(linearGrad) * a, a);\n}"
    }
    static GetPenumbraFillFragmentShaderSource()
    {
        return "#ifdef GL_FRAGMENT_PRECISION_HIGH\n#define highmedp highp\n#else\n#define highmedp mediump\n#endif\nprecision lowp float;\nvarying highmedp vec2 vTex;\nuniform vec4 color;\nvoid main(void) {\n\thighmedp float grad = vTex.x / (1.0 - vTex.y);\n\tgl_FragColor = color * (1.0 - (cos(grad * 3.141592653589793) + 1.0) / 2.0);\n}"
    }
    static GetSmoothLineFillFragmentShaderSource()
    {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tlowp float f = 1.0 - abs(vTex.y - 0.5) * 2.0;\n\tgl_FragColor = color * f;\n}"
    }
    static GetHardEllipseFillFragmentShaderSource()
    {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float f = step(diffSq.x + diffSq.y, 0.25);\n\tgl_FragColor = color * f;\n}"
    }
    static GetHardEllipseOutlineFragmentShaderSource()
    {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump float innerF = step(distSq, 0.25);\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm * outlineThickness;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float outerF = step(innerEdgeSq.x + innerEdgeSq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
    }
    static GetSmoothEllipseFillFragmentShaderSource()
    {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 innerEdge = halfNorm - pixelSize * norm;\n\tmediump vec2 innerEdgeSq = innerEdge * innerEdge;\n\tmediump float f = smoothstep(halfNormSq.x + halfNormSq.y, innerEdgeSq.x + innerEdgeSq.y, diffSq.x + diffSq.y);\n\tgl_FragColor = color * f;\n}"
    }
    static GetSmoothEllipseOutlineFragmentShaderSource()
    {
        return "varying mediump vec2 vTex;\nuniform lowp vec4 color;\nuniform mediump vec2 pixelSize;\nuniform mediump float outlineThickness;\nvoid main(void) {\n\tmediump vec2 diff = vTex - vec2(0.5, 0.5);\n\tmediump vec2 diffSq = diff * diff;\n\tmediump float distSq = diffSq.x + diffSq.y;\n\tmediump vec2 norm = normalize(diff);\n\tmediump vec2 halfNorm = norm * 0.5;\n\tmediump vec2 halfNormSq = halfNorm * halfNorm;\n\tmediump vec2 pxNorm = pixelSize * norm;\n\tmediump vec2 innerEdge1 = halfNorm - pxNorm;\n\tmediump vec2 innerEdge1Sq = innerEdge1 * innerEdge1;\n\tmediump float innerF = smoothstep(halfNormSq.x + halfNormSq.y, innerEdge1Sq.x + innerEdge1Sq.y, distSq);\n\tmediump vec2 innerEdge2 = halfNorm - pxNorm * outlineThickness;\n\tmediump vec2 innerEdge2Sq = innerEdge2 * innerEdge2;\n\tmediump vec2 innerEdge3 = halfNorm - pxNorm * (outlineThickness + 1.0);\n\tmediump vec2 innerEdge3Sq = innerEdge3 * innerEdge3;\n\tmediump float outerF = smoothstep(innerEdge3Sq.x + innerEdge3Sq.y, innerEdge2Sq.x + innerEdge2Sq.y, distSq);\n\tgl_FragColor = color * innerF * outerF;\n}"
    }
}
;
"use strict";
const C3$jscomp$52 = self.C3,
    mat4$jscomp$4 = self.glMatrix.mat4,
    TYPE_SIZES = new Map([["float", 1], ["percent", 1], ["sampler", 1], ["vec2", 2], ["vec3", 3], ["color", 3], ["vec4", 4], ["mat4", 16]]);
C3$jscomp$52.Gfx.WebGLShaderUniform = class {
    constructor(a, b, c)
    {
        if (!TYPE_SIZES.has(c))
            throw Error("invalid uniform type");
        this._owner = a;
        this._gl = this._owner.GetWebGLContext();
        this._name = b;
        this._type = c;
        this._isColorType = "color" === this._type;
        this._location = this._gl.getUniformLocation(this._owner.GetShaderProgram(), b);
        this._isUsed = !!this._location;
        a = TYPE_SIZES.get(c);
        this._lastValue = new Float32Array(a);
        this._lastBatchValue = new Float32Array(a)
    }
    Release()
    {
        this._location = this._gl = this._owner = null
    }
    IsUsed()
    {
        return this._isUsed
    }
    GetType()
    {
        return this._type
    }
    IsColorType()
    {
        return this._isColorType
    }
    Init1f(a)
    {
        this.IsUsed() &&
        (this._lastValue[0] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform1f(this._location, a))
    }
    Init1i(a)
    {
        this.IsUsed() && (this._lastValue[0] = a, this._lastBatchValue.set(this._lastValue), this._gl.uniform1i(this._location, a))
    }
    Init2f(a, b)
    {
        this.IsUsed() && (this._lastValue[0] = a, this._lastValue[1] = b, this._lastBatchValue.set(this._lastValue), this._gl.uniform2f(this._location, a, b))
    }
    Init3f(a, b, c)
    {
        this.IsUsed() && (this._lastValue[0] = a, this._lastValue[1] = b, this._lastValue[2] = c, this._lastBatchValue.set(this._lastValue),
        this._gl.uniform3f(this._location, a, b, c))
    }
    Init4f(a, b, c, d)
    {
        this.IsUsed() && (this._lastValue[0] = a, this._lastValue[1] = b, this._lastValue[2] = c, this._lastValue[3] = d, this._lastBatchValue.set(this._lastValue), this._gl.uniform4f(this._location, a, b, c, d))
    }
    Update1f(a)
    {
        a = Math.fround(a);
        const b = this._lastValue;
        b[0] !== a && (b[0] = a, this._gl.uniform1f(this._location, a))
    }
    Update1i(a)
    {
        const b = this._lastValue;
        b[0] !== a && (b[0] = a, this._gl.uniform1i(this._location, a))
    }
    Update2f(a, b)
    {
        a = Math.fround(a);
        b = Math.fround(b);
        const c =
        this._lastValue;
        if (c[0] !== a || c[1] !== b)
            c[0] = a,
            c[1] = b,
            this._gl.uniform2f(this._location, a, b)
    }
    Update3f(a, b, c)
    {
        a = Math.fround(a);
        b = Math.fround(b);
        c = Math.fround(c);
        const d = this._lastValue;
        if (d[0] !== a || d[1] !== b || d[2] !== c)
            d[0] = a,
            d[1] = b,
            d[2] = c,
            this._gl.uniform3f(this._location, a, b, c)
    }
    Update4f(a, b, c, d)
    {
        a = Math.fround(a);
        b = Math.fround(b);
        c = Math.fround(c);
        d = Math.fround(d);
        const e = this._lastValue;
        if (e[0] !== a || e[1] !== b || e[2] !== c || e[3] !== d)
            e[0] = a,
            e[1] = b,
            e[2] = c,
            e[3] = d,
            this._gl.uniform4f(this._location, a, b, c, d)
    }
    UpdateMatrix4fv(a)
    {
        const b =
        this._lastValue;
        mat4$jscomp$4.exactEquals(b, a) || (C3$jscomp$52.typedArraySet16(b, a, 0), this._gl.uniformMatrix4fv(this._location, !1, a))
    }
    IsSetToCustomInBatch(a)
    {
        const b = this._lastBatchValue;
        return this.IsColorType() ? b[0] === Math.fround(a.getR()) && b[1] === Math.fround(a.getG()) && b[2] === Math.fround(a.getB()) : b[0] === Math.fround(a)
    }
    SetBatchValueCustom(a)
    {
        const b = this._lastBatchValue;
        this.IsColorType() ? (b[0] = a.getR(), b[1] = a.getG(), b[2] = a.getB()) : b[0] = a
    }
    IsSetTo1InBatch(a)
    {
        return this._lastBatchValue[0] === Math.fround(a)
    }
    IsSetTo2InBatch(a,
    b)
    {
        const c = this._lastBatchValue;
        return c[0] === Math.fround(a) && c[1] === Math.fround(b)
    }
    SetBatch1(a)
    {
        this._lastBatchValue[0] = a
    }
    SetBatch2(a, b)
    {
        const c = this._lastBatchValue;
        c[0] = a;
        c[1] = b
    }
}
;
"use strict";
const C3$jscomp$53 = self.C3,
    glMatrix$jscomp$5 = self.glMatrix,
    vec4$jscomp$2 = glMatrix$jscomp$5.vec4,
    mat4$jscomp$5 = glMatrix$jscomp$5.mat4;
C3$jscomp$53.Gfx.BatchState = class {
    constructor(a)
    {
        this.renderer = a;
        this.currentMV = mat4$jscomp$5.create();
        this.currentMatP = mat4$jscomp$5.create();
        this.currentFramebufferNoDepth = this.currentFramebuffer = null;
        this.isDepthSamplingEnabled = !1;
        this.currentColor = vec4$jscomp$2.fromValues(1, 1, 1, 1);
        this.currentShader = null;
        this.pointTexCoords = new C3$jscomp$53.Rect;
        this.clearColor = C3$jscomp$53.New(C3$jscomp$53.Color, 0, 0, 0, 0)
    }
}
;
C3$jscomp$53.Gfx.WebGLBatchJob = class {
    constructor(a)
    {
        const b = new ArrayBuffer(96);
        this._type = 0;
        this._batchState = a;
        this._gl = a.renderer.GetContext();
        this._indexCount = this._startIndex = 0;
        this._texParam = null;
        this._mat4param = new Float32Array(b, 0, 16);
        this._colorParam = new Float32Array(b, 64, 4);
        this._srcOriginRect = new Float32Array(b, 80, 4);
        this._shaderParams = []
    }
    InitQuad(a, b)
    {
        this._type = 1;
        this._startIndex = a;
        this._indexCount = b
    }
    DoQuad()
    {
        const a = this._gl;
        a.drawElements(a.TRIANGLES, this._indexCount, a.UNSIGNED_SHORT,
        this._startIndex)
    }
    InitSetTexture(a)
    {
        this._type = 2;
        this._texParam = a
    }
    DoSetTexture()
    {
        const a = this._gl,
            b = this._texParam;
        a.bindTexture(a.TEXTURE_2D, b ? b._GetTexture() : null)
    }
    InitSetColor(a)
    {
        this._type = 3;
        a.writeToTypedArray(this._colorParam, 0)
    }
    DoSetColor()
    {
        const a = this._colorParam,
            b = this._batchState;
        vec4$jscomp$2.copy(b.currentColor, a);
        b.currentShader.UpdateColor(a)
    }
    InitSetGradientColor(a)
    {
        this._type = 21;
        a.writeToTypedArray(this._colorParam, 0)
    }
    DoSetGradientColor()
    {
        const a = this._colorParam,
            b = this._batchState.currentShader;
        b._uColor2.IsUsed() && b._uColor2.Update4f(a[0], a[1], a[2], a[3])
    }
    InitSetBlend(a, b)
    {
        this._type = 4;
        this._startIndex = a;
        this._indexCount = b
    }
    DoSetBlend()
    {
        this._gl.blendFunc(this._startIndex, this._indexCount)
    }
    InitSetViewport(a, b, c, d)
    {
        this._type = 5;
        const e = this._colorParam;
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d
    }
    DoSetViewport()
    {
        const a = this._colorParam;
        this._gl.viewport(a[0], a[1], a[2], a[3])
    }
    InitSetProjection(a)
    {
        this._type = 6;
        mat4$jscomp$5.copy(this._mat4param, a)
    }
    DoSetProjection()
    {
        const a = this._batchState,
            b = a.renderer._allShaderPrograms,
            c = a.currentShader,
            d = this._mat4param;
        for (let e = 0, f = b.length; e < f; ++e) {
            const g = b[e];
            g === c ? g.UpdateMatP(d, !0) : g.SetMatPStale()
        }
        mat4$jscomp$5.copy(a.currentMatP, d)
    }
    InitSetModelView(a)
    {
        this._type = 7;
        mat4$jscomp$5.copy(this._mat4param, a)
    }
    DoSetModelView()
    {
        const a = this._batchState,
            b = a.renderer._allShaderPrograms,
            c = a.currentShader,
            d = this._mat4param;
        for (let e = 0, f = b.length; e < f; ++e) {
            const g = b[e];
            g === c ? g.UpdateMatMV(d, !0) : g.SetMatMVStale()
        }
        mat4$jscomp$5.copy(a.currentMV, d)
    }
    InitSetRenderTarget(a)
    {
        this._type = 8;
        this._texParam =
        a
    }
    DoSetRenderTarget()
    {
        const a = this._gl,
            b = this._texParam,
            c = this._batchState;
        b ? (c.currentFramebuffer = b._GetFramebuffer(), c.currentFramebufferNoDepth = b._GetFramebufferNoDepth(), c.isDepthSamplingEnabled && c.currentFramebufferNoDepth ? a.bindFramebuffer(a.FRAMEBUFFER, c.currentFramebufferNoDepth) : a.bindFramebuffer(a.FRAMEBUFFER, c.currentFramebuffer)) : (c.currentFramebuffer = null, c.currentFramebufferNoDepth = null, a.bindFramebuffer(a.FRAMEBUFFER, null))
    }
    InitClearSurface(a)
    {
        this._type = 9;
        a.writeToTypedArray(this._mat4param,
        0)
    }
    InitClearSurface2(a, b, c, d)
    {
        this._type = 9;
        const e = this._mat4param;
        e[0] = a;
        e[1] = b;
        e[2] = c;
        e[3] = d
    }
    DoClearSurface()
    {
        const a = this._gl;
        var b = this._mat4param;
        const c = this._batchState.clearColor,
            d = b[0],
            e = b[1],
            f = b[2];
        b = b[3];
        c.equalsRgba(d, e, f, b) || (a.clearColor(d, e, f, b), c.setRgba(d, e, f, b));
        a.clear(a.COLOR_BUFFER_BIT)
    }
    InitSetPointTexCoords(a)
    {
        this._type = 15;
        a.writeToTypedArray(this._mat4param, 0)
    }
    DoSetPointTextureCoords()
    {
        const a = this._mat4param;
        this._batchState.pointTexCoords.set(a[0], a[1], a[2], a[3])
    }
    InitPoints(a,
    b)
    {
        this._type = 10;
        this._startIndex = a;
        this._indexCount = 1;
        this._mat4param[0] = b
    }
    DoPoints()
    {
        const a = this._gl,
            b = this._batchState,
            c = b.renderer._spPoints;
        a.useProgram(c._shaderProgram);
        c.UpdateMatP(b.currentMatP, !1);
        c.UpdateMatMV(b.currentMV, !1);
        var d = b.pointTexCoords;
        c._uPointTexStart.IsUsed() && c._uPointTexStart.Update2f(d.getLeft(), d.getTop());
        c._uPointTexEnd.IsUsed() && c._uPointTexEnd.Update2f(d.getRight(), d.getBottom());
        d = this._mat4param[0];
        c._uZElevation.IsUsed() && c._uZElevation.Update1f(d);
        c._uColor.IsUsed() &&
        (d = b.currentColor, c._uColor.Update4f(d[0], d[1], d[2], d[3]));
        a.drawArrays(a.POINTS, this._startIndex / 4, this._indexCount);
        a.useProgram(b.currentShader._shaderProgram)
    }
    InitSetProgram(a)
    {
        this._type = 11;
        this._texParam = a
    }
    DoSetProgram()
    {
        var a = this._gl;
        const b = this._batchState,
            c = this._texParam;
        b.currentShader = c;
        a.useProgram(c._shaderProgram);
        c.UpdateMatP(b.currentMatP, !1);
        c.UpdateMatMV(b.currentMV, !1);
        c._uColor.IsUsed() && (a = b.currentColor, c._uColor.Update4f(a[0], a[1], a[2], a[3]))
    }
    InitSetProgramParameters()
    {
        this._type =
        12
    }
    DoSetProgramParameters()
    {
        const a = this._batchState.currentShader,
            b = this._gl,
            c = this._mat4param,
            d = this._colorParam,
            e = this._srcOriginRect;
        if (a._uSamplerBack.IsUsed()) {
            const f = this._batchState.renderer,
                g = this._texParam;
            f._lastTexture1 !== g && (b.activeTexture(b.TEXTURE1), b.bindTexture(b.TEXTURE_2D, g ? g._GetTexture() : null), f._lastTexture1 = g, b.activeTexture(b.TEXTURE0))
        }
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(c[0], c[1]);
        a._uDestStart.IsUsed() && a._uDestStart.Update2f(c[2], c[3]);
        a._uDestEnd.IsUsed() &&
        a._uDestEnd.Update2f(c[4], c[5]);
        a._uDevicePixelRatio.IsUsed() && a._uDevicePixelRatio.Update1f(this._indexCount);
        a._uLayerScale.IsUsed() && a._uLayerScale.Update1f(c[6]);
        a._uLayerAngle.IsUsed() && a._uLayerAngle.Update1f(c[7]);
        a._uSrcStart.IsUsed() && a._uSrcStart.Update2f(c[12], c[13]);
        a._uSrcEnd.IsUsed() && a._uSrcEnd.Update2f(c[14], c[15]);
        a._uSrcOriginStart.IsUsed() && a._uSrcOriginStart.Update2f(e[0], e[1]);
        a._uSrcOriginEnd.IsUsed() && a._uSrcOriginEnd.Update2f(e[2], e[3]);
        a._uLayoutStart.IsUsed() && a._uLayoutStart.Update2f(d[0],
        d[1]);
        a._uLayoutEnd.IsUsed() && a._uLayoutEnd.Update2f(d[2], d[3]);
        a._uSeconds.IsUsed() && a._uSeconds.Update1f(this._startIndex)
    }
    InitSetProgramCustomParameters()
    {
        this._type = 13
    }
    DoSetProgramCustomParameters()
    {
        const a = this._batchState.currentShader._uCustomParameters,
            b = this._shaderParams;
        for (let c = 0, d = a.length; c < d; ++c) {
            const e = a[c],
                f = b[c];
            e.IsColorType() ? e.Update3f(f.getR(), f.getG(), f.getB()) : e.Update1f(f)
        }
    }
    InitInvalidateFramebuffer(a)
    {
        this._type = 14;
        this._texParam = a
    }
    DoInvalidateFramebuffer()
    {
        const a = this._gl,
            b = this._texParam,
            c = this._batchState.currentFramebuffer;
        b !== c && a.bindFramebuffer(a.FRAMEBUFFER, b);
        a.invalidateFramebuffer(a.FRAMEBUFFER, [a.COLOR_ATTACHMENT0]);
        b !== c && a.bindFramebuffer(a.FRAMEBUFFER, c)
    }
    InitBlitFramebuffer(a, b, c)
    {
        this._type = 17;
        const d = this._mat4param,
            e = this._batchState.renderer;
        d[0] = a.GetWidth();
        d[1] = a.GetHeight();
        d[2] = b ? b.GetWidth() : e.GetWidth();
        d[3] = b ? b.GetHeight() : e.GetHeight();
        d[4] = a.IsLinearSampling() ? 1 : 0;
        d[5] = "stretch" === c;
        c = this._shaderParams;
        C3$jscomp$53.clearArray(c);
        c.push(a._GetFramebuffer());
        c.push(b ? b._GetFramebuffer() : null)
    }
    DoBlitFramebuffer()
    {
        var a = this._mat4param,
            b = this._shaderParams;
        const c = this._gl;
        var d = a[0],
            e = a[1],
            f = a[2];
        const g = a[3],
            h = 0 !== a[4];
        a = 0 !== a[5];
        const k = b[1];
        c.bindFramebuffer(c.READ_FRAMEBUFFER, b[0]);
        c.bindFramebuffer(c.DRAW_FRAMEBUFFER, k);
        a ? c.blitFramebuffer(0, 0, d, e, 0, 0, f, g, c.COLOR_BUFFER_BIT, h ? c.LINEAR : c.NEAREST) : (b = Math.min(d, f), d = Math.min(e, g), f = Math.max(e - g, 0), e = Math.max(g - e, 0), c.blitFramebuffer(0, f, b, d + f, 0, e, b, d + e, c.COLOR_BUFFER_BIT, c.NEAREST))
    }
    InitStartQuery(a)
    {
        this._type =
        18;
        this._texParam = a
    }
    DoStartQuery()
    {
        this._texParam.BeginTimeElapsed();
        this._texParam = null
    }
    InitEndQuery(a)
    {
        this._type = 19;
        this._texParam = a
    }
    DoEndQuery()
    {
        this._texParam.EndTimeElapsed();
        this._texParam = null
    }
    InitSetEllipseParams(a, b, c)
    {
        this._type = 20;
        const d = this._mat4param;
        d[0] = a;
        d[1] = b;
        d[2] = c
    }
    DoSetEllipseParams()
    {
        const a = this._batchState.currentShader,
            b = this._mat4param;
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[0], b[1]);
        a._uOutlineThickness.IsUsed() && a._uOutlineThickness.Update1f(b[2])
    }
    InitSetTilemapInfo(a,
    b, c, d, e, f, g)
    {
        this._type = 16;
        const h = this._mat4param;
        a.writeToTypedArray(h, 0);
        h[4] = 1 / b;
        h[5] = 1 / c;
        h[6] = d / b;
        h[7] = e / c;
        h[8] = f / b;
        h[9] = g / c
    }
    DoSetTilemapInfo()
    {
        const a = this._batchState.currentShader,
            b = this._mat4param;
        a._uSrcStart.IsUsed() && a._uSrcStart.Update2f(b[0], b[1]);
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[4], b[5]);
        a._uTileSize.IsUsed() && a._uTileSize.Update2f(b[6], b[7]);
        a._uTileSpacing.IsUsed() && a._uTileSpacing.Update2f(b[8], b[9])
    }
    InitSetTileRandomizationInfo(a, b, c, d, e, f, g)
    {
        this._type = 29;
        const h =
        this._mat4param;
        h[0] = 1 / a;
        h[1] = 1 / b;
        h[2] = c;
        h[3] = d;
        h[4] = e;
        h[5] = f;
        h[6] = g
    }
    DoSetTileRandomizationInfo()
    {
        const a = this._batchState.currentShader,
            b = this._mat4param;
        a._uPixelSize.IsUsed() && a._uPixelSize.Update2f(b[0], b[1]);
        a._uTileSize.IsUsed() && a._uTileSize.Update2f(b[2], b[3]);
        a._uOutlineThickness.IsUsed() && a._uOutlineThickness.Update1f(b[4]);
        a._uTileSpacing.IsUsed() && a._uTileSpacing.Update2f(b[5], b[6])
    }
    InitClearDepth(a)
    {
        this._type = 22;
        this._startIndex = a ? 1 : 0
    }
    DoClearDepth()
    {
        const a = this._gl,
            b = 0 !== this._startIndex;
        b || a.depthMask(!0);
        a.clear(a.DEPTH_BUFFER_BIT);
        b || a.depthMask(!1)
    }
    InitSetDepthEnabled(a)
    {
        this._type = 23;
        this._startIndex = a ? 1 : 0
    }
    DoSetDepthEnabled()
    {
        const a = this._gl;
        0 === this._startIndex ? (a.disable(a.DEPTH_TEST), a.depthMask(!1)) : (a.enable(a.DEPTH_TEST), a.depthMask(!0))
    }
    InitSetDepthSamplingEnabled(a)
    {
        this._type = 24;
        this._startIndex = a ? 1 : 0
    }
    DoSetDepthSamplingEnabled()
    {
        const a = this._gl,
            b = this._batchState,
            c = b.renderer,
            d = 0 !== this._startIndex;
        b.isDepthSamplingEnabled = d;
        a.activeTexture(a.TEXTURE2);
        d ? (b.currentFramebufferNoDepth &&
        a.bindFramebuffer(a.FRAMEBUFFER, b.currentFramebufferNoDepth), a.bindTexture(a.TEXTURE_2D, c._GetDepthBuffer())) : (a.bindTexture(a.TEXTURE_2D, null), b.currentFramebufferNoDepth && a.bindFramebuffer(a.FRAMEBUFFER, b.currentFramebuffer));
        a.activeTexture(a.TEXTURE0)
    }
    InitCoplanarStartStencilPass()
    {
        this._type = 25
    }
    DoCoplanarStartStencilPass()
    {
        const a = this._gl;
        a.clear(a.STENCIL_BUFFER_BIT);
        a.enable(a.STENCIL_TEST);
        a.stencilFunc(a.ALWAYS, 1, 1);
        a.stencilOp(a.KEEP, a.KEEP, a.REPLACE);
        a.colorMask(!1, !1, !1, !1)
    }
    InitCoplanarStartColorPass()
    {
        this._type =
        26
    }
    DoCoplanarStartColorPass()
    {
        const a = this._gl;
        a.colorMask(!0, !0, !0, !0);
        a.stencilFunc(a.EQUAL, 1, 1);
        a.stencilOp(a.KEEP, a.KEEP, a.KEEP)
    }
    InitCoplanarRestore()
    {
        this._type = 27
    }
    DoCoplanarRestore()
    {
        const a = this._gl;
        a.disable(a.STENCIL_TEST)
    }
    InitSetScissor(a, b, c, d, e)
    {
        this._type = 28;
        this._startIndex = a ? 1 : 0;
        a = this._mat4param;
        a[0] = b;
        a[1] = c;
        a[2] = d;
        a[3] = e
    }
    DoSetScissor()
    {
        const a = this._gl,
            b = this._mat4param;
        1 === this._startIndex ? (a.enable(a.SCISSOR_TEST), a.scissor(b[0], b[1], b[2], b[3])) : a.disable(a.SCISSOR_TEST)
    }
    Run()
    {
        switch (this._type) {
        case 1:
            this.DoQuad();
            break;
        case 2:
            this.DoSetTexture();
            break;
        case 3:
            this.DoSetColor();
            break;
        case 4:
            this.DoSetBlend();
            break;
        case 5:
            this.DoSetViewport();
            break;
        case 6:
            this.DoSetProjection();
            break;
        case 7:
            this.DoSetModelView();
            break;
        case 8:
            this.DoSetRenderTarget();
            break;
        case 9:
            this.DoClearSurface();
            break;
        case 10:
            this.DoPoints();
            break;
        case 11:
            this.DoSetProgram();
            break;
        case 12:
            this.DoSetProgramParameters();
            break;
        case 13:
            this.DoSetProgramCustomParameters();
            break;
        case 14:
            this.DoInvalidateFramebuffer();
            break;
        case 15:
            this.DoSetPointTextureCoords();
            break;
        case 16:
            this.DoSetTilemapInfo();
            break;
        case 17:
            this.DoBlitFramebuffer();
            break;
        case 18:
            this.DoStartQuery();
            break;
        case 19:
            this.DoEndQuery();
            break;
        case 20:
            this.DoSetEllipseParams();
            break;
        case 21:
            this.DoSetGradientColor();
            break;
        case 22:
            this.DoClearDepth();
            break;
        case 23:
            this.DoSetDepthEnabled();
            break;
        case 24:
            this.DoSetDepthSamplingEnabled();
            break;
        case 25:
            this.DoCoplanarStartStencilPass();
            break;
        case 26:
            this.DoCoplanarStartColorPass();
            break;
        case 27:
            this.DoCoplanarRestore();
            break;
        case 28:
            this.DoSetScissor();
            break;
        case 29:
            this.DoSetTileRandomizationInfo()
        }
    }
}
;
"use strict";
const C3$jscomp$54 = self.C3,
    GENERIC_FONT_FAMILIES = new Set("serif sans-serif monospace cursive fantasy system-ui ui-serif ui-sans-serif ui-monospace ui-rounded math emoji fangsong".split(" ")),
    DEFAULT_OPTS = {
        timeout: 60
    },
    tempColor = new C3$jscomp$54.Color(0, 0, 0, 1),
    VALID_HORIZ_ALIGNMENTS = new Set(["left", "center", "right"]),
    VALID_VERT_ALIGNMENTS = new Set(["top", "center", "bottom"]),
    VALID_WORD_WRAP_MODES = new Set(["word", "cjk", "character"]),
    VALID_TEXT_DIRECTIONS = new Set(["ltr", "rtl"]),
    allRendererTexts = new Set;
C3$jscomp$54.FontManager && C3$jscomp$54.FontManager.addEventListener("fontload", a => {
    a = a.font.GetName();
    for (const b of allRendererTexts)
        (b.IsBBCodeEnabled() || C3$jscomp$54.equalsNoCase(b.GetFontName(), a)) && b._SetWordWrapChanged()
});
function fillOrStrokeRect(a, b, c, d, e, f) {
    b ? a.strokeRect(c, d, e, f) : a.fillRect(c, d, e, f)
}
function ptToPx(a) {
    return 4 / 3 * a
}
function getOffsetParam(a, b) {
    a = a.trim();
    const c = parseFloat(a);
    return isFinite(c) ? a.endsWith("%") ? b * c / 100 : c : 0
}
let didCheckFoundBoundingBoxSupport = !1,
    supportsFontBoundingBoxMeasurements = !1;
C3$jscomp$54.Gfx.RendererText = class {
    constructor(a, b)
    {
        b = Object.assign({}, DEFAULT_OPTS, b);
        this._renderer = a;
        this._fontName = "Arial";
        this._fontSize = 16;
        this._fontSizeScale = 1;
        this._lineHeight = 0;
        this._isItalic = this._isBold = !1;
        this._colorStr = "black";
        this._isBBcodeEnabled = !1;
        this._iconSet = null;
        this._iconSmoothing = !0;
        this.onloadfont = null;
        this._alreadyLoadedFonts = new Set;
        this._horizontalAlign = "left";
        this._verticalAlign = "top";
        this._text = "";
        this._bbString = null;
        this._wrappedText = C3$jscomp$54.New(C3$jscomp$54.WordWrap);
        this._wrapMode = "word";
        this._textDirection = "ltr";
        this._drawChanged = this._textLayoutChanged = this._wordWrapChanged = !1;
        this._drawMaxCharCount = -1;
        this._height = this._width = this._cssHeight = this._cssWidth = this._drawCharCount = 0;
        this._zoom = 1;
        this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = null;
        this._lastCanvasHeight = this._lastCanvasWidth = -1;
        this._lastTextCanvasFillStyle = this._lastMeasureCanvasFont = this._lastTextCanvasFont = "";
        this._lastTextCanvasLineWidth = this._lastTextCanvasOpacity =
        1;
        this._measureTextCallback = c => this._MeasureText(c);
        this._texture = null;
        this._rcTex = new C3$jscomp$54.Rect;
        this._scaleFactor = 1;
        this._textureTimeout = new C3$jscomp$54.IdleTimeout(() => {
            this.ReleaseTexture();
            this._SetTextCanvasSize(8, 8)
        }, b.timeout);
        this.ontextureupdate = null;
        this._wasReleased = !1;
        allRendererTexts.add(this)
    }
    Release()
    {
        this.onloadfont = null;
        this._alreadyLoadedFonts.clear();
        this._measureTextCallback = this._measureContextTop = this._measureContext = this._textContext = this._textCanvas = this._bbString =
        this._iconSet = null;
        this._textureTimeout.Release();
        this.ontextureupdate = null;
        this.ReleaseTexture();
        this._wrappedText.Clear();
        this._renderer = this._wrappedText = null;
        this._wasReleased = !0;
        allRendererTexts.delete(this)
    }
    _SetDrawChanged()
    {
        this._drawChanged = !0
    }
    _SetTextLayoutChanged()
    {
        this._SetDrawChanged();
        this._textLayoutChanged = !0
    }
    _SetWordWrapChanged()
    {
        this._SetTextLayoutChanged();
        this._wordWrapChanged = !0
    }
    SetBBCodeEnabled(a)
    {
        a = !!a;
        this._isBBcodeEnabled !== a && (a = (this._isBBcodeEnabled = a) ? "alphabetic" : "top",
        this._textContext && (this._textContext.textBaseline = a), this._measureContext && (this._measureContext.textBaseline = a), this._SetWordWrapChanged())
    }
    IsBBCodeEnabled()
    {
        return this._isBBcodeEnabled
    }
    SetIconSet(a)
    {
        this._iconSet !== a && (this._iconSet = a, this._wrappedText.SetIconSet(a), this._iconSet && this._iconSet.IsLoading() && this._iconSet.LoadContent().then(() => this._SetDrawChanged()), this._SetWordWrapChanged())
    }
    SetIconSmoothing(a)
    {
        a = !!a;
        this._iconSmoothing !== a && (this._iconSmoothing = a, this._SetDrawChanged())
    }
    SetFontName(a)
    {
        a ||
        (a = "serif");
        this._fontName !== a && (this._fontName = a, this._SetWordWrapChanged())
    }
    GetFontName()
    {
        return this._fontName
    }
    SetFontSize(a)
    {
        .1 > a && (a = .1);
        this._fontSize !== a && (this._fontSize = a, this._SetWordWrapChanged())
    }
    GetFontSize()
    {
        return this._fontSize
    }
    SetFontSizeScale(a)
    {
        this._fontSizeScale !== a && (this._fontSizeScale = a, this._SetWordWrapChanged())
    }
    SetLineHeight(a)
    {
        this._lineHeight !== a && (this._lineHeight = a, this._SetTextLayoutChanged())
    }
    GetLineHeight()
    {
        return this._lineHeight
    }
    SetBold(a)
    {
        a = !!a;
        this._isBold !==
        a && (this._isBold = a, this._SetWordWrapChanged())
    }
    IsBold()
    {
        return this._isBold
    }
    SetItalic(a)
    {
        a = !!a;
        this._isItalic !== a && (this._isItalic = a, this._SetWordWrapChanged())
    }
    IsItalic()
    {
        return this._isItalic
    }
    SetDrawMaxCharacterCount(a)
    {
        a = Math.floor(a);
        this._drawMaxCharCount !== a && (this._drawMaxCharCount = a, this._SetDrawChanged())
    }
    GetDrawMaxCharacterCount()
    {
        return this._drawMaxCharCount
    }
    _GetFontString(a, b)
    {
        let c = [];
        (this._isBold || b.HasStyleTag("b")) && c.push("bold");
        (this._isItalic || b.HasStyleTag("i")) && c.push("italic");
        var d = b.GetStyleTag("size");
        d = (d ? parseFloat(d.param) : this._fontSize) * this._fontSizeScale;
        a ? c.push(d + "pt") : c.push(d * this.GetDrawScale() + "pt");
        a = this._fontName;
        (b = b.GetStyleTag("font")) && b.param && (a = b.param, this.onloadfont && !this._alreadyLoadedFonts.has(a) && (this.onloadfont(a), this._alreadyLoadedFonts.add(a)));
        a && (GENERIC_FONT_FAMILIES.has(a) ? c.push(a) : c.push('"' + a + '"'));
        return c.join(" ")
    }
    SetColor(a)
    {
        a instanceof C3$jscomp$54.Color && (a = a.getCssRgb());
        this._colorStr !== a && (this._colorStr = a, this._SetDrawChanged())
    }
    SetColorRgb(a,
    b, c)
    {
        tempColor.setRgb(a, b, c);
        this.SetColor(tempColor)
    }
    SetHorizontalAlignment(a)
    {
        if (!VALID_HORIZ_ALIGNMENTS.has(a))
            throw Error("invalid horizontal alignment");
        this._horizontalAlign !== a && (this._horizontalAlign = a, this._SetTextLayoutChanged())
    }
    GetHorizontalAlignment()
    {
        return this._horizontalAlign
    }
    SetVerticalAlignment(a)
    {
        if (!VALID_VERT_ALIGNMENTS.has(a))
            throw Error("invalid vertical alignment");
        this._verticalAlign !== a && (this._verticalAlign = a, this._SetTextLayoutChanged())
    }
    GetVerticalAlignment()
    {
        return this._verticalAlign
    }
    SetWordWrapMode(a)
    {
        if (!VALID_WORD_WRAP_MODES.has(a))
            throw Error("invalid word wrap mode");
        this._wrapMode !== a && (this._wrapMode = a, this._SetWordWrapChanged())
    }
    GetWordWrapMode()
    {
        return this._wrapMode
    }
    SetTextDirection(a)
    {
        if (!VALID_TEXT_DIRECTIONS.has(a))
            throw Error("invalid text direction");
        this._textDirection !== a && (this._textDirection = a, this._textContext && (this._textContext.direction = this._textDirection), this._measureContext && (this._measureContext.direction = this._textDirection), this._SetWordWrapChanged())
    }
    GetTextDirection()
    {
        return this._textDirection
    }
    SetText(a)
    {
        this._text !== a && (this._text =
        a, this._SetWordWrapChanged())
    }
    GetText()
    {
        return this._text
    }
    GetDrawScale()
    {
        return this._scaleFactor * this._zoom * self.devicePixelRatio
    }
    SetSize(a, b, c)
    {
        "undefined" === typeof c && (c = 1);
        if (!(0 >= a || 0 >= a || this._cssWidth === a && this._cssHeight === b && this._zoom === c)) {
            var d = this._cssWidth;
            this._cssWidth = a;
            this._cssHeight = b;
            this._zoom = c;
            a = self.devicePixelRatio;
            this._width = this._cssWidth * this._zoom * a;
            this._height = this._cssHeight * this._zoom * a;
            a = Math.max(this._width, this._height);
            b = Math.min(this._renderer.GetMaxTextureSize(),
            4096);
            c = 1;
            a > b && (c = b / a, this._width = Math.min(this._width * c, b), this._height = Math.min(this._height * c, b));
            this._scaleFactor = c;
            this._cssWidth !== d ? this._SetWordWrapChanged() : this._SetTextLayoutChanged()
        }
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    GetZoom()
    {
        return this._zoom
    }
    GetTextWidth()
    {
        this._UpdateTextMeasurements();
        return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight()
    {
        this._UpdateTextMeasurements();
        return this._wrappedText.GetTotalLineHeight() + this._wrappedText.GetLineCount() *
        (this._lineHeight + 4) - this._lineHeight
    }
    GetLengthInGraphemes()
    {
        this._UpdateTextMeasurements();
        let a = 0;
        for (const b of this._wrappedText.GetLines())
            for (const c of b.fragments())
                a += c.GetLength();
        return a
    }
    GetTexture()
    {
        this._textureTimeout.Reset();
        this._MaybeUpdate();
        return this._texture
    }
    HitTestFragment(a, b)
    {
        this._UpdateTextMeasurements();
        const c = this.GetDrawScale();
        var d = this._wrappedText.GetLines();
        for (const e of d)
            if (d = e.GetFontBoundingBoxDescent() * c, b >= e.GetPosY() - e.GetHeight() * c + d && b < e.GetPosY() + d)
                for (const f of e.fragments())
                    if (a >=
                    f.GetPosX() && a < f.GetPosX() + f.GetWidth() * c)
                        return f;
        return null
    }
    *fragmentsWithTag(a)
    {
        this._UpdateTextMeasurements();
        var b = this._wrappedText.GetLines();
        for (const c of b)
            for (const d of c.fragments())
                (b = d.GetStyleTag("tag")) && C3$jscomp$54.equalsNoCase(b.param, a) && (yield d)
    }
    FindFragmentWithTag(a, b)
    {
        for (const c of this.fragmentsWithTag(a)) {
            if (0 === b)
                return c;
            --b
        }
        return null
    }
    CountFragmentsWithTag(a)
    {
        let b = 0;
        for (const c of this.fragmentsWithTag(a))
            ++b;
        return b
    }
    _MaybeUpdate()
    {
        this._texture && !this._drawChanged &&
        !this._textLayoutChanged && !this._wordWrapChanged || this._wasReleased || 0 >= this._width || 0 >= this._height || (this._drawChanged = !1, this._DoUpdate())
    }
    _DoUpdate()
    {
        this._wasReleased || (this._UpdateTextMeasurements(), this._SetTextCanvasSize(Math.max(C3$jscomp$54.nextHighestPowerOfTwo(Math.ceil(this._width)), 128), Math.max(C3$jscomp$54.nextHighestPowerOfTwo(Math.ceil(this._height)), 64)), this._DrawTextToCanvas(), this._UpdateTexture(), this._textureTimeout.Reset())
    }
    _SetTextCanvasSize(a, b)
    {
        this._textCanvas || (this._textCanvas =
        C3$jscomp$54.CreateCanvas(16, 16));
        let c = !1;
        if (this._lastCanvasWidth !== a || this._lastCanvasHeight !== b)
            this._lastCanvasWidth = a,
            this._lastCanvasHeight = b,
            this._textCanvas.width = a,
            this._textCanvas.height = b,
            c = !0;
        this._textContext || (this._textContext = this._textCanvas.getContext("2d"), c = !0);
        c ? (this._textContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._textContext.direction = this._textDirection, this._textContext.font = this._lastTextCanvasFont, this._textContext.fillStyle = this._lastTextCanvasFillStyle,
        this._textContext.strokeStyle = this._lastTextCanvasFillStyle, this._textContext.globalAlpha = this._lastTextCanvasOpacity, this._textContext.lineWidth = this._lastTextCanvasLineWidth) : this._textContext.clearRect(0, 0, a, b)
    }
    _MaybeCreateMeasureContext()
    {
        this._measureContext || (this._measureContext = C3$jscomp$54.CreateCanvas(16, 16).getContext("2d"), this._measureContextTop = C3$jscomp$54.CreateCanvas(16, 16).getContext("2d"), this._measureContext.textBaseline = this._isBBcodeEnabled ? "alphabetic" : "top", this._measureContextTop.textBaseline =
        "top", this._measureContext.direction = this._textDirection, this._measureContextTop.direction = this._textDirection)
    }
    _SetMeasureFontString(a)
    {
        this._lastMeasureCanvasFont !== a && (this._lastMeasureCanvasFont = a, this._measureContext.font = a, this._measureContextTop.font = a)
    }
    _SupportsFontBoundingBoxMeasurements()
    {
        if (!didCheckFoundBoundingBoxSupport) {
            didCheckFoundBoundingBoxSupport = !0;
            this._MaybeCreateMeasureContext();
            const a = this._measureContext.measureText("test");
            supportsFontBoundingBoxMeasurements = "number" ===
            typeof a.fontBoundingBoxAscent && "number" === typeof a.fontBoundingBoxDescent
        }
        return supportsFontBoundingBoxMeasurements
    }
    _UpdateTextMeasurements()
    {
        this._UpdateWordWrap();
        this._UpdateTextLayout()
    }
    _UpdateWordWrap()
    {
        this._wordWrapChanged && (this._MaybeCreateMeasureContext(), !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C3$jscomp$54.BBString(this._text, {
            noEscape: !0
        })), this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text,
        this._measureTextCallback, this._cssWidth, this._wrapMode, 0), this._wordWrapChanged = !1)
    }
    _UpdateTextLayout()
    {
        this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged = !1)
    }
    _MeasureText(a)
    {
        var b = a.IsText() ? a.GetCharacterArray().join("") : " ";
        this._SetMeasureFontString(this._GetFontString(!0, a));
        a = a.GetStyleTag("size");
        a = (a ? parseFloat(a.param) : this._fontSize) * this._fontSizeScale;
        const c = this._measureContext.measureText(b);
        let d = 0;
        this._isBBcodeEnabled && this._SupportsFontBoundingBoxMeasurements() &&
        (b = this._measureContextTop.measureText(b), d = c.fontBoundingBoxAscent - b.fontBoundingBoxAscent);
        return {
            width: c.width,
            height: ptToPx(a),
            fontBoundingBoxAscent: c.fontBoundingBoxAscent || 0,
            fontBoundingBoxDescent: c.fontBoundingBoxDescent || 0,
            topToAlphabeticDistance: d
        }
    }
    _SetDrawFontString(a)
    {
        this._lastTextCanvasFont !== a && (this._lastTextCanvasFont = a, this._textContext.font = a)
    }
    _SetDrawCanvasColor(a)
    {
        this._lastTextCanvasFillStyle !== a && (this._lastTextCanvasFillStyle = a, this._textContext.fillStyle = a, this._textContext.strokeStyle =
        a)
    }
    _SetDrawCanvasOpacity(a)
    {
        this._lastTextCanvasOpacity !== a && (this._lastTextCanvasOpacity = a, this._textContext.globalAlpha = a)
    }
    _SetDrawCanvasLineWith(a)
    {
        this._lastTextCanvasLineWidth !== a && (this._lastTextCanvasLineWidth = a, this._textContext.lineWidth = a)
    }
    _LayoutText()
    {
        const a = this.GetDrawScale(),
            b = (4 + this._lineHeight) * a;
        var c = 0;
        const d = this._wrappedText.GetLines();
        if (0 !== d.length) {
            for (var e of d) {
                e.SetPosX(NaN);
                e.SetPosY(NaN);
                for (var f of e.fragments())
                    f.SetPosX(NaN),
                    f.SetPosY(NaN)
            }
            f = this._isBBcodeEnabled &&
            this._SupportsFontBoundingBoxMeasurements();
            e = d[0].GetHeight() * a;
            "center" === this._verticalAlign ? (c = d.reduce((g, h) => g + h.GetHeight() * a + b, 0) - b, c = Math.max(this._height / 2 - c / 2, 0), f && (e = d[0].GetTopToAlphabeticDistance() * a)) : "bottom" === this._verticalAlign && (c = d.reduce((g, h) => g + h.GetHeight() * a + b, 0) - this._lineHeight * a, f = f ? d.at(-1).GetFontBoundingBoxDescent() * a : 0, c = this._height - c - f - 2);
            for (let g = 0, h = d.length; g < h; ++g) {
                f = d[g];
                const k = f.GetHeight() * a,
                    l = c;
                if (this._isBBcodeEnabled) {
                    if (c += 0 === g ? e : k, 0 < g && c > this._height -
                    4 * a)
                        break
                } else if (0 < g && c >= this._height - k)
                    break;
                0 <= l && this._LayoutTextLine(f, c, a);
                this._isBBcodeEnabled || (c += k);
                c += b
            }
        }
    }
    _LayoutTextLine(a, b, c)
    {
        let d = 0;
        "center" === this._horizontalAlign ? d = (this._width - a.GetWidth() * c) / 2 : "right" === this._horizontalAlign && (d = this._width - a.GetWidth() * c);
        a.SetPosX(d);
        a.SetPosY(b);
        for (const e of "ltr" === this._textDirection ? a.fragments() : a.fragmentsReverse())
            this._LayoutFragment(e, d, b, c),
            d += e.GetWidth() * c
    }
    _LayoutFragment(a, b, c, d)
    {
        var e = a.GetStyleTag("offsetx");
        b += e ? getOffsetParam(e.param,
        a.GetHeight()) * d : 0;
        e = a.GetStyleTag("offsety");
        c += e ? getOffsetParam(e.param, a.GetHeight()) * d : 0;
        a.IsIcon() && (e = a.GetStyleTag("iconoffsety"), c += e ? getOffsetParam(e.param, a.GetHeight()) * d : .2 * a.GetHeight() * d);
        a.SetPosX(b);
        a.SetPosY(c)
    }
    _DrawTextToCanvas()
    {
        this._textContext.imageSmoothingEnabled = this._iconSmoothing;
        this._textContext.imageSmoothingQuality = "high";
        this._drawCharCount = 0;
        const a = this.GetDrawScale(),
            b = this._wrappedText.GetLines();
        for (const c of b)
            this._DrawTextLine(c, a)
    }
    _DrawTextLine(a, b)
    {
        const c =
            a.GetPosX(),
            d = a.GetPosY();
        if (Number.isFinite(c) && Number.isFinite(d))
            for (const e of "ltr" === this._textDirection ? a.fragments() : a.fragmentsReverse())
                this._DrawFragment(e, b, a.GetHeight())
    }
    _DrawFragment(a, b, c)
    {
        const d = this._textContext,
            e = a.GetPosX(),
            f = a.GetPosY();
        if (Number.isFinite(e) && Number.isFinite(f)) {
            var g = c / 16;
            c = a.GetWidth() * b;
            var h = a.GetHeight() * b,
                k = a.GetHeight() / 16,
                l = (4 + this._lineHeight) * b,
                m = a.IsText() ? a.GetCharacterArray() : null;
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount)
                    return;
                a.IsText() && this._drawCharCount + m.length > this._drawMaxCharCount && (m = m.slice(0, this._drawMaxCharCount - this._drawCharCount), c = this._MeasureText(a).width * b);
                this._drawCharCount += a.GetLength()
            }
            var n = a.GetStyleTag("background"),
                p = a.HasStyleTag("u"),
                q = a.HasStyleTag("s");
            if ((!a.IsText() || !C3$jscomp$54.IsCharArrayAllWhitespace(m) || n || p || q) && !a.HasStyleTag("hide")) {
                var r = a.GetStyleTag("color"),
                    t = a.GetStyleTag("opacity");
                this._SetDrawCanvasOpacity(t ? parseFloat(t.param) / 100 : 1);
                n && (this._SetDrawCanvasColor(n.param),
                d.fillRect(e, f - h, c, h + l));
                l = (l = a.GetStyleTag("linethickness")) ? parseFloat(l.param) : 1;
                (n = a.HasStyleTag("stroke")) && this._SetDrawCanvasLineWith(.5 * k * l * this.GetDrawScale());
                a.IsText() ? (m = m.join(""), this._SetDrawFontString(this._GetFontString(!1, a)), !n && (this._SetDrawCanvasLineWith(.5 * k * l * this.GetDrawScale()), t = a.GetStyleTag("outlineback")) && (this._SetDrawCanvasColor(t.param), this._FillOrStrokeText(!0, m, e, f, c)), this._SetDrawCanvasColor(r ? r.param : this._colorStr), this._FillOrStrokeText(n, m, e, f, c), !n && (this._SetDrawCanvasLineWith(.5 *
                k * l * this.GetDrawScale()), a = a.GetStyleTag("outline")) && (this._SetDrawCanvasColor(a.param), this._FillOrStrokeText(!0, m, e, f, c))) : a.IsIcon() && 0 < a.GetWidth() && (a = a.GetDrawable(this._iconSet)) && d.drawImage(a, e, f - h, c, h);
                this._SetDrawCanvasColor(r ? r.param : this._colorStr);
                p && fillOrStrokeRect(d, n, e, f + b * g, c, b * g * l);
                q && (b *= k, d.fillRect(e, f - h / 4 + b / 2 - b * l / 2, c, b * l))
            }
        }
    }
    _FillOrStrokeText(a, b, c, d, e)
    {
        "rtl" === this._textDirection && (c += e);
        a ? "Gecko" === C3$jscomp$54.Platform.BrowserEngine ? this._textContext.strokeText(b, c, d,
        e) : this._textContext.strokeText(b, c, d) : "Gecko" === C3$jscomp$54.Platform.BrowserEngine ? this._textContext.fillText(b, c, d, e) : this._textContext.fillText(b, c, d)
    }
    _UpdateTexture()
    {
        if (!this._renderer.IsContextLost() && (this._texture || (this._texture = this._renderer.CreateDynamicTexture(this._textCanvas.width, this._textCanvas.height, {
            mipMap: !0,
            mipMapQuality: "high"
        })), this._renderer.UpdateTexture(this._textCanvas, this._texture), this._rcTex.set(0, 0, this._width / this._texture.GetWidth(), this._height / this._texture.GetHeight()),
        this.ontextureupdate))
            this.ontextureupdate()
    }
    GetTexRect()
    {
        return this._rcTex
    }
    ReleaseTexture()
    {
        this._texture && (this._renderer.IsContextLost() || this._renderer.DeleteTexture(this._texture), this._texture = null)
    }
    static OnContextLost()
    {
        for (const a of allRendererTexts)
            a.ReleaseTexture()
    }
    static GetAll()
    {
        return allRendererTexts.values()
    }
}
;
"use strict";
const C3$jscomp$55 = self.C3;
class WebGLRealTimeElapsedQuery {
    constructor(a)
    {
        this._gl = a.GetContext();
        this._version = a.GetWebGLVersionNumber();
        this._timerExt = a._GetDisjointTimerQueryExtension();
        this._query = null;
        this._hasResult = this._isActive = !1;
        this._result = 0;
        this._query = 1 === this._version ? this._timerExt.createQueryEXT() : this._gl.createQuery()
    }
    Release()
    {
        this._DeleteQueryObject();
        this._timerExt = this._gl = null;
        this._hasResult = !1
    }
    _DeleteQueryObject()
    {
        this._query && (1 === this._version ? this._timerExt.deleteQueryEXT(this._query) : this._gl.deleteQuery(this._query),
        this._query = null)
    }
    BeginTimeElapsed()
    {
        if (this._isActive)
            throw Error("query already active");
        1 === this._version ? this._timerExt.beginQueryEXT(this._timerExt.TIME_ELAPSED_EXT, this._query) : this._gl.beginQuery(this._timerExt.TIME_ELAPSED_EXT, this._query);
        this._isActive = !0
    }
    EndTimeElapsed()
    {
        if (!this._isActive)
            throw Error("query not active");
        1 === this._version ? this._timerExt.endQueryEXT(this._timerExt.TIME_ELAPSED_EXT) : this._gl.endQuery(this._timerExt.TIME_ELAPSED_EXT);
        this._isActive = !1
    }
    CheckForResult()
    {
        if (this._query &&
        !this._hasResult && !this._isActive) {
            var a = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_AVAILABLE_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT_AVAILABLE);
            var b = this._gl.getParameter(this._timerExt.GPU_DISJOINT_EXT);
            a && !b && (this._result = 1 === this._version ? this._timerExt.getQueryObjectEXT(this._query, this._timerExt.QUERY_RESULT_EXT) : this._gl.getQueryParameter(this._query, this._gl.QUERY_RESULT), this._result /= 1E9, this._hasResult = !0);
            (a ||
            b) && this._DeleteQueryObject()
        }
    }
    HasResult()
    {
        return this._hasResult
    }
    GetResult()
    {
        if (!this._hasResult)
            throw Error("no result available");
        return this._result
    }
}
C3$jscomp$55.Gfx.WebGLTimeElapsedQuery = class {
    constructor(a)
    {
        this._renderer = a;
        this._frameNumber = a.GetFrameNumber();
        this._isActive = !1;
        this._parentQuery = null;
        this._isNested = !1;
        this._realQuery = null;
        this._queries = []
    }
    Release()
    {
        for (const a of this._queries)
            a instanceof WebGLRealTimeElapsedQuery && a.Release();
        C3$jscomp$55.clearArray(this._queries);
        this._renderer = this._realQuery = this._parentQuery = null
    }
    BeginTimeElapsed()
    {
        if (this._isActive)
            throw Error("query already active");
        const a = this._renderer._GetTimeQueryStack();
        0 < a.length ? (this._isNested = !0, this._parentQuery = a.at(-1), this._parentQuery._EndReal(), this._parentQuery._queries.push(this)) : (this._isNested = !1, this._parentQuery = null);
        this._isActive = !0;
        a.push(this);
        this._StartReal()
    }
    EndTimeElapsed()
    {
        if (!this._isActive)
            throw Error("query not active");
        if (this._renderer._GetTimeQueryStack().pop() !== this)
            throw Error("can only end most nested query");
        this._isActive = !1;
        this._EndReal();
        this._parentQuery && (this._parentQuery._StartReal(), this._parentQuery = null)
    }
    _StartReal()
    {
        this._realQuery =
        C3$jscomp$55.New(WebGLRealTimeElapsedQuery, this._renderer);
        this._queries.push(this._realQuery);
        this._realQuery.BeginTimeElapsed()
    }
    _EndReal()
    {
        this._realQuery.EndTimeElapsed();
        this._realQuery = null
    }
    CheckForResult()
    {
        for (const a of this._queries)
            a.CheckForResult()
    }
    IsNested()
    {
        return this._isNested
    }
    HasResult()
    {
        return this._queries.every(a => a.HasResult())
    }
    GetResult()
    {
        return this._queries.reduce((a, b) => a + b.GetResult(), 0)
    }
    GetFrameNumber()
    {
        return this._frameNumber
    }
}
;
"use strict";
const C3$jscomp$56 = self.C3;
C3$jscomp$56.Gfx.WebGLQueryResultBuffer = class {
    constructor(a, b=1E3)
    {
        this._renderer = a;
        this._maxQueries = b;
        this._buffer = [];
        this._renderer._AddQueryResultBuffer(this)
    }
    Release()
    {
        this.Clear();
        this._renderer._RemoveQueryResultBuffer(this);
        this._renderer = null
    }
    Clear()
    {
        for (const a of this._buffer)
            a.Release();
        C3$jscomp$56.clearArray(this._buffer)
    }
    AddTimeElapsedQuery()
    {
        const a = new C3$jscomp$56.Gfx.WebGLTimeElapsedQuery(this._renderer);
        this._buffer.push(a);
        this._buffer.length > this._maxQueries && this._buffer.shift().Release();
        return a
    }
    CheckForResults(a)
    {
        for (const b of this._buffer) {
            if (b.GetFrameNumber() >= a)
                break;
            if (b.IsNested())
                break;
            b.CheckForResult()
        }
    }
    GetFrameRangeResultSum(a, b)
    {
        if (b <= a)
            return NaN;
        let c = 0;
        for (const d of this._buffer) {
            if (d.GetFrameNumber() >= b)
                break;
            if (!(d.GetFrameNumber() < a))
                if (d.HasResult())
                    c += d.GetResult();
                else
                    return NaN
        }
        return c
    }
    DeleteAllBeforeFrameNumber(a)
    {
        for (let b = 0, c = this._buffer.length; b < c; ++b) {
            const d = this._buffer[b];
            if (d.GetFrameNumber() < a)
                d.Release();
            else {
                0 < b && this._buffer.splice(0, b);
                break
            }
        }
    }
}
;
"use strict";
const C3$jscomp$57 = self.C3,
    glMatrix$jscomp$6 = self.glMatrix,
    vec4$jscomp$3 = glMatrix$jscomp$6.vec4,
    mat4$jscomp$6 = glMatrix$jscomp$6.mat4,
    DEFAULT_WEBGLRENDERER_OPTS = {
        powerPreference: "default",
        enableGpuProfiling: !0,
        alpha: !1,
        depth: !1,
        canSampleDepth: !1,
        maxWebGLVersion: 2,
        failIfMajorPerformanceCaveat: !1
    },
    VALID_POWER_PREFERENCES = new Set(["default", "low-power", "high-performance"]),
    MAX_INDICES = 12E3,
    LAST_POINT = 7996,
    defaultTexCoordsQuad$jscomp$1 = new C3$jscomp$57.Quad(0, 0, 1, 0, 1, 1, 0, 1),
    tmpProjection = mat4$jscomp$6.create(),
    tmpModelView = mat4$jscomp$6.create(),
    tmpQuad$jscomp$1 = new C3$jscomp$57.Quad,
    tmpRect$jscomp$1 = new C3$jscomp$57.Rect;
let loseContextExtension = null;
C3$jscomp$57.isDebug && (self.debug_lose_webgl_context = function() {
    loseContextExtension ? loseContextExtension.loseContext() : console.warn("WEBGL_lose_context not supported")
}, self.debug_restore_webgl_context = function() {
    loseContextExtension ? loseContextExtension.restoreContext() : console.warn("WEBGL_lose_context not supported")
});
const pendingPolls = new Set;
let pollRafId = -1;
function CheckPendingPolls() {
    pollRafId = -1;
    for (const a of pendingPolls)
        a.checkFunc() && (a.resolve(), pendingPolls.delete(a));
    0 < pendingPolls.size && (pollRafId = self.requestAnimationFrame(CheckPendingPolls))
}
C3$jscomp$57.Gfx.WebGLRenderer = class  extends C3$jscomp$57.Gfx.RendererBase{
    constructor(a, b)
    {
        super(b);
        b = Object.assign({}, DEFAULT_WEBGLRENDERER_OPTS, b);
        if (!VALID_POWER_PREFERENCES.has(b.powerPreference))
            throw Error("invalid power preference");
        const c = {
            alpha: !!b.alpha,
            depth: !1,
            antialias: !1,
            powerPreference: b.powerPreference,
            failIfMajorPerformanceCaveat: !!b.failIfMajorPerformanceCaveat
        };
        let d = null,
            e = 0;
        2 <= b.maxWebGLVersion && (d = a.getContext("webgl2", c), e = 2);
        d || (d = a.getContext("webgl", c), e = 1);
        if (!d)
            throw Error("renderer-unavailable (could not get WebGL context)");
        this._gl = d;
        this._attribs = d.getContextAttributes();
        this._versionString = d.getParameter(d.VERSION);
        this._version = e;
        this._viewport = vec4$jscomp$3.create();
        this._didChangeTransform = !1;
        this._bbProjectionMatrix = mat4$jscomp$6.create();
        this._usesDepthBuffer = !!b.depth;
        this._canSampleDepth = !(!b.depth || !b.canSampleDepth);
        this._isDepthEnabled = this._usesDepthBuffer;
        this._isDepthSamplingEnabled = !1;
        this._depthBuffer = null;
        this._isAutoSizeDepthBuffer = !0;
        this._depthBufferHeight = this._depthBufferWidth = 0;
        this._pointBuffer =
        this._indexBuffer = this._texcoordBuffer = this._vertexBuffer = null;
        this._vertexData = new Float32Array(8E3 * this.GetNumVertexComponents());
        this._indexData = new Uint16Array(MAX_INDICES);
        this._texcoordData = new Float32Array(16E3);
        this._pointData = new Float32Array(32E3);
        this._lastVertexPtr = this._pointPtr = this._texPtr = this._vertexPtr = 0;
        this._spDeviceTransformTextureFill = this._lastProgram = null;
        this._batch = [];
        this._topOfBatch = this._batchPtr = 0;
        this._currentRenderTarget = null;
        this._lastPointZ = 0;
        this._batchState = C3$jscomp$57.New(C3$jscomp$57.Gfx.BatchState,
        this);
        this._lastColor = C3$jscomp$57.New(C3$jscomp$57.Color, 1, 1, 1, 1);
        this._lastTexture1 = this._lastTexture0 = null;
        this._lastDestBlend = this._lastSrcBlend = 0;
        this._lastPointTexCoords = new C3$jscomp$57.Rect;
        this._lastScissorRect = C3$jscomp$57.New(C3$jscomp$57.Rect, 0, 0, -1, -1);
        this._coplanarMode = 0;
        this._maxTextureSize = -1;
        this._highpPrecision = this._maxPointSize = this._minPointSize = 0;
        this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
        this._extensions = [];
        this._isInitialisingAfterContextRestored = !1;
        this._textureLodExt =
        this._stdDerivativesExt = this._fragDepthExt = this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = null;
        this._maxAnisotropy = 0;
        this._isGpuProfilingEnabled = !!b.enableGpuProfiling;
        this._timerExt = null;
        this._allQueryResultBuffers = new Set;
        this._timeQueryStack = [];
        this.FillIndexBufferData(this._indexData)
    }
    IsWebGL()
    {
        return !0
    }
    async InitState()
    {
        super.InitState();
        var a = this._gl,
            b = this.GetNumVertexComponents();
        this._lastColor.setRgba(1, 1, 1, 1);
        this._lastTexture1 = this._lastTexture0 = null;
        this._pointPtr =
        this._vertexPtr = 0;
        this._lastVertexPtr = 8E3 * b - 4 * b;
        C3$jscomp$57.clearArray(this._batch);
        this._topOfBatch = this._batchPtr = 0;
        this._currentRenderTarget = this._lastProgram = null;
        this._lastPointTexCoords.set(0, 0, 1, 1);
        this._lastPointZ = 0;
        b = this._batchState;
        b.currentShader = null;
        b.currentFramebuffer = null;
        b.currentFramebufferNoDepth = null;
        vec4$jscomp$3.set(b.currentColor, 1, 1, 1, 1);
        b.clearColor.setRgba(0, 0, 0, 0);
        b.pointTexCoords.set(0, 0, 1, 1);
        a.clearColor(0, 0, 0, 0);
        a.clear(a.COLOR_BUFFER_BIT);
        a.enable(a.BLEND);
        a.blendFunc(a.ONE,
        a.ONE_MINUS_SRC_ALPHA);
        this._lastSrcBlend = a.ONE;
        this._lastDestBlend = a.ONE_MINUS_SRC_ALPHA;
        this._InitBlendModes(a);
        a.disable(a.CULL_FACE);
        a.disable(a.STENCIL_TEST);
        a.disable(a.DITHER);
        this._usesDepthBuffer ? (a.enable(a.DEPTH_TEST), a.depthMask(!0), a.depthFunc(a.LEQUAL)) : (a.disable(a.DEPTH_TEST), a.depthMask(!1));
        this._isDepthEnabled = this._usesDepthBuffer;
        this._isDepthSamplingEnabled = !1;
        this._pointBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._pointBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._pointData.byteLength,
        a.DYNAMIC_DRAW);
        this._vertexBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._vertexBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._vertexData.byteLength, a.DYNAMIC_DRAW);
        this._texcoordBuffer = a.createBuffer();
        a.bindBuffer(a.ARRAY_BUFFER, this._texcoordBuffer);
        a.bufferData(a.ARRAY_BUFFER, this._texcoordData.byteLength, a.DYNAMIC_DRAW);
        this._indexBuffer = a.createBuffer();
        a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        a.bufferData(a.ELEMENT_ARRAY_BUFFER, this._indexData, a.STATIC_DRAW);
        a.activeTexture(a.TEXTURE0);
        a.bindTexture(a.TEXTURE_2D, null);
        this._maxTextureSize = a.getParameter(a.MAX_TEXTURE_SIZE);
        b = a.getParameter(a.ALIASED_POINT_SIZE_RANGE);
        this._minPointSize = b[0];
        this._maxPointSize = b[1];
        b = a.getShaderPrecisionFormat(a.VERTEX_SHADER, a.HIGH_FLOAT);
        var c = a.getShaderPrecisionFormat(a.FRAGMENT_SHADER, a.HIGH_FLOAT);
        this._highpPrecision = b && c ? Math.min(b.precision, c.precision) : 0;
        2048 < this._maxPointSize && (this._maxPointSize = 2048);
        this._extensions = a.getSupportedExtensions();
        if (b = a.getExtension("WEBGL_debug_renderer_info"))
            this._unmaskedVendor =
            a.getParameter(b.UNMASKED_VENDOR_WEBGL),
            this._unmaskedRenderer = a.getParameter(b.UNMASKED_RENDERER_WEBGL);
        this._parallelShaderCompileExt = a.getExtension("KHR_parallel_shader_compile");
        C3$jscomp$57.isDebug && (loseContextExtension = a.getExtension("WEBGL_lose_context"));
        this._isGpuProfilingEnabled && (1 === this.GetWebGLVersionNumber() ? this._timerExt = a.getExtension("EXT_disjoint_timer_query") : this._timerExt = a.getExtension("EXT_disjoint_timer_query_webgl2") || a.getExtension("EXT_disjoint_timer_query"));
        this._maxAnisotropy =
        (this._anisotropicExt = a.getExtension("EXT_texture_filter_anisotropic")) ? a.getParameter(this._anisotropicExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        if (2 > this.GetWebGLVersionNumber() && this._usesDepthBuffer && this._canSampleDepth && (this._depthTextureExt = a.getExtension("WEBGL_depth_texture"), !this._depthTextureExt))
            throw Error("no depth texture support");
        2 > this.GetWebGLVersionNumber() && (this._fragDepthExt = a.getExtension("EXT_frag_depth"), this._stdDerivativesExt = a.getExtension("OES_standard_derivatives"), this._textureLodExt =
        a.getExtension("EXT_shader_texture_lod"));
        a = C3$jscomp$57.Gfx.WebGLShaderProgram;
        b = a.GetDefaultVertexShaderSource(!1);
        c = a.GetTextureFillFragmentShaderSource_WebGL1_NoFragDepth();
        let d = b,
            e = a.GetPointFragmentShaderSource_WebGL1_NoFragDepth(),
            f = a.GetPointVertexShaderSource_WebGL1(),
            g = a.GetTilemapFragmentShaderSource_WebGL1_NoFragDepth(),
            h = a.GetDefaultVertexShaderSource(!0);
        var k = !1;
        this._usesDepthBuffer && (2 > this.GetWebGLVersionNumber() ? this._fragDepthExt && (c = a.GetTextureFillFragmentShaderSource_WebGL1_FragDepthEXT(),
        e = a.GetPointFragmentShaderSource_WebGL1_FragDepthEXT(), g = a.GetTilemapFragmentShaderSource_WebGL1_FragDepthEXT(), k = !0) : (d = a.GetDefaultVertexShaderSource_WebGL2(), c = a.GetTextureFillFragmentShaderSource_WebGL2(), e = a.GetPointFragmentShaderSource_WebGL2(), f = a.GetPointVertexShaderSource_WebGL2(), g = a.GetTilemapFragmentShaderSource_WebGL2(), h = a.GetDefaultVertexShaderSource_WebGL2(!0)));
        k = a.GetTileRandomizationFragmentShaderSource(this.GetWebGLVersionNumber(), k, this._stdDerivativesExt && this._textureLodExt);
        const l = 2 <= this.GetWebGLVersionNumber() ? a.GetDefaultVertexShaderSource_WebGL2() : b;
        a = [[c, d, "<default>"], [c, d, "<default-device-transform>"], [e, f, "<point>"], [a.GetColorFillFragmentShaderSource(), b, "<fill>"], [a.GetLinearGradientFillFragmentShaderSource(), b, "<lineargradient>"], [a.GetPenumbraFillFragmentShaderSource(), b, "<penumbra>"], [a.GetHardEllipseFillFragmentShaderSource(), b, "<hardellipse>"], [a.GetHardEllipseOutlineFragmentShaderSource(), b, "<hardellipseoutline>"], [a.GetSmoothEllipseFillFragmentShaderSource(),
        b, "<smoothellipse>"], [a.GetSmoothEllipseOutlineFragmentShaderSource(), b, "<smoothellipseoutline>"], [a.GetSmoothLineFillFragmentShaderSource(), b, "<smoothline>"], [g, h, "<tilemap>"], [k, l, "<tilerandomization>"]];
        a = await Promise.all(a.map(m => this.CreateShaderProgram({
            src: m[0],
            vertexSrc: m[1],
            name: m[2]
        })));
        this._spTextureFill = a[0];
        this._spDeviceTransformTextureFill = a[1];
        this._spPoints = a[2];
        this._spColorFill = a[3];
        this._spLinearGradientFill = a[4];
        this._spPenumbraFill = a[5];
        this._spHardEllipseFill = a[6];
        this._spHardEllipseOutline =
        a[7];
        this._spSmoothEllipseFill = a[8];
        this._spSmoothEllipseOutline = a[9];
        this._spSmoothLineFill = a[10];
        this._spTilemapFill = a[11];
        this._spTileRandomization = a[12];
        this.SetTextureFillMode()
    }
    async CreateShaderProgram(a)
    {
        a = await C3$jscomp$57.Gfx.WebGLShaderProgram.Create(this, a);
        this._AddShaderProgram(a);
        return a
    }
    ResetLastProgram()
    {
        this._lastProgram = null
    }
    SetSize(a, b, c)
    {
        if (this._width !== a || this._height !== b || c) {
            this.EndBatch();
            c = this._gl;
            var d = this._batchState;
            this._width = a;
            this._height = b;
            this._SetViewport(0,
            0, a, b);
            this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, a / b);
            this.SetProjectionMatrix(this._bbProjectionMatrix);
            this._spDeviceTransformTextureFill && (c.useProgram(this._spDeviceTransformTextureFill.GetShaderProgram()), this._spDeviceTransformTextureFill._UpdateDeviceTransformUniforms(this._matP), this._lastProgram = this._spDeviceTransformTextureFill, this._batchState.currentShader = this._spDeviceTransformTextureFill);
            c.bindTexture(c.TEXTURE_2D, null);
            c.activeTexture(c.TEXTURE1);
            c.bindTexture(c.TEXTURE_2D,
            null);
            c.activeTexture(c.TEXTURE0);
            this._lastTexture1 = this._lastTexture0 = null;
            this._usesDepthBuffer && this._isAutoSizeDepthBuffer && this._SetDepthBufferSize(this._width, this._height);
            this._currentRenderTarget && this._currentRenderTarget._Resize(this._width, this._height);
            c.bindFramebuffer(c.FRAMEBUFFER, null);
            this._currentRenderTarget = null;
            d.currentFramebuffer = null;
            d.currentFramebufferNoDepth = null
        }
    }
    _SetDepthBufferSize(a, b)
    {
        const c = this._gl;
        this._depthBuffer && this._depthBufferWidth === a && this._depthBufferHeight ===
        b || (this._canSampleDepth ? (this._depthBuffer && c.deleteTexture(this._depthBuffer), this._depthBuffer = c.createTexture(), c.bindTexture(c.TEXTURE_2D, this._depthBuffer), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.NEAREST), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), 2 <= this.GetWebGLVersionNumber() ? c.texImage2D(c.TEXTURE_2D, 0, c.DEPTH24_STENCIL8, a, b, 0, c.DEPTH_STENCIL,
        c.UNSIGNED_INT_24_8, null) : this._depthTextureExt && c.texImage2D(c.TEXTURE_2D, 0, c.DEPTH_STENCIL, a, b, 0, c.DEPTH_STENCIL, this._depthTextureExt.UNSIGNED_INT_24_8_WEBGL, null), c.bindTexture(c.TEXTURE_2D, null)) : (this._depthBuffer && c.deleteRenderbuffer(this._depthBuffer), this._depthBuffer = c.createRenderbuffer(), c.bindRenderbuffer(c.RENDERBUFFER, this._depthBuffer), c.renderbufferStorage(c.RENDERBUFFER, 2 <= this._version ? c.DEPTH24_STENCIL8 : c.DEPTH_STENCIL, a, b), c.bindRenderbuffer(c.RENDERBUFFER, null)), this._depthBufferWidth =
        a, this._depthBufferHeight = b)
    }
    SetFixedSizeDepthBuffer(a, b)
    {
        this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !1, this._SetDepthBufferSize(a, b))
    }
    SetAutoSizeDepthBuffer()
    {
        this._usesDepthBuffer && (this._isAutoSizeDepthBuffer = !0, this._SetDepthBufferSize(this._width, this._height))
    }
    _SetViewport(a, b, c, d)
    {
        const e = this._viewport;
        if (e[0] !== a || e[1] !== b || e[2] !== c || e[3] !== d)
            this.PushBatch().InitSetViewport(a, b, c, d),
            vec4$jscomp$3.set(e, a, b, c, d),
            this._topOfBatch = 0
    }
    SetFovY(a)
    {
        super.SetFovY(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix,
        this._width / this._height)
    }
    SetNearZ(a)
    {
        super.SetNearZ(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetFarZ(a)
    {
        super.SetFarZ(a);
        this.CalculatePerspectiveMatrix(this._bbProjectionMatrix, this._width / this._height)
    }
    SetProjectionMatrix(a)
    {
        mat4$jscomp$6.exactEquals(this._matP, a) || (this.PushBatch().InitSetProjection(a), mat4$jscomp$6.copy(this._matP, a), this._topOfBatch = 0, this._didChangeTransform = !0)
    }
    SetDefaultRenderTargetProjectionState()
    {
        let a,
            b;
        var c = this._currentRenderTarget;
        null === c ? (a = this._bbProjectionMatrix, b = this.GetWidth(), c = this.GetHeight()) : (a = c.GetProjectionMatrix(), b = c.GetWidth(), c = c.GetHeight());
        this.SetProjectionMatrix(a);
        this._SetViewport(0, 0, b, c)
    }
    SetModelViewMatrix(a)
    {
        mat4$jscomp$6.exactEquals(this._matMV, a) || (this.PushBatch().InitSetModelView(a), mat4$jscomp$6.copy(this._matMV, a), this._topOfBatch = 0, this._didChangeTransform = !0)
    }
    ResetDidChangeTransformFlag()
    {
        this._didChangeTransform = !1
    }
    DidChangeTransform()
    {
        return this._didChangeTransform
    }
    GetBatchState()
    {
        return this._batchState
    }
    PushBatch()
    {
        const a =
        this._batch;
        this._batchPtr === a.length && a.push(new C3$jscomp$57.Gfx.WebGLBatchJob(this._batchState));
        return a[this._batchPtr++]
    }
    EndBatch()
    {
        0 === this._batchPtr || this.IsContextLost() || (this._WriteBuffers(), this._ExecuteBatch(), this._topOfBatch = this._pointPtr = this._texPtr = this._vertexPtr = this._batchPtr = 0)
    }
    _WriteBuffers()
    {
        const a = this._gl;
        0 < this._pointPtr && (a.bindBuffer(a.ARRAY_BUFFER, this._pointBuffer), a.bufferSubData(a.ARRAY_BUFFER, 0, this._pointData.subarray(0, this._pointPtr)));
        0 < this._vertexPtr && (a.bindBuffer(a.ARRAY_BUFFER,
        this._vertexBuffer), a.bufferSubData(a.ARRAY_BUFFER, 0, this._vertexData.subarray(0, this._vertexPtr)), a.bindBuffer(a.ARRAY_BUFFER, this._texcoordBuffer), a.bufferSubData(a.ARRAY_BUFFER, 0, this._texcoordData.subarray(0, this._texPtr)))
    }
    _ExecuteBatch()
    {
        const a = this._batch;
        for (let b = 0, c = this._batchPtr; b < c; ++b)
            a[b].Run()
    }
    GetOpacity()
    {
        return this._lastColor.getA()
    }
    SetColorRgba(a, b, c, d)
    {
        const e = this._lastColor;
        e.equalsRgba(a, b, c, d) || (e.setRgba(a, b, c, d), this.PushBatch().InitSetColor(e), this._topOfBatch = 0, this._currentStateGroup =
        null)
    }
    SetOpacity(a)
    {
        const b = this._lastColor;
        b.getA() !== a && (b.setA(a), this.PushBatch().InitSetColor(b), this._topOfBatch = 0, this._currentStateGroup = null)
    }
    SetColor(a)
    {
        const b = this._lastColor;
        b.equals(a) || (b.set(a), this.PushBatch().InitSetColor(b), this._topOfBatch = 0, this._currentStateGroup = null)
    }
    ResetColor()
    {
        this.SetColorRgba(1, 1, 1, 1)
    }
    GetColor()
    {
        return this._lastColor
    }
    SetTexture(a)
    {
        a !== this._lastTexture0 && (this.PushBatch().InitSetTexture(a), this._lastTexture0 = a, this._topOfBatch = 0)
    }
    _ResetLastTexture()
    {
        this._lastTexture0 =
        null
    }
    SetBlendMode(a)
    {
        a = this._GetBlendByIndex(a);
        this._SetBlend(a[0], a[1])
    }
    SetNamedBlendMode(a)
    {
        a = this.GetNamedBlend(a);
        this._SetBlend(a.srcBlend, a.destBlend)
    }
    _SetBlend(a, b)
    {
        if (a !== this._lastSrcBlend || b !== this._lastDestBlend)
            this.PushBatch().InitSetBlend(a, b),
            this._lastSrcBlend = a,
            this._lastDestBlend = b,
            this._topOfBatch = 0,
            this._currentStateGroup = null
    }
    IsPremultipliedAlphaBlend()
    {
        return this._lastSrcBlend === this._gl.ONE && this._lastDestBlend === this._gl.ONE_MINUS_SRC_ALPHA
    }
    SetAlphaBlend()
    {
        this._SetBlend(this._gl.ONE,
        this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetNoPremultiplyAlphaBlend()
    {
        this._SetBlend(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA)
    }
    SetCopyBlend()
    {
        this._SetBlend(this._gl.ONE, this._gl.ZERO)
    }
    Rect(a)
    {
        this.Rect2(a.getLeft(), a.getTop(), a.getRight(), a.getBottom())
    }
    Rect2(a, b, c, d)
    {
        this.Quad2(a, b, c, b, c, d, a, d)
    }
    _ExtendQuadBatch()
    {
        let a = this._vertexPtr;
        a >= this._lastVertexPtr && (this.EndBatch(), a = 0);
        1 === this._topOfBatch ? this._batch[this._batchPtr - 1]._indexCount += 6 : (this.PushBatch().InitQuad(a, 6), this._topOfBatch = 1)
    }
    _WriteQuadToVertexBuffer(a)
    {
        a.writeToTypedArray3D(this._vertexData,
        this._vertexPtr, this._baseZ + this._currentZ);
        this._vertexPtr += 12
    }
    Quad(a)
    {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        defaultTexCoordsQuad$jscomp$1.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad2(a, b, c, d, e, f, g, h)
    {
        this._ExtendQuadBatch();
        const k = this._vertexData;
        let l = this._vertexPtr;
        const m = this._baseZ + this._currentZ;
        k[l++] = a;
        k[l++] = b;
        k[l++] = m;
        k[l++] = c;
        k[l++] = d;
        k[l++] = m;
        k[l++] = e;
        k[l++] = f;
        k[l++] = m;
        k[l++] = g;
        k[l++] = h;
        k[l++] = m;
        this._vertexPtr = l;
        defaultTexCoordsQuad$jscomp$1.writeToTypedArray(this._texcoordData,
        this._texPtr);
        this._texPtr += 8
    }
    Quad3(a, b)
    {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        b.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad4(a, b)
    {
        this._ExtendQuadBatch();
        this._WriteQuadToVertexBuffer(a);
        b.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3D(a, b, c, d, e, f, g, h, k, l, m, n, p)
    {
        this._ExtendQuadBatch();
        const q = this._vertexData;
        let r = this._vertexPtr;
        const t = this._baseZ + this._currentZ;
        q[r++] = a;
        q[r++] = b;
        q[r++] = t + c;
        q[r++] = d;
        q[r++] = e;
        q[r++] =
        t + f;
        q[r++] = g;
        q[r++] = h;
        q[r++] = t + k;
        q[r++] = l;
        q[r++] = m;
        q[r++] = t + n;
        this._vertexPtr = r;
        p.writeAsQuadToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    Quad3D2(a, b, c, d, e, f, g, h, k, l, m, n, p)
    {
        this._ExtendQuadBatch();
        const q = this._vertexData;
        let r = this._vertexPtr;
        const t = this._baseZ + this._currentZ;
        q[r++] = a;
        q[r++] = b;
        q[r++] = t + c;
        q[r++] = d;
        q[r++] = e;
        q[r++] = t + f;
        q[r++] = g;
        q[r++] = h;
        q[r++] = t + k;
        q[r++] = l;
        q[r++] = m;
        q[r++] = t + n;
        this._vertexPtr = r;
        p.writeToTypedArray(this._texcoordData, this._texPtr);
        this._texPtr += 8
    }
    DrawMesh(a,
    b, c)
    {
        const d = this._vertexData,
            e = this._texcoordData;
        if (0 !== c.length % 3)
            throw Error("invalid index buffer length");
        for (let k = 0, l = c.length; k < l;) {
            var f = c[k++],
                g = c[k++],
                h = c[k++];
            const m = 3 * f,
                n = 3 * g,
                p = 3 * h;
            f *= 2;
            g *= 2;
            h *= 2;
            this._ExtendQuadBatch();
            let q = this._vertexPtr,
                r = this._texPtr;
            d[q++] = a[m + 0];
            d[q++] = a[m + 1];
            d[q++] = a[m + 2];
            d[q++] = a[n + 0];
            d[q++] = a[n + 1];
            d[q++] = a[n + 2];
            d[q++] = a[p + 0];
            d[q++] = a[p + 1];
            d[q++] = a[p + 2];
            d[q++] = a[p + 0];
            d[q++] = a[p + 1];
            d[q++] = a[p + 2];
            e[r++] = b[f + 0];
            e[r++] = b[f + 1];
            e[r++] = b[g + 0];
            e[r++] = b[g + 1];
            e[r++] =
            b[h + 0];
            e[r++] = b[h + 1];
            e[r++] = b[h + 0];
            e[r++] = b[h + 1];
            this._vertexPtr = q;
            this._texPtr = r
        }
    }
    FullscreenQuad(a, b)
    {
        this.SetCurrentZ(0);
        mat4$jscomp$6.copy(tmpProjection, this._matP);
        mat4$jscomp$6.copy(tmpModelView, this._matMV);
        this.SetDefaultRenderTargetProjectionState();
        const [c, d] = this.GetRenderTargetSize(this._currentRenderTarget);
        var e = this.CalculateLookAtModelView2(0, 0, this.GetDefaultCameraZ(d), 0, 0, 0, d);
        this.SetModelViewMatrix(e);
        if ("crop" === a && this._currentRenderTarget && b) {
            a = this._width / 2;
            e = this._height /
            2;
            const h = b.GetWidth();
            b = b.GetHeight();
            var f = this._currentRenderTarget.GetWidth(),
                g = this._currentRenderTarget.GetHeight();
            f = Math.min(f, h);
            const k = Math.min(g, b),
                l = Math.max(b - g, 0);
            g = Math.max(g - b, 0);
            tmpRect$jscomp$1.set(-a, e - g, -a + f, e - k - g);
            tmpQuad$jscomp$1.setFromRect(tmpRect$jscomp$1);
            tmpRect$jscomp$1.set(0, l, f, k + l);
            tmpRect$jscomp$1.divide(h, b);
            this.Quad3(tmpQuad$jscomp$1, tmpRect$jscomp$1)
        } else
            a = c / 2,
            e = d / 2,
            this.Rect2(-a, e, a, -e);
        this.SetProjectionMatrix(tmpProjection);
        this.SetModelViewMatrix(tmpModelView)
    }
    StartRenderingPoints(a)
    {
        this._lastPointTexCoords.equals(a) ||
        (this._lastPointTexCoords.copy(a), this.PushBatch().InitSetPointTexCoords(a), this._topOfBatch = 0)
    }
    FinishRenderingPoints() {}
    Point(a, b, c, d)
    {
        this._pointPtr >= LAST_POINT && this.EndBatch();
        let e = this._pointPtr;
        var f = this._baseZ + this._currentZ;
        2 === this._topOfBatch && this._lastPointZ === f ? this._batch[this._batchPtr - 1]._indexCount++ : (this.PushBatch().InitPoints(e, f), this._topOfBatch = 2, this._lastPointZ = f);
        f = this._pointData;
        f[e++] = a;
        f[e++] = b;
        f[e++] = c;
        f[e++] = d;
        this._pointPtr = e
    }
    SetProgram(a)
    {
        this._lastProgram !== a &&
        (this.PushBatch().InitSetProgram(a), this._lastProgram = a, this._topOfBatch = 0, this._currentStateGroup = null)
    }
    GetProgram()
    {
        return this._lastProgram
    }
    SetDeviceTransformTextureFillMode()
    {
        this.SetProgram(this._spDeviceTransformTextureFill)
    }
    SetGradientColor(a)
    {
        this.PushBatch().InitSetGradientColor(a);
        this._topOfBatch = 0
    }
    SetEllipseParams(a, b, c=1)
    {
        this.PushBatch().InitSetEllipseParams(a, b, c);
        this._topOfBatch = 0
    }
    SetTilemapInfo(a, b, c, d, e, f, g)
    {
        if (this._lastProgram !== this._spTilemapFill)
            throw Error("must set tilemap fill mode first");
        this.PushBatch().InitSetTilemapInfo(a, b, c, d, e, f, g);
        this._topOfBatch = 0
    }
    SetTileRandomizationInfo(a, b, c, d, e, f, g)
    {
        if (this._lastProgram !== this._spTileRandomization)
            throw Error("must set tile randomization mode first");
        this.PushBatch().InitSetTileRandomizationInfo(a, b, c, d, e, f, g);
        this._topOfBatch = 0
    }
    SetProgramParameters(a, b, c, d, e, f, g, h, k, l, m)
    {
        const n = this._lastProgram;
        m %= 10800;
        if (n._hasAnyOptionalUniforms && !n.AreOptionalUniformsAlreadySetInBatch(b, c, d, e, f, g, h, k, l, m)) {
            var p = this.PushBatch();
            p.InitSetProgramParameters();
            n.SetOptionalUniformsInBatch(b, c, d, e, f, g, h, k, l, m);
            var q = p._mat4param;
            q[0] = f;
            q[1] = g;
            b.writeToTypedArray(q, 2);
            q[6] = k;
            q[7] = l;
            c.writeToTypedArray(q, 12);
            b = p._colorParam;
            e.writeToTypedArray(b, 0);
            e = b[1];
            b[1] = b[3];
            b[3] = e;
            d.writeToTypedArray(p._srcOriginRect, 0);
            p._startIndex = m;
            p._indexCount = h;
            n._uSamplerBack.IsUsed() ? p._texParam = a ? a.GetTexture() : null : p._texParam = null;
            this._topOfBatch = 0
        }
    }
    SetProgramCustomParameters(a)
    {
        const b = this._lastProgram;
        if (0 !== a.length && !b.AreCustomParametersAlreadySetInBatch(a)) {
            var c =
            this.PushBatch();
            c.InitSetProgramCustomParameters();
            b.SetCustomParametersInBatch(a);
            C3$jscomp$57.shallowAssignArray(c._shaderParams, a);
            this._topOfBatch = 0
        }
    }
    ClearRgba(a, b, c, d)
    {
        this.PushBatch().InitClearSurface2(a, b, c, d);
        this._topOfBatch = 0
    }
    Clear(a)
    {
        this.PushBatch().InitClearSurface(a);
        this._topOfBatch = 0
    }
    Start() {}
    Finish()
    {
        super.Finish();
        this._gl.flush()
    }
    ClearDepth()
    {
        this._usesDepthBuffer && this._currentRenderTarget && this._currentRenderTarget.HasDepthBuffer() && (this.PushBatch().InitClearDepth(this._isDepthEnabled),
        this._topOfBatch = 0)
    }
    SetDepthEnabled(a)
    {
        a = !!a;
        this._isDepthEnabled !== a && this._usesDepthBuffer && (this._isDepthEnabled = a, this.PushBatch().InitSetDepthEnabled(a), this._topOfBatch = 0)
    }
    IsDepthEnabled()
    {
        return this._isDepthEnabled
    }
    _GetDepthBuffer()
    {
        return this._depthBuffer
    }
    _CanSampleDepth()
    {
        return this._canSampleDepth
    }
    SetDepthSamplingEnabled(a)
    {
        a = !!a;
        if (this._canSampleDepth && this._isDepthSamplingEnabled !== a) {
            if (a && this.IsDepthEnabled())
                throw Error("depth still enabled");
            this._isDepthSamplingEnabled = a;
            this.PushBatch().InitSetDepthSamplingEnabled(a);
            this._topOfBatch = 0
        }
    }
    SetScissorRect(a, b, c, d, e=0)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        d = Math.floor(d);
        this._lastScissorRect.equalsWH(a, b, c, d) || (this._lastScissorRect.setWH(a, b, c, d), b = (e || this.GetRenderTargetSize(this.GetRenderTarget())[1]) - b - d, this.PushBatch().InitSetScissor(!0, a, b, c, d), this._topOfBatch = 0)
    }
    RemoveScissorRect()
    {
        -1 !== this._lastScissorRect.getRight() && (this._lastScissorRect.set(0, 0, -1, -1), this.PushBatch().InitSetScissor(!1, 0, 0, 0, 0), this._topOfBatch = 0)
    }
    CheckForQueryResults()
    {
        for (const a of this._allQueryResultBuffers)
            a.CheckForResults(this._frameNumber)
    }
    IsContextLost()
    {
        return !this._gl ||
            this._gl.isContextLost() || this._isInitialisingAfterContextRestored
    }
    OnContextLost()
    {
        super.OnDeviceOrContextLost();
        C3$jscomp$57.Gfx.WebGLRendererTexture.OnContextLost();
        C3$jscomp$57.Gfx.WebGLRenderTarget.OnContextLost();
        C3$jscomp$57.Gfx.RendererText.OnContextLost();
        for (const a of this._allQueryResultBuffers)
            a.Clear();
        this._extensions = [];
        this._textureLodExt = this._stdDerivativesExt = this._fragDepthExt = this._depthTextureExt = this._anisotropicExt = this._parallelShaderCompileExt = this._timerExt = null;
        this._maxAnisotropy =
        0;
        this._unmaskedRenderer = this._unmaskedVendor = "(unavailable)";
        this._depthBuffer = this._spDeviceTransformTextureFill = this._lastProgram = null;
        for (const a of this._stateGroups.values())
            a.OnContextLost()
    }
    async OnContextRestored()
    {
        this._isInitialisingAfterContextRestored = !0;
        await this.InitState();
        this._isInitialisingAfterContextRestored = !1;
        for (const a of this._stateGroups.values())
            a.OnContextRestored(this);
        this.SetSize(this._width, this._height, !0)
    }
    CreateStaticTexture(a, b)
    {
        if (this.IsContextLost())
            throw Error("context lost");
        this.EndBatch();
        const c = C3$jscomp$57.New(C3$jscomp$57.Gfx.WebGLRendererTexture, this);
        c._CreateStatic(a, b);
        return c
    }
    async CreateStaticTextureAsync(a, b)
    {
        if (this.IsContextLost())
            throw Error("context lost");
        b = Object.assign({}, b);
        if (C3$jscomp$57.Supports.ImageBitmapOptions) {
            let c = await createImageBitmap(a, {
                premultiplyAlpha: "premultiply"
            });
            const d = b.wrapX && "clamp-to-edge" !== b.wrapX || b.wrapY && "clamp-to-edge" !== b.wrapY,
                e = C3$jscomp$57.isPOT(c.width) && C3$jscomp$57.isPOT(c.height);
            this.SupportsNPOTTextures() ||
            e || !d ? b.premultiplyAlpha = !1 : C3$jscomp$57.Supports.ImageBitmapOptionsResize ? (c = await createImageBitmap(a, {
                premultiplyAlpha: "premultiply",
                resizeWidth: C3$jscomp$57.nextHighestPowerOfTwo(c.width),
                resizeHeight: C3$jscomp$57.nextHighestPowerOfTwo(c.height)
            }), b.premultiplyAlpha = !1) : c = await createImageBitmap(a, {
                premultiplyAlpha: "none"
            });
            return await C3$jscomp$57.Asyncify(() => this.CreateStaticTexture(c, b))
        }
        if (a instanceof Blob) {
            if ("undefined" === typeof Image)
                throw Error("texture upload variant not supported in worker");
            a = await C3$jscomp$57.BlobToImage(a)
        }
        return await C3$jscomp$57.Asyncify(() => this.CreateStaticTexture(a, b))
    }
    CreateDynamicTexture(a, b, c)
    {
        this.EndBatch();
        const d = C3$jscomp$57.New(C3$jscomp$57.Gfx.WebGLRendererTexture, this);
        d._CreateDynamic(a, b, c);
        return d
    }
    UpdateTexture(a, b, c)
    {
        this.EndBatch();
        b._Update(a, c)
    }
    DeleteTexture(a)
    {
        a && (a.SubtractReference(), 0 < a.GetReferenceCount() || (this.EndBatch(), a === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null), a === this._lastTexture1 &&
        (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null), a._Delete()))
    }
    CreateRenderTarget(a)
    {
        let b = this._width,
            c = this._height,
            d = !0;
        a && ("number" === typeof a.width && (b = Math.floor(a.width), d = !1), "number" === typeof a.height && (c = Math.floor(a.height), d = !1));
        if (0 >= b || 0 >= c)
            throw Error("invalid size");
        this.EndBatch();
        const e = C3$jscomp$57.New(C3$jscomp$57.Gfx.WebGLRenderTarget, this);
        e._Create(b, c, Object.assign({
            isDefaultSize: d
        },
        a));
        this._currentRenderTarget = null;
        this._batchState.currentFramebuffer = null;
        this._batchState.currentFramebufferNoDepth = null;
        return e
    }
    SetRenderTarget(a, b=!0)
    {
        a !== this._currentRenderTarget && (a && a.IsDefaultSize() && a._Resize(this._width, this._height), this.PushBatch().InitSetRenderTarget(a), this._currentRenderTarget = a, this._topOfBatch = 0, b && this.SetDefaultRenderTargetProjectionState())
    }
    GetRenderTarget()
    {
        return this._currentRenderTarget
    }
    GetRenderTargetSize(a)
    {
        return a ? [a.GetWidth(), a.GetHeight()] : [this._width,
        this._height]
    }
    CopyRenderTarget(a, b="stretch")
    {
        2 > this._version || this._currentRenderTarget && 0 < this._currentRenderTarget.GetMultisampling() ? (this.SetCopyBlend(), this.ResetColor(), this.DrawRenderTarget(a, b)) : (this.PushBatch().InitBlitFramebuffer(a, this._currentRenderTarget, b), this._topOfBatch = 0)
    }
    DrawRenderTarget(a, b="stretch")
    {
        a = a.GetTexture();
        if (!a)
            throw Error("not a texture-backed render target");
        this.SetTexture(a);
        this.FullscreenQuad(b, a)
    }
    InvalidateRenderTarget(a)
    {
        2 > this._version || (this.PushBatch().InitInvalidateFramebuffer(a._GetFramebuffer()),
        this._topOfBatch = 0)
    }
    DeleteRenderTarget(a)
    {
        this.SetRenderTarget(null);
        this.EndBatch();
        const b = a.GetTexture();
        b === this._lastTexture0 && (this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._lastTexture0 = null);
        b === this._lastTexture1 && (this._gl.activeTexture(this._gl.TEXTURE1), this._gl.bindTexture(this._gl.TEXTURE_2D, null), this._gl.activeTexture(this._gl.TEXTURE0), this._lastTexture1 = null);
        a._Delete()
    }
    async ReadBackRenderTargetToImageData(a, b, c)
    {
        this.EndBatch();
        const d = this._currentRenderTarget;
        if (a) {
            var e =
            a.GetWidth();
            var f = a.GetHeight();
            var g = a._GetFramebuffer()
        } else
            e = this.GetWidth(),
            f = this.GetHeight(),
            g = null;
        let h = a = 0;
        var k = e,
            l = f;
        c && (a = C3$jscomp$57.clamp(Math.floor(c.getLeft()), 0, e - 1), h = C3$jscomp$57.clamp(Math.floor(c.getTop()), 0, f - 1), k = c.width(), k = 0 === k ? e - a : C3$jscomp$57.clamp(Math.floor(k), 0, e - a), l = c.height(), l = 0 === l ? f - h : C3$jscomp$57.clamp(Math.floor(l), 0, f - h), h = f - (h + l));
        const m = this._gl;
        m.bindFramebuffer(m.FRAMEBUFFER, g);
        f = () => {
            m.bindFramebuffer(m.FRAMEBUFFER, null);
            this._currentRenderTarget = null;
            this._batchState.currentFramebuffer = null;
            this._batchState.currentFramebufferNoDepth = null;
            this.SetRenderTarget(d)
        };
        if (!b && 2 <= this.GetWebGLVersionNumber()) {
            m.bindFramebuffer(m.READ_FRAMEBUFFER, g);
            g = m.createBuffer();
            c = k * l * 4;
            e = m.PIXEL_PACK_BUFFER;
            m.bindBuffer(e, g);
            m.bufferData(e, c, m.STREAM_READ);
            m.readPixels(a, h, k, l, m.RGBA, m.UNSIGNED_BYTE, 0);
            m.bindFramebuffer(m.READ_FRAMEBUFFER, null);
            m.bindBuffer(e, null);
            f();
            const n = m.fenceSync(m.SYNC_GPU_COMMANDS_COMPLETE, 0);
            await this._WaitForObjectReady(() => m.getSyncParameter(n,
            m.SYNC_STATUS) === m.SIGNALED);
            m.deleteSync(n);
            b = new ImageData(k, l);
            m.bindBuffer(e, g);
            m.getBufferSubData(e, 0, new Uint8Array(b.data.buffer), 0, c);
            m.bindBuffer(e, null);
            m.deleteBuffer(g)
        } else
            b = new ImageData(k, l),
            m.readPixels(a, h, k, l, m.RGBA, m.UNSIGNED_BYTE, new Uint8Array(b.data.buffer)),
            f();
        return b
    }
    CoplanarStartStencilPass()
    {
        this.SetDepthEnabled(!0);
        this.PushBatch().InitCoplanarStartStencilPass();
        this._topOfBatch = 0;
        this._coplanarMode = 1
    }
    CoplanarStartColorPass()
    {
        this.SetDepthEnabled(!1);
        this.PushBatch().InitCoplanarStartColorPass();
        this._topOfBatch = 0;
        this._coplanarMode = 2
    }
    IsCoplanarColorPass()
    {
        return 2 === this._coplanarMode
    }
    CoplanarRestoreStandardRendering()
    {
        this.SetDepthEnabled(!0);
        this.PushBatch().InitCoplanarRestore();
        this._coplanarMode = this._topOfBatch = 0
    }
    StartQuery(a)
    {
        this.SupportsGPUProfiling() && (this.PushBatch().InitStartQuery(a), this._topOfBatch = 0)
    }
    EndQuery(a)
    {
        this.SupportsGPUProfiling() && (this.PushBatch().InitEndQuery(a), this._topOfBatch = 0)
    }
    _WaitForObjectReady(a)
    {
        const b = new Promise(c => pendingPolls.add({
            resolve: c,
            checkFunc: a
        }));
        -1 === pollRafId && (pollRafId = self.requestAnimationFrame(CheckPendingPolls));
        return b
    }
    GetEstimatedBackBufferMemoryUsage()
    {
        return this._width * this._height * (this._attribs.alpha ? 4 : 3)
    }
    GetEstimatedRenderBufferMemoryUsage()
    {
        let a = 0;
        for (const b of C3$jscomp$57.Gfx.WebGLRenderTarget.allRenderTargets())
            b.GetTexture() || (a += b.GetEstimatedMemoryUsage());
        return a
    }
    GetEstimatedTextureMemoryUsage()
    {
        let a = 0;
        for (const b of C3$jscomp$57.Gfx.WebGLRendererTexture.allTextures())
            a += b.GetEstimatedMemoryUsage();
        return a
    }
    GetWebGLVersionString()
    {
        return this._versionString
    }
    GetWebGLVersionNumber()
    {
        return this._version
    }
    GetDisplayName()
    {
        return "webgl" +
        this.GetWebGLVersionNumber()
    }
    SupportsNPOTTextures()
    {
        return 2 <= this.GetWebGLVersionNumber()
    }
    GetMaxTextureSize()
    {
        return this._maxTextureSize
    }
    GetMinPointSize()
    {
        return this._minPointSize
    }
    GetMaxPointSize()
    {
        return this._maxPointSize
    }
    SupportsHighP()
    {
        return 0 !== this._highpPrecision
    }
    GetHighPPrecision()
    {
        return this._highpPrecision
    }
    GetUnmaskedVendor()
    {
        return this._unmaskedVendor
    }
    GetUnmaskedRenderer()
    {
        return this._unmaskedRenderer
    }
    GetWebGLExtensionsAnalyticsString()
    {
        if (2 <= this.GetWebGLVersionNumber())
            return "webgl2";
        const a = [];
        this._fragDepthExt && a.push("EXT_frag_depth");
        this._stdDerivativesExt && a.push("OES_standard_derivatives");
        this._textureLodExt && a.push("EXT_shader_texture_lod");
        return 0 < a.length ? "webgl1:" + a.join(",") : "webgl1:none"
    }
    GetExtensions()
    {
        return this._extensions
    }
    SupportsGPUProfiling()
    {
        return !!this._timerExt
    }
    _GetDisjointTimerQueryExtension()
    {
        return this._timerExt
    }
    _GetParallelShaderCompileExtension()
    {
        return this._parallelShaderCompileExt
    }
    _GetAnisotropicExtension()
    {
        return this._anisotropicExt
    }
    _GetMaxAnisotropy()
    {
        return this._maxAnisotropy
    }
    _AddQueryResultBuffer(a)
    {
        this._allQueryResultBuffers.add(a)
    }
    _RemoveQueryResultBuffer(a)
    {
        this._allQueryResultBuffers.delete(a)
    }
    _GetTimeQueryStack()
    {
        return this._timeQueryStack
    }
    GetContext()
    {
        return this._gl
    }
    _InitBlendModes(a)
    {
        this._InitBlendModeData([["normal",
        a.ONE, a.ONE_MINUS_SRC_ALPHA], ["additive", a.ONE, a.ONE], ["xor", a.ONE, a.ONE_MINUS_SRC_ALPHA], ["copy", a.ONE, a.ZERO], ["destination-over", a.ONE_MINUS_DST_ALPHA, a.ONE], ["source-in", a.DST_ALPHA, a.ZERO], ["destination-in", a.ZERO, a.SRC_ALPHA], ["source-out", a.ONE_MINUS_DST_ALPHA, a.ZERO], ["destination-out", a.ZERO, a.ONE_MINUS_SRC_ALPHA], ["source-atop", a.DST_ALPHA, a.ONE_MINUS_SRC_ALPHA], ["destination-atop", a.ONE_MINUS_DST_ALPHA, a.SRC_ALPHA]])
    }
    CreateWebGLText()
    {
        return this.CreateRendererText()
    }
}
;
"use strict";
const DEFAULT_CTOR_OPTS = {
    getDrawSize: null,
    getRenderTarget: null,
    releaseRenderTarget: null,
    getTime: null,
    redraw: null
};
self.C3.Gfx.EffectChainManager = class {
    constructor(a)
    {
        a = Object.assign({}, DEFAULT_CTOR_OPTS, a);
        this._cbGetDrawSize = a.getDrawSize;
        this._cbGetRenderTarget = a.getRenderTarget;
        this._cbReleaseRenderTarget = a.releaseRenderTarget;
        this._cbGetTime = a.getTime;
        this._cbRedraw = a.redraw;
        this._webgpuBackTexture = null;
        this._allEffectChains = new Set
    }
    _AddEffectChain(a)
    {
        this._allEffectChains.add(a)
    }
    _RemoveEffectChain(a)
    {
        this._allEffectChains.delete(a)
    }
    OnContextLost()
    {
        this._webgpuBackTexture = null;
        for (const a of this._allEffectChains)
            a.OnContextLost()
    }
    GetDrawSize(a)
    {
        return this._cbGetDrawSize ?
        this._cbGetDrawSize(a) : [a.GetWidth(), a.GetHeight()]
    }
    GetRenderTarget(a)
    {
        return this._cbGetRenderTarget(a)
    }
    ReleaseRenderTarget(a, b)
    {
        this._cbReleaseRenderTarget(a, b)
    }
    GetTime()
    {
        return this._cbGetTime()
    }
    Redraw(a)
    {
        this._cbRedraw(a)
    }
    _GetWebGPUBackTexture(a, b, c)
    {
        b = Math.floor(b);
        c = Math.floor(c);
        !this._webgpuBackTexture || this._webgpuBackTexture.GetWidth() === b && this._webgpuBackTexture.GetHeight() === c || (a.DeleteTexture(this._webgpuBackTexture), this._webgpuBackTexture = null);
        null === this._webgpuBackTexture && (this._webgpuBackTexture =
        a.CreateStaticTexture(null, {
            width: b,
            height: c,
            sampling: "nearest",
            mipMap: !1
        }));
        return this._webgpuBackTexture
    }
}
;
"use strict";
const C3$jscomp$59 = self.C3,
    mat4$jscomp$7 = self.glMatrix.mat4,
    tempRect = C3$jscomp$59.New(C3$jscomp$59.Rect),
    tempRect2 = C3$jscomp$59.New(C3$jscomp$59.Rect),
    tempRect3 = C3$jscomp$59.New(C3$jscomp$59.Rect),
    tempRect4 = C3$jscomp$59.New(C3$jscomp$59.Rect),
    tempMat4a = mat4$jscomp$7.create(),
    tempMat4b$jscomp$1 = mat4$jscomp$7.create(),
    DEFAULT_CTOR_OPTS$jscomp$1 = {
        drawContent: null,
        getSourceTextureInfo: null,
        getShaderParameters: null,
        invalidateRenderTargets: !1
    },
    DEFAULT_BUILDSTEPS_OPTS = {
        indexMap: null,
        forcePreDraw: !1,
        forcePostDraw: !1,
        is3D: !1,
        isSourceTextureRotated: !1,
        isRotatedOrNegativeSizeInstance: !1,
        useFullSurface: !1
    };
C3$jscomp$59.Gfx.EffectChain = class {
    constructor(a, b)
    {
        b = Object.assign({}, DEFAULT_CTOR_OPTS$jscomp$1, b);
        this._manager = a;
        this._cbDrawContent = b.drawContent;
        this._cbGetSourceTextureInfo = b.getSourceTextureInfo;
        this._cbGetShaderParameters = b.getShaderParameters;
        this._cbDrawContentHook = null;
        this._shaderProgramList = [];
        this._shaderProgramIndices = [];
        this._steps = [];
        this._needsRebuild = !1;
        this._blendMode = 0;
        this._isSourceTextureRotated = this._useFullSurface = this._canUseFastPath = this._coplanarColorPassAtStart = this._depthEnabledAtStart =
        this._didChangeTransform = this._useCopyTextureBackgroundSampling = this._isAnyIsSrcTexRotated = this._isAnyShaderCrossSampling = this._isAnyShaderBackgroundBlending = this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
        this._numTempSurfacesRequired = 0;
        this._renderTargets = [null, null, null];
        this._invalidateRenderTargets = !!b.invalidateRenderTargets;
        this._drawHeight = this._drawWidth = this._boxExtendVertical = this._boxExtendHorizontal = 0;
        this._contextObject = this._contentObject = null;
        this._layoutRect = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._drawSurfaceRect = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._rcTexOriginal = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._rcTexBounce = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._rcTexDest = C3$jscomp$59.New(C3$jscomp$59.Rect);
        this._layerScale = this._devicePixelRatio = 1;
        this._time = this._layerAngle = 0;
        this._backTex = this._destRenderTarget = null;
        this._compositOffY = this._compositOffX = 0;
        this._updateOwnProjection = !1;
        this._projectionMatrix = mat4$jscomp$7.create();
        this._modelViewMatrix = mat4$jscomp$7.create();
        this._manager._AddEffectChain(this)
    }
    Release()
    {
        this._manager._RemoveEffectChain(this);
        C3$jscomp$59.clearArray(this._steps);
        C3$jscomp$59.clearArray(this._shaderProgramList);
        C3$jscomp$59.clearArray(this._shaderProgramIndices);
        this._cbGetShaderParameters = this._cbGetSourceTextureInfo = this._cbDrawContent = this._contextObject = this._contentObject = null
    }
    OnContextLost()
    {
        this._needsRebuild = !0;
        C3$jscomp$59.clearArray(this._steps);
        C3$jscomp$59.clearArray(this._shaderProgramList);
        C3$jscomp$59.clearArray(this._shaderProgramIndices)
    }
    NeedsRebuild()
    {
        return this._needsRebuild
    }
    BuildSteps(a, b)
    {
        b = Object.assign({},
        DEFAULT_BUILDSTEPS_OPTS, b);
        C3$jscomp$59.clearArray(this._steps);
        this._boxExtendVertical = this._boxExtendHorizontal = 0;
        this._useCopyTextureBackgroundSampling = this._isAnyIsSrcTexRotated = this._isAnyShaderCrossSampling = this._isAnyShaderBackgroundBlending = this._isAnyShaderDepthSampling = this._isAnyShaderAnimated = !1;
        this._numTempSurfacesRequired = 0;
        this._isSourceTextureRotated = !!b.isSourceTextureRotated;
        this._useFullSurface = !!b.useFullSurface;
        this._needsRebuild = !1;
        C3$jscomp$59.shallowAssignArray(this._shaderProgramList,
        a);
        if (0 !== a.length) {
            if (b.indexMap) {
                if (b.indexMap.length !== a.length)
                    throw Error("incorrect indexMap length");
                C3$jscomp$59.shallowAssignArray(this._shaderProgramIndices, b.indexMap)
            } else {
                C3$jscomp$59.clearArray(this._shaderProgramIndices);
                for (let e = 0, f = a.length; e < f; ++e)
                    this._shaderProgramIndices.push(e)
            }
            for (var c of a)
                this._boxExtendHorizontal += c.GetBoxExtendHorizontal(),
                this._boxExtendVertical += c.GetBoxExtendVertical(),
                c.IsAnimated() && (this._isAnyShaderAnimated = !0),
                c.UsesDepth() && (this._isAnyShaderDepthSampling =
                !0),
                c.BlendsBackground() && (this._isAnyShaderBackgroundBlending = !0),
                c.UsesCrossSampling() && (this._isAnyShaderCrossSampling = !0),
                c.UsesIsSrcTexRotated() && (this._isAnyIsSrcTexRotated = !0);
            this._useCopyTextureBackgroundSampling = this._ShouldUseCopyTextureBackgroundSampling(a[0].GetRenderer());
            c = this._ShouldPreDraw(a[0], b);
            b = this._ShouldPostDraw(a.at(-1), b);
            if (1 !== a.length || c || b) {
                this._canUseFastPath = !1;
                var d = 0;
                c && (this._numTempSurfacesRequired = 1, this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.PreDraw,
                this, -1, 1)), d = 1);
                for (let e = 0, f = a.length; e < f; ++e)
                    0 !== e || c ? (a = 1 === d ? 2 : 1, e !== f - 1 || b || (a = 0), this._numTempSurfacesRequired = Math.max(this._numTempSurfacesRequired, a), this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.Bounce, this, d, a, e)), d = a) : (this._numTempSurfacesRequired = 1, this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.FirstBounce, this, -1, 1, e)), d = 1);
                b && this._steps.push(C3$jscomp$59.New(C3$jscomp$59.Gfx.EffectChain.Step.PostDraw, this, d, 0))
            } else
                this._canUseFastPath =
                !0
        }
    }
    _ShouldPreDraw(a, b)
    {
        return b.forcePreDraw || a.MustPreDraw() || b.is3D && !a.Supports3DDirectRendering() || a.UsesDepth() && !this._useFullSurface || 0 !== this._boxExtendHorizontal || 0 !== this._boxExtendVertical ? !0 : a.GetRenderer().IsWebGL() ? a.BlendsBackground() && (b.isRotatedOrNegativeSizeInstance || b.isSourceTextureRotated) || a.UsesAnySrcRectOrPixelSize() && b.isSourceTextureRotated : a.BlendsBackground() && !this._useCopyTextureBackgroundSampling && b.isRotatedOrNegativeSizeInstance
    }
    _ShouldPostDraw(a, b)
    {
        return b.forcePostDraw ?
        !0 : a.GetRenderer().IsWebGL() ? a.BlendsBackground() || a.UsesCrossSampling() : (a.BlendsBackground() || a.UsesCrossSampling()) && this._UseRenderTargetBackgroundSampling()
    }
    _ShouldUseCopyTextureBackgroundSampling(a)
    {
        return a.IsWebGPU() && this._isAnyShaderBackgroundBlending && !this._isAnyShaderCrossSampling
    }
    Render(a, b, c)
    {
        a.IsWebGPU() && null === b && (b = a.GetBackbufferRenderTarget());
        this._destRenderTarget = b;
        this._contentObject = c.contentObject || null;
        this._contextObject = c.contextObject || null;
        this._blendMode = c.blendMode ||
        0;
        this._devicePixelRatio = c.devicePixelRatio || 1;
        this._layerScale = c.layerScale || 1;
        this._layerAngle = c.layerAngle || 0;
        this._time = "number" === typeof c.time ? c.time : this._manager.GetTime();
        this._didChangeTransform = !1;
        a.ResetDidChangeTransformFlag();
        this._isAnyShaderAnimated && this._Redraw();
        let d = !1;
        this._UseCopyTextureBackgroundSampling() && (this._CalculateDrawSizeAndRectangles(a, c), d = !0, this._backTex = this._manager._GetWebGPUBackTexture(a, this._drawWidth, this._drawHeight), tempRect.copy(this._drawSurfaceRect),
        tempRect.roundOuter(), a.IsWebGPU() && a._MaybeDoPendingClearRenderPass(this._destRenderTarget), a.CopyTextureToTexture(this._destRenderTarget.GetTexture(), this._backTex, tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height()));
        if (this._canUseFastPath)
            this._Render_FastPath(a, c);
        else if (d || this._CalculateDrawSizeAndRectangles(a, c), 0 !== this._rcTexOriginal.width() || 0 !== this._rcTexOriginal.height()) {
            a.SetAlphaBlend();
            a.ResetColor();
            a.SetBaseZ(0);
            a.SetCurrentZ(0);
            this._cbDrawContentHook = c.drawContentHook ||
            null;
            this._compositOffX = c.compositOffX || 0;
            this._compositOffY = c.compositOffY || 0;
            this._updateOwnProjection = !!c.updateOwnProjection;
            this._OnBeforeStartEffectChain(a);
            this._renderTargets[0] = b;
            this._renderTargets[1] = 1 <= this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            this._renderTargets[2] = 2 === this._numTempSurfacesRequired ? this._GetRenderTarget() : null;
            for (const e of this._steps)
                b = this._GetRenderTargetForId(e.GetSrcTargetId()),
                c = this._GetRenderTargetForId(e.GetDestTargetId()),
                a.IsWebGPU() ? e.Run_WebGPU(a,
                b, c) : e.Run_WebGL(a, b, c);
            a.SetTexture(null);
            this._renderTargets[1] && this._ReleaseRenderTarget(this._renderTargets[1]);
            this._renderTargets[2] && this._ReleaseRenderTarget(this._renderTargets[2]);
            this._renderTargets.fill(null);
            this._OnAfterEndEffectChain(a);
            this._cbDrawContentHook = this._contextObject = this._contentObject = this._backTex = this._destRenderTarget = null
        }
    }
    _CalculateDrawSizeAndRectangles(a, b)
    {
        const [c, d] = this._manager.GetDrawSize(a);
        this._SetDrawSize(a, c, d);
        this._CalculateRectangles(b)
    }
    _SetDrawSize(a,
    b, c)
    {
        if (0 >= b || 0 >= c)
            throw Error("invalid draw size");
        this._drawWidth === b && this._drawHeight === c || this._CalculateDeviceTransformMatrices(a, b, c, 0, 0, this._projectionMatrix, this._modelViewMatrix);
        this._drawWidth = b;
        this._drawHeight = c
    }
    _CalculateDeviceTransformMatrices(a, b, c, d, e, f, g)
    {
        d = b / 2 + d;
        e = c / 2 + e;
        a.CalculatePerspectiveMatrix(f, b / c);
        a = a.CalculateLookAtModelView2(d, e, a.GetDefaultCameraZ(c), d, e, 0, c);
        mat4$jscomp$7.copy(g, a)
    }
    _CalculateRectangles(a)
    {
        this._layoutRect.copy(a.layoutRect);
        a.drawSurfaceRect ? this._drawSurfaceRect.copy(a.drawSurfaceRect) :
        this._drawSurfaceRect.set(0, 0, this._drawWidth, this._drawHeight);
        this._rcTexOriginal.copy(this._drawSurfaceRect);
        this._rcTexOriginal.divide(this._drawWidth, this._drawHeight);
        a = this._layerScale * this._devicePixelRatio;
        this._drawSurfaceRect.inflate(this._boxExtendHorizontal * a, this._boxExtendVertical * a);
        this._rcTexDest.copy(this._drawSurfaceRect);
        this._rcTexDest.divide(this._drawWidth, this._drawHeight);
        this._drawSurfaceRect.clampBoth(0, 0, this._drawWidth, this._drawHeight);
        this._rcTexBounce.copy(this._drawSurfaceRect);
        this._rcTexBounce.divide(this._drawWidth, this._drawHeight)
    }
    _OnBeforeStartEffectChain(a)
    {
        this._depthEnabledAtStart = a.IsDepthEnabled();
        this._coplanarColorPassAtStart = a.IsCoplanarColorPass();
        if (this._useFullSurface)
            a.SetDepthEnabled(!1),
            this._isAnyShaderDepthSampling && a.SetDepthSamplingEnabled(!0);
        else {
            tempRect.copy(this._drawSurfaceRect);
            if (a.IsWebGL()) {
                const b = this._layerScale * this._devicePixelRatio;
                tempRect.inflate(Math.max(this._boxExtendHorizontal, 1) * b, Math.max(this._boxExtendVertical, 1) * b);
                tempRect.roundOuter();
                tempRect.clamp(0, 0, this._drawWidth, this._drawHeight)
            } else
                tempRect.roundOuter();
            a.SetScissorRect(tempRect.getLeft(), tempRect.getTop(), tempRect.width(), tempRect.height(), this._drawHeight)
        }
    }
    _OnAfterEffectChainDrawContent(a)
    {
        a.ResetColor();
        this._useFullSurface || (this._coplanarColorPassAtStart && a.CoplanarRestoreStandardRendering(), a.SetDepthEnabled(!1), this._isAnyShaderDepthSampling && a.SetDepthSamplingEnabled(!0));
        a.IsWebGPU() && a.SetNormalizedCoordsProgramVariant(!0)
    }
    _OnAfterEndEffectChain(a)
    {
        a.SetDepthSamplingEnabled(!1);
        this._coplanarColorPassAtStart && a.CoplanarStartColorPass();
        a.SetDepthEnabled(this._depthEnabledAtStart);
        this._useFullSurface || a.RemoveScissorRect();
        a.IsWebGPU() && a.SetNormalizedCoordsProgramVariant(!1);
        this._didChangeTransform = a.DidChangeTransform()
    }
    _ClampRcTexDest()
    {
        this._rcTexDest.clamp(0, 0, 1, 1)
    }
    _GetRenderTargetForId(a)
    {
        return 0 > a ? null : this._renderTargets[a]
    }
    _GetRenderTarget()
    {
        return this._manager.GetRenderTarget(this)
    }
    _GetDestRenderTarget()
    {
        return this._destRenderTarget
    }
    _ReleaseRenderTarget(a)
    {
        this._manager.ReleaseRenderTarget(a,
        this)
    }
    _GetShaderProgramAt(a)
    {
        return this._shaderProgramList[a]
    }
    _DrawContent(a)
    {
        this._cbDrawContentHook ? this._cbDrawContentHook(this, a, () => this._cbDrawContent(a, this)) : this._cbDrawContent(a, this);
        this._canUseFastPath || this._OnAfterEffectChainDrawContent(a)
    }
    _IsRenderTargetSameSizeAndOffset(a)
    {
        if (this._useFullSurface)
            return !0;
        if (0 !== this._compositOffX || 0 !== this._compositOffY)
            return !1;
        const [b, c] = a.GetRenderTargetSize(a.GetRenderTarget());
        return b !== this._drawWidth || c !== this._drawHeight ? !1 : !0
    }
    _SetDeviceTransform(a,
    b)
    {
        let c = this._projectionMatrix,
            d = this._modelViewMatrix;
        if (b && !this._IsRenderTargetSameSizeAndOffset(a)) {
            c = tempMat4a;
            d = tempMat4b$jscomp$1;
            const [e, f] = a.GetRenderTargetSize(a.GetRenderTarget());
            this._CalculateDeviceTransformMatrices(a, e, f, this._compositOffX, this._compositOffY, c, d);
            this._useFullSurface || a.RemoveScissorRect()
        }
        a.SetProjectionMatrix(c);
        a.SetModelViewMatrix(d)
    }
    _Redraw()
    {
        this._manager.Redraw(this)
    }
    _GetShaderParameters(a, b)
    {
        return this._cbGetShaderParameters(this._shaderProgramIndices[a],
        b)
    }
    _SetProgramParameters(a, b)
    {
        let c = this._rcTexDest,
            d = this._rcTexBounce,
            e = this._rcTexOriginal;
        a.IsWebGL() && (tempRect2.copy(c), tempRect2.flipAround(1), c = tempRect2, tempRect3.copy(d), tempRect3.flipAround(1), d = tempRect3, tempRect4.copy(e), tempRect4.flipAround(1), e = tempRect4);
        this._DoSetProgramParameters(a, b, d, e, c, 1 / this._drawWidth, 1 / this._drawHeight)
    }
    _SetFirstBounceProgramParameters(a, b)
    {
        let c = this._rcTexBounce,
            d = this._rcTexOriginal,
            e = 1 / this._drawWidth,
            f = 1 / this._drawHeight;
        if (this._cbGetSourceTextureInfo) {
            let {srcTexRect: h,
            srcWidth: k, srcHeight: l} = this._cbGetSourceTextureInfo(this._contentObject);
            h || (tempRect.set(0, 0, 0, 0), h = tempRect);
            k || (k = this._drawWidth);
            l || (l = this._drawHeight);
            d = c = h;
            e = 1 / k;
            f = 1 / l
        } else
            a.IsWebGL() && (tempRect3.copy(c), tempRect3.flipAround(1), c = tempRect3, tempRect4.copy(d), tempRect4.flipAround(1), d = tempRect4);
        let g = this._rcTexDest;
        a.IsWebGL() && (g = tempRect2, g.copy(this._rcTexDest), g.flipAround(1));
        this._DoSetProgramParameters(a, b, c, d, g, e, f);
        a.IsWebGPU() && this._isAnyIsSrcTexRotated && a.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated)
    }
    _GetBackTex(a)
    {
        return this._isAnyShaderBackgroundBlending ?
        a.IsWebGPU() ? this._UseCopyTextureBackgroundSampling() ? this._backTex : this._destRenderTarget.GetTexture() : this._destRenderTarget : null
    }
    _DoSetProgramParameters(a, b, c, d, e, f, g)
    {
        a.SetProgramParameters(this._GetBackTex(a), e, c, d, this._layoutRect, f, g, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);
        a.SetProgramCustomParameters(this._GetShaderParameters(b, a))
    }
    _Render_FastPath(a, b)
    {
        var c = this._shaderProgramList[0];
        const d = a.IsDepthEnabled(),
            e = c.UsesDepth();
        e && (a.SetDepthEnabled(!1), a.SetDepthSamplingEnabled(!0),
        this._rcTexDest.set(0, 0, 1, 1), this._rcTexOriginal.set(0, 0, 1, 1));
        a.SetProgram(c);
        a.SetBlendMode(this._blendMode);
        a.SetRenderTarget(this._destRenderTarget);
        let f;
        this._rcTexOriginal.set(0, 0, 1, 1);
        if (c.UsesAnySrcRectOrPixelSize() && this._cbGetSourceTextureInfo) {
            const {srcTexRect: g, srcWidth: h, srcHeight: k} = this._cbGetSourceTextureInfo(this._contentObject);
            g && this._rcTexOriginal.copy(g);
            c = Number.isFinite(h) ? 1 / h : 0;
            f = Number.isFinite(k) ? 1 / k : 0
        } else {
            const [g, h] = this._manager.GetDrawSize(a);
            c = 1 / g;
            f = 1 / h
        }
        b.layoutRect ?
        this._layoutRect.copy(b.layoutRect) : this._layoutRect.set(0, 0, 0, 0);
        a.SetProgramParameters(this._GetBackTex(a), this._rcTexDest, this._rcTexOriginal, this._rcTexOriginal, this._layoutRect, c, f, this._devicePixelRatio, this._layerScale, this._layerAngle, this._time);
        a.SetProgramCustomParameters(this._GetShaderParameters(0, a));
        a.IsWebGPU() && this._isAnyIsSrcTexRotated && a.SetProgramParameter_IsSrcTexRotated(this._isSourceTextureRotated);
        a.SetBaseZ(0);
        this._DrawContent(a);
        e && (a.SetDepthSamplingEnabled(!1), a.SetDepthEnabled(d))
    }
    _UseCopyTextureBackgroundSampling()
    {
        return this._useCopyTextureBackgroundSampling
    }
    _UseRenderTargetBackgroundSampling()
    {
        return !this._useCopyTextureBackgroundSampling
    }
    IsAnyShaderBackgroundBlending()
    {
        return this._isAnyShaderBackgroundBlending
    }
    CanSkipCalculatingDrawSurfaceRect()
    {
        return !this._canUseFastPath ||
        this._UseCopyTextureBackgroundSampling() ? !1 : !0
    }
    UseFullSurface()
    {
        return this._useFullSurface
    }
    GetContentObject()
    {
        return this._contentObject
    }
    GetContextObject()
    {
        return this._contextObject
    }
    _GetBlendMode()
    {
        return this._blendMode
    }
    _UpdateOwnProjection()
    {
        return this._updateOwnProjection
    }
    DidChangeTransform()
    {
        return this._didChangeTransform
    }
    _GetDrawSurfaceRect()
    {
        return this._drawSurfaceRect
    }
    _GetRcTexBounce()
    {
        return this._rcTexBounce
    }
    _ShouldInvalidateRenderTargets()
    {
        return this._invalidateRenderTargets
    }
    async DebugLogRenderTargetContents(a,
    b, c) {}
}
;
"use strict";
self.C3.Gfx.EffectChain.Step = class {
    constructor(a, b, c, d=-1)
    {
        this._effectChain = a;
        this._srcTargetId = b;
        this._destTargetId = c;
        this._index = d
    }
    GetEffectChain()
    {
        return this._effectChain
    }
    GetSrcTargetId()
    {
        return this._srcTargetId
    }
    GetDestTargetId()
    {
        return this._destTargetId
    }
    GetIndex()
    {
        return this._index
    }
    GetShaderProgram()
    {
        return this.GetEffectChain()._GetShaderProgramAt(this.GetIndex())
    }
    Run_WebGL(a, b, c) {}
    Run_WebGPU(a, b, c) {}
}
;
"use strict";
const C3$jscomp$61 = self.C3;
C3$jscomp$61.Gfx.EffectChain.Step.PreDraw = class  extends C3$jscomp$61.Gfx.EffectChain.Step{
    constructor(a, b, c, d)
    {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c)
    {
        b = this.GetEffectChain();
        a.SetAlphaBlend();
        a.SetTextureFillMode();
        a.SetRenderTarget(c, b._UpdateOwnProjection());
        a.ClearRgba(0, 0, 0, 0);
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
    Run_WebGPU(a, b, c)
    {
        b = this.GetEffectChain();
        a.SetAlphaBlend();
        a.SetTextureFillMode();
        a.SetRenderTarget(c, !1);
        a.ClearRgba(0, 0, 0, 0);
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
}
;
"use strict";
const C3$jscomp$62 = self.C3,
    tempRect$jscomp$1 = C3$jscomp$62.New(C3$jscomp$62.Rect),
    tempQuad$jscomp$1 = C3$jscomp$62.New(C3$jscomp$62.Quad);
C3$jscomp$62.Gfx.EffectChain.Step.PostDraw = class  extends C3$jscomp$62.Gfx.EffectChain.Step{
    constructor(a, b, c, d)
    {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c)
    {
        const d = this.GetEffectChain();
        a.SetTextureFillMode();
        a.SetRenderTarget(c);
        d._SetDeviceTransform(a, !0);
        a.SetBlendMode(d._GetBlendMode());
        a.SetTexture(b.GetTexture());
        tempQuad$jscomp$1.setFromRect(d._GetDrawSurfaceRect());
        tempRect$jscomp$1.copy(d._GetRcTexBounce());
        tempRect$jscomp$1.flipAround(1);
        a.Quad3(tempQuad$jscomp$1, tempRect$jscomp$1);
        d._ShouldInvalidateRenderTargets() &&
        a.InvalidateRenderTarget(b)
    }
    Run_WebGPU(a, b, c)
    {
        const d = this.GetEffectChain();
        a.SetTextureFillMode();
        a.SetRenderTarget(c, !1);
        d._IsRenderTargetSameSizeAndOffset(a) ? tempQuad$jscomp$1.setFromRect(d._GetRcTexBounce()) : (a.SetNormalizedCoordsProgramVariant(!1), d._SetDeviceTransform(a, !0), tempQuad$jscomp$1.setFromRect(d._GetDrawSurfaceRect()));
        a.SetBackTexture(null);
        a.SetBlendMode(d._GetBlendMode());
        a.SetTexture(b.GetTexture());
        d.UseFullSurface() ? a.FullscreenQuad() : a.Quad3(tempQuad$jscomp$1, d._GetRcTexBounce())
    }
}
;
"use strict";
const C3$jscomp$63 = self.C3;
C3$jscomp$63.Gfx.EffectChain.Step.FirstBounce = class  extends C3$jscomp$63.Gfx.EffectChain.Step{
    constructor(a, b, c, d)
    {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c)
    {
        b = this.GetEffectChain();
        a.SetRenderTarget(c, b._UpdateOwnProjection());
        a.ClearRgba(0, 0, 0, 0);
        a.SetCopyBlend();
        a.SetProgram(this.GetShaderProgram());
        b._SetFirstBounceProgramParameters(a, this.GetIndex());
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
    Run_WebGPU(a, b, c)
    {
        b = this.GetEffectChain();
        a.SetRenderTarget(c, !1);
        a.ClearRgba(0, 0, 0, 0);
        a.SetCopyBlend();
        a.SetProgram(this.GetShaderProgram());
        b._SetFirstBounceProgramParameters(a, this.GetIndex());
        b._DrawContent(a);
        b._ClampRcTexDest()
    }
}
;
"use strict";
const C3$jscomp$64 = self.C3,
    tempRect$jscomp$2 = C3$jscomp$64.New(C3$jscomp$64.Rect),
    tempQuad$jscomp$2 = C3$jscomp$64.New(C3$jscomp$64.Quad);
C3$jscomp$64.Gfx.EffectChain.Step.Bounce = class  extends C3$jscomp$64.Gfx.EffectChain.Step{
    constructor(a, b, c, d)
    {
        super(a, b, c, d)
    }
    Run_WebGL(a, b, c)
    {
        const d = this.GetEffectChain();
        a.SetRenderTarget(c);
        (c = 0 === this.GetDestTargetId()) ? a.SetBlendMode(d._GetBlendMode()) : (a.ClearRgba(0, 0, 0, 0), a.SetCopyBlend());
        a.SetProgram(this.GetShaderProgram());
        d._SetProgramParameters(a, this.GetIndex());
        a.SetTexture(b.GetTexture());
        d._SetDeviceTransform(a, c);
        tempQuad$jscomp$2.setFromRect(d._GetDrawSurfaceRect());
        tempRect$jscomp$2.copy(d._GetRcTexBounce());
        tempRect$jscomp$2.flipAround(1);
        a.Quad3(tempQuad$jscomp$2, tempRect$jscomp$2);
        d._ShouldInvalidateRenderTargets() && a.InvalidateRenderTarget(b)
    }
    Run_WebGPU(a, b, c)
    {
        const d = this.GetEffectChain();
        a.SetRenderTarget(c, !1);
        0 === this.GetDestTargetId() ? (a.SetBlendMode(d._GetBlendMode()), a.SetBackTexture(null), d._IsRenderTargetSameSizeAndOffset(a) ? tempQuad$jscomp$2.setFromRect(d._GetRcTexBounce()) : (a.SetNormalizedCoordsProgramVariant(!1), d._SetDeviceTransform(a, !0), tempQuad$jscomp$2.setFromRect(d._GetDrawSurfaceRect()))) :
        (a.ClearRgba(0, 0, 0, 0), a.SetCopyBlend(), tempQuad$jscomp$2.setFromRect(d._GetRcTexBounce()));
        a.SetProgram(this.GetShaderProgram());
        d._SetProgramParameters(a, this.GetIndex());
        a.SetTexture(b.GetTexture());
        d.UseFullSurface() ? a.FullscreenQuad() : a.Quad3(tempQuad$jscomp$2, d._GetRcTexBounce())
    }
}
;
"use strict";
const C3$jscomp$65 = self.C3,
    C3X$jscomp$1 = self.C3X;
let runtime$jscomp$1 = null;
const keysDownByKey = new Set;
function SortZOrderList(a, b) {
    const c = a[0] - b[0];
    return 0 !== c ? c : a[1] - b[1]
}
const tempZOrderList = [],
    tempInstances = [];
let didWarnInAlertPolyfill = !1,
    didWarnFpsDeprecated = !1;
const VALID_FRAMERATE_MODES = new Set(["vsync", "unlimited-tick", "unlimited-frame"]);
self.IRuntime = class {
    constructor(a)
    {
        runtime$jscomp$1 = a;
        Object.defineProperties(this, {
            assets: {
                value: runtime$jscomp$1.GetAssetManager().GetIAssetManager(),
                writable: !1
            },
            collisions: {
                value: runtime$jscomp$1.GetCollisionEngine().GetICollisionEngine(),
                writable: !1
            },
            objects: {
                value: {},
                writable: !1
            },
            globalVars: {
                value: {},
                writable: !1
            },
            projectName: {
                value: runtime$jscomp$1.GetProjectName(),
                writable: !1
            },
            projectVersion: {
                value: runtime$jscomp$1.GetProjectVersion(),
                writable: !1
            },
            storage: {
                value: new self.IStorage(runtime$jscomp$1),
                writable: !1
            },
            isInWorker: {
                value: runtime$jscomp$1.IsInWorker(),
                writable: !1
            },
            viewportWidth: {
                value: runtime$jscomp$1.GetOriginalViewportWidth(),
                writable: !1
            },
            viewportHeight: {
                value: runtime$jscomp$1.GetOriginalViewportHeight(),
                writable: !1
            },
            sampling: {
                value: runtime$jscomp$1.GetSampling(),
                writable: !1
            },
            isPixelRoundingEnabled: {
                value: runtime$jscomp$1.IsPixelRoundingEnabled(),
                writable: !1
            },
            sdk: {
                value: new self.ISDKUtils(a),
                writable: !1
            }
        });
        runtime$jscomp$1.UserScriptDispatcher().addEventListener("keydown", b => {
            keysDownByKey.has(b.key) ?
            b.stopPropagation() : keysDownByKey.add(b.key)
        });
        runtime$jscomp$1.UserScriptDispatcher().addEventListener("keyup", b => keysDownByKey.delete(b.key));
        runtime$jscomp$1.Dispatcher().addEventListener("window-blur", () => keysDownByKey.clear());
        runtime$jscomp$1.IsInWorker() && (self.alert = b => {
            didWarnInAlertPolyfill || (didWarnInAlertPolyfill = !0, console.warn("[Construct] alert() was called from a Web Worker, because the project 'Use worker' setting is enabled. This method is not normally available in a Web Worker. Construct has implemented the alert for you, but note that other features may be missing in worker mode. You may wish to disable 'Use worker', or use a more convenient function like console.log(). For more information please refer to the scripting section of the manual."));
            return this.alert(b)
        })
    }
    _InitObjects(a)
    {
        Object.defineProperties(this.objects, a)
    }
    _InitGlobalVars(a)
    {
        Object.defineProperties(this.globalVars, a)
    }
    addEventListener(a, b)
    {
        runtime$jscomp$1.UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b)
    {
        runtime$jscomp$1.UserScriptDispatcher().removeEventListener(a, b)
    }
    callFunction(a, ...b)
    {
        C3X$jscomp$1.RequireString(a);
        const c = runtime$jscomp$1.GetEventSheetManager(),
            d = c.GetFunctionBlockByName(a);
        if (!d)
            throw Error(`cannot find function name '${a}'`);
        if (!d.IsEnabled())
            return d.GetDefaultReturnValue();
        if (b.length < d.GetFunctionParameterCount())
            throw Error(`not enough function parameters passed for '${a}' (${b.length} passed, ${d.GetFunctionParameterCount()} expected)`);
        a = d.GetEventBlock();
        let e = a.GetSolModifiersIncludingParents();
        const f = c.GetCurrentEvent();
        if (f) {
            e = e.slice(0);
            const g = new Set(e);
            for (const h of f.GetSolModifiersIncludingParents())
                g.has(h) || (e.push(h), g.add(h));
            for (const h of c.GetDynamicSolModifiersSet())
                g.has(h) || (e.push(h), g.add(h))
        }
        return a.RunAsExpressionFunctionCall(e, d.IsCopyPicked(),
        d.GetReturnType(), d.GetDefaultReturnValue(), ...b)
    }
    setReturnValue(a)
    {
        const b = runtime$jscomp$1.GetEventStack().GetCurrentExpFuncStackFrame();
        if (!b)
            throw Error("not in a function which returns a value");
        switch (b.GetFunctionReturnType()) {
        case 1:
            "number" === typeof a && b.SetFunctionReturnValue(a);
            break;
        case 2:
            "string" === typeof a && b.SetFunctionReturnValue(a);
            break;
        case 3:
            "number" !== typeof a && "string" !== typeof a || b.SetFunctionReturnValue(a)
        }
    }
    signal(a)
    {
        C3X$jscomp$1.RequireString(a);
        runtime$jscomp$1.GetEventSheetManager().Signal(a)
    }
    waitForSignal(a)
    {
        C3X$jscomp$1.RequireString(a);
        return runtime$jscomp$1.GetEventSheetManager().WaitForSignal(a)
    }
    getViewportSize()
    {
        return [runtime$jscomp$1.GetOriginalViewportWidth(), runtime$jscomp$1.GetOriginalViewportHeight()]
    }
    get isSuspended()
    {
        return runtime$jscomp$1.IsSuspended()
    }
    get dt()
    {
        return runtime$jscomp$1.GetDt()
    }
    get dtRaw()
    {
        return runtime$jscomp$1.GetDtRaw()
    }
    get gameTime()
    {
        return runtime$jscomp$1.GetGameTime()
    }
    get wallTime()
    {
        return runtime$jscomp$1.GetWallTime()
    }
    get timeScale()
    {
        return runtime$jscomp$1.GetTimeScale()
    }
    set timeScale(a)
    {
        C3X$jscomp$1.RequireFiniteNumber(a);
        runtime$jscomp$1.SetTimeScale(a)
    }
    get fps()
    {
        didWarnFpsDeprecated || (console.warn("IRuntime.fps is deprecated. Use IRuntime.framesPerSecond instead."), didWarnFpsDeprecated = !0);
        return runtime$jscomp$1.GetFramesPerSecond()
    }
    get framesPerSecond()
    {
        return runtime$jscomp$1.GetFramesPerSecond()
    }
    get ticksPerSecond()
    {
        return runtime$jscomp$1.GetTicksPerSecond()
    }
    get cpuUtilisation()
    {
        return runtime$jscomp$1.GetMainThreadTime()
    }
    get gpuUtilisation()
    {
        return runtime$jscomp$1.GetGPUUtilisation()
    }
    get framerateMode()
    {
        return runtime$jscomp$1.GetFramerateMode()
    }
    set framerateMode(a)
    {
        if (!VALID_FRAMERATE_MODES.has(a))
            throw Error("invalid framerate mode");
        runtime$jscomp$1._SetFramerateMode(a)
    }
    get minDt()
    {
        return runtime$jscomp$1.GetMinDt()
    }
    set minDt(a)
    {
        C3X$jscomp$1.RequireFiniteNumber(a);
        runtime$jscomp$1.SetMinDt(a)
    }
    get maxDt()
    {
        return runtime$jscomp$1.GetMaxDt()
    }
    set maxDt(a)
    {
        runtime$jscomp$1.SetMaxDt(a)
    }
    random()
    {
        return runtime$jscomp$1.Random()
    }
    get layout()
    {
        const a = runtime$jscomp$1.GetMainRunningLayout();
        if (!a)
            throw Error("no layout is running - make sure a layout is loaded before accessing");
        return a.GetILayout()
    }
    getLayout(a)
    {
        const b = runtime$jscomp$1.GetLayoutManager();
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayout(a);
        else
            throw new TypeError("expected string or number");
        if (!a)
            throw Error("invalid layout");
        return a.GetILayout()
    }
    getAllLayouts()
    {
        return runtime$jscomp$1.GetLayoutManager().GetAllLayouts().map(a => a.GetILayout())
    }
    goToLayout(a)
    {
        const b = runtime$jscomp$1.GetLayoutManager();
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayout(a);
        else
            throw new TypeError("expected string or number");
        if (!a)
            throw Error("invalid layout");
        b.IsPendingChangeMainLayout() ||
        b.ChangeMainLayout(a)
    }
    get keyboard()
    {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().keyboard;
        if (!a)
            throw Error("runtime.keyboard used but Keyboard object missing - add it to your project first");
        return a
    }
    get mouse()
    {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().mouse;
        if (!a)
            throw Error("runtime.mouse used but Mouse object missing - add it to your project first");
        return a
    }
    get touch()
    {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().touch;
        if (!a)
            throw Error("runtime.touch used but Touch object missing - add it to your project first");
        return a
    }
    get timelineController()
    {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().timelineController;
        if (!a)
            throw Error("runtime.timelineController used but Timeline Controller object missing - add it to your project first");
        return a
    }
    get platformInfo()
    {
        const a = runtime$jscomp$1._GetCommonScriptInterfaces().platformInfo;
        if (!a)
            throw Error("runtime.platformInfo used but Platform Info object missing - add it to your project first");
        return a
    }
    invokeDownload(a, b)
    {
        C3X$jscomp$1.RequireString(a);
        C3X$jscomp$1.RequireString(b);
        runtime$jscomp$1.InvokeDownload(a, b)
    }
    getInstanceByUid(a)
    {
        C3X$jscomp$1.RequireFiniteNumber(a);
        return (a = runtime$jscomp$1.GetInstanceByUID(a)) ? a.GetInterfaceClass() : null
    }
    sortZOrder(a, b)
    {
        C3X$jscomp$1.RequireFunction(b);
        const c = runtime$jscomp$1.GetCurrentLayout();
        for (var d of a) {
            a = runtime$jscomp$1._UnwrapIWorldInstance(d);
            var e = a.GetWorldInfo();
            tempZOrderList.push([e.GetLayer().GetIndex(), e.GetZIndex()]);
            tempInstances.push(a)
        }
        if (0 !== tempZOrderList.length) {
            tempZOrderList.sort(SortZOrderList);
            tempInstances.sort((f,
            g) => b(f.GetInterfaceClass(), g.GetInterfaceClass()));
            d = !1;
            for (let f = 0, g = tempZOrderList.length; f < g; ++f) {
                a = tempInstances[f];
                e = c.GetLayerByIndex(tempZOrderList[f][0]);
                const h = tempZOrderList[f][1],
                    k = e._GetInstances();
                k[h] !== a && (k[h] = a, a.GetWorldInfo()._SetLayer(e, !0), e.SetZIndicesChanged(a), d = !0)
            }
            d && runtime$jscomp$1.UpdateRender();
            C3$jscomp$65.clearArray(tempZOrderList);
            C3$jscomp$65.clearArray(tempInstances)
        }
    }
    async createWorker(a, b)
    {
        var c = new MessageChannel;
        const d = c.port1;
        c = c.port2;
        await runtime$jscomp$1.PostComponentMessageToDOMAsync("runtime",
        "script-create-worker", {
            url: a,
            opts: b,
            port2: c
        }, [c]);
        return d
    }
    alert(a)
    {
        return runtime$jscomp$1.PostComponentMessageToDOMAsync("runtime", "alert", {
            message: a + (runtime$jscomp$1.IsInWorker() ? " [via Web Worker]" : "")
        })
    }
    getHTMLLayer(a)
    {
        C3X$jscomp$1.RequireFiniteNumber(a);
        return runtime$jscomp$1._GetHTMLLayerWrapElement(a)
    }
    addLoadPromise(a)
    {
        runtime$jscomp$1.AddLoadPromise(a)
    }
}
;
"use strict";
const C3$jscomp$66 = self.C3;
let assetManager = null;
self.IAssetManager = class {
    constructor(a)
    {
        assetManager = a;
        Object.defineProperties(this, {
            isWebMOpusSupported: {
                value: assetManager.IsAudioFormatSupported("audio/webm; codecs=opus"),
                writable: !1
            }
        })
    }
    loadImageAsset(a)
    {
        a = self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        a.LoadAsset(assetManager.GetRuntime())
    }
    fetchText(a)
    {
        return assetManager.FetchText(a)
    }
    fetchJson(a)
    {
        return assetManager.FetchJson(a)
    }
    fetchBlob(a)
    {
        return assetManager.FetchBlob(a)
    }
    fetchArrayBuffer(a)
    {
        return assetManager.FetchArrayBuffer(a)
    }
    getProjectFileUrl(a)
    {
        return assetManager.GetProjectFileUrl(a)
    }
    getMediaFileUrl(a)
    {
        "flat" ===
        assetManager.GetFileStructure() && C3$jscomp$66.IsRelativeURL(a) && (a = a.toLowerCase());
        return assetManager.GetMediaFileUrl(a)
    }
    get mediaFolder()
    {
        return assetManager.GetMediaSubfolder()
    }
    async decodeWebMOpus(a, b)
    {
        if (this.isWebMOpusSupported)
            throw Error("decodeWebMOpus(): not supported because WebM Opus is supported by the platform");
        b = await assetManager.GetRuntime()._WasmDecodeWebMOpus(b);
        b = new Float32Array(b);
        a = a.createBuffer(1, b.length, 48E3);
        a.getChannelData(0).set(b);
        return a
    }
    loadScripts(...a)
    {
        return assetManager.LoadScripts(...a)
    }
    compileWebAssembly(a)
    {
        return assetManager.CompileWebAssembly(a)
    }
    loadStyleSheet(a)
    {
        return assetManager.LoadStyleSheet(a)
    }
}
;
"use strict";
const C3$jscomp$67 = self.C3,
    C3X$jscomp$3 = self.C3X;
let collisionEngine = null;
self.ICollisionEngine = class {
    constructor(a)
    {
        collisionEngine = a;
        Object.defineProperties(this, {
            runtime: {
                value: collisionEngine.GetRuntime(),
                writable: !1
            }
        })
    }
    testOverlap(a, b)
    {
        const c = collisionEngine.GetRuntime();
        a = c._UnwrapIWorldInstance(a);
        b = c._UnwrapIWorldInstance(b);
        return collisionEngine.TestOverlap(a, b)
    }
    testOverlapAny(a, b)
    {
        const c = collisionEngine.GetRuntime();
        a = c._UnwrapIWorldInstance(a);
        for (const d of b)
            if (b = c._UnwrapIWorldInstance(d), collisionEngine.TestOverlap(a, b))
                return d;
        return null
    }
    testOverlapSolid(a)
    {
        a =
        collisionEngine.GetRuntime()._UnwrapIWorldInstance(a);
        return (a = collisionEngine.TestOverlapSolid(a)) ? a.GetInterfaceClass() : null
    }
    setCollisionCellSize(a, b)
    {
        C3X$jscomp$3.RequireFiniteNumber(a);
        C3X$jscomp$3.RequireFiniteNumber(b);
        a = Math.floor(a);
        b = Math.floor(b);
        if (0 >= a || 0 >= b)
            throw Error("invalid cell size");
        collisionEngine.SetCollisionCellSize(a, b)
    }
    getCollisionCellSize()
    {
        return collisionEngine.GetCollisionCellSize()
    }
    getCollisionCandidates(a, b)
    {
        const c = collisionEngine.GetRuntime();
        a = Array.isArray(a) ? a.map(e =>
        c._UnwrapIObjectClass(e)) : [c._UnwrapIObjectClass(a)];
        b = C3$jscomp$67.Rect.FromObject(b);
        const d = [];
        collisionEngine.GetObjectClassesCollisionCandidates(null, a, b, d);
        return d.map(e => e.GetInterfaceClass())
    }
}
;
"use strict";
const C3X$jscomp$4 = self.C3X;
self.IStorage = class {
    constructor(a)
    {
        this._storage = a._GetProjectStorage()
    }
    getItem(a)
    {
        C3X$jscomp$4.RequireString(a);
        return this._storage.getItem(a)
    }
    setItem(a, b)
    {
        C3X$jscomp$4.RequireString(a);
        return this._storage.setItem(a, b)
    }
    removeItem(a)
    {
        C3X$jscomp$4.RequireString(a);
        return this._storage.removeItem(a)
    }
    clear()
    {
        return this._storage.clear()
    }
    keys()
    {
        return this._storage.keys()
    }
}
;
"use strict";
const C3$jscomp$69 = self.C3,
    map$jscomp$2 = new WeakMap,
    internalApiToken$jscomp$1 = C3$jscomp$69._GetInternalAPIToken();
self.IPlugin = class {
    constructor()
    {
        const a = C3$jscomp$69.AddonManager._GetInitObject2(internalApiToken$jscomp$1);
        map$jscomp$2.set(this, a);
        Object.defineProperties(this, {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            isSingleGlobal: {
                value: a.IsSingleGlobal(),
                writable: !1
            },
            isWorldType: {
                value: a.IsWorldType(),
                writable: !1
            },
            isHTMLElementType: {
                value: a.IsHTMLElementType(),
                writable: !1
            },
            isRotatable: {
                value: a.IsRotatable(),
                writable: !1
            },
            hasEffects: {
                value: a.HasEffects(),
                writable: !1
            },
            is3d: {
                value: a.Is3D(),
                writable: !1
            },
            supportsHierarchies: {
                value: a.SupportsSceneGraph(),
                writable: !1
            },
            supportsMesh: {
                value: a.SupportsMesh(),
                writable: !1
            }
        })
    }
    static getByConstructor(a)
    {
        return a ? (a = C3$jscomp$69.AddonManager.GetPluginByConstructorFunction(a)) ? a.GetIPlugin() : null : null
    }
    getSingleGlobalObjectType()
    {
        return map$jscomp$2.get(this).GetSingleGlobalObjectClass().GetIObjectClass()
    }
    getSingleGlobalInstance()
    {
        return map$jscomp$2.get(this).GetSingleGlobalInstance().GetInterfaceClass()
    }
}
;
"use strict";
const C3$jscomp$70 = self.C3,
    C3X$jscomp$6 = self.C3X,
    map$jscomp$3 = new WeakMap,
    internalApiToken$jscomp$2 = C3$jscomp$70._GetInternalAPIToken();
self.IObjectClass = class {
    constructor()
    {
        const a = C3$jscomp$70.AddonManager._GetInitObject2(internalApiToken$jscomp$2);
        map$jscomp$3.set(this, a);
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            plugin: {
                value: a.GetPlugin().GetIPlugin(),
                writable: !1
            }
        });
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    addEventListener(a, b)
    {
        C3X$jscomp$6.RequireString(a);
        C3X$jscomp$6.RequireFunction(b);
        map$jscomp$3.get(this).UserScriptDispatcher().addEventListener(a,
        b)
    }
    removeEventListener(a, b)
    {
        C3X$jscomp$6.RequireString(a);
        C3X$jscomp$6.RequireFunction(b);
        map$jscomp$3.get(this).UserScriptDispatcher().removeEventListener(a, b)
    }
    getAllInstances()
    {
        return [...this.instances()]
    }
    getFirstInstance()
    {
        return C3$jscomp$70.first(this.instances())
    }
    getPickedInstances()
    {
        return [...this.pickedInstances()]
    }
    getFirstPickedInstance()
    {
        return C3$jscomp$70.first(this.pickedInstances())
    }
    getPairedInstance(a)
    {
        var b = map$jscomp$3.get(this);
        a = b.GetRuntime()._UnwrapIInstance(a);
        return (b = b.GetPairedInstance(a)) ?
        b.GetInterfaceClass() : null
    }
    *instances()
    {
        for (const a of map$jscomp$3.get(this).instancesIncludingPendingCreate())
            yield a.GetInterfaceClass()
    }
    *pickedInstances()
    {
        for (const a of map$jscomp$3.get(this).GetCurrentSol().GetInstances())
            yield a.GetInterfaceClass()
    }
    setInstanceClass(a)
    {
        C3X$jscomp$6.RequireFunction(a);
        if (0 < map$jscomp$3.get(this).GetInstanceCount())
            throw Error("setInstanceClass() called too late, because instances have already been created - call in runOnStartup");
        map$jscomp$3.get(this)._SetUserScriptInstanceClass(a)
    }
    createInstance(a,
    b, c, d, e)
    {
        C3X$jscomp$6.RequireNumber(b);
        C3X$jscomp$6.RequireNumber(c);
        if ("number" !== typeof a && "string" !== typeof a)
            throw new TypeError("invalid layer parameter");
        const f = map$jscomp$3.get(this),
            g = f.GetRuntime();
        a = g.GetMainRunningLayout().GetLayer(a);
        if (!a)
            throw Error("invalid layer");
        b = g.CreateInstance(f, a, b, c, d, e);
        d && a.SortAndAddInstancesByZIndex(b);
        d = g.GetEventSheetManager();
        d.BlockFlushingInstances(!0);
        b._TriggerOnCreatedOnSelfAndRelated();
        d.BlockFlushingInstances(!1);
        d.IsInEventEngine() || g.GetLayoutManager().IsEndingLayout() ||
        g.FlushPendingInstances();
        return b.GetInterfaceClass()
    }
}
;
"use strict";
const C3X$jscomp$7 = self.C3X,
    map$jscomp$4 = new WeakMap,
    VALID_WHERE_STRINGS = ["above", "below", "top-sublayer", "bottom-sublayer"];
self.ILayout = class {
    constructor(a)
    {
        map$jscomp$4.set(this, a);
        const b = [],
            c = a.GetEffectList(),
            d = c.GetAllEffectTypes().length;
        for (let e = 0; e < d; ++e)
            b.push(new self.IEffectInstance(c, e));
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            index: {
                value: a.GetIndex(),
                writable: !1
            },
            effects: {
                value: b,
                writable: !1
            }
        })
    }
    addEventListener(a, b)
    {
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireFunction(b);
        map$jscomp$4.get(this).UserScriptDispatcher().addEventListener(a, b)
    }
    removeEventListener(a, b)
    {
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireFunction(b);
        map$jscomp$4.get(this).UserScriptDispatcher().removeEventListener(a, b)
    }
    get width()
    {
        return map$jscomp$4.get(this).GetWidth()
    }
    set width(a)
    {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetWidth(a)
    }
    get height()
    {
        return map$jscomp$4.get(this).GetHeight()
    }
    set height(a)
    {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetHeight(a)
    }
    setSize(a, b)
    {
        C3X$jscomp$7.RequireFiniteNumber(a);
        C3X$jscomp$7.RequireFiniteNumber(b);
        const c = map$jscomp$4.get(this);
        c.SetWidth(a);
        c.SetHeight(b)
    }
    getSize()
    {
        const a = map$jscomp$4.get(this);
        return [a.GetWidth(), a.GetHeight()]
    }
    set scale(a)
    {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetScale(a)
    }
    get scale()
    {
        return map$jscomp$4.get(this).GetScale()
    }
    set angle(a)
    {
        C3X$jscomp$7.RequireFiniteNumber(a);
        map$jscomp$4.get(this).SetAngle(a)
    }
    get angle()
    {
        return map$jscomp$4.get(this).GetAngle()
    }
    set scrollX(a)
    {
        C3X$jscomp$7.RequireNumber(a);
        map$jscomp$4.get(this).SetScrollX(a)
    }
    get scrollX()
    {
        return map$jscomp$4.get(this).GetScrollX()
    }
    set scrollY(a)
    {
        C3X$jscomp$7.RequireNumber(a);
        map$jscomp$4.get(this).SetScrollY(a)
    }
    get scrollY()
    {
        return map$jscomp$4.get(this).GetScrollY()
    }
    scrollTo(a, b)
    {
        C3X$jscomp$7.RequireNumber(a);
        C3X$jscomp$7.RequireNumber(b);
        const c = map$jscomp$4.get(this);
        c.SetScrollX(a);
        c.SetScrollY(b)
    }
    getScrollPosition()
    {
        const a = map$jscomp$4.get(this);
        return [a.GetScrollX(), a.GetScrollY()]
    }
    getLayer(a)
    {
        const b = map$jscomp$4.get(this);
        if ("number" === typeof a || "string" === typeof a)
            a = b.GetLayer(a);
        else
            throw new TypeError("expected string or number");
        return a ? a.GetILayer() : null
    }
    getAllLayers()
    {
        return map$jscomp$4.get(this).GetLayers().map(a =>
        a.GetILayer())
    }
    *allLayers()
    {
        for (const a of map$jscomp$4.get(this).allLayers())
            yield a.GetILayer()
    }
    addLayer(a, b, c)
    {
        const d = map$jscomp$4.get(this),
            e = self.ILayer;
        C3X$jscomp$7.RequireString(a);
        C3X$jscomp$7.RequireOptionalInstanceOf(b, e);
        b = b ? d.GetRuntime()._UnwrapScriptInterface(b) : null;
        c = VALID_WHERE_STRINGS.indexOf(c);
        if (0 > c)
            throw Error("invalid location");
        d.AddLayer(a, b, c)
    }
    moveLayer(a, b, c)
    {
        const d = map$jscomp$4.get(this),
            e = d.GetRuntime(),
            f = self.ILayer;
        C3X$jscomp$7.RequireInstanceOf(a, f);
        a = e._UnwrapScriptInterface(a);
        if (!a)
            throw Error("invalid layer");
        C3X$jscomp$7.RequireOptionalInstanceOf(b, f);
        b = b ? e._UnwrapScriptInterface(b) : null;
        c = VALID_WHERE_STRINGS.indexOf(c);
        if (0 > c)
            throw Error("invalid location");
        d.MoveLayer(a, b, c)
    }
    removeLayer(a)
    {
        const b = map$jscomp$4.get(this);
        C3X$jscomp$7.RequireInstanceOf(a, self.ILayer);
        a = b.GetRuntime()._UnwrapScriptInterface(a);
        if (!a)
            throw Error("invalid layer");
        const c = a.GetRuntime();
        b.RemoveLayer(a);
        c.GetEventSheetManager().IsInEventEngine() || c.FlushPendingInstances()
    }
    removeAllDynamicLayers()
    {
        const a =
            map$jscomp$4.get(this),
            b = a.GetRuntime();
        a.RemoveAllDynamicLayers();
        b.GetEventSheetManager().IsInEventEngine() || b.FlushPendingInstances()
    }
    setVanishingPoint(a, b)
    {
        C3X$jscomp$7.RequireFiniteNumber(a);
        C3X$jscomp$7.RequireFiniteNumber(b);
        map$jscomp$4.get(this).SetVanishingPointXY(a, b)
    }
    getVanishingPoint()
    {
        return map$jscomp$4.get(this)._GetVanishingPoint()
    }
    set projection(a)
    {
        C3X$jscomp$7.RequireString(a);
        const b = map$jscomp$4.get(this);
        if ("perspective" === a)
            b.SetPerspectiveProjection();
        else if ("orthographic" ===
        a)
            b.SetOrthographicProjection();
        else
            throw Error("invalid projection");
    }
    get projection()
    {
        return map$jscomp$4.get(this).IsOrthographicProjection() ? "orthographic" : "perspective"
    }
}
;
"use strict";
const C3$jscomp$72 = self.C3,
    C3X$jscomp$8 = self.C3X,
    map$jscomp$5 = new WeakMap,
    BLEND_MODE_TO_INDEX = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]),
    INDEX_TO_BLEND_MODE = new Map([...BLEND_MODE_TO_INDEX.entries()].map(a => [a[1], a[0]])),
    tempColor$jscomp$1 = C3$jscomp$72.New(C3$jscomp$72.Color);
self.ILayer = class {
    constructor(a)
    {
        map$jscomp$5.set(this, a);
        const b = [],
            c = a.GetEffectList(),
            d = c.GetAllEffectTypes().length;
        for (let e = 0; e < d; ++e)
            b.push(new self.IEffectInstance(c, e));
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            },
            layout: {
                value: a.GetLayout().GetILayout(),
                writable: !1
            },
            effects: {
                value: b,
                writable: !1
            }
        });
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    get parentLayer()
    {
        const a = map$jscomp$5.get(this).GetParentLayer();
        return a ? a.GetILayer() : null
    }
    *parentLayers()
    {
        for (const a of map$jscomp$5.get(this).parentLayers())
            yield a.GetILayer()
    }
    *subLayers()
    {
        for (const a of map$jscomp$5.get(this).GetSubLayers())
            yield a.GetILayer()
    }
    *allSubLayers()
    {
        for (const a of map$jscomp$5.get(this).GetSubLayers())
            for (const b of a.selfAndAllSubLayers())
                yield b.GetILayer()
    }
    get index()
    {
        return map$jscomp$5.get(this).GetIndex()
    }
    get isVisible()
    {
        return map$jscomp$5.get(this)._IsVisibleFlagSet()
    }
    set isVisible(a)
    {
        map$jscomp$5.get(this).SetVisible(a)
    }
    get isSelfAndParentsVisible()
    {
        return map$jscomp$5.get(this).IsVisible()
    }
    get isInteractive()
    {
        return map$jscomp$5.get(this).IsInteractive()
    }
    set isInteractive(a)
    {
        map$jscomp$5.get(this).SetInteractive(a)
    }
    get isHTMLElementsLayer()
    {
        return map$jscomp$5.get(this).IsHTMLElementsLayer()
    }
    set isHTMLElementsLayer(a)
    {
        map$jscomp$5.get(this).SetIsHTMLElementsLayer(!!a)
    }
    get isSelfAndParentsInteractive()
    {
        return map$jscomp$5.get(this).IsSelfAndParentsInteractive()
    }
    get opacity()
    {
        return map$jscomp$5.get(this).GetOpacity()
    }
    set opacity(a)
    {
        a =
        C3$jscomp$72.clamp(+a, 0, 1);
        isNaN(a) || map$jscomp$5.get(this).SetOpacity(a)
    }
    set scale(a)
    {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetOwnScale(a)
    }
    get scale()
    {
        return map$jscomp$5.get(this).GetOwnScale()
    }
    set scaleRate(a)
    {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetScaleRate(a)
    }
    get scaleRate()
    {
        return map$jscomp$5.get(this).GetScaleRate()
    }
    set angle(a)
    {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetAngle(a)
    }
    get angle()
    {
        return map$jscomp$5.get(this).GetOwnAngle()
    }
    set parallaxX(a)
    {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetParallaxX(a)
    }
    get parallaxX()
    {
        return map$jscomp$5.get(this).GetParallaxX()
    }
    set parallaxY(a)
    {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetParallaxY(a)
    }
    get parallaxY()
    {
        return map$jscomp$5.get(this).GetParallaxY()
    }
    set zElevation(a)
    {
        C3X$jscomp$8.RequireFiniteNumber(a);
        map$jscomp$5.get(this).SetZElevation(a)
    }
    get zElevation()
    {
        return map$jscomp$5.get(this).GetZElevation()
    }
    set isTransparent(a)
    {
        map$jscomp$5.get(this).SetTransparent(a)
    }
    get isTransparent()
    {
        return map$jscomp$5.get(this).IsTransparent()
    }
    set isForceOwnTexture(a)
    {
        map$jscomp$5.get(this).SetForceOwnTexture(a)
    }
    get isForceOwnTexture()
    {
        return map$jscomp$5.get(this).IsForceOwnTexture()
    }
    set blendMode(a)
    {
        C3X$jscomp$8.RequireString(a);
        a = BLEND_MODE_TO_INDEX.get(a);
        if ("number" !== typeof a)
            throw Error("invalid blend mode");
        map$jscomp$5.get(this).SetBlendMode(a)
    }
    get blendMode()
    {
        return INDEX_TO_BLEND_MODE.get(map$jscomp$5.get(this).GetBlendMode())
    }
    set backgroundColor(a)
    {
        C3X$jscomp$8.RequireArray(a);
        if (3 > a.length)
            throw Error("expected 3 elements");
        tempColor$jscomp$1.setRgb(a[0], a[1], a[2]);
        a = map$jscomp$5.get(this);
        const b = a.GetBackgroundColor();
        b.equalsIgnoringAlpha(tempColor$jscomp$1) || (b.copyRgb(tempColor$jscomp$1), a.GetRuntime().UpdateRender())
    }
    get backgroundColor()
    {
        const a =
        map$jscomp$5.get(this).GetBackgroundColor();
        return [a.getR(), a.getG(), a.getB()]
    }
    set scrollX(a)
    {
        C3X$jscomp$8.RequireNumber(a);
        const b = map$jscomp$5.get(this);
        b.SetOwnScrollPositionEnabled(!0);
        b.SetScrollX(a)
    }
    get scrollX()
    {
        return map$jscomp$5.get(this).GetScrollX()
    }
    set scrollY(a)
    {
        C3X$jscomp$8.RequireNumber(a);
        const b = map$jscomp$5.get(this);
        b.SetOwnScrollPositionEnabled(!0);
        b.SetScrollY(a)
    }
    get scrollY()
    {
        return map$jscomp$5.get(this).GetScrollY()
    }
    scrollTo(a, b)
    {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        const c = map$jscomp$5.get(this);
        c.SetOwnScrollPositionEnabled(!0);
        c.SetScrollX(a);
        c.SetScrollY(b)
    }
    getScrollPosition()
    {
        const a = map$jscomp$5.get(this);
        return [a.GetScrollX(), a.GetScrollY()]
    }
    restoreScrollPosition()
    {
        map$jscomp$5.get(this).SetOwnScrollPositionEnabled(!1)
    }
    getViewport()
    {
        return map$jscomp$5.get(this).GetViewport().toDOMRect()
    }
    cssPxToLayer(a, b, c=0)
    {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        const d = map$jscomp$5.get(this),
            e = d.GetRuntime();
        return d.CanvasCssToLayer(a -
        e.GetCanvasClientX(), b - e.GetCanvasClientY(), c)
    }
    layerToCssPx(a, b, c=0)
    {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        const d = map$jscomp$5.get(this),
            e = d.GetRuntime(),
            [f, g] = d.LayerToCanvasCss(a, b, c);
        return [f + e.GetCanvasClientX(), g + e.GetCanvasClientY()]
    }
    drawSurfaceToLayer(a, b, c=0)
    {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        return map$jscomp$5.get(this).DrawSurfaceToLayer(a, b, c)
    }
    layerToDrawSurface(a, b, c=0)
    {
        C3X$jscomp$8.RequireNumber(a);
        C3X$jscomp$8.RequireNumber(b);
        C3X$jscomp$8.RequireNumber(c);
        return map$jscomp$5.get(this).LayerToDrawSurface(a, b, c)
    }
    get renderScale()
    {
        return map$jscomp$5.get(this).GetRenderScale()
    }
}
;
"use strict";
const C3$jscomp$73 = self.C3,
    C3X$jscomp$9 = self.C3X,
    map$jscomp$6 = new WeakMap,
    dispatchers = new WeakMap,
    internalApiToken$jscomp$3 = C3$jscomp$73._GetInternalAPIToken();
function GetDispatcher(a) {
    let b = dispatchers.get(a);
    if (b)
        return b;
    b = C3$jscomp$73.New(C3$jscomp$73.Event.Dispatcher);
    dispatchers.set(a, b);
    return b
}
self.IInstance = class {
    constructor()
    {
        const a = C3$jscomp$73.AddonManager._GetInitObject2(internalApiToken$jscomp$3);
        map$jscomp$6.set(this, a);
        const b = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            objectType: {
                value: a.GetObjectClass().GetIObjectClass(),
                writable: !1
            },
            plugin: {
                value: a.GetPlugin().GetIPlugin(),
                writable: !1
            }
        };
        a._GetInstVarsScriptDescriptor(b);
        a._GetBehaviorsScriptDescriptor(b);
        Object.defineProperties(this, b);
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    static _GetInitInst()
    {
        return C3$jscomp$73.AddonManager._GetInitObject()
    }
    _release()
    {
        const a =
        dispatchers.get(this);
        a && (a.Release(), dispatchers.delete(this));
        map$jscomp$6.delete(this)
    }
    addEventListener(a, b, c)
    {
        C3X$jscomp$9.RequireString(a);
        C3X$jscomp$9.RequireFunction(b);
        GetDispatcher(this).addEventListener(a, b, c)
    }
    removeEventListener(a, b, c)
    {
        C3X$jscomp$9.RequireString(a);
        C3X$jscomp$9.RequireFunction(b);
        GetDispatcher(this).removeEventListener(a, b, c)
    }
    dispatchEvent(a)
    {
        GetDispatcher(this).dispatchEvent(a)
    }
    destroy()
    {
        const a = map$jscomp$6.get(this),
            b = a.GetRuntime();
        b.DestroyInstance(a);
        b.GetEventSheetManager().IsInEventEngine() ||
        b.GetLayoutManager().IsEndingLayout() || b.GetEventSheetManager().IsFlushingBlocked() || b.FlushPendingInstances()
    }
    getOtherContainerInstances()
    {
        const a = map$jscomp$6.get(this).GetSiblings();
        return a ? a.map(b => b.GetInterfaceClass()) : []
    }
    *otherContainerInstances()
    {
        const a = map$jscomp$6.get(this);
        if (a.IsInContainer())
            for (const b of a.siblings())
                yield b.GetInterfaceClass()
    }
    get uid()
    {
        return map$jscomp$6.get(this).GetUID()
    }
    get templateName()
    {
        return map$jscomp$6.get(this).GetTemplateName()
    }
    set timeScale(a)
    {
        C3X$jscomp$9.RequireFiniteNumber(a);
        map$jscomp$6.get(this).SetTimeScale(a)
    }
    get timeScale()
    {
        return map$jscomp$6.get(this).GetActiveTimeScale()
    }
    restoreTimeScale()
    {
        map$jscomp$6.get(this).RestoreTimeScale()
    }
    get dt()
    {
        const a = map$jscomp$6.get(this);
        return a.GetRuntime().GetDt(a)
    }
    hasTags(...a)
    {
        C3X$jscomp$9.RequireArray(a);
        a = new Set(a);
        const b = map$jscomp$6.get(this).GetTagsSet();
        return a.isSubsetOf(b)
    }
    setAllTags(a)
    {
        C3X$jscomp$9.RequireInstanceOf(a, Set);
        map$jscomp$6.get(this).SetTagsSet(a)
    }
    getAllTags()
    {
        return new Set(map$jscomp$6.get(this).GetTagsSet())
    }
    signal(a)
    {
        C3X$jscomp$9.RequireString(a);
        const b = map$jscomp$6.get(this);
        b.GetRuntime().GetEventSheetManager().InstanceSignal(b, a)
    }
    waitForSignal(a)
    {
        C3X$jscomp$9.RequireString(a);
        const b = map$jscomp$6.get(this);
        return b.GetRuntime().GetEventSheetManager().WaitForInstanceSignal(b, a)
    }
}
;
"use strict";
const C3$jscomp$74 = self.C3,
    C3X$jscomp$10 = self.C3X,
    map$jscomp$7 = new WeakMap,
    internalApiToken$jscomp$4 = C3$jscomp$74._GetInternalAPIToken();
self.ISDKInstanceBase = class  extends self.IInstance{
    constructor(a)
    {
        super();
        map$jscomp$7.set(this, C3$jscomp$74.AddonManager._GetInitObject2(internalApiToken$jscomp$4));
        this._p_isTicking = !1;
        this._p_tickFunc = null;
        this._p_isTicking2 = !1;
        this._p_tickFunc2 = null;
        this._p_domComponentId=a?.domComponentId;
        this._p_wrapperComponentId=a?.wrapperComponentId
    }
    _release()
    {
        super._release();
        map$jscomp$7.delete(this)
    }
    _getInitProperties()
    {
        return C3$jscomp$74.AddonManager._GetInitProperties()
    }
    _trigger(a)
    {
        const b = map$jscomp$7.get(this);
        b.GetRuntime().Trigger(a, b)
    }
    _triggerAsync(a)
    {
        const b = map$jscomp$7.get(this);
        return b.GetRuntime().TriggerAsync(a, b)
    }
    _addDOMMessageHandler(a, b)
    {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireFunction(b);
        if (!this._p_domComponentId)
            throw Error("no DOM component id set");
        map$jscomp$7.get(this).GetRuntime().AddDOMComponentMessageHandler(this._p_domComponentId, a, b)
    }
    _addDOMMessageHandlers(a)
    {
        C3X$jscomp$10.RequireArray(a);
        for (const [b, c] of a)
            this._addDOMMessageHandler(b, c)
    }
    _postToDOM(a, b)
    {
        C3X$jscomp$10.RequireString(a);
        if (!this._p_domComponentId)
            throw Error("no DOM component id set");
        map$jscomp$7.get(this).GetRuntime().PostComponentMessageToDOM(this._p_domComponentId, a, b)
    }
    _postToDOMAsync(a, b)
    {
        C3X$jscomp$10.RequireString(a);
        if (!this._p_domComponentId)
            throw Error("no DOM component id set");
        return map$jscomp$7.get(this).GetRuntime().PostComponentMessageToDOMAsync(this._p_domComponentId, a, b)
    }
    _postToDOMMaybeSync(a, b)
    {
        if (map$jscomp$7.get(this).GetRuntime().IsInWorker())
            this._postToDOM(a, b);
        else
            return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._p_domComponentId,
                handler: a,
                data: b,
                responseId: null
            })
    }
    _setTicking(a)
    {
        a = !!a;
        if (this._p_isTicking !== a) {
            this._p_isTicking = a;
            var b = map$jscomp$7.get(this).GetRuntime();
            a ? (this._p_tickFunc || (this._p_tickFunc = () => this._tick()), b.Dispatcher().addEventListener("tick", this._p_tickFunc)) : b.Dispatcher().removeEventListener("tick", this._p_tickFunc)
        }
    }
    _isTicking()
    {
        return this._p_isTicking
    }
    _tick() {}
    _setTicking2(a)
    {
        a = !!a;
        if (this._p_isTicking2 !== a) {
            this._p_isTicking2 = a;
            var b = map$jscomp$7.get(this).GetRuntime();
            a ? (this._p_tickFunc2 || (this._p_tickFunc2 = () => this._tick2()), b.Dispatcher().addEventListener("tick2", this._p_tickFunc2)) : b.Dispatcher().removeEventListener("tick2", this._p_tickFunc2)
        }
    }
    _isTicking2()
    {
        return this._p_isTicking2
    }
    _tick2() {}
    _getDebuggerProperties()
    {
        return []
    }
    _saveToJson()
    {
        return null
    }
    _loadFromJson(a) {}
    _isWrapperExtensionAvailable()
    {
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        return map$jscomp$7.get(this).GetRuntime().HasWrapperComponentId(this._p_wrapperComponentId)
    }
    _addWrapperExtensionMessageHandler(a,
    b)
    {
        C3X$jscomp$10.RequireString(a);
        C3X$jscomp$10.RequireFunction(b);
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        map$jscomp$7.get(this).GetRuntime().AddWrapperExtensionMessageHandler(this._p_wrapperComponentId, a, b)
    }
    _addWrapperMessageHandlers(a)
    {
        C3X$jscomp$10.RequireArray(a);
        for (const [b, c] of a)
            this._addWrapperExtensionMessageHandler(b, c)
    }
    _sendWrapperExtensionMessage(a, b)
    {
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        this.runtime.sendWrapperExtensionMessage(this._p_wrapperComponentId,
        a, b)
    }
    _sendWrapperExtensionMessageAsync(a, b)
    {
        if (!this._p_wrapperComponentId)
            throw Error("no wrapper component id set");
        return this.runtime.sendWrapperExtensionMessageAsync(this._p_wrapperComponentId, a, b)
    }
}
;
"use strict";
const C3$jscomp$75 = self.C3,
    C3X$jscomp$11 = self.C3X,
    ILayer$jscomp$4 = self.ILayer,
    map$jscomp$8 = new WeakMap,
    internalApiToken$jscomp$5 = C3$jscomp$75._GetInternalAPIToken(),
    BLEND_MODE_TO_INDEX$jscomp$1 = new Map([["normal", 0], ["additive", 1], ["copy", 3], ["destination-over", 4], ["source-in", 5], ["destination-in", 6], ["source-out", 7], ["destination-out", 8], ["source-atop", 9], ["destination-atop", 10]]),
    INDEX_TO_BLEND_MODE$jscomp$1 = new Map([...BLEND_MODE_TO_INDEX$jscomp$1.entries()].map(a => [a[1], a[0]])),
    tempColor$jscomp$2 =
    C3$jscomp$75.New(C3$jscomp$75.Color);
function MakeIWorldInstanceClass(a) {
    return class b extends a {
        constructor(c)
        {
            super(c);
            var d = C3$jscomp$75.AddonManager._GetInitObject2(internalApiToken$jscomp$5);
            map$jscomp$8.set(this, d);
            c = [];
            var e = d.GetWorldInfo();
            if (d = e.GetInstanceEffectList()) {
                e = e.GetObjectClass().GetEffectList().GetAllEffectTypes().length;
                for (let f = 0; f < e; ++f)
                    c.push(new self.IEffectInstance(d, f))
            }
            Object.defineProperties(this, {
                effects: {
                    value: c,
                    writable: !1
                }
            })
        }
        get layout()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetLayout().GetILayout()
        }
        get layer()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetLayer().GetILayer()
        }
        get x()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetX()
        }
        set x(c)
        {
            c = +c;
            const d = map$jscomp$8.get(this).GetWorldInfo();
            isNaN(c) || d.GetX() === c || (d.SetX(c), d.SetBboxChanged())
        }
        get y()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetY()
        }
        set y(c)
        {
            c = +c;
            const d = map$jscomp$8.get(this).GetWorldInfo();
            isNaN(c) || d.GetY() === c || (d.SetY(c), d.SetBboxChanged())
        }
        setPosition(c, d)
        {
            c = +c;
            d = +d;
            const e = map$jscomp$8.get(this).GetWorldInfo();
            isNaN(c) || isNaN(d) || e.GetX() === c && e.GetY() === d || (e.SetXY(c, d), e.SetBboxChanged())
        }
        getPosition()
        {
            const c = map$jscomp$8.get(this).GetWorldInfo();
            return [c.GetX(),
            c.GetY()]
        }
        offsetPosition(c, d)
        {
            c = +c;
            d = +d;
            if (!(isNaN(c) || isNaN(d) || 0 === c && 0 === d)) {
                var e = map$jscomp$8.get(this).GetWorldInfo();
                e.OffsetXY(c, d);
                e.SetBboxChanged()
            }
        }
        get zElevation()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetZElevation()
        }
        set zElevation(c)
        {
            c = +c;
            const d = map$jscomp$8.get(this),
                e = d.GetWorldInfo();
            isNaN(c) || e.GetZElevation() === c || (e.SetZElevation(c), d.GetRuntime().UpdateRender())
        }
        get totalZElevation()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetTotalZElevation()
        }
        get width()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetWidth()
        }
        set width(c)
        {
            c =
            +c;
            const d = map$jscomp$8.get(this).GetWorldInfo();
            isNaN(c) || d.GetWidth() === c || (d.SetWidth(c), d.SetBboxChanged())
        }
        get height()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetHeight()
        }
        set height(c)
        {
            c = +c;
            const d = map$jscomp$8.get(this).GetWorldInfo();
            isNaN(c) || d.GetHeight() === c || (d.SetHeight(c), d.SetBboxChanged())
        }
        setSize(c, d)
        {
            c = +c;
            d = +d;
            const e = map$jscomp$8.get(this).GetWorldInfo();
            isNaN(c) || isNaN(d) || e.GetWidth() === c && e.GetHeight() === d || (e.SetSize(c, d), e.SetBboxChanged())
        }
        getSize()
        {
            const c = map$jscomp$8.get(this).GetWorldInfo();
            return [c.GetWidth(), c.GetHeight()]
        }
        get angle()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetAngle()
        }
        set angle(c)
        {
            c = C3$jscomp$75.clampAngle(+c);
            const d = map$jscomp$8.get(this).GetWorldInfo();
            isNaN(c) || d.GetAngle() === c || (d.SetAngle(c), d.SetBboxChanged())
        }
        get angleDegrees()
        {
            return C3$jscomp$75.toDegrees(this.angle)
        }
        set angleDegrees(c)
        {
            this.angle = C3$jscomp$75.toRadians(c)
        }
        getBoundingBox()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetBoundingBox().toDOMRect()
        }
        getBoundingQuad()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetBoundingQuad().toDOMQuad()
        }
        isOnScreen()
        {
            return map$jscomp$8.get(this).GetWorldInfo().IsInViewport2()
        }
        get isVisible()
        {
            return map$jscomp$8.get(this).GetWorldInfo().IsVisible()
        }
        set isVisible(c)
        {
            c =
            !!c;
            const d = map$jscomp$8.get(this),
                e = d.GetWorldInfo();
            e.IsVisible() !== c && (e.SetVisible(c), d.GetRuntime().UpdateRender())
        }
        get opacity()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetOpacity()
        }
        set opacity(c)
        {
            c = C3$jscomp$75.clamp(+c, 0, 1);
            const d = map$jscomp$8.get(this),
                e = d.GetWorldInfo();
            isNaN(c) || e.GetOpacity() === c || (e.SetOpacity(c), d.GetRuntime().UpdateRender())
        }
        set colorRgb(c)
        {
            C3X$jscomp$11.RequireArray(c);
            if (3 > c.length)
                throw Error("expected 3 elements");
            tempColor$jscomp$2.setRgb(c[0], c[1], c[2]);
            c = map$jscomp$8.get(this);
            const d = c.GetWorldInfo();
            d.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor$jscomp$2) || (d.SetUnpremultipliedColor(tempColor$jscomp$2), c.GetRuntime().UpdateRender())
        }
        get colorRgb()
        {
            const c = map$jscomp$8.get(this).GetWorldInfo().GetUnpremultipliedColor();
            return [c.getR(), c.getG(), c.getB()]
        }
        set blendMode(c)
        {
            C3X$jscomp$11.RequireString(c);
            c = BLEND_MODE_TO_INDEX$jscomp$1.get(c);
            if ("number" !== typeof c)
                throw Error("invalid blend mode");
            const d = map$jscomp$8.get(this);
            d.GetWorldInfo().SetBlendMode(c);
            d.GetRuntime().UpdateRender()
        }
        get blendMode()
        {
            return INDEX_TO_BLEND_MODE$jscomp$1.get(map$jscomp$8.get(this).GetWorldInfo().GetBlendMode())
        }
        moveToTop()
        {
            map$jscomp$8.get(this).GetWorldInfo().ZOrderMoveToTop()
        }
        moveToBottom()
        {
            map$jscomp$8.get(this).GetWorldInfo().ZOrderMoveToBottom()
        }
        moveToLayer(c)
        {
            C3X$jscomp$11.RequireInstanceOf(c, ILayer$jscomp$4);
            const d = map$jscomp$8.get(this);
            c = d.GetRuntime()._UnwrapScriptInterface(c);
            if (!c)
                throw Error("invalid layer");
            d.GetWorldInfo().ZOrderMoveToLayer(c)
        }
        moveAdjacentToInstance(c,
        d)
        {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            map$jscomp$8.get(this).GetWorldInfo().ZOrderMoveAdjacentToInstance(map$jscomp$8.get(c), d)
        }
        get zIndex()
        {
            return map$jscomp$8.get(this).GetWorldInfo().GetZIndex()
        }
        get isCollisionEnabled()
        {
            return map$jscomp$8.get(this).GetWorldInfo().IsCollisionEnabled()
        }
        set isCollisionEnabled(c)
        {
            map$jscomp$8.get(this).GetWorldInfo().SetCollisionEnabled(!!c)
        }
        containsPoint(c, d)
        {
            C3X$jscomp$11.RequireNumber(c);
            C3X$jscomp$11.RequireNumber(d);
            return map$jscomp$8.get(this).GetWorldInfo().ContainsPoint(+c,
            +d)
        }
        testOverlap(c)
        {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            const d = map$jscomp$8.get(this);
            c = map$jscomp$8.get(c);
            return d.GetRuntime().GetCollisionEngine().TestOverlap(d, c)
        }
        testOverlapSolid()
        {
            var c = map$jscomp$8.get(this);
            return (c = c.GetRuntime().GetCollisionEngine().TestOverlapSolid(c)) ? c.GetInterfaceClass() : null
        }
        getParent()
        {
            const c = map$jscomp$8.get(this).GetParent();
            return c ? c.GetInterfaceClass() : null
        }
        getTopParent()
        {
            const c = map$jscomp$8.get(this).GetTopParent();
            return c ? c.GetInterfaceClass() : null
        }
        *parents()
        {
            for (const c of map$jscomp$8.get(this).parents())
                yield c.GetInterfaceClass()
        }
        getChildCount()
        {
            return map$jscomp$8.get(this).GetChildCount()
        }
        getChildAt(c)
        {
            return (c =
            map$jscomp$8.get(this).GetChildAt(c)) ? c.GetInterfaceClass() : null
        }
        *children()
        {
            for (const c of map$jscomp$8.get(this).children())
                yield c.GetInterfaceClass()
        }
        *allChildren()
        {
            for (const c of map$jscomp$8.get(this).allChildren())
                yield c.GetInterfaceClass()
        }
        addChild(c, d)
        {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            C3X$jscomp$11.RequireOptionalObject(d);
            d || (d = {});
            const e = map$jscomp$8.get(this);
            c = map$jscomp$8.get(c);
            e.AddChild(c, d)
        }
        removeChild(c)
        {
            C3X$jscomp$11.RequireInstanceOf(c, b);
            const d = map$jscomp$8.get(this);
            c = map$jscomp$8.get(c);
            d.RemoveChild(c)
        }
        removeFromParent()
        {
            const c = map$jscomp$8.get(this);
            c.HasParent() && c.GetParent().RemoveChild(c)
        }
        getHierarchyOpts()
        {
            const c = map$jscomp$8.get(this).GetWorldInfo();
            return {
                transformX: c.GetTransformWithParentX(),
                transformY: c.GetTransformWithParentY(),
                transformWidth: c.GetTransformWithParentWidth(),
                transformHeight: c.GetTransformWithParentHeight(),
                transformAngle: c.GetTransformWithParentAngle(),
                transformZElevation: c.GetTransformWithParentZElevation(),
                transformOpacity: c.GetTransformWithParentOpacity(),
                transformVisibility: c.GetTransformWithParentVisibility(),
                destroyWithParent: c.GetDestroyWithParent()
            }
        }
        createMesh(c, d)
        {
            C3X$jscomp$11.RequireFiniteNumber(c);
            C3X$jscomp$11.RequireFiniteNumber(d);
            map$jscomp$8.get(this).GetWorldInfo().CreateMesh(c, d)
        }
        releaseMesh()
        {
            const c = map$jscomp$8.get(this).GetWorldInfo();
            c.ReleaseMesh();
            c.SetBboxChanged()
        }
        setMeshPoint(c, d, e)
        {
            C3X$jscomp$11.RequireFiniteNumber(c);
            C3X$jscomp$11.RequireFiniteNumber(d);
            C3X$jscomp$11.RequireObject(e);
            const f = map$jscomp$8.get(this).GetWorldInfo();
            f.SetMeshPoint(c, d, e) && f.SetBboxChanged()
        }
        getMeshPoint(c, d)
        {
            let e = NaN,
                f = NaN,
                g = NaN,
                h = NaN,
                k = NaN;
            const l = map$jscomp$8.get(this).GetWorldInfo();
            l.HasMesh() && (c = l.GetSourceMesh().GetMeshPointAt(c, d), null !== c && (e = c.GetX(), f = c.GetY(), g = c.GetZElevation(), h = c.GetU(), k = c.GetV()));
            return {
                x: e,
                y: f,
                zElevation: g,
                u: h,
                v: k
            }
        }
        getMeshSize()
        {
            var c = map$jscomp$8.get(this).GetWorldInfo();
            if (!c.HasMesh())
                return [0, 0];
            c = c.GetSourceMesh();
            return [c.GetHSize(), c.GetVSize()]
        }
    }
}
self.IWorldInstance = MakeIWorldInstanceClass(self.IInstance);
self.IWorldInstanceSDKBase = MakeIWorldInstanceClass(self.ISDKInstanceBase);
"use strict";
const C3X$jscomp$12 = self.C3X,
    map$jscomp$9 = new WeakMap;
self.IDOMInstance = class  extends self.IWorldInstance{
    constructor()
    {
        super();
        map$jscomp$9.set(this, self.IInstance._GetInitInst())
    }
    getElement()
    {
        return map$jscomp$9.get(this).GetSdkInstance()._GetElementInDOMMode()
    }
    focus()
    {
        map$jscomp$9.get(this).GetSdkInstance().FocusElement()
    }
    blur()
    {
        map$jscomp$9.get(this).GetSdkInstance().BlurElement()
    }
    setCssStyle(a, b)
    {
        C3X$jscomp$12.RequireString(a);
        map$jscomp$9.get(this).GetSdkInstance().SetElementCSSStyle(a, b)
    }
}
;
"use strict";
const C3$jscomp$77 = self.C3,
    C3X$jscomp$13 = self.C3X,
    map$jscomp$10 = new WeakMap,
    dispatchers$jscomp$1 = new WeakMap,
    internalApiToken$jscomp$6 = C3$jscomp$77._GetInternalAPIToken();
function GetDispatcher$jscomp$1(a) {
    let b = dispatchers$jscomp$1.get(a);
    if (b)
        return b;
    b = C3$jscomp$77.New(C3$jscomp$77.Event.Dispatcher);
    dispatchers$jscomp$1.set(a, b);
    return b
}
self.IBehaviorInstance = class {
    constructor()
    {
        const a = C3$jscomp$77.AddonManager._GetInitObject2(internalApiToken$jscomp$6);
        map$jscomp$10.set(this, a);
        const b = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            behavior: {
                value: a.GetBehavior().GetIBehavior(),
                writable: !1
            },
            behaviorType: {
                value: a.GetBehaviorType().GetIBehaviorType(),
                writable: !1
            }
        };
        Object.defineProperties(this, b);
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    static _GetInitInst()
    {
        return C3$jscomp$77.AddonManager._GetInitObject()
    }
    get instance()
    {
        return map$jscomp$10.get(this).GetObjectInstance().GetInterfaceClass()
    }
    _release()
    {
        const a =
        dispatchers$jscomp$1.get(this);
        a && (a.Release(), dispatchers$jscomp$1.delete(this));
        map$jscomp$10.delete(this)
    }
    addEventListener(a, b, c)
    {
        C3X$jscomp$13.RequireString(a);
        C3X$jscomp$13.RequireFunction(b);
        GetDispatcher$jscomp$1(this).addEventListener(a, b, c)
    }
    removeEventListener(a, b, c)
    {
        C3X$jscomp$13.RequireString(a);
        C3X$jscomp$13.RequireFunction(b);
        GetDispatcher$jscomp$1(this).removeEventListener(a, b, c)
    }
    dispatchEvent(a)
    {
        GetDispatcher$jscomp$1(this).dispatchEvent(a)
    }
}
;
"use strict";
const C3$jscomp$78 = self.C3,
    internalApiToken$jscomp$7 = C3$jscomp$78._GetInternalAPIToken();
self.IBehaviorType = class {
    constructor()
    {
        var a = C3$jscomp$78.AddonManager._GetInitObject2(internalApiToken$jscomp$7);
        a = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            },
            behavior: {
                value: a.GetBehavior().GetIBehavior(),
                writable: !1
            },
            name: {
                value: a.GetName(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
}
;
"use strict";
const C3$jscomp$79 = self.C3,
    map$jscomp$11 = new WeakMap,
    internalApiToken$jscomp$8 = C3$jscomp$79._GetInternalAPIToken();
self.IBehavior = class {
    constructor()
    {
        var a = C3$jscomp$79.AddonManager._GetInitObject2(internalApiToken$jscomp$8);
        map$jscomp$11.set(this, a);
        a = {
            runtime: {
                value: a.GetRuntime().GetIRuntime(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
    getAllInstances()
    {
        return map$jscomp$11.get(this).GetInstances().map(a => a.GetInterfaceClass())
    }
    static getByConstructor(a)
    {
        return a ? (a = C3$jscomp$79.AddonManager.GetBehaviorByConstructorFunction(a)) ? a.GetIBehavior() : null : null
    }
}
;
"use strict";
const C3$jscomp$80 = self.C3,
    C3X$jscomp$16 = self.C3X,
    map$jscomp$12 = new WeakMap,
    tempColor$jscomp$3 = C3$jscomp$80.New(C3$jscomp$80.Color);
self.IEffectInstance = class {
    constructor(a, b)
    {
        map$jscomp$12.set(this, a);
        Object.defineProperties(this, {
            index: {
                value: b,
                writable: !1
            }
        })
    }
    get name()
    {
        return map$jscomp$12.get(this).GetAllEffectTypes()[this.index].GetName()
    }
    get isActive()
    {
        return map$jscomp$12.get(this).IsEffectIndexActive(this.index)
    }
    set isActive(a)
    {
        a = !!a;
        const b = map$jscomp$12.get(this);
        b.IsEffectIndexActive(this.index) !== a && (b.SetEffectIndexActive(this.index, a), b.UpdateActiveEffects(), b.GetRuntime().UpdateRender())
    }
    setParameter(a, b)
    {
        C3X$jscomp$16.RequireFiniteNumber(a);
        a = Math.floor(+a);
        const c = map$jscomp$12.get(this),
            d = c.GetEffectParameter(this.index, a);
        if (null === d)
            throw new RangeError("invalid index");
        if (d instanceof C3$jscomp$80.Color) {
            if (!Array.isArray(b) || 3 > b.length)
                throw new TypeError("expected array with 3 elements");
            tempColor$jscomp$3.setRgb(b[0], b[1], b[2]);
            b = tempColor$jscomp$3
        } else if ("number" !== typeof b)
            throw new TypeError("expected number");
        c.SetEffectParameter(this.index, a, b) && c.IsEffectIndexActive(this.index) && c.GetRuntime().UpdateRender()
    }
    getParameter(a)
    {
        C3X$jscomp$16.RequireFiniteNumber(a);
        a = Math.floor(+a);
        a = map$jscomp$12.get(this).GetEffectParameter(this.index, a);
        if (null === a)
            throw new RangeError("invalid index");
        return a instanceof C3$jscomp$80.Color ? [a.getR(), a.getG(), a.getB()] : a
    }
}
;
"use strict";
const map$jscomp$13 = new WeakMap;
self.IAnimation = class {
    constructor(a)
    {
        map$jscomp$13.set(this, a);
        Object.defineProperties(this, {
            name: {
                value: a.GetName(),
                writable: !1
            }
        })
    }
    get speed()
    {
        return map$jscomp$13.get(this).GetSpeed()
    }
    get isLooping()
    {
        return map$jscomp$13.get(this).IsLooping()
    }
    get repeatCount()
    {
        return map$jscomp$13.get(this).GetRepeatCount()
    }
    get repeatTo()
    {
        return map$jscomp$13.get(this).GetRepeatTo()
    }
    get isPingPong()
    {
        return map$jscomp$13.get(this).IsPingPong()
    }
    get frameCount()
    {
        return map$jscomp$13.get(this).GetFrameCount()
    }
    getFrames()
    {
        return map$jscomp$13.get(this).GetFrames().map(a => a.GetIAnimationFrame())
    }
    *frames()
    {
        for (const a of map$jscomp$13.get(this).GetFrames())
            yield a.GetIAnimationFrame()
    }
}
;
"use strict";
const map$jscomp$14 = new WeakMap;
self.IImageInfo = class {
    constructor(a)
    {
        map$jscomp$14.set(this, a)
    }
    static _Unwrap(a)
    {
        return map$jscomp$14.get(a)
    }
    get width()
    {
        return map$jscomp$14.get(this).GetWidth()
    }
    get height()
    {
        return map$jscomp$14.get(this).GetHeight()
    }
    getSize()
    {
        const a = map$jscomp$14.get(this);
        return [a.GetWidth(), a.GetHeight()]
    }
    getTexture(a)
    {
        return a.getTextureForImageInfo(this)
    }
    getTexRect()
    {
        return map$jscomp$14.get(this).GetTexRect().toDOMRect()
    }
}
;
"use strict";
const C3X$jscomp$19 = self.C3X,
    map$jscomp$15 = new WeakMap;
self.IAnimationFrame = class  extends self.IImageInfo{
    constructor(a)
    {
        super(a.GetImageInfo());
        map$jscomp$15.set(this, a);
        Object.defineProperties(this, {
            duration: {
                value: a.GetDuration(),
                writable: !1
            },
            originX: {
                value: a.GetOriginX(),
                writable: !1
            },
            originY: {
                value: a.GetOriginY(),
                writable: !1
            }
        })
    }
    getOrigin()
    {
        const a = map$jscomp$15.get(this);
        return [a.GetOriginX(), a.GetOriginY()]
    }
    getImagePointCount()
    {
        return map$jscomp$15.get(this).GetImagePointCount()
    }
    getImagePointX(a)
    {
        return this.getImagePoint(a)[0]
    }
    getImagePointY(a)
    {
        return this.getImagePoint(a)[1]
    }
    getImagePoint(a)
    {
        const b = map$jscomp$15.get(this);
        if ("number" === typeof a)
            a = b.GetImagePointByIndex(Math.floor(a));
        else if ("string" === typeof a)
            a = b.GetImagePointByName(a);
        else
            throw new TypeError("expected string or number");
        return a ? [a.GetX(), a.GetY()] : this.getOrigin()
    }
    getPolyPointCount()
    {
        const a = map$jscomp$15.get(this).GetCollisionPoly();
        return a ? a.pointCount() : 0
    }
    getPolyPointX(a)
    {
        return this.getPolyPoint(a)[0]
    }
    getPolyPointY(a)
    {
        return this.getPolyPoint(a)[1]
    }
    getPolyPoint(a)
    {
        C3X$jscomp$19.RequireFiniteNumber(a);
        a = Math.floor(a);
        var b = map$jscomp$15.get(this).GetCollisionPoly();
        if (!b || 0 > a || a >= b.pointCount())
            return [0, 0];
        b = b.pointsArr();
        return [b[2 * a], b[2 * a + 1]]
    }
    get tag()
    {
        return map$jscomp$15.get(this).GetTag()
    }
}
;
"use strict";
const C3X$jscomp$20 = self.C3X,
    map$jscomp$16 = new WeakMap;
function GetTimelineState(a) {
    a = map$jscomp$16.get(a);
    if (a.IsReleased())
        throw Error("timeline/tween was released and is no longer valid");
    return a
}
self.ITimelineStateBase = class {
    constructor(a)
    {
        map$jscomp$16.set(this, a);
        a.GetRuntime()._MapScriptInterface(this, a)
    }
    pause()
    {
        GetTimelineState(this).Stop()
    }
    resume()
    {
        GetTimelineState(this).Resume()
    }
    stop()
    {
        GetTimelineState(this).Reset()
    }
    hasTags(a)
    {
        return GetTimelineState(this).HasTags(a)
    }
    set time(a)
    {
        C3X$jscomp$20.RequireFiniteNumber(a);
        GetTimelineState(this).SetTime(a)
    }
    get time()
    {
        return GetTimelineState(this).GetTime()
    }
    set totalTime(a)
    {
        C3X$jscomp$20.RequireFiniteNumber(a);
        GetTimelineState(this).SetTotalTime(a)
    }
    get totalTime()
    {
        return GetTimelineState(this).GetTotalTime()
    }
    set isLooping(a)
    {
        GetTimelineState(this).SetLoop(!!a)
    }
    get isLooping()
    {
        return GetTimelineState(this).GetLoop()
    }
    set isPingPong(a)
    {
        GetTimelineState(this).SetPingPong(!!a)
    }
    get isPingPong()
    {
        return GetTimelineState(this).GetPingPong()
    }
    set playbackRate(a)
    {
        C3X$jscomp$20.RequireFiniteNumber(a);
        GetTimelineState(this).SetPlaybackRate(a)
    }
    get playbackRate()
    {
        return GetTimelineState(this).GetPlaybackRate()
    }
    get progress()
    {
        const a = GetTimelineState(this);
        return a.GetTime() / a.GetTotalTime()
    }
    get tags()
    {
        return GetTimelineState(this).GetTags()
    }
    get finished()
    {
        return GetTimelineState(this).GetPlayPromise()
    }
    get isPlaying()
    {
        return GetTimelineState(this).IsPlaying()
    }
    get isPaused()
    {
        return GetTimelineState(this).IsPaused()
    }
    get isReleased()
    {
        return map$jscomp$16.get(this).IsReleased()
    }
}
;
"use strict";
const map$jscomp$17 = new WeakMap;
self.ITimelineState = class  extends self.ITimelineStateBase{
    constructor(a)
    {
        super(a);
        map$jscomp$17.set(this, a);
        a = {
            name: {
                value: a.GetName(),
                writable: !1
            }
        };
        Object.defineProperties(this, a)
    }
}
;
"use strict";
const C3X$jscomp$22 = self.C3X,
    map$jscomp$18 = new WeakMap,
    behInstMap = new WeakMap;
let easeToIndexFunc$jscomp$1 = null;
function GetTweenState(a) {
    a = map$jscomp$18.get(a);
    if (a.IsReleased())
        throw Error("tween was released and is no longer valid");
    return a
}
self.ITweenState = class  extends self.ITimelineStateBase{
    constructor(a, b, c)
    {
        super(a);
        easeToIndexFunc$jscomp$1 || (easeToIndexFunc$jscomp$1 = c.easeToIndexFunc);
        map$jscomp$18.set(this, a);
        b && behInstMap.set(this, b)
    }
    stop()
    {
        const a = GetTweenState(this);
        behInstMap.get(this).ReleaseTween(a)
    }
    setEase(a)
    {
        C3X$jscomp$22.RequireString(a);
        a = self.Ease.GetEaseFromIndex(easeToIndexFunc$jscomp$1(a));
        GetTweenState(this).SetEase(a)
    }
    get instance()
    {
        const a = GetTweenState(this).GetInstance();
        return a ? a.GetInterfaceClass() : null
    }
    get isDestroyOnComplete()
    {
        return GetTweenState(this).GetDestroyInstanceOnComplete()
    }
    set isDestroyOnComplete(a)
    {
        GetTweenState(this).SetDestroyInstanceOnComplete(!!a)
    }
    get value()
    {
        const a =
        GetTweenState(this);
        if ("value" !== a.GetId())
            throw Error("not a value tween");
        return a.GetPropertyTrack("value").GetSourceAdapterValue()
    }
}
;
"use strict";
self.ISDKPluginBase = class  extends self.IPlugin{
    constructor()
    {
        super()
    }
}
;
"use strict";
const C3$jscomp$88 = self.C3,
    C3X$jscomp$24 = self.C3X,
    map$jscomp$19 = new WeakMap,
    internalApiToken$jscomp$9 = C3$jscomp$88._GetInternalAPIToken();
self.ISDKDOMPluginBase = class  extends self.ISDKPluginBase{
    constructor(a)
    {
        super();
        map$jscomp$19.set(this, C3$jscomp$88.AddonManager._GetInitObject2(internalApiToken$jscomp$9));
        if (!a?.domComponentId)
            throw Error("no DOM component ID specified");
        this._p_domComponentId = a.domComponentId;
        this._p_nextElementId = 0;
        this._p_instMap = new Map;
        this._addElementMessageHandler("elem-focused", b => b._onElemFocused());
        this._addElementMessageHandler("elem-blurred", b => {
            b && b._onElemBlurred()
        })
    }
    _addElement(a)
    {
        const b = this._p_nextElementId++;
        this._p_instMap.set(b, a);
        return b
    }
    _removeElement(a)
    {
        this._p_instMap.delete(a)
    }
    _addElementMessageHandler(a, b)
    {
        map$jscomp$19.get(this).GetRuntime().AddDOMComponentMessageHandler(this._p_domComponentId, a, c => {
            const d = this._p_instMap.get(c.elementId);
            b(d, c)
        })
    }
    _addElementMessageHandlers(a)
    {
        C3X$jscomp$24.RequireArray(a);
        for (const [b, c] of a)
            this._addElementMessageHandlers(b, c)
    }
}
;
"use strict";
const C3$jscomp$89 = self.C3,
    map$jscomp$20 = new WeakMap,
    internalApiToken$jscomp$10 = C3$jscomp$89._GetInternalAPIToken();
self.ISDKObjectTypeBase = class  extends self.IObjectClass{
    constructor()
    {
        super();
        const a = C3$jscomp$89.AddonManager._GetInitObject2(internalApiToken$jscomp$10);
        map$jscomp$20.set(this, a)
    }
    _onCreate() {}
    getImageInfo()
    {
        return map$jscomp$20.get(this).GetImageInfo().GetIImageInfo()
    }
    _loadTextures(a) {}
    _releaseTextures(a) {}
    _onDynamicTextureLoadComplete() {}
    _preloadTexturesWithInstances(a) {}
}
;
"use strict";
const C3$jscomp$90 = self.C3,
    map$jscomp$21 = new WeakMap,
    internalApiToken$jscomp$11 = C3$jscomp$90._GetInternalAPIToken();
self.ISDKWorldInstanceBase = class  extends self.IWorldInstanceSDKBase{
    constructor(a)
    {
        super(a);
        map$jscomp$21.set(this, C3$jscomp$90.AddonManager._GetInitObject2(internalApiToken$jscomp$11));
        this._p_renderercontextrestored_handler = this._p_renderercontextlost_handler = null
    }
    _release()
    {
        super._release();
        if (this._p_renderercontextlost_handler) {
            const a = map$jscomp$21.get(this).GetRuntime().Dispatcher();
            a.removeEventListener("renderercontextlost", this._p_renderercontextlost_handler);
            a.removeEventListener("renderercontextrestored",
            this._p_renderercontextrestored_handler);
            this._p_renderercontextrestored_handler = this._p_renderercontextlost_handler = null
        }
        map$jscomp$21.delete(this)
    }
    _handleRendererContextLoss()
    {
        if (!this._p_renderercontextlost_handler) {
            this._p_renderercontextlost_handler = () => this._onRendererContextLost();
            this._p_renderercontextrestored_handler = () => this._onRendererContextRestored();
            var a = map$jscomp$21.get(this).GetRuntime().Dispatcher();
            a.addEventListener("renderercontextlost", this._p_renderercontextlost_handler);
            a.addEventListener("renderercontextrestored", this._p_renderercontextrestored_handler)
        }
    }
    _onRendererContextLost() {}
    _onRendererContextRestored() {}
    _draw(a) {}
}
;
"use strict";
const C3$jscomp$91 = self.C3,
    tempRect$jscomp$3 = C3$jscomp$91.New(C3$jscomp$91.Rect),
    map$jscomp$22 = new WeakMap,
    internalApiToken$jscomp$12 = C3$jscomp$91._GetInternalAPIToken();
self.ISDKDOMInstanceBase = class  extends self.ISDKWorldInstanceBase{
    constructor(a)
    {
        if (!a?.domComponentId)
            throw Error("no DOM component ID specified");
        super(a);
        a = C3$jscomp$91.AddonManager._GetInitObject2(internalApiToken$jscomp$12);
        map$jscomp$22.set(this, a);
        this._p_elementId = this.plugin._addElement(this);
        this._p_isElementShowing = !0;
        this._p_autoFontSize = this._p_elemHasFocus = !1;
        this._p_autoFontSizeOffset = -.2;
        this._p_lastRect = C3$jscomp$91.New(C3$jscomp$91.Rect, 0, 0, -1, -1);
        a = a.GetRuntime().GetCanvasManager();
        this._p_lastWindowWidth = a.GetLastWidth();
        this._p_lastWindowHeight = a.GetLastHeight();
        this._p_lastHTMLZIndex = this._p_lastHTMLIndex = -1;
        this._p_isPendingUpdateState = !1;
        this._setTicking(!0)
    }
    _release()
    {
        super._release();
        this.plugin._removeElement(this._p_elementId);
        this._postToDOMElement("destroy");
        this._p_elementId = -1;
        map$jscomp$22.delete(this)
    }
    _getElementInDOMMode()
    {
        if (map$jscomp$22.get(this).GetRuntime().IsInWorker())
            throw Error("not valid in worker mode");
        return this._postToDOMElementMaybeSync("get-element")
    }
    _postToDOMElement(a,
    b)
    {
        b || (b = {});
        b.elementId = this._p_elementId;
        this._postToDOM(a, b)
    }
    _postToDOMElementMaybeSync(a, b)
    {
        b || (b = {});
        b.elementId = this._p_elementId;
        return this._postToDOMMaybeSync(a, b)
    }
    _postToDOMElementAsync(a, b)
    {
        b || (b = {});
        b.elementId = this._p_elementId;
        return this._postToDOMAsync(a, b)
    }
    _createElement(a)
    {
        a || (a = {});
        const b = map$jscomp$22.get(this).GetWorldInfo();
        a.elementId = this._p_elementId;
        a.isVisible = b.IsVisible();
        a.htmlIndex = b.GetLayer().GetHTMLIndex();
        a.htmlZIndex = b.GetHTMLZIndex();
        Object.assign(a, this._getElementState());
        this._p_isElementShowing = !!a.isVisible;
        this._postToDOMMaybeSync("create", a);
        this._updatePosition(!0)
    }
    setElementVisible(a)
    {
        a = !!a;
        this._p_isElementShowing !== a && (this._p_isElementShowing = a, this._postToDOMElement("set-visible", {
            isVisible: a
        }))
    }
    _tick()
    {
        this._updatePosition(!1)
    }
    _shouldPreserveElement()
    {
        const a = map$jscomp$22.get(this).GetRuntime().GetCanvasManager().GetFullscreenMode();
        return "Android" === C3$jscomp$91.Platform.OS && ("scale-inner" === a || "scale-outer" === a || "crop" === a)
    }
    _updatePosition(a)
    {
        var b =
        map$jscomp$22.get(this);
        if (!b.IsDestroyed()) {
            var c = b.GetWorldInfo(),
                d = c.GetLayer(),
                e = c.GetBoundingBox(),
                [f, g] = d.LayerToCanvasCss(e.getLeft(), e.getTop()),
                [h, k] = d.LayerToCanvasCss(e.getRight(), e.getBottom());
            e = b.GetRuntime().GetCanvasManager();
            b = e.GetCssWidth();
            var l = e.GetCssHeight();
            c.IsVisible() && d.IsVisible() ? !this._shouldPreserveElement() && (0 >= h || 0 >= k || f >= b || g >= l) ? this.setElementVisible(!1) : (tempRect$jscomp$3.set(f, g, h, k), b = e.GetLastWidth(), l = e.GetLastHeight(), e = d.GetHTMLIndex(), c = c.GetHTMLZIndex(),
            !a && tempRect$jscomp$3.equals(this._p_lastRect) && this._p_lastWindowWidth === b && this._p_lastWindowHeight === l && this._p_lastHTMLIndex === e && this._p_lastHTMLZIndex === c ? this.setElementVisible(!0) : (this._p_lastRect.copy(tempRect$jscomp$3), this._p_lastWindowWidth = b, this._p_lastWindowHeight = l, this._p_lastHTMLIndex = e, this._p_lastHTMLZIndex = c, this.setElementVisible(!0), a = null, this._p_autoFontSize && (a = d.GetDisplayScale() + this._p_autoFontSizeOffset), this._postToDOMElement("update-position", {
                left: Math.round(this._p_lastRect.getLeft()),
                top: Math.round(this._p_lastRect.getTop()),
                width: Math.round(this._p_lastRect.width()),
                height: Math.round(this._p_lastRect.height()),
                htmlIndex: e,
                htmlZIndex: c,
                fontSize: a
            }))) : this.setElementVisible(!1)
        }
    }
    focusElement()
    {
        this._postToDOMElementMaybeSync("focus", {
            focus: !0
        })
    }
    blurElement()
    {
        this._postToDOMElementMaybeSync("focus", {
            focus: !1
        })
    }
    _onElemFocused()
    {
        this._p_elemHasFocus = !0
    }
    _onElemBlurred()
    {
        this._p_elemHasFocus = !1
    }
    isElementFocused()
    {
        return this._p_elemHasFocus
    }
    setElementCSSStyle(a, b)
    {
        this.postToDOMElement("set-css-style",
        {
            prop: C3$jscomp$91.CSSToCamelCase(a),
            val: b
        })
    }
    setElementAttribute(a, b)
    {
        this.postToDOMElement("set-attribute", {
            name: a,
            val: b
        })
    }
    removeElementAttribute(a)
    {
        this.postToDOMElement("remove-attribute", {
            name: a
        })
    }
    _updateElementState()
    {
        this._p_isPendingUpdateState || (this._p_isPendingUpdateState = !0, Promise.resolve().then(() => {
            this._p_isPendingUpdateState = !1;
            this._postToDOMElement("update-state", this._getElementState())
        }))
    }
    _getElementState() {}
    _getElementId()
    {
        return this._p_elementId
    }
}
;
"use strict";
self.ISDKBehaviorBase = class  extends self.IBehavior{
    constructor()
    {
        super()
    }
}
;
"use strict";
self.ISDKBehaviorTypeBase = class  extends globalThis.IBehaviorType{
    constructor()
    {
        super()
    }
    _onCreate() {}
}
;
"use strict";
const C3$jscomp$94 = self.C3,
    map$jscomp$23 = new WeakMap,
    internalApiToken$jscomp$13 = C3$jscomp$94._GetInternalAPIToken();
self.ISDKBehaviorInstanceBase = class  extends self.IBehaviorInstance{
    constructor()
    {
        super();
        map$jscomp$23.set(this, C3$jscomp$94.AddonManager._GetInitObject2(internalApiToken$jscomp$13));
        this._p_isPostTicking = this._p_isTicking2 = this._p_isTicking = !1
    }
    _release()
    {
        super._release();
        this._setTicking(!1);
        this._setTicking2(!1);
        this._setPostTicking(!1);
        map$jscomp$23.delete(this)
    }
    _getInitProperties()
    {
        return C3$jscomp$94.AddonManager._GetInitProperties()
    }
    _postCreate() {}
    _trigger(a)
    {
        const b = map$jscomp$23.get(this);
        b.GetRuntime().Trigger(a, b.GetObjectInstance(), b.GetBehaviorType())
    }
    _triggerAsync(a)
    {
        const b = map$jscomp$23.get(this);
        return b.GetRuntime().TriggerAsync(a, b.GetObjectInstance(), b.GetBehaviorType())
    }
    _setTicking(a)
    {
        a = !!a;
        if (this._p_isTicking !== a) {
            this._p_isTicking = a;
            var b = map$jscomp$23.get(this).GetRuntime();
            a ? b._AddBehInstToTick(this) : b._RemoveBehInstToTick(this)
        }
    }
    _isTicking()
    {
        return this._p_isTicking
    }
    _tick() {}
    _setTicking2(a)
    {
        a = !!a;
        if (this._p_isTicking2 !== a) {
            this._p_isTicking2 = a;
            var b = map$jscomp$23.get(this).GetRuntime();
            a ? b._AddBehInstToTick2(this) : b._RemoveBehInstToTick2(this)
        }
    }
    _isTicking2()
    {
        return this._p_isTicking2
    }
    _tick2() {}
    _setPostTicking(a)
    {
        a = !!a;
        if (this._p_isPostTicking !== a) {
            this._p_isPostTicking = a;
            var b = map$jscomp$23.get(this).GetRuntime();
            a ? b._AddBehInstToPostTick(this) : b._RemoveBehInstToPostTick(this)
        }
    }
    _isPostTicking()
    {
        return this._p_isPostTicking
    }
    _postTick() {}
    _getDebuggerProperties()
    {
        return []
    }
    _saveToJson()
    {
        return null
    }
    _loadFromJson(a) {}
}
;
"use strict";
const C3X$jscomp$31 = self.C3X;
let runtime$jscomp$27 = null;
self.ISDKUtils = class {
    constructor(a)
    {
        runtime$jscomp$27 = a
    }
    addLoadPromise(a)
    {
        runtime$jscomp$27.AddLoadPromise(a)
    }
    sendWrapperExtensionMessage(a, b, c)
    {
        C3X$jscomp$31.RequireString(a);
        C3X$jscomp$31.RequireString(b);
        C3X$jscomp$31.RequireOptionalArray(c);
        runtime$jscomp$27.SendWrapperExtensionMessage(a, b, c)
    }
    sendWrapperExtensionMessageAsync(a, b, c)
    {
        C3X$jscomp$31.RequireString(a);
        C3X$jscomp$31.RequireString(b);
        C3X$jscomp$31.RequireOptionalArray(c);
        return runtime$jscomp$27.SendWrapperExtensionMessageAsync(a, b, c)
    }
    createLoopingConditionContext(a)
    {
        C3X$jscomp$31.RequireOptionalString(a);
        return new self.ILoopingConditionContext(runtime$jscomp$27, a)
    }
    set isAutoSuspendEnabled(a)
    {
        runtime$jscomp$27._SetAutoSuspendEnabled(!!a)
    }
    get isAutoSuspendEnabled()
    {
        return runtime$jscomp$27._IsAutoSuspendEnabled()
    }
    setSuspended(a)
    {
        runtime$jscomp$27.SetSuspended(!!a)
    }
}
;
"use strict";
const map$jscomp$24 = new WeakMap;
self.ILoopingConditionContext = class {
    constructor(a, b)
    {
        var c = a.GetEventSheetManager();
        const d = a.GetCurrentEvent(),
            e = d.GetSolModifiers();
        var f = a.GetEventStack();
        const g = f.GetCurrentStackFrame();
        f = f.Push(d);
        c = c.GetLoopStack().Push();
        b && c.SetName(b);
        a.SetDebuggingEnabled(!1);
        map$jscomp$24.set(this, {
            runtime: a,
            currentEvent: d,
            solModifiers: e,
            oldFrame: g,
            newFrame: f,
            loop: c
        })
    }
    retrigger()
    {
        const {runtime: a, currentEvent: b, solModifiers: c, oldFrame: d, newFrame: e, loop: f} = map$jscomp$24.get(this),
            g = a.GetEventSheetManager();
        g.PushCopySol(c);
        b.Retrigger(d, e);
        g.PopSol(c);
        f.SetIndex(f.GetIndex() + 1)
    }
    get isStopped()
    {
        const {loop: a} = map$jscomp$24.get(this);
        return a.IsStopped()
    }
    release()
    {
        const {runtime: a} = map$jscomp$24.get(this),
            b = a.GetEventStack(),
            c = a.GetEventSheetManager().GetLoopStack();
        a.SetDebuggingEnabled(!0);
        c.Pop();
        b.Pop();
        map$jscomp$24.delete(this)
    }
}
;
"use strict";
const C3$jscomp$97 = self.C3,
    C3X$jscomp$33 = self.C3X;
let renderer$jscomp$57 = null,
    runtime$jscomp$31 = null;
self.IRenderer = class {
    constructor(a, b)
    {
        runtime$jscomp$31 = a;
        renderer$jscomp$57 = b
    }
    setAlphaBlendMode()
    {
        renderer$jscomp$57.SetAlphaBlend()
    }
    setBlendMode(a)
    {
        renderer$jscomp$57.SetNamedBlendMode(a)
    }
    setColorFillMode()
    {
        renderer$jscomp$57.SetColorFillMode()
    }
    setTextureFillMode()
    {
        renderer$jscomp$57.SetTextureFillMode()
    }
    setSmoothLineFillMode()
    {
        renderer$jscomp$57.SetSmoothLineFillMode()
    }
    setColor(a)
    {
        renderer$jscomp$57.SetColorRgba(a[0], a[1], a[2], a[3])
    }
    setColorRgba(a, b, c, d)
    {
        renderer$jscomp$57.SetColorRgba(a, b, c, d)
    }
    resetColor()
    {
        renderer$jscomp$57.ResetColor()
    }
    setOpacity(a)
    {
        renderer$jscomp$57.SetOpacity(a)
    }
    setCurrentZ(a)
    {
        renderer$jscomp$57.SetCurrentZ(a)
    }
    getCurrentZ()
    {
        renderer$jscomp$57.GetCurrentZ()
    }
    rect(a)
    {
        renderer$jscomp$57.Rect2(a.left,
        a.top, a.right, a.bottom)
    }
    rect2(a, b, c, d)
    {
        renderer$jscomp$57.Rect2(a, b, c, d)
    }
    quad(a)
    {
        renderer$jscomp$57.Quad(C3$jscomp$97.Quad.fromDOMQuad(a))
    }
    quad2(a, b, c, d, e, f, g, h)
    {
        renderer$jscomp$57.Quad2(a, b, c, d, e, f, g, h)
    }
    quad3(a, b)
    {
        renderer$jscomp$57.Quad3(C3$jscomp$97.Quad.fromDOMQuad(a), C3$jscomp$97.Rect.fromDOMRect(b))
    }
    quad4(a, b)
    {
        renderer$jscomp$57.Quad4(C3$jscomp$97.Quad.fromDOMQuad(a), C3$jscomp$97.Quad.fromDOMQuad(b))
    }
    quad3D(a, b, c, d, e, f, g, h, k, l, m, n, p)
    {
        renderer$jscomp$57.Quad3D(a, b, c, d, e, f, g, h, k, l, m, n, C3$jscomp$97.Rect.fromDOMRect(p))
    }
    quad3D2(a,
    b, c, d, e, f, g, h, k, l, m, n, p)
    {
        renderer$jscomp$57.Quad3D2(a, b, c, d, e, f, g, h, k, l, m, n, C3$jscomp$97.Quad.fromDOMQuad(p))
    }
    drawMesh(a, b, c)
    {
        renderer$jscomp$57.DrawMesh(a, b, c)
    }
    convexPoly(a)
    {
        renderer$jscomp$57.ConvexPoly(a)
    }
    line(a, b, c, d)
    {
        renderer$jscomp$57.Line(a, b, c, d)
    }
    texturedLine(a, b, c, d, e, f)
    {
        renderer$jscomp$57.TexturedLine(a, b, c, d, e, f)
    }
    lineRect(a, b, c, d)
    {
        renderer$jscomp$57.LineRect(a, b, c, d)
    }
    lineRect2(a)
    {
        renderer$jscomp$57.LineRect2(C3$jscomp$97.Rect.fromDOMRect(a))
    }
    lineQuad(a)
    {
        renderer$jscomp$57.LineQuad(C3$jscomp$97.Quad.fromDOMQuad(a))
    }
    pushLineWidth(a)
    {
        renderer$jscomp$57.PushLineWidth(a)
    }
    popLineWidth()
    {
        renderer$jscomp$57.PopLineWidth()
    }
    pushLineCap(a)
    {
        renderer$jscomp$57.PushLineCap(a)
    }
    popLineCap()
    {
        renderer$jscomp$57.PopLineCap()
    }
    setTexture(a)
    {
        C3X$jscomp$33.RequireOptionalInstanceOf(a,
        self.ITexture);
        a = a ? runtime$jscomp$31._UnwrapScriptInterface(a) : null;
        renderer$jscomp$57.SetTexture(a)
    }
    loadTextureForImageInfo(a, b)
    {
        a = self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        return a.LoadStaticTexture(renderer$jscomp$57, {
            wrapX: b?.wrapX ?? "clamp-to-edge",
            wrapY: b?.wrapY ?? "clamp-to-edge",
            sampling: b?.sampling ?? "trilinear",
            mipMap: b?.mipMap ?? !0
        })
    }
    releaseTextureForImageInfo(a)
    {
        a = self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        a.ReleaseTexture()
    }
    getTextureForImageInfo(a)
    {
        a =
        self.IImageInfo._Unwrap(a);
        if (!a)
            throw Error("invalid IImageInfo");
        a = a.GetTexture();
        return self.ITexture.GetInterface(runtime$jscomp$31, a)
    }
    createDynamicTexture(a, b, c)
    {
        C3X$jscomp$33.RequireFiniteNumber(a);
        C3X$jscomp$33.RequireFiniteNumber(b);
        a = renderer$jscomp$57.CreateDynamicTexture(a, b, {
            wrapX: c?.wrapX ?? "clamp-to-edge",
            wrapY: c?.wrapY ?? "clamp-to-edge",
            sampling: c?.sampling ?? "trilinear",
            mipMap: c?.mipMap ?? !0
        });
        return self.ITexture.GetInterface(runtime$jscomp$31, a)
    }
    updateTexture(a, b, c)
    {
        C3X$jscomp$33.RequireInstanceOf(b,
        self.ITexture);
        b = runtime$jscomp$31._UnwrapScriptInterface(b);
        renderer$jscomp$57.UpdateTexture(a, b, {
            premultiplyAlpha: c?.premultiplyAlpha ?? !0
        })
    }
    deleteTexture(a)
    {
        C3X$jscomp$33.RequireInstanceOf(a, self.ITexture);
        a = runtime$jscomp$31._UnwrapScriptInterface(a);
        renderer$jscomp$57.DeleteTexture(a)
    }
    createRendererText()
    {
        const a = renderer$jscomp$57.CreateRendererText();
        return new self.IRendererText(runtime$jscomp$31, a)
    }
    setDeviceTransform()
    {
        runtime$jscomp$31.GetCanvasManager().SetDeviceTransform(renderer$jscomp$57)
    }
    setLayerTransform(a)
    {
        C3X$jscomp$33.RequireInstanceOf(a,
        globalThis.ILayer);
        runtime$jscomp$31._UnwrapScriptInterface(a)._SetTransform(renderer$jscomp$57)
    }
}
;
"use strict";
const map$jscomp$25 = new WeakMap,
    reverseMap = new WeakMap;
self.ITexture = class {
    constructor(a, b)
    {
        map$jscomp$25.set(this, {
            runtime: a,
            texture: b
        });
        reverseMap.set(b, this);
        a._MapScriptInterface(this, b);
        Object.defineProperties(this, {
            width: {
                value: b.GetWidth(),
                writable: !1
            },
            height: {
                value: b.GetHeight(),
                writable: !1
            }
        })
    }
    static GetInterface(a, b)
    {
        if (!b)
            return null;
        const c = reverseMap.get(b);
        return c ? c : new self.ITexture(a, b)
    }
}
;
"use strict";
const C3X$jscomp$35 = self.C3X,
    map$jscomp$26 = new WeakMap;
function getActual(a) {
    return map$jscomp$26.get(a).rendererText
}
self.IRendererText = class {
    constructor(a, b)
    {
        map$jscomp$26.set(this, {
            runtime: a,
            rendererText: b
        });
        a._MapScriptInterface(this, b)
    }
    release()
    {
        getActual(this).Release()
    }
    set fontFace(a)
    {
        C3X$jscomp$35.RequireString(a);
        getActual(this).SetFontName(a)
    }
    get fontFace()
    {
        return getActual(this).GetFontName()
    }
    set sizePt(a)
    {
        C3X$jscomp$35.RequireFiniteNumber(a);
        getActual(this).SetFontSize(a)
    }
    get sizePt()
    {
        return getActual(this).GetFontSize()
    }
    set lineHeight(a)
    {
        C3X$jscomp$35.RequireFiniteNumber(a);
        getActual(this).SetLineHeight(a)
    }
    get lineHeight()
    {
        return getActual(this).GetLineHeight()
    }
    set isBold(a)
    {
        getActual(this).SetBold(a)
    }
    get isBold()
    {
        return getActual(this).IsBold()
    }
    set isItalic(a)
    {
        getActual(this).SetItalic(a)
    }
    get isItalic()
    {
        return getActual(this).IsItalic()
    }
    setColor(a)
    {
        C3X$jscomp$35.RequireArray(a);
        this.setColorRgb(a[0], a[1], a[2])
    }
    setColorRgb(a, b, c)
    {
        getActual(this).SetColorRgb(a, b, c)
    }
    setCssColor(a)
    {
        C3X$jscomp$35.RequireString(a);
        getActual(this).SetColor(a)
    }
    set horizontalAlign(a)
    {
        getActual(this).SetHorizontalAlignment(a)
    }
    get horizontalAlign()
    {
        return getActual(this).GetHorizontalAlignment()
    }
    set verticalAlign(a)
    {
        getActual(this).SetVerticalAlignment(a)
    }
    get verticalAlign()
    {
        return getActual(this).GetVerticalAlignment()
    }
    set wordWrapMode(a)
    {
        getActual(this).SetWordWrapMode(a)
    }
    get wordWrapMode()
    {
        return getActual(this).GetWordWrapMode()
    }
    set textDirection(a)
    {
        getActual(this).SetTextDirection(a)
    }
    get textDirection()
    {
        return getActual(this).GetTextDirection()
    }
    set text(a)
    {
        C3X$jscomp$35.RequireString(a);
        getActual(this).SetText(a)
    }
    get text()
    {
        return getActual(this).GetText()
    }
    setSize(a, b, c)
    {
        C3X$jscomp$35.RequireFiniteNumber(a);
        C3X$jscomp$35.RequireFiniteNumber(b);
        C3X$jscomp$35.RequireFiniteNumber(c);
        getActual(this).SetSize(a, b, c)
    }
    getTexture()
    {
        const {runtime: a, rendererText: b} = map$jscomp$26.get(this),
            c = b.GetTexture();
        return self.ITexture.GetInterface(a, c)
    }
    getTexRect()
    {
        return getActual(this).GetTexRect().toDOMRect()
    }
    setTextureUpdateCallback(a)
    {
        C3X$jscomp$35.RequireFunction(a);
        getActual(this).ontextureupdate =
        a
    }
    releaseTexture()
    {
        getActual(this).ReleaseTexture()
    }
    get textWidth()
    {
        return getActual(this).GetTextWidth()
    }
    get textHeight()
    {
        return getActual(this).GetTextHeight()
    }
}
;
"use strict";
const C3$jscomp$100 = self.C3,
    VALID_LOAD_POLICIES = new Set(["local", "remote"]),
    EXT_TO_TYPE = new Map([["mp4", "video/mp4"], ["webm", "video/webm"], ["m4a", "audio/mp4"], ["mp3", "audio/mpeg"], ["js", "application/javascript"], ["wasm", "application/wasm"], ["svg", "image/svg+xml"], ["html", "text/html"]]);
function GetTypeFromFileExtension(a) {
    if (!a)
        return "";
    a = a.split(".");
    if (2 > a.length)
        return "";
    a = a.at(-1).toLowerCase();
    return EXT_TO_TYPE.get(a) || ""
}
function AddScript(a) {
    return new Promise((b, c) => {
        const d = document.createElement("script");
        d.onload = b;
        d.onerror = c;
        d.async = !1;
        d.type = "module";
        d.src = a;
        document.head.appendChild(d)
    })
}
C3$jscomp$100.AssetManager = class  extends C3$jscomp$100.DefendedBase{
    constructor(a, b)
    {
        super();
        const c = b.exportType;
        this._runtime = a;
        this._fileStructure = "folders";
        this._cordovaBlobUrlCache = new Map;
        this._isCordova = "cordova" === c;
        this._isiOSCordova = !!b.isiOSCordova;
        this._isFileProtocol = !!b.isFileProtocol;
        this._swClientId = b.swClientId;
        this._supportedAudioFormats = b.supportedAudioFormats || {};
        this._audioFiles = new Map;
        this._preloadSounds = !1;
        this._scriptSubfolder = b.scriptFolder;
        this._iconsSubfolder = this._fontsSubfolder =
        this._mediaSubfolder = "";
        this._fileMap = b.fileMap || new Map;
        this._fileMapBlobUrls = new Map;
        this._defaultLoadPolicy = "html5" === c || "scirra-arcade" === c || "instant-games" === c ? "remote" : "local";
        this._assetsByUrl = new Map;
        this._webFonts = [];
        this._loadPromises = [];
        this._hasFinishedInitialLoad = !1;
        this._lastLoadProgress = this._assetSizeLoaded = this._totalAssetSizeToLoad = 0;
        this._hasHadErrorLoading = !1;
        this._loadingRateLimiter = C3$jscomp$100.New(C3$jscomp$100.RateLimiter, () => this._FireLoadingProgressEvent(), 50);
        this._localPromiseThrottle =
        C3$jscomp$100.New(C3$jscomp$100.PromiseThrottle, Math.max(C3$jscomp$100.hardwareConcurrency, 8));
        this._remotePromiseThrottle = C3$jscomp$100.New(C3$jscomp$100.PromiseThrottle, 20);
        this._iAssetManager = new self.IAssetManager(this)
    }
    Release()
    {
        for (const a of this._assetsByUrl.values())
            a.Release();
        this._assetsByUrl.clear();
        C3$jscomp$100.clearArray(this._loadPromises);
        this._runtime = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    _SetFileStructure(a)
    {
        this._fileStructure = a
    }
    GetFileStructure()
    {
        return this._fileStructure
    }
    GetScriptSubfolder()
    {
        return this._scriptSubfolder
    }
    _SetMediaSubfolder(a)
    {
        this._mediaSubfolder =
        a
    }
    GetMediaSubfolder()
    {
        return this._mediaSubfolder
    }
    _SetFontsSubfolder(a)
    {
        this._fontsSubfolder = a
    }
    GetFontsSubfolder()
    {
        return this._fontsSubfolder
    }
    _SetIconsSubfolder(a)
    {
        this._iconsSubfolder = a
    }
    GetIconsSubfolder()
    {
        return this._iconsSubfolder
    }
    IsFileProtocol()
    {
        return this._isFileProtocol
    }
    FetchBlob(a, b)
    {
        b = b || this._defaultLoadPolicy;
        return C3$jscomp$100.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsBlob(a) : "playable-ad-single-file" ===
        this._runtime.GetExportType() ? self.c3_runtimeInterface._PlayableAdFetchBlob(a) : "local" === b ? this._localPromiseThrottle.Add(() => C3$jscomp$100.FetchBlob(a)) : this._remotePromiseThrottle.Add(() => C3$jscomp$100.FetchBlob(a))) : C3$jscomp$100.FetchBlob(a)
    }
    FetchArrayBuffer(a)
    {
        return C3$jscomp$100.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsArrayBuffer(a) : "playable-ad-single-file" === this._runtime.GetExportType() ? C3$jscomp$100.BlobToArrayBuffer(self.c3_runtimeInterface._PlayableAdFetchBlob(a)) :
        "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C3$jscomp$100.FetchArrayBuffer(a)) : this._remotePromiseThrottle.Add(() => C3$jscomp$100.FetchArrayBuffer(a))) : C3$jscomp$100.FetchArrayBuffer(a)
    }
    FetchText(a)
    {
        return C3$jscomp$100.IsRelativeURL(a) ? ("flat" === this._fileStructure && (a = a.toLowerCase()), this._isCordova && this._isFileProtocol ? this.CordovaFetchLocalFileAsText(a) : "playable-ad-single-file" === this._runtime.GetExportType() ? C3$jscomp$100.BlobToString(self.c3_runtimeInterface._PlayableAdFetchBlob(a)) :
        "local" === this._defaultLoadPolicy ? this._localPromiseThrottle.Add(() => C3$jscomp$100.FetchText(a)) : this._remotePromiseThrottle.Add(() => C3$jscomp$100.FetchText(a))) : C3$jscomp$100.FetchText(a)
    }
    async FetchJson(a)
    {
        a = await this.FetchText(a);
        return JSON.parse(a)
    }
    _CordovaFetchLocalFileAs(a, b)
    {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return this._runtime.PostComponentMessageToDOMAsync("runtime", "cordova-fetch-local-file", {
            filename: a,
            as: b
        })
    }
    CordovaFetchLocalFileAsText(a)
    {
        return this._CordovaFetchLocalFileAs(a,
        "text")
    }
    async CordovaFetchLocalFileAsBlob(a)
    {
        const b = await this._CordovaFetchLocalFileAs(a, "buffer");
        a = GetTypeFromFileExtension(a);
        return new Blob([b], {
            type: a
        })
    }
    async CordovaFetchLocalFileAsBlobURL(a)
    {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        var b = this._cordovaBlobUrlCache.get(a);
        if (b)
            return b;
        b = await this.CordovaFetchLocalFileAsBlob(a);
        b = URL.createObjectURL(b);
        this._cordovaBlobUrlCache.set(a, b);
        return b
    }
    CordovaFetchLocalFileAsArrayBuffer(a)
    {
        return this._CordovaFetchLocalFileAs(a, "buffer")
    }
    GetMediaFileUrl(a)
    {
        "flat" ===
        this._fileStructure && (a = a.toLowerCase());
        a = this._mediaSubfolder + a;
        "Gecko" === C3$jscomp$100.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() && (a = this._GetLocalBlobURLFromFileMap(a));
        return a
    }
    GetProjectFileUrl(a)
    {
        if (C3$jscomp$100.IsAbsoluteURL(a))
            return Promise.resolve(a);
        if (this._isCordova && this._isFileProtocol)
            return this.CordovaFetchLocalFileAsBlobURL(a);
        if ("playable-ad-single-file" === this._runtime.GetExportType())
            return URL.createObjectURL(self.c3_runtimeInterface._PlayableAdFetchBlob(a));
        "flat" === this._fileStructure && (a = a.toLowerCase());
        return Promise.resolve(a)
    }
    GetProjectFileIframeUrl(a)
    {
        if (!C3$jscomp$100.IsAbsoluteURL(a) && "preview" === this._runtime.GetExportType() && this._swClientId && a)
            try {
                const b = new URL(a, location.href);
                b.searchParams.set("__c3_client_id", this._swClientId);
                return b.toString()
            } catch (b) {
                return console.warn("Invalid iframe URL: " + a), a
            }
        else
            return a
    }
    LoadProjectFileUrl(a)
    {
        return this.GetProjectFileUrl(a)
    }
    LoadImage(a)
    {
        if (a.loadPolicy && !VALID_LOAD_POLICIES.has(a.loadPolicy))
            throw Error("invalid load policy");
        let b = this._assetsByUrl.get(a.url);
        if (b)
            return b;
        b = C3$jscomp$100.New(C3$jscomp$100.ImageAsset, this, {
            url: a.url,
            size: a.size || 0,
            loadPolicy: a.loadPolicy || this._defaultLoadPolicy
        });
        this._assetsByUrl.set(b.GetURL(), b);
        this._hasFinishedInitialLoad || (this._totalAssetSizeToLoad += b.GetSize(), this._loadPromises.push(b.Load().then(() => this._AddLoadedSize(b.GetSize()))));
        return b
    }
    _ReleaseAsset(a)
    {
        this._assetsByUrl.delete(a.GetURL())
    }
    async WaitForAllToLoad()
    {
        try {
            await Promise.all(this._loadPromises),
            this._lastLoadProgress =
            1
        } catch (a) {
            console.error("Error loading: ", a),
            this._hasHadErrorLoading = !0,
            this._FireLoadingProgressEvent()
        }
    }
    SetInitialLoadFinished()
    {
        this._hasFinishedInitialLoad = !0
    }
    HasHadErrorLoading()
    {
        return this._hasHadErrorLoading
    }
    _AddLoadedSize(a)
    {
        this._assetSizeLoaded += a;
        this._loadingRateLimiter.Call()
    }
    _FireLoadingProgressEvent()
    {
        const a = C3$jscomp$100.New(C3$jscomp$100.Event, "loadingprogress");
        this._lastLoadProgress = C3$jscomp$100.clamp(this._assetSizeLoaded / this._totalAssetSizeToLoad, 0, 1);
        a.progress = this._lastLoadProgress;
        this._runtime.Dispatcher().dispatchEvent(a)
    }
    GetLoadProgress()
    {
        return this._lastLoadProgress
    }
    _SetWebFonts(a)
    {
        C3$jscomp$100.shallowAssignArray(this._webFonts, a);
        this._webFonts.length && this._loadPromises.push(this._LoadWebFonts())
    }
    async _LoadWebFonts()
    {
        const a = [],
            b = [];
        for (const [c, d, e] of this._webFonts)
            this._totalAssetSizeToLoad += e,
            a.push(this._LoadWebFont(c, d, b).then(() => this._AddLoadedSize(e)));
        await Promise.all(a);
        this._runtime.IsInWorker() && 0 < b.length && await this._runtime.PostComponentMessageToDOMAsync("runtime",
        "load-webfonts", {
            webfonts: b
        })
    }
    async _LoadWebFont(a, b, c)
    {
        try {
            let d = await this.GetProjectFileUrl(b);
            "Gecko" === C3$jscomp$100.Platform.BrowserEngine && (a = `'${a}'`);
            if ("Gecko" === C3$jscomp$100.Platform.BrowserEngine && "preview" === this._runtime.GetExportType() || "playable-ad-single-file" === this._runtime.GetExportType())
                d = this._GetLocalBlobURLFromFileMap(d);
            const e = new FontFace(a, `url('${d}')`);
            this._runtime.IsInWorker() ? self.fonts.add(e) : document.fonts.add(e);
            await e.load();
            this._runtime.IsInWorker() && c.push({
                name: a,
                url: d
            })
        } catch (d) {
            console.warn(`[C3 runtime] Failed to load web font '${a}': `, d)
        }
    }
    IsAudioFormatSupported(a)
    {
        return !!this._supportedAudioFormats[a]
    }
    _SetAudioFiles(a, b)
    {
        this._preloadSounds = !!b;
        for (const [c, d, e] of a)
            this._audioFiles.set(c, {
                fileName: c,
                formats: d.map(f => ({
                    type: f[0],
                    fileExtension: f[1],
                    fullName: c + f[1],
                    fileSize: f[2]
                })),
                isMusic: e
            })
    }
    GetPreferredAudioFile(a)
    {
        "flat" === this._fileStructure && (a = a.toLowerCase());
        a = this._audioFiles.get(a);
        if (!a)
            return null;
        let b = null;
        for (const c of a.formats)
            if (b ||
            "audio/webm; codecs=opus" !== c.type || (b = c), this.IsAudioFormatSupported(c.type))
                return c;
        return b
    }
    GetProjectAudioFileUrl(a)
    {
        return (a = this.GetPreferredAudioFile(a)) ? {
            url: this.GetMediaFileUrl(a.fullName),
            type: a.type
        } : null
    }
    GetAudioToPreload()
    {
        if (this._preloadSounds) {
            const a = [];
            for (const b of this._audioFiles.values()) {
                if (b.isMusic)
                    continue;
                const c = this.GetPreferredAudioFile(b.fileName);
                c && a.push({
                    originalUrl: b.fileName,
                    url: this.GetMediaFileUrl(c.fullName),
                    type: c.type,
                    fileSize: c.fileSize
                })
            }
            return a
        }
        return []
    }
    _GetLocalBlobFromFileMap(a)
    {
        "preview" ===
        this._runtime.GetExportType() && (a = (new URL(a, location.href)).toString());
        return this._fileMap.get(a) || null
    }
    _GetLocalBlobURLFromFileMap(a)
    {
        var b = this._fileMapBlobUrls.get(a);
        if (b)
            return b;
        b = this._GetLocalBlobFromFileMap(a);
        if (!b)
            return a;
        b = URL.createObjectURL(b);
        this._fileMapBlobUrls.set(a, b);
        return b
    }
    GetIAssetManager()
    {
        return this._iAssetManager
    }
    async LoadScripts(...a)
    {
        const b = await Promise.all(a.map(c => this.GetProjectFileUrl(c)));
        this._runtime.IsInWorker() ? 1 === a.length ? (a = a[0], await self.c3_import((C3$jscomp$100.IsRelativeURL(a) ?
        "./" : "") + a)) : (a = a.map(c => `import "${C3$jscomp$100.IsRelativeURL(c) ? "./" : ""}${c}";`).join("\n"), a = URL.createObjectURL(new Blob([a], {
            type: "application/javascript"
        })), await self.c3_import(a)) : await Promise.all(b.map(c => AddScript(c)))
    }
    async CompileWebAssembly(a)
    {
        if (WebAssembly.compileStreaming)
            return a = await this.GetProjectFileUrl(a), await WebAssembly.compileStreaming(fetch(a));
        a = await C3$jscomp$100.FetchArrayBuffer(a);
        return await WebAssembly.compile(a)
    }
    async LoadStyleSheet(a)
    {
        a = await this.GetProjectFileUrl(a);
        return await this._runtime.PostComponentMessageToDOMAsync("runtime", "add-stylesheet", {
            url: a
        })
    }
}
;
"use strict";
const C3$jscomp$101 = self.C3;
C3$jscomp$101.Asset = class  extends C3$jscomp$101.DefendedBase{
    constructor(a, b)
    {
        super();
        this._assetManager = a;
        this._runtime = a.GetRuntime();
        this._url = b.url || "";
        this._size = b.size;
        this._loadPolicy = b.loadPolicy;
        this._blob = b.blob || null;
        this._isLoaded = !!this._blob;
        this._loadPromise = null
    }
    Release()
    {
        this._blob = this._runtime = this._assetManager = this._loadPromise = null
    }
    GetURL()
    {
        return this._url
    }
    GetSize()
    {
        return this._size
    }
    Load()
    {
        return "local" === this._loadPolicy || this._blob ? (this._isLoaded = !0, Promise.resolve()) : this._loadPromise ?
        this._loadPromise : this._loadPromise = this._assetManager.FetchBlob(this._url, this._loadPolicy).then(a => {
            this._isLoaded = !0;
            this._loadPromise = null;
            return this._blob = a
        }).catch(a => {
            console.error("Error loading resource: ", a);
            this._loadPromise = null
        })
    }
    IsLoaded()
    {
        return this._isLoaded
    }
    GetBlob()
    {
        return this._blob ? Promise.resolve(this._blob) : this._loadPromise ? this._loadPromise : this._assetManager.FetchBlob(this._url, this._loadPolicy)
    }
}
;
"use strict";
const C3$jscomp$102 = self.C3,
    promiseThrottle = new C3$jscomp$102.PromiseThrottle,
    allImageAssets = new Set;
C3$jscomp$102.ImageAsset = class  extends C3$jscomp$102.Asset{
    constructor(a, b)
    {
        super(a, b);
        this._webglTexture = this._texturePromise = null;
        this._refCount = 0;
        this._imageHeight = this._imageWidth = -1;
        allImageAssets.add(this)
    }
    Release()
    {
        if (0 !== this._refCount)
            throw Error("released image asset which still has texture references");
        this._assetManager._ReleaseAsset(this);
        this._texturePromise = null;
        allImageAssets.delete(this);
        super.Release()
    }
    static OnRendererContextLost()
    {
        for (const a of allImageAssets)
            a._texturePromise =
            null,
            a._webglTexture = null,
            a._refCount = 0
    }
    LoadStaticTexture(a, b)
    {
        b = b || {};
        this._refCount++;
        if (this._webglTexture)
            return Promise.resolve(this._webglTexture);
        if (this._texturePromise)
            return this._texturePromise;
        b.anisotropy = this._runtime.GetCanvasManager().GetTextureAnisotropy();
        return this._texturePromise = this._DoLoadStaticTexture(a, b)
    }
    async _DoLoadStaticTexture(a, b)
    {
        try {
            const c = await this.GetBlob();
            return 0 === this._refCount ? this._texturePromise = null : await promiseThrottle.Add(async () => {
                const d = await a.CreateStaticTextureAsync(c,
                b);
                this._texturePromise = null;
                if (0 === this._refCount)
                    return a.DeleteTexture(d), null;
                this._webglTexture = d;
                this._imageWidth = d.GetWidth();
                this._imageHeight = d.GetHeight();
                return this._webglTexture
            })
        } catch (c) {
            throw console.error("Failed to load texture: ", c), c;
        }
    }
    ReleaseTexture()
    {
        if (0 >= this._refCount)
            throw Error("texture released too many times");
        this._refCount--;
        0 === this._refCount && this._webglTexture && (this._webglTexture.GetRenderer().DeleteTexture(this._webglTexture), this._webglTexture = null)
    }
    GetRefCount()
    {
        return this._refCount
    }
    GetTexture()
    {
        return this._webglTexture
    }
    GetWidth()
    {
        return this._imageWidth
    }
    GetHeight()
    {
        return this._imageHeight
    }
    async LoadToDrawable()
    {
        const a =
        await this.GetBlob();
        return C3$jscomp$102.Supports.ImageBitmap ? await createImageBitmap(a) : await C3$jscomp$102.BlobToImage(a)
    }
}
;
"use strict";
const C3$jscomp$103 = self.C3;
function SortByInstLastCachedZIndex(a, b) {
    return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()
}
C3$jscomp$103.RenderCell = class  extends C3$jscomp$103.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._grid = a;
        this._x = b;
        this._y = c;
        this._instances = [];
        this._isSorted = !0;
        this._pendingRemoval = new Set;
        this._isAnyPendingRemoval = !1
    }
    Release()
    {
        C3$jscomp$103.clearArray(this._instances);
        this._pendingRemoval.clear();
        this._grid = null
    }
    Reset()
    {
        C3$jscomp$103.clearArray(this._instances);
        this._isSorted = !0;
        this._pendingRemoval.clear();
        this._isAnyPendingRemoval = !1
    }
    SetChanged()
    {
        this._isSorted = !1
    }
    IsEmpty()
    {
        if (!this._instances.length)
            return !0;
        if (this._instances.length > this._pendingRemoval.size)
            return !1;
        this._FlushPending();
        return !0
    }
    Insert(a)
    {
        this._pendingRemoval.has(a) ? (this._pendingRemoval.delete(a), 0 === this._pendingRemoval.size && (this._isAnyPendingRemoval = !1)) : (this._instances.push(a), this._isSorted = 1 === this._instances.length)
    }
    Remove(a)
    {
        this._pendingRemoval.add(a);
        this._isAnyPendingRemoval = !0;
        50 <= this._pendingRemoval.size && this._FlushPending()
    }
    _FlushPending()
    {
        this._isAnyPendingRemoval && (this._instances.length === this._pendingRemoval.size ?
        this.Reset() : (C3$jscomp$103.arrayRemoveAllInSet(this._instances, this._pendingRemoval), this._pendingRemoval.clear(), this._isAnyPendingRemoval = !1))
    }
    _EnsureSorted()
    {
        this._isSorted || (this._instances.sort(SortByInstLastCachedZIndex), this._isSorted = !0)
    }
    Dump(a)
    {
        this._FlushPending();
        this._EnsureSorted();
        this._instances.length && a.push(this._instances)
    }
}
;
"use strict";
const C3$jscomp$104 = self.C3;
C3$jscomp$104.RenderGrid = class  extends C3$jscomp$104.DefendedBase{
    constructor(a, b)
    {
        super();
        this._cellWidth = a;
        this._cellHeight = b;
        this._cells = C3$jscomp$104.New(C3$jscomp$104.PairMap)
    }
    Release()
    {
        this._cells.Release();
        this._cells = null
    }
    GetCell(a, b, c)
    {
        let d = this._cells.Get(a, b);
        return d ? d : c ? (d = C3$jscomp$104.New(C3$jscomp$104.RenderCell, this, a, b), this._cells.Set(a, b, d), d) : null
    }
    XToCell(a)
    {
        return Math.floor(a / this._cellWidth)
    }
    YToCell(a)
    {
        return Math.floor(a / this._cellHeight)
    }
    Update(a, b, c)
    {
        if (b)
            for (let d = b.getLeft(),
                e = b.getRight(); d <= e; ++d)
                for (let f = b.getTop(), g = b.getBottom(); f <= g; ++f) {
                    if (c && c.containsPoint(d, f))
                        continue;
                    const h = this.GetCell(d, f, !1);
                    h && (h.Remove(a), h.IsEmpty() && this._cells.Delete(d, f))
                }
        if (c)
            for (let d = c.getLeft(), e = c.getRight(); d <= e; ++d)
                for (let f = c.getTop(), g = c.getBottom(); f <= g; ++f)
                    b && b.containsPoint(d, f) || this.GetCell(d, f, !0).Insert(a)
    }
    QueryRange(a, b)
    {
        let c = this.XToCell(a.getLeft());
        const d = this.YToCell(a.getTop()),
            e = this.XToCell(a.getRight());
        for (a = this.YToCell(a.getBottom()); c <= e; ++c)
            for (let f =
            d; f <= a; ++f) {
                const g = this.GetCell(c, f, !1);
                g && g.Dump(b)
            }
    }
    MarkRangeChanged(a)
    {
        let b = a.getLeft();
        const c = a.getTop(),
            d = a.getRight();
        for (a = a.getBottom(); b <= d; ++b)
            for (let e = c; e <= a; ++e) {
                const f = this.GetCell(b, e, !1);
                f && f.SetChanged()
            }
    }
}
;
"use strict";
const C3$jscomp$105 = self.C3,
    tmpRect$jscomp$2 = new C3$jscomp$105.Rect,
    tmpQuad$jscomp$2 = new C3$jscomp$105.Quad,
    renderCellArr = [];
new C3$jscomp$105.Rect;
new C3$jscomp$105.Rect;
const glMatrix$jscomp$8 = self.glMatrix,
    vec3$jscomp$5 = glMatrix$jscomp$8.vec3,
    vec4$jscomp$4 = glMatrix$jscomp$8.vec4,
    mat4$jscomp$8 = glMatrix$jscomp$8.mat4,
    tempMat4$jscomp$4 = mat4$jscomp$8.create(),
    tempVec3 = vec3$jscomp$5.create(),
    tempVec4$jscomp$1 = vec4$jscomp$4.create(),
    camVector = vec3$jscomp$5.create(),
    lookVector = vec3$jscomp$5.create(),
    upVector = vec3$jscomp$5.create(),
    tempVec2 = C3$jscomp$105.New(C3$jscomp$105.Vector2);
C3$jscomp$105.New(C3$jscomp$105.Rect);
function SortByInstLastCachedZIndex$jscomp$1(a, b) {
    return a.GetWorldInfo()._GetLastCachedZIndex() - b.GetWorldInfo()._GetLastCachedZIndex()
}
function SortByInstZElevation(a, b) {
    return a.GetWorldInfo().GetZElevation() - b.GetWorldInfo().GetZElevation()
}
const tempInstanceList1 = [],
    tempInstanceList2 = [],
    tempInstancesByCameraDist = [],
    DEFAULT_LAYER_OPTIONS = {
        name: "",
        sid: -1,
        isDynamic: !1,
        isVisible: !0,
        isInteractive: !0,
        isHTMLElementsLayer: !1,
        backgroundColor: [1, 1, 1, 1],
        isTransparent: !0,
        parallax: [1, 1],
        opacity: 1,
        isForceOwnTexture: !1,
        renderAs3d: !1,
        useCameraDistanceDrawOrder: !1,
        useRenderCells: !1,
        scaleRate: 1,
        blendMode: 0,
        zElevation: 0,
        initialInstancesData: [],
        effectListData: [],
        subLayersData: []
    };
C3$jscomp$105.Layer = class  extends C3$jscomp$105.DefendedBase{
    constructor(a, b, c)
    {
        super();
        c = Object.assign({}, DEFAULT_LAYER_OPTIONS, c);
        this._layout = a;
        this._runtime = a.GetRuntime();
        this._parentLayer = b;
        this._name = c.name;
        this._index = -1;
        this._isHTMLElementsLayer = !!c.isHTMLElementsLayer;
        this._htmlIndex = -1;
        this._sid = c.sid;
        this._isDynamic = !!c.isDynamic;
        this._isVisible = !!c.isVisible;
        this._isInteractive = !!c.isInteractive;
        this._backgroundColor = C3$jscomp$105.New(C3$jscomp$105.Color);
        this._backgroundColor.setFromJSON(c.backgroundColor);
        this._isTransparent = !!c.isTransparent;
        this._parallaxX = c.parallax[0];
        this._parallaxY = c.parallax[1];
        this._color = C3$jscomp$105.New(C3$jscomp$105.Color, 1, 1, 1, c.opacity);
        this._premultipliedColor = C3$jscomp$105.New(C3$jscomp$105.Color);
        this._isForceOwnTexture = !!c.isForceOwnTexture;
        this._renderAs3d = !!c.renderAs3d;
        this._useCameraDistanceDrawOrder = !!c.useCameraDistanceDrawOrder;
        this._useRenderCells = !!c.useRenderCells;
        this._scaleRate = c.scaleRate;
        this._blendMode = c.blendMode;
        this._curRenderTarget = null;
        this._scale =
        1;
        this._zElevation = c.zElevation;
        this._scrollY = this._scrollX = this._angle = 0;
        this._hasOwnScrollPosition = !1;
        this._viewport = C3$jscomp$105.New(C3$jscomp$105.Rect);
        this._viewportZ0 = C3$jscomp$105.New(C3$jscomp$105.Rect);
        this._viewport3D = C3$jscomp$105.New(C3$jscomp$105.Rect);
        this._isViewportChanged = !0;
        this._projectionMatrix = mat4$jscomp$8.create();
        this._isProjectionMatrixChanged = !0;
        this._modelViewMatrix = mat4$jscomp$8.create();
        this._isMVMatrixChanged = !0;
        this._viewFrustum = C3$jscomp$105.New(C3$jscomp$105.Gfx.ViewFrustum);
        this._isViewFrustumChanged = !0;
        this._startupInitialInstances = [];
        this._initialInstancesData = c.initialInstancesData;
        this._initialInstances = [];
        this._createdGlobalUids = [];
        this._initialUIDsToInstanceData = new Map;
        this._instances = [];
        this._anyInstanceZElevated = this._htmlZIndicesUpToDate = this._zIndicesUpToDate = !1;
        const d = this._runtime.GetCanvasManager();
        this._effectList = C3$jscomp$105.New(C3$jscomp$105.EffectList, this, c.effectListData);
        this._effectChain = C3$jscomp$105.New(C3$jscomp$105.Gfx.EffectChain, d.GetEffectChainManager(),
        {
            drawContent: (e, f) => {
                f = f.GetContentObject();
                const g = f.GetRenderTarget();
                e.SetColor(f.GetPremultipliedColor());
                e.DrawRenderTarget(g);
                e.InvalidateRenderTarget(g);
                d.ReleaseAdditionalRenderTarget(g)
            },
            getShaderParameters: e => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e)
        });
        this._wasDefaultColor = this._needsRebuildEffectChainSteps = !0;
        this._renderGrid = null;
        this._lastRenderList = [];
        this._isRenderListUpToDate = !1;
        this._lastRenderCells = C3$jscomp$105.New(C3$jscomp$105.Rect, 0, 0, -1, -1);
        this._curRenderCells =
        C3$jscomp$105.New(C3$jscomp$105.Rect, 0, 0, -1, -1);
        this._iLayer = new self.ILayer(this);
        this._UpdatePremultipliedColor();
        this.UsesRenderCells() && (this._renderGrid = C3$jscomp$105.New(C3$jscomp$105.RenderGrid, this._runtime.GetOriginalViewportWidth(), this._runtime.GetOriginalViewportHeight()));
        this._subLayers = c.subLayersData.map(e => C3$jscomp$105.Layer.CreateFromExportData(this._layout, this, e))
    }
    _InitInitialInstances()
    {
        for (const a of this._initialInstancesData) {
            const b = this._runtime.GetObjectClassByIndex(a[1]);
            this._layout._AddInitialObjectClass(b);
            b.GetDefaultInstanceData() || (b.SetDefaultInstanceData(a), b._SetDefaultLayerIndex(this._index));
            this._initialInstances.push(a);
            this._initialUIDsToInstanceData.set(a[2], a)
        }
        C3$jscomp$105.shallowAssignArray(this._startupInitialInstances, this._initialInstances);
        this._initialInstancesData = null
    }
    static CreateFromExportData(a, b, c)
    {
        return C3$jscomp$105.New(C3$jscomp$105.Layer, a, b, {
            name: c[0],
            sid: c[2],
            isVisible: c[3],
            isInteractive: c[13],
            isHTMLElementsLayer: c[19],
            backgroundColor: c[4].map(d =>
            d / 255),
            isTransparent: c[5],
            parallax: [c[6], c[7]],
            opacity: c[8],
            isForceOwnTexture: c[9],
            renderAs3d: c[17],
            useCameraDistanceDrawOrder: c[18],
            useRenderCells: c[10],
            scaleRate: c[11],
            blendMode: c[12],
            zElevation: c[16],
            initialInstancesData: c[14],
            effectListData: c[15],
            subLayersData: c[20]
        })
    }
    Release()
    {
        for (const a of this._subLayers)
            a.Release();
        C3$jscomp$105.clearArray(this._subLayers);
        for (const a of this._instances)
            this._runtime.DestroyInstance(a);
        C3$jscomp$105.clearArray(this._instances);
        this._effectList.Release();
        this._effectList = null;
        this._effectChain.Release();
        this._runtime = this._layout = this._parentLayer = this._iLayer = this._effectChain = null
    }
    GetInitialInstanceData(a)
    {
        return this._initialUIDsToInstanceData.get(a)
    }
    CreateInitialInstances(a)
    {
        const b = this._layout.IsFirstVisit();
        let c = 0;
        const d = this._initialInstances;
        for (let f = 0, g = d.length; f < g; ++f) {
            var e = d[f];
            const h = this._runtime.GetObjectClassByIndex(e[1]);
            let k = !0;
            if (!h.HasPersistBehavior() || b)
                e = this._runtime.CreateInstanceFromData(e, this, !0),
                a.push(e),
                h.IsGlobal() &&
                (k = !1, this._createdGlobalUids.push(e.GetUID()));
            k && (d[c] = d[f], ++c)
        }
        C3$jscomp$105.truncateArray(d, c);
        this._runtime.FlushPendingInstances();
        this.SetZIndicesChanged()
    }
    _AddInstance(a, b)
    {
        if (!a.GetPlugin().IsWorldType())
            throw Error("instance is not of world type");
        const c = a.GetWorldInfo();
        if (c.GetLayer() !== this)
            throw Error("instance added to wrong layer");
        this._instances.push(a);
        0 !== c.GetZElevation() && (this._anyInstanceZElevated = !0);
        b && this.UsesRenderCells() && a.GetWorldInfo().SetBboxChanged();
        this.SetZIndicesChanged(a)
    }
    _MaybeAddInstance(a)
    {
        this._instances.includes(a) ||
        (this._instances.push(a), 0 !== a.GetWorldInfo().GetZElevation() && (this._anyInstanceZElevated = !0), this.SetZIndicesChanged(a))
    }
    _PrependInstance(a, b)
    {
        const c = a.GetWorldInfo();
        if (c.GetLayer() !== this)
            throw Error("instance added to wrong layer");
        this._instances.unshift(a);
        0 !== c.GetZElevation() && (this._anyInstanceZElevated = !0);
        this.SetZIndicesChanged(a);
        b && this.UsesRenderCells() && a.GetWorldInfo().SetBboxChanged()
    }
    _RemoveInstance(a, b)
    {
        const c = this._instances.indexOf(a);
        0 > c || (b && this.UsesRenderCells() && a.GetWorldInfo()._RemoveFromRenderCells(),
        this._instances.splice(c, 1), this.SetZIndicesChanged(a), this._MaybeResetAnyInstanceZElevatedFlag())
    }
    _SetAnyInstanceZElevated()
    {
        this._anyInstanceZElevated = !0
    }
    _MaybeResetAnyInstanceZElevatedFlag()
    {
        0 === this._instances.length && (this._anyInstanceZElevated = !1)
    }
    _SortInstancesByLastCachedZIndex(a)
    {
        if (a) {
            a = new Set;
            for (var b of this._instances) {
                var c = b.GetWorldInfo()._GetLastCachedZIndex();
                0 <= c && a.add(c)
            }
            b = -1;
            for (const d of this._instances)
                if (c = d.GetWorldInfo(), !(0 <= c._GetLastCachedZIndex())) {
                    for (++b; a.has(b);)
                        ++b;
                    c._SetZIndex(b)
                }
        }
        this._instances.sort(SortByInstLastCachedZIndex$jscomp$1)
    }
    _Start() {}
    _End()
    {
        for (const a of this._instances)
            a.GetObjectClass().IsGlobal() || this._runtime.DestroyInstance(a);
        this._runtime.FlushPendingInstances();
        C3$jscomp$105.clearArray(this._instances);
        this._anyInstanceZElevated = !1;
        this.SetZIndicesChanged()
    }
    RecreateInitialObjects(a, b, c, d, e, f)
    {
        const g = this._runtime.GetEventSheetManager(),
            h = this._runtime.GetAllObjectClasses(),
            k = a.IsFamily(),
            l = [];
        for (const p of this._initialInstances) {
            var m =
            p[0];
            if (b.containsPoint(m[0], m[1])) {
                m = h[p[1]];
                if (m !== a)
                    if (k) {
                        if (!a.FamilyHasMember(m))
                            continue
                    } else
                        continue;
                m = e;
                if (!m) {
                    var n = this._runtime.GetCurrentLayout();
                    this.GetLayout() === n ? m = this : (m = n.GetLayerByName(this.GetName())) || (m = n.GetLayerByIndex(this.GetIndex()))
                }
                n = this._runtime.CreateInstanceFromData(p, m, !1, void 0, void 0, !1, f);
                m.SortAndAddInstancesByZIndex(n);
                m = n.GetWorldInfo();
                m.OffsetXY(c, d);
                m.SetBboxChanged();
                g.BlockFlushingInstances(!0);
                n._TriggerOnCreatedOnSelfAndRelated();
                g.BlockFlushingInstances(!1);
                l.push(n)
            }
        }
        return l
    }
    GetInstanceCount()
    {
        return this._instances.length
    }
    GetLayout()
    {
        return this._layout
    }
    GetName()
    {
        return this._name
    }
    _SetIndex(a)
    {
        this._index = a
    }
    GetIndex()
    {
        return this._index
    }
    _SetHTMLIndex(a)
    {
        this._htmlIndex = a
    }
    GetHTMLIndex()
    {
        return this._htmlIndex
    }
    IsHTMLElementsLayer()
    {
        return this._isHTMLElementsLayer
    }
    SetIsHTMLElementsLayer(a)
    {
        a = !!a;
        this._isHTMLElementsLayer !== a && (this._isHTMLElementsLayer = a, this._layout._ReindexAndUpdateAllLayers(), this._runtime.UpdateRender())
    }
    _GetSiblingIndex()
    {
        const a =
        this.GetParentLayer();
        return a ? a.GetSubLayers().indexOf(this) : this.GetLayout()._GetRootLayers().indexOf(this)
    }
    GetSID()
    {
        return this._sid
    }
    GetRuntime()
    {
        return this._runtime
    }
    IsDynamic()
    {
        return this._isDynamic
    }
    HasAnyDynamicParentLayer()
    {
        for (const a of this.parentLayers())
            if (a.IsDynamic())
                return !0;
        return !1
    }
    GetDevicePixelRatio()
    {
        return this._runtime.GetDevicePixelRatio()
    }
    GetEffectList()
    {
        return this._effectList
    }
    GetEffectChain()
    {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    _MaybeRebuildEffectChainSteps()
    {
        const a =
        this.HasDefaultColor();
        if (this._needsRebuildEffectChainSteps || a !== this._wasDefaultColor || this._effectChain.NeedsRebuild()) {
            var b = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(b.map(c => c.GetShaderProgram()), {
                indexMap: b.map(c => c.GetIndex()),
                forcePreDraw: !a,
                useFullSurface: !0
            });
            this._needsRebuildEffectChainSteps = !1;
            this._wasDefaultColor = a
        }
    }
    UpdateActiveEffects()
    {
        this.GetEffectList().UpdateActiveEffects();
        this._needsRebuildEffectChainSteps = !0
    }
    UsesRenderCells()
    {
        return this._useRenderCells &&
            !this._useCameraDistanceDrawOrder
    }
    GetRenderGrid()
    {
        return this._renderGrid
    }
    SetRenderListStale()
    {
        this._isRenderListUpToDate = !1
    }
    IsVisible()
    {
        for (const a of this.selfAndParentLayers())
            if (!a._IsVisibleFlagSet())
                return !1;
        return !0
    }
    _IsVisibleFlagSet()
    {
        return this._isVisible
    }
    SetVisible(a)
    {
        a = !!a;
        this._isVisible !== a && (this._isVisible = a, this._runtime.UpdateRender())
    }
    SetInteractive(a)
    {
        this._isInteractive = !!a
    }
    IsInteractive()
    {
        return this._isInteractive
    }
    IsSelfAndParentsInteractive()
    {
        for (const a of this.selfAndParentLayers())
            if (!a.IsInteractive())
                return !1;
        return !0
    }
    SetOwnScrollPositionEnabled(a)
    {
        a = !!a;
        if (this._hasOwnScrollPosition !== a) {
            if (this._hasOwnScrollPosition = a)
                a = this.GetLayout(),
                this._scrollX = a.GetScrollX(),
                this._scrollY = a.GetScrollY();
            this._SetMVMatrixChanged();
            this._runtime.UpdateRender()
        }
    }
    IsOwnScrollPositionEnabled()
    {
        return this._hasOwnScrollPosition
    }
    SetScrollX(a)
    {
        var b = this.GetLayout();
        const c = b.GetScrollLeftBound();
        b = b.GetScrollRightBound();
        a > b && (a = b);
        a < c && (a = c);
        this._scrollX !== a && (this._scrollX = a, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(),
        this._runtime.UpdateRender()))
    }
    SetScrollY(a)
    {
        var b = this.GetLayout();
        const c = b.GetScrollTopBound();
        b = b.GetScrollBottomBound();
        a > b && (a = b);
        a < c && (a = c);
        this._scrollY !== a && (this._scrollY = a, this.IsOwnScrollPositionEnabled() && (this._SetMVMatrixChanged(), this._runtime.UpdateRender()))
    }
    GetScrollX()
    {
        return this.IsOwnScrollPositionEnabled() ? this._scrollX : this.GetLayout().GetScrollX()
    }
    GetScrollY()
    {
        return this.IsOwnScrollPositionEnabled() ? this._scrollY : this.GetLayout().GetScrollY()
    }
    GetViewport()
    {
        this._MaybeUpdateViewport();
        return this._viewport
    }
    _GetViewportZ0()
    {
        this._MaybeUpdateViewport();
        return this._viewportZ0
    }
    GetViewport3D()
    {
        this._MaybeUpdateViewport();
        return this._viewport3D
    }
    _GetVanishingPoint()
    {
        const a = this.GetLayout();
        return [a.GetVanishingPointX(), a.GetVanishingPointY()]
    }
    GetDefaultCameraZ(a)
    {
        return this._runtime.GetDefaultCameraZ(a)
    }
    GetViewportForZ(a, b)
    {
        var c = this._GetViewportZ0();
        if (0 === a)
            b.copy(c);
        else {
            let g = c.midX(),
                h = c.midY();
            var d = this.Get2DScaleFactorToZ(a);
            const k = c.width() / d;
            c = c.height() / d;
            const [l, m] =
            this._GetVanishingPoint();
            if (.5 !== l || .5 !== m) {
                const n = this.Get2DCameraZ();
                var e = this._runtime,
                    f = this.GetDefaultCameraZ() / n;
                d = (l - .5) * e.GetViewportWidth() / f;
                e = (m - .5) * e.GetViewportHeight() / f;
                f = this.GetAngle();
                0 !== f && (tempVec2.set(d, e), tempVec2.rotate(f), d = tempVec2.getX(), e = tempVec2.getY());
                a = C3$jscomp$105.unlerp(n, 0, a);
                g += C3$jscomp$105.lerp(d, 0, a);
                h += C3$jscomp$105.lerp(e, 0, a)
            }
            b.set(g - k / 2, h - c / 2, g + k / 2, h + c / 2)
        }
    }
    GetOpacity()
    {
        return this._color.getA()
    }
    SetOpacity(a)
    {
        a = C3$jscomp$105.clamp(a, 0, 1);
        this._color.getA() !==
        a && (this._color.setA(a), this._UpdatePremultipliedColor(), this._runtime.UpdateRender())
    }
    _UpdatePremultipliedColor()
    {
        this._premultipliedColor.copy(this._color);
        this._premultipliedColor.premultiply()
    }
    GetPremultipliedColor()
    {
        return this._premultipliedColor
    }
    HasDefaultColor()
    {
        return this._color.equalsRgba(1, 1, 1, 1)
    }
    GetScaleRate()
    {
        return this._scaleRate
    }
    SetScaleRate(a)
    {
        this._scaleRate !== a && (this._scaleRate = a, this._SetMVMatrixChanged(), this._runtime.UpdateRender())
    }
    GetParallaxX()
    {
        return this._parallaxX
    }
    GetParallaxY()
    {
        return this._parallaxY
    }
    SetParallax(a,
    b)
    {
        if (this._parallaxX !== a || this._parallaxY !== b)
            this._parallaxX = a,
            this._parallaxY = b,
            this._SetMVMatrixChanged(),
            this._runtime.UpdateRender()
    }
    SetParallaxX(a)
    {
        this.SetParallax(a, this.GetParallaxY())
    }
    SetParallaxY(a)
    {
        this.SetParallax(this.GetParallaxX(), a)
    }
    SetZElevation(a)
    {
        this._zElevation !== a && (this._zElevation = a, this._runtime.UpdateRender())
    }
    GetZElevation()
    {
        return this._zElevation
    }
    SetAngle(a)
    {
        a = C3$jscomp$105.clampAngle(a);
        this._angle !== a && (this._angle = a, this._SetMVMatrixChanged(), this._runtime.UpdateRender())
    }
    GetAngle()
    {
        return C3$jscomp$105.clampAngle(this._layout.GetAngle() +
        this._angle)
    }
    GetOwnAngle()
    {
        return this._angle
    }
    HasInstances()
    {
        return 0 < this._instances.length
    }
    _GetInstances()
    {
        return this._instances
    }
    _GetInstancesInDrawOrder()
    {
        return this.RendersIn3DMode() && this._useCameraDistanceDrawOrder ? (C3$jscomp$105.shallowAssignArray(tempInstancesByCameraDist, this._GetInstances()), tempInstancesByCameraDist.sort((a, b) => this._SortInstancesByCameraDistance(a, b)), tempInstancesByCameraDist) : this._GetInstances()
    }
    _AppendAllInstancesIncludingSubLayersInDrawOrder(a)
    {
        C3$jscomp$105.appendArray(a,
        this._GetInstancesInDrawOrder());
        for (const b of this._subLayers)
            b.IsVisible() && 0 < b.GetOpacity() && b._AppendAllInstancesIncludingSubLayersInDrawOrder(a)
    }
    _SortInstancesByCameraDistance(a, b)
    {
        var c = this.GetLayout().Get3DCameraPosition(),
            d = c[0],
            e = c[1];
        c = c[2];
        var f = a.GetWorldInfo();
        const g = b.GetWorldInfo();
        b = f.GetX() - d;
        a = f.GetY() - e;
        f = f.GetZElevation() - c;
        d = g.GetX() - d;
        e = g.GetY() - e;
        c = g.GetZElevation() - c;
        return d * d + e * e + c * c - (b * b + a * a + f * f)
    }
    GetBackgroundColor()
    {
        return this._backgroundColor
    }
    IsTransparent()
    {
        return this._isTransparent
    }
    SetTransparent(a)
    {
        a =
        !!a;
        this._isTransparent !== a && (this._isTransparent = a, this._runtime.UpdateRender())
    }
    IsForceOwnTexture()
    {
        return this._isForceOwnTexture
    }
    SetForceOwnTexture(a)
    {
        a = !!a;
        this._isForceOwnTexture !== a && (this._isForceOwnTexture = a, this._runtime.UpdateRender())
    }
    RendersIn2DMode()
    {
        return !this.GetRuntime().Uses3DFeatures() || !this._renderAs3d
    }
    RendersIn3DMode()
    {
        return !this.RendersIn2DMode()
    }
    Has3DCamera()
    {
        return this.RendersIn3DMode() && this.GetLayout().Is3DCameraEnabled()
    }
    SelfAndAllSubLayersHave3DCamera()
    {
        if (!this.Has3DCamera())
            return !1;
        for (const a of this._subLayers)
            if (!a.SelfAndAllSubLayersHave3DCamera())
                return !1;
        return !0
    }
    SetBlendMode(a)
    {
        this._blendMode !== a && (this._blendMode = a, this._runtime.UpdateRender())
    }
    GetBlendMode()
    {
        return this._blendMode
    }
    IsRootLayer()
    {
        return !this._parentLayer
    }
    GetParentLayer()
    {
        return this._parentLayer
    }
    _SetParentLayer(a)
    {
        this._parentLayer = a
    }
    GetSubLayers()
    {
        return this._subLayers
    }
    HasAnySubLayers()
    {
        return 0 < this._subLayers.length
    }
    _AddSubLayer(a, b=!0)
    {
        b ? this._subLayers.push(a) : this._subLayers.unshift(a)
    }
    _InsertSubLayer(a,
    b, c)
    {
        b = this._subLayers.indexOf(b);
        if (-1 === b)
            throw Error("cannot find layer to insert by");
        c && ++b;
        this._subLayers.splice(b, 0, a)
    }
    _RemoveSubLayer(a)
    {
        a = this._subLayers.indexOf(a);
        if (-1 === a)
            throw Error("cannot find layer to remove");
        this._subLayers.splice(a, 1)
    }
    HasAnyVisibleSubLayer()
    {
        for (const a of this._subLayers)
            if (a.ShouldDraw())
                return !0;
        return !1
    }
    *selfAndAllSubLayers()
    {
        for (const a of this._subLayers)
            yield *a.selfAndAllSubLayers();
        yield this
    }
    *parentLayers()
    {
        let a = this.GetParentLayer();
        for (; a;)
            yield a,
            a = a.GetParentLayer()
    }
    *selfAndParentLayers()
    {
        yield this;
        yield *this.parentLayers()
    }
    HasParentLayer(a)
    {
        for (const b of this.parentLayers())
            if (b === a)
                return !0;
        return !1
    }
    IsTransformCompatibleWith(a)
    {
        return this === a || this._parallaxX === a._parallaxX && this._parallaxY === a._parallaxY && this._scale === a._scale && this._scaleRate === a._scaleRate && this._angle === a._angle && this.GetScrollX() === a.GetScrollX() && this.GetScrollY() === a.GetScrollY()
    }
    SaveTransform()
    {
        return {
            parallaxX: this.GetParallaxX(),
            parallaxY: this.GetParallaxY(),
            scale: this.GetOwnScale(),
            scaleRate: this.GetScaleRate(),
            angle: this.GetOwnAngle(),
            hasOwnScroll: this.IsOwnScrollPositionEnabled(),
            scrollX: this.GetScrollX(),
            scrollY: this.GetScrollY()
        }
    }
    RestoreTransform(a)
    {
        this.SetParallax(a.parallaxX, a.parallaxY);
        this.SetOwnScale(a.scale);
        this.SetScaleRate(a.scaleRate);
        this.SetAngle(a.angle);
        this.SetOwnScrollPositionEnabled(a.hasOwnScroll);
        this.SetScrollX(a.scrollX);
        this.SetScrollY(a.scrollY);
        this._MaybeUpdateViewport()
    }
    _RemoveAllInstancesInSet(a)
    {
        0 !== a.size && 0 < C3$jscomp$105.arrayRemoveAllInSet(this._instances,
        a) && (this._MaybeResetAnyInstanceZElevatedFlag(), this.SetZIndicesChanged())
    }
    SetZIndicesChanged(a)
    {
        this._isRenderListUpToDate = this._zIndicesUpToDate = !1;
        if (!a || a.GetObjectClass().GetPlugin().IsHTMLElementType())
            this._htmlZIndicesUpToDate = !1
    }
    _UpdateZIndices()
    {
        if (!this._zIndicesUpToDate) {
            this._instances.sort(SortByInstZElevation);
            if (this.UsesRenderCells())
                for (let a = 0, b = this._instances.length; a < b; ++a) {
                    const c = this._instances[a].GetWorldInfo();
                    c._SetZIndex(a);
                    this._renderGrid.MarkRangeChanged(c.GetRenderCellRange())
                }
            else
                for (let a =
                    0, b = this._instances.length; a < b; ++a)
                    this._instances[a].GetWorldInfo()._SetZIndex(a);
            this._zIndicesUpToDate = !0
        }
    }
    _UpdateHTMLZIndices()
    {
        if (!this._htmlZIndicesUpToDate) {
            var a = this._layout.GetRootLayersForHTMLLayer(this.GetHTMLIndex()).map(c => [...c.selfAndAllSubLayers()]).flat(),
                b = 0;
            for (const c of a) {
                for (const d of c._GetInstances())
                    d.GetObjectClass().GetPlugin().IsHTMLElementType() && d.GetWorldInfo()._SetHTMLZIndex(b++);
                c._SetHTMLZIndicesUpToDate()
            }
        }
    }
    _SetHTMLZIndicesUpToDate()
    {
        this._htmlZIndicesUpToDate =
        !0
    }
    MoveInstanceAdjacent(a, b, c)
    {
        var d = a.GetWorldInfo();
        b = b.GetWorldInfo();
        if (d.GetLayer() !== this || b.GetLayer() !== this)
            throw Error("can't arrange Z order unless both objects on this layer");
        d = d.GetZIndex();
        b = b.GetZIndex();
        if (d === b + (c ? 1 : -1))
            return !1;
        C3$jscomp$105.arrayRemove(this._instances, d);
        d < b && b--;
        c && b++;
        b === this._instances.length ? this._instances.push(a) : this._instances.splice(b, 0, a);
        this.SetZIndicesChanged(a);
        return !0
    }
    _MergeSortedZArrays(a, b)
    {
        const c = [];
        let d = 0,
            e = 0,
            f = a.length,
            g = b.length;
        for (; d <
        f && e < g;) {
            const h = a[d],
                k = b[e];
            h.GetWorldInfo()._GetLastCachedZIndex() < k.GetWorldInfo()._GetLastCachedZIndex() ? (c.push(h), ++d) : (c.push(k), ++e)
        }
        for (; d < f; ++d)
            c.push(a[d]);
        for (; e < g; ++e)
            c.push(b[e]);
        return c
    }
    _MergeAllSortedZArrays_pass(a)
    {
        const b = [],
            c = a.length;
        for (let d = 0; d < c - 1; d += 2)
            b.push(this._MergeSortedZArrays(a[d], a[d + 1]));
        1 === c % 2 && b.push(a[c - 1]);
        return b
    }
    _MergeAllSortedZArrays(a)
    {
        for (; 1 < a.length;)
            a = this._MergeAllSortedZArrays_pass(a);
        return a[0]
    }
    _GetRenderCellInstancesToDraw()
    {
        this._UpdateZIndices();
        C3$jscomp$105.clearArray(renderCellArr);
        this._renderGrid.QueryRange(this.GetViewport(), renderCellArr);
        return renderCellArr.length ? 1 === renderCellArr.length ? renderCellArr[0] : this._MergeAllSortedZArrays(renderCellArr) : []
    }
    ShouldDraw()
    {
        return this.IsVisible() && 0 < this.GetOpacity() && this._DrawsAnyContentInSelfOrSubLayers()
    }
    _DrawsAnyContentInSelfOrSubLayers()
    {
        if (this.HasInstances() || !this.IsTransparent())
            return !0;
        for (const a of this._subLayers)
            if (a._DrawsAnyContentInSelfOrSubLayers())
                return !0;
        return !1
    }
    UsesOwnTexture()
    {
        return this.IsForceOwnTexture() ||
            !this.HasDefaultColor() || 0 !== this.GetBlendMode() || this._effectList.HasAnyActiveEffect()
    }
    SelfOrAnySubLayerUsesOwnTexture()
    {
        if (this.UsesOwnTexture())
            return !0;
        for (const a of this._subLayers)
            if (a.SelfOrAnySubLayerUsesOwnTexture())
                return !0;
        return !1
    }
    GetRenderTarget()
    {
        return this._curRenderTarget
    }
    Get2DScaleFactorToZ(a)
    {
        if (this._layout.IsOrthographicProjection())
            return 1;
        const b = this.Get3DCameraZ();
        return b / (b - a)
    }
    GetResolutionScaleFactorToZ(a)
    {
        const b = this._runtime.GetRenderScale();
        if (this._layout.IsOrthographicProjection())
            return b;
        const c = this.Get3DCameraZ();
        return this.GetDefaultCameraZ() / Math.abs(c - a) * b
    }
    _SetMVMatrixChanged()
    {
        this._isViewportChanged = this._isViewFrustumChanged = this._isMVMatrixChanged = !0
    }
    _GetModelViewMatrix(a)
    {
        this._isMVMatrixChanged && (this._CalculateModelViewMatrix(a, this._modelViewMatrix, 0, 0, null), this._isMVMatrixChanged = !1);
        return this._modelViewMatrix
    }
    Get2DCameraZ(a)
    {
        return this.GetDefaultCameraZ(a) / this.GetNormalScale()
    }
    Get3DCameraZ()
    {
        return this.Has3DCamera() ? this.GetLayout().Get3DCameraPosition()[2] :
        this.Get2DCameraZ()
    }
    GetCameraPosition()
    {
        if (this.Has3DCamera()) {
            const a = this.GetLayout().Get3DCameraPosition();
            return [a[0], a[1], a[2]]
        }
        return this._Get2DCameraPosition()
    }
    _Get2DCameraPosition(a=0, b=0, c=0)
    {
        var d = this._runtime,
            e = this.GetLayout(),
            f = d.GetParallaxXOrigin(),
            g = d.GetParallaxYOrigin();
        f = (this.GetScrollX() - f) * this._parallaxX + f;
        g = (this.GetScrollY() - g) * this._parallaxY + g;
        d.IsPixelRoundingEnabled() && (f = Math.round(f), g = Math.round(g));
        a = f + a;
        b = g + b;
        e = e.IsOrthographicProjection() ? this.GetDefaultCameraZ(c) :
        this.Get2DCameraZ(c);
        const [h, k] = this._GetVanishingPoint();
        if (.5 !== h || .5 !== k)
            g = this.GetDefaultCameraZ(c) / e,
            c = (h - .5) * d.GetViewportWidth() / g,
            d = (k - .5) * d.GetViewportHeight() / g,
            g = this.GetAngle(),
            0 !== g && (tempVec2.set(c, d), tempVec2.rotate(g), c = tempVec2.getX(), d = tempVec2.getY()),
            a += c,
            b += d;
        return [a, b, e]
    }
    _CalculateModelViewMatrix(a, b, c, d, e)
    {
        const f = this._runtime;
        var g = this.GetLayout();
        if (this.Has3DCamera()) {
            vec3$jscomp$5.copy(camVector, g.Get3DCameraPosition());
            vec3$jscomp$5.copy(lookVector, g.Get3DCameraLookAt());
            vec3$jscomp$5.copy(upVector, g.Get3DCameraUpVector());
            c = f.GetParallaxXOrigin();
            d = f.GetParallaxYOrigin();
            g = lookVector[0] - camVector[0];
            const h = lookVector[1] - camVector[1],
                k = lookVector[2] - camVector[2];
            camVector[0] = (camVector[0] - c) * this._parallaxX + c;
            camVector[1] = (camVector[1] - d) * this._parallaxY + d;
            camVector[2] *= Math.max(this._parallaxX, this._parallaxY);
            lookVector[0] = camVector[0] + g;
            lookVector[1] = camVector[1] + h;
            lookVector[2] = camVector[2] + k
        } else {
            const [h, k, l] = this._Get2DCameraPosition(c, d, e);
            vec3$jscomp$5.set(camVector,
            h, k, l);
            vec3$jscomp$5.set(lookVector, h, k, l - 100);
            c = this.GetAngle();
            0 === c ? vec3$jscomp$5.set(upVector, 0, 1, 0) : vec3$jscomp$5.set(upVector, Math.sin(c), Math.cos(c), 0)
        }
        a.CalculateLookAtModelView(b, camVector, lookVector, upVector, e || f.GetViewportHeight())
    }
    _SetProjectionMatrixChanged()
    {
        this._isViewportChanged = this._isViewFrustumChanged = this._isProjectionMatrixChanged = !0
    }
    _GetProjectionMatrix(a)
    {
        this._isProjectionMatrixChanged && (this._CalculateProjectionMatrix(a), this._isProjectionMatrixChanged = !1);
        return this._projectionMatrix
    }
    _CalculateProjectionMatrix(a)
    {
        var b =
        this._runtime.GetCanvasManager();
        const [c, d] = this._GetVanishingPoint();
        if (this._layout.IsOrthographicProjection())
            a.CalculateOrthographicMatrix(this._projectionMatrix, b.GetDrawWidth(), b.GetDrawHeight());
        else if (.5 === c && .5 === d)
            mat4$jscomp$8.copy(this._projectionMatrix, b.GetDefaultProjectionMatrix());
        else {
            const e = b.GetDrawWidth();
            b = b.GetDrawHeight();
            a.CalculatePerspectiveMatrix(this._projectionMatrix, e / b, c, d)
        }
    }
    _SetTransform(a, b=!0, c=0, d=0, e=0)
    {
        b && a.SetProjectionMatrix(this._GetProjectionMatrix(a));
        0 === c && 0 === d && 0 === e ? b = this._GetModelViewMatrix(a) : (this._CalculateModelViewMatrix(a, tempMat4$jscomp$4, c, d, e), b = tempMat4$jscomp$4);
        a.SetModelViewMatrix(b)
    }
    PrepareForDraw(a)
    {
        this._SetTransform(a);
        a.SetBaseZ(this.GetZElevation())
    }
    _MaybeStartWebGLProfiling(a)
    {
        let b = null;
        if (a.IsWebGL() && this._runtime.IsGPUProfiling()) {
            const c = this._runtime.GetCanvasManager().GetLayerTimingsBuffer(this);
            c && (b = c.AddTimeElapsedQuery(), a.StartQuery(b))
        }
        return b
    }
    _MaybeStartWebGPUProfiling(a)
    {
        if (a.IsWebGPU() && this._runtime.IsGPUProfiling()) {
            const b =
            2 * (this.GetIndex() + 1);
            a.StartMeasuringRenderPassTime(b, b + 1)
        }
    }
    Draw(a, b, c)
    {
        var d = this._runtime.GetCanvasManager();
        const e = this.UsesOwnTexture();
        var f = null;
        const g = this._MaybeStartWebGLProfiling(a);
        this._MaybeStartWebGPUProfiling(a);
        e ? (f = {
            sampling: this._runtime.GetSampling(),
            isSampled: !0,
            canReadPixels: a.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() : !1
        }, "low" === d.GetCurrentFullscreenScalingQuality() && (f.width = d.GetDrawWidth(), f.height = d.GetDrawHeight()), this._curRenderTarget = f = this._runtime.GetAdditionalRenderTarget(f),
        a.SetRenderTarget(f), this.IsTransparent() && a.ClearRgba(0, 0, 0, 0)) : (this._curRenderTarget = b, a.SetRenderTarget(b));
        this.IsTransparent() || a.Clear(this._backgroundColor);
        this._layout._DrawLayerList(a, this._curRenderTarget, this._subLayers, e && this.IsTransparent());
        this._MaybeStartWebGPUProfiling(a);
        this._SetTransform(a);
        a.SetBaseZ(this.GetZElevation());
        a.SetDepthEnabled(this.RendersIn3DMode());
        this.GetNormalScale() > Number.EPSILON && (this._UpdateZIndices(), d = this.UsesRenderCells() && 0 === this.GetZElevation() &&
        !this._anyInstanceZElevated, this.Has3DCamera() ? this._DrawInstances_3DCamera(a) : d ? this._DrawInstances_RenderCells(a) : this._DrawInstances(a, this._GetInstancesInDrawOrder()));
        a.SetBaseZ(0);
        a.SetCurrentZ(0);
        e && (a.SetDepthEnabled(!1), this._DrawLayerOwnTextureToRenderTarget(a, f, b, c));
        g && a.EndQuery(g);
        this._curRenderTarget = null
    }
    _DrawInstances(a, b)
    {
        const c = this.GetViewport(),
            d = this._curRenderTarget,
            e = this.GetLayout().IsOrthographicProjection(),
            f = this.GetLayout().HasVanishingPointOutsideViewport();
        let g = null;
        for (let h = 0, k = b.length; h < k; ++h) {
            const l = b[h];
            if (l === g)
                continue;
            g = l;
            const m = l.GetWorldInfo();
            m.IsVisible() && m.IsInViewport(c, f, e) && this._DrawInstanceMaybeWithEffects(l, m, a, d)
        }
    }
    _DrawInstances_3DCamera(a)
    {
        const b = this._curRenderTarget,
            c = this._GetViewFrustum(),
            d = this._GetInstancesInDrawOrder();
        for (let h = 0, k = d.length; h < k;) {
            var e = d[h],
                f = e.GetWorldInfo();
            if (!f.IsVisible() || !f.IsInViewport3D(c)) {
                ++h;
                continue
            }
            (!e.RendersToOwnZPlane() || 0 < f.GetDepth()) && tempInstanceList2.push(e);
            var g = e.GetWorldInfo().GetTotalZElevation();
            tempInstanceList1.push(e);
            let l = h + 1;
            for (; l < k; ++l) {
                const m = d[l],
                    n = m.GetWorldInfo();
                if (n.IsVisible() && n.IsInViewport3D(c)) {
                    if (n.GetTotalZElevation() !== g)
                        break;
                    m.RendersToOwnZPlane() ? (0 < n.GetDepth() && tempInstanceList2.push(m), tempInstanceList1.push(m)) : tempInstanceList2.push(m)
                }
            }
            if (1 !== tempInstanceList1.length || tempInstanceList1[0].MustMitigateZFighting()) {
                this._DrawCoplanarInstances_3DCamera(a, tempInstanceList1);
                for (let m = 0, n = tempInstanceList2.length; m < n; ++m)
                    e = tempInstanceList2[m],
                    f = e.GetWorldInfo(),
                    f._SetDrawNonBackFacesOnly(!0),
                    this._DrawInstanceMaybeWithEffects(e, f, a, b),
                    f._SetDrawNonBackFacesOnly(!1)
            } else {
                this._DrawInstanceMaybeWithEffects(e, f, a, b);
                for (let m = 0, n = tempInstanceList2.length; m < n; ++m)
                    f = tempInstanceList2[m],
                    f !== e && (g = f.GetWorldInfo(), g.GetLayer()._DrawInstanceMaybeWithEffects(f, g, a, b))
            }
            h = l;
            C3$jscomp$105.clearArray(tempInstanceList1);
            C3$jscomp$105.clearArray(tempInstanceList2)
        }
    }
    _DrawCoplanarInstances_3DCamera(a, b)
    {
        const c = this._curRenderTarget;
        a.CoplanarStartStencilPass();
        for (let f =
            0, g = b.length; f < g; ++f) {
            var d = b[f],
                e = d.GetWorldInfo();
            e._SetDrawBackFaceOnly(!0);
            this._DrawInstance(d, e, a)
        }
        a.CoplanarStartColorPass();
        for (let f = 0, g = b.length; f < g; ++f)
            d = b[f],
            e = d.GetWorldInfo(),
            this._DrawInstanceMaybeWithEffects(d, e, a, c),
            e._SetDrawBackFaceOnly(!1);
        a.CoplanarRestoreStandardRendering()
    }
    _DrawInstances_RenderCells(a)
    {
        var b = this._renderGrid;
        const c = this._curRenderCells,
            d = this._lastRenderCells,
            e = this.GetViewport();
        c.set(b.XToCell(e.getLeft()), b.YToCell(e.getTop()), b.XToCell(e.getRight()), b.YToCell(e.getBottom()));
        this._isRenderListUpToDate && c.equals(d) ? b = this._lastRenderList : (b = this._GetRenderCellInstancesToDraw(), this._isRenderListUpToDate = !0, d.copy(c));
        this._DrawInstances(a, b);
        b !== this._lastRenderList && C3$jscomp$105.shallowAssignArray(this._lastRenderList, b)
    }
    _DrawInstanceMaybeWithEffects(a, b, c, d)
    {
        b.HasAnyActiveEffect() ? this._DrawInstanceWithEffectsAndRestore(a, b, c, d) : this._DrawInstance(a, b, c)
    }
    _DrawInstance(a, b, c)
    {
        b = b.GetRendererStateGroup();
        c.GetCurrentStateGroup() !== b && b.Apply();
        a.Draw(c)
    }
    _DrawInstanceWithEffectsAndRestore(a,
    b, c, d)
    {
        this._DrawInstanceWithEffects(a, b, c, d, null) && this._SetTransform(c)
    }
    _DrawInstanceWithEffects(a, b, c, d, e)
    {
        const f = b.GetInstanceEffectList().GetEffectChain();
        f.Render(c, d, {
            contentObject: a,
            blendMode: b.GetBlendMode(),
            devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
            time: a.GetInstanceGameTime(),
            layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetNormalScale(),
            layerAngle: this.GetAngle(),
            layoutRect: b.GetBoundingBox(),
            drawSurfaceRect: f.CanSkipCalculatingDrawSurfaceRect() ? null :
            this._InstanceBoxToDrawSurface(b),
            drawContentHook: e && e.drawContentHook,
            compositOffX: e && e.compositOffX,
            compositOffY: e && e.compositOffY,
            updateOwnProjection: e && e.updateOwnProjection
        });
        c.SetBaseZ(this.GetZElevation());
        return f.DidChangeTransform()
    }
    _DrawLayerOwnTextureToRenderTarget(a, b, c, d)
    {
        const e = this._effectList.GetActiveEffectTypes(),
            f = this._runtime;
        0 === e.length ? (a.SetRenderTarget(c), a.SetTextureFillMode(), d && 0 === this._blendMode && this.HasDefaultColor() ? a.CopyRenderTarget(b) : (a.SetBlendMode(this._blendMode),
        a.SetColor(this._premultipliedColor), a.DrawRenderTarget(b)), a.InvalidateRenderTarget(b), f.ReleaseAdditionalRenderTarget(b)) : this.GetEffectChain().Render(a, c, {
            contentObject: this,
            blendMode: this.GetBlendMode(),
            devicePixelRatio: f.GetEffectDevicePixelRatioParam(),
            layerScale: f.GetEffectLayerScaleParam() * this.GetNormalScale(),
            layerAngle: this.GetAngle(),
            layoutRect: this.GetViewport(),
            drawSurfaceRect: null,
            invalidateRenderTargets: !0
        })
    }
    GetOwnScale()
    {
        return this._scale
    }
    SetOwnScale(a)
    {
        this._scale !== a && (this._scale =
        a, this._layout.BoundScrolling(), this._SetMVMatrixChanged(), this._runtime.UpdateRender())
    }
    GetRenderScale()
    {
        return this.GetNormalScale() * this._runtime.GetRenderScale()
    }
    GetDisplayScale()
    {
        return this.GetNormalScale() * this._runtime.GetDisplayScale()
    }
    GetNormalScale()
    {
        return (this._scale * this._layout.GetScale() - 1) * this._scaleRate + 1
    }
    _MaybeUpdateViewport()
    {
        if (this._isViewportChanged) {
            this._isViewportChanged = !1;
            var a = this._runtime.GetParallaxXOrigin(),
                b = this._runtime.GetParallaxYOrigin(),
                c = (this.GetScrollX() -
                a) * this._parallaxX + a,
                d = (this.GetScrollY() - b) * this._parallaxY + b;
            a = this.GetNormalScale();
            b = this._runtime.GetViewportWidth() / a;
            a = this._runtime.GetViewportHeight() / a;
            c -= b / 2;
            var e = d - a / 2;
            this._runtime.IsPixelRoundingEnabled() && (c = Math.round(c), e = Math.round(e));
            d = this._viewportZ0;
            d.set(c, e, c + b, e + a);
            b = this.GetAngle();
            0 !== b && (tmpRect$jscomp$2.copy(d), tmpRect$jscomp$2.offset(-d.midX(), -d.midY()), tmpQuad$jscomp$2.setFromRotatedRect(tmpRect$jscomp$2, b), tmpQuad$jscomp$2.getBoundingBox(tmpRect$jscomp$2), tmpRect$jscomp$2.offset(d.midX(),
            d.midY()), d.copy(tmpRect$jscomp$2));
            b = this._zElevation;
            this.GetViewportForZ(b, this._viewport);
            this.Has3DCamera() ? this.CalculateViewport3D(b, this._viewport3D) : this._viewport3D.copy(this._viewport)
        }
    }
    CalculateViewport3D(a, b)
    {
        var c = this._runtime.GetCanvasManager(),
            d = c.GetCssWidth();
        c = c.GetCssHeight();
        const [e, f] = this.CanvasCssToLayer(0, 0, a),
            [g, h] = this.CanvasCssToLayer(d, 0, a),
            [k, l] = this.CanvasCssToLayer(d, c, a),
            [m, n] = this.CanvasCssToLayer(0, c, a);
        a = Math.min(e, g, k, m);
        d = Math.min(f, h, l, n);
        c = Math.max(e, g, k,
        m);
        let p = Math.max(f, h, l, n);
        isFinite(a) || (a = -Infinity);
        isFinite(d) || (d = -Infinity);
        isFinite(c) || (c = Infinity);
        isFinite(p) || (p = Infinity);
        b.set(a, d, c, p)
    }
    CanvasCssToLayer(a, b, c=0)
    {
        return this._CanvasToLayer(a, b, c, this.GetDisplayScale())
    }
    DrawSurfaceToLayer(a, b, c=0)
    {
        return this._CanvasToLayer(a, b, c, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _CanvasToLayer(a, b, c, d)
    {
        var e = this._runtime,
            f = e.GetRenderer();
        const g = this.GetNormalScale(),
            h = e.GetViewportWidth() / g;
        e = e.GetViewportHeight() / g;
        vec4$jscomp$4.set(tempVec4$jscomp$1,
        0, 0, h, e);
        a /= d;
        b = tempVec4$jscomp$1[3] - b / d;
        d = this._GetProjectionMatrix(f);
        f = this._GetModelViewMatrix(f);
        return C3$jscomp$105.Gfx.UnprojectScreenToWorldZ(a, b, c, f, d, tempVec4$jscomp$1, tempVec3) ? [tempVec3[0], tempVec3[1]] : [NaN, NaN]
    }
    CanvasCssToLayer_DefaultTransform(a, b)
    {
        const c = this._scale,
            d = this._scaleRate,
            e = this._parallaxX,
            f = this._parallaxY,
            g = this._angle;
        this._parallaxY = this._parallaxX = this._scaleRate = this._scale = 1;
        this._angle = 0;
        this._SetMVMatrixChanged();
        a = this.CanvasCssToLayer(a, b);
        this._scale = c;
        this._scaleRate =
        d;
        this._parallaxX = e;
        this._parallaxY = f;
        this._angle = g;
        this._SetMVMatrixChanged();
        return a
    }
    LayerToCanvasCss(a, b, c=0)
    {
        return this._LayerToCanvas(a, b, c, this.GetDisplayScale())
    }
    LayerToDrawSurface(a, b, c=0)
    {
        return this._LayerToCanvas(a, b, c, this.GetRenderScale() * this.GetDevicePixelRatio())
    }
    _LayerToCanvas(a, b, c, d)
    {
        var e = this._runtime,
            f = e.GetRenderer();
        const g = this.GetNormalScale();
        var h = e.GetViewportWidth() / g;
        e = e.GetViewportHeight() / g;
        vec4$jscomp$4.set(tempVec4$jscomp$1, 0, 0, h, e);
        h = this._GetProjectionMatrix(f);
        f = this._GetModelViewMatrix(f);
        return C3$jscomp$105.Gfx.Project(a, b, c, f, h, tempVec4$jscomp$1, tempVec3) ? [tempVec3[0] * d, (tempVec4$jscomp$1[3] - tempVec3[1]) * d] : [NaN, NaN]
    }
    _GetLayerToDrawSurfaceScale(a, b)
    {
        a *= this.GetRenderScale() * this.GetDevicePixelRatio();
        0 !== b && (a *= this.Get2DScaleFactorToZ(b));
        return a
    }
    _InstanceBoxToDrawSurface(a)
    {
        var b = a.GetBoundingBox(),
            c = a.GetTotalZElevation();
        a = a.GetDepth();
        const d = c + a,
            e = b.getLeft(),
            f = b.getTop(),
            g = b.getRight();
        b = b.getBottom();
        if (this.Has3DCamera()) {
            if (this._IsPointBehindNearPlane(e,
            f, c) || this._IsPointBehindNearPlane(g, f, c) || this._IsPointBehindNearPlane(g, b, c) || this._IsPointBehindNearPlane(e, b, c) || 0 < a && (this._IsPointBehindNearPlane(e, f, d) || this._IsPointBehindNearPlane(g, f, d) || this._IsPointBehindNearPlane(g, b, d) || this._IsPointBehindNearPlane(e, b, d)))
                return null
        } else if (d >= this.Get2DCameraZ())
            return null;
        let [h, k] = this.LayerToDrawSurface(e, f, c),
            [l, m] = this.LayerToDrawSurface(g, b, c);
        if (0 !== this.GetAngle() || 0 < a || this.Has3DCamera()) {
            const [n, p] = this.LayerToDrawSurface(g, f, c),
                [q, r] =
                this.LayerToDrawSurface(e, b, c);
            if (0 < a) {
                const [t, u] = this.LayerToDrawSurface(e, f, d),
                    [v, w] = this.LayerToDrawSurface(g, f, d),
                    [x, y] = this.LayerToDrawSurface(g, b, d),
                    [z, A] = this.LayerToDrawSurface(e, b, d);
                c = Math.min(h, l, n, q, t, v, x, z);
                l = Math.max(h, l, n, q, t, v, x, z);
                h = c;
                c = Math.min(k, m, p, r, u, w, y, A);
                m = Math.max(k, m, p, r, u, w, y, A);
                k = c
            } else
                c = Math.min(h, l, n, q),
                l = Math.max(h, l, n, q),
                h = c,
                c = Math.min(k, m, p, r),
                m = Math.max(k, m, p, r),
                k = c
        }
        tmpRect$jscomp$2.set(h, k, l, m);
        return tmpRect$jscomp$2
    }
    _GetViewFrustum()
    {
        this._isViewFrustumChanged &&
        (this._UpdateViewFrustum(), this._isViewFrustumChanged = !1);
        return this._viewFrustum
    }
    _UpdateViewFrustum()
    {
        var a = this._runtime.GetRenderer();
        const b = this._GetProjectionMatrix(a);
        a = this._GetModelViewMatrix(a);
        this._viewFrustum.CalculatePlanes(a, b)
    }
    _IsPointBehindNearPlane(a, b, c)
    {
        return this._GetViewFrustum().IsBehindNearPlane(a, b, c)
    }
    _SaveToJson()
    {
        return {
            d: this.IsDynamic(),
            s: this.GetOwnScale(),
            a: this.GetOwnAngle(),
            v: this._IsVisibleFlagSet(),
            i: this.IsInteractive(),
            html: this.IsHTMLElementsLayer(),
            bc: this._backgroundColor.toJSON(),
            t: this.IsTransparent(),
            sx: this._scrollX,
            sy: this._scrollY,
            hosp: this._hasOwnScrollPosition,
            px: this.GetParallaxX(),
            py: this.GetParallaxY(),
            c: this._color.toJSON(),
            sr: this.GetScaleRate(),
            fx: this._effectList.SaveToJson(),
            cg: this._createdGlobalUids
        }
    }
    _LoadFromJson(a)
    {
        this._isDynamic = !!a.d;
        this._scale = a.s;
        this._angle = a.a;
        this._isVisible = !!a.v;
        this._isInteractive = a.hasOwnProperty("i") ? a.i : !0;
        this._isHTMLElementsLayer = !!a.html;
        this._backgroundColor.setFromJSON(a.bc);
        this._isTransparent = !!a.t;
        a.hasOwnProperty("sx") &&
        (this._scrollX = a.sx);
        a.hasOwnProperty("sy") && (this._scrollY = a.sy);
        a.hasOwnProperty("hosp") && (this._hasOwnScrollPosition = !!a.hosp);
        this._parallaxX = a.px;
        this._parallaxY = a.py;
        this._color.setFromJSON(a.c);
        this._UpdatePremultipliedColor();
        this._scaleRate = a.sr;
        C3$jscomp$105.shallowAssignArray(this._createdGlobalUids, a.cg);
        C3$jscomp$105.shallowAssignArray(this._initialInstances, this._startupInitialInstances);
        const b = new Set(this._createdGlobalUids);
        let c = 0;
        for (let d = 0, e = this._initialInstances.length; d < e; ++d)
            b.has(this._initialInstances[d][2]) ||
            (this._initialInstances[c] = this._initialInstances[d], ++c);
        C3$jscomp$105.truncateArray(this._initialInstances, c);
        this._effectList.LoadFromJson(a.fx);
        this._needsRebuildEffectChainSteps = !0
    }
    _LoadFromJsonAfterInstances()
    {
        this._SortInstancesByLastCachedZIndex(!1);
        this.SetZIndicesChanged();
        this._SetMVMatrixChanged();
        this._SetProjectionMatrixChanged()
    }
    GetILayer()
    {
        return this._iLayer
    }
    SortAndAddInstancesByZIndex(a, b=!1)
    {
        if (this._instances.includes(a))
            b && this._instances.sort((e, f) => {
                e = e.GetWorldInfo().GetSceneGraphZIndex();
                f = f.GetWorldInfo().GetSceneGraphZIndex();
                return e - f
            });
        else if (a.HasChildren()) {
            var c = [...a.allChildren()];
            c.push(a);
            c.sort((e, f) => {
                e = e.GetWorldInfo().GetSceneGraphZIndex();
                f = f.GetWorldInfo().GetSceneGraphZIndex();
                return e - f
            });
            for (var d of c)
                if (d.IsInContainer())
                    for (const e of d.siblings())
                        c.includes(e) || (a = [...e.allChildren()], a.push(e), a.sort((f, g) => {
                            f = f.GetWorldInfo().GetSceneGraphZIndex();
                            g = g.GetWorldInfo().GetSceneGraphZIndex();
                            return f - g
                        }), a && a.length && c.splice(c.length, 0, ...a));
            for (const e of c)
                e.GetPlugin().IsWorldType() &&
                this._AddInstance(e, !0)
        } else if (a.GetPlugin().IsWorldType() && this._AddInstance(a, !0), a.IsInContainer())
            for (c of a.siblings())
                if (d = [...c.allChildren()], d.push(c), d.sort((e, f) => {
                    e = e.GetWorldInfo().GetSceneGraphZIndex();
                    f = f.GetWorldInfo().GetSceneGraphZIndex();
                    return e - f
                }), d && d.length)
                    for (const e of d)
                        e.GetPlugin().IsWorldType() && this._AddInstance(e, !0)
    }
}
;
"use strict";
const C3$jscomp$106 = self.C3,
    C3Debugger = self.C3Debugger;
C3$jscomp$106.New(C3$jscomp$106.Rect);
C3$jscomp$106.New(C3$jscomp$106.Rect);
const tempLayoutRect = C3$jscomp$106.New(C3$jscomp$106.Rect),
    tempColor$jscomp$4 = C3$jscomp$106.New(C3$jscomp$106.Color),
    vec3$jscomp$6 = self.glMatrix.vec3,
    tempRender3dList = [],
    tempInstanceList1$jscomp$1 = [],
    tempInstanceList2$jscomp$1 = [],
    tempInstanceList3 = [];
function vec3EqualsXYZ(a, b, c, d) {
    return a[0] === Math.fround(b) && a[1] === Math.fround(c) && a[2] === Math.fround(d)
}
let lastLayerPreparedForDrawing = null;
function MaybePrepareLayerDraw(a, b) {
    lastLayerPreparedForDrawing !== a && (a.PrepareForDraw(b), lastLayerPreparedForDrawing = a)
}
C3$jscomp$106.Layout = class  extends C3$jscomp$106.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._layoutManager = a;
        this._runtime = a.GetRuntime();
        this._name = c[0];
        this._originalWidth = c[1];
        this._originalHeight = c[2];
        this._width = c[1];
        this._height = c[2];
        this._isUnboundedScrolling = !!c[3];
        this._isOrthographicProjection = !!c[4];
        this._vanishingPointX = c[5];
        this._vanishingPointY = c[6];
        this._eventSheetName = c[7];
        this._eventSheet = null;
        this._sid = c[8];
        this._index = b;
        this._scrollY = this._scrollX = 0;
        this._scale = 1;
        this._angle =
        0;
        this._initialObjectClasses = new Set;
        this._textureLoadedTypes = new Set;
        this._textureLoadPendingPromises = new Set;
        this._createdInstances = [];
        this._createdPersistedInstances = [];
        this._createdPersistedInstancesToDataMap = new Map;
        this._createdPersistedIndexToInstanceMap = new Map;
        this._initialNonWorld = [];
        this._is3dCameraEnabled = !1;
        this._cam3dposition = vec3$jscomp$6.create();
        this._cam3dlook = vec3$jscomp$6.create();
        this._cam3dup = vec3$jscomp$6.create();
        this._rootLayers = [];
        this._allLayersFlat = [];
        this._layersByName =
        new Map;
        this._layersBySid = new Map;
        this._pendingSetHTMLLayerCount = -1;
        const d = this._runtime.GetCanvasManager();
        this._effectList = C3$jscomp$106.New(C3$jscomp$106.EffectList, this, c[11]);
        this._effectChain = C3$jscomp$106.New(C3$jscomp$106.Gfx.EffectChain, d.GetEffectChainManager(), {
            drawContent: (e, f) => {
                f = f.GetContentObject().GetRenderTarget();
                e.ResetColor();
                e.DrawRenderTarget(f);
                e.InvalidateRenderTarget(f);
                d.ReleaseAdditionalRenderTarget(f)
            },
            getShaderParameters: e => this.GetEffectList()._GetEffectChainShaderParametersForIndex(e)
        });
        this._needsRebuildEffectChainSteps = !0;
        this._wasFullScreenQualityLow = !1;
        this._curRenderTarget = null;
        this._persistData = {};
        this._persistedIntances = new Map;
        this._isFirstVisit = !0;
        this._iLayout = new self.ILayout(this);
        this._userScriptDispatcher = C3$jscomp$106.New(C3$jscomp$106.Event.Dispatcher);
        for (const e of c[9])
            this._rootLayers.push(C3$jscomp$106.Layer.CreateFromExportData(this, null, e));
        this._ReindexLayers();
        for (const e of this.allLayers())
            e._InitInitialInstances();
        for (const e of c[10]) {
            a = this._runtime.GetObjectClassByIndex(e[1]);
            if (!a)
                throw Error("missing nonworld object class");
            a.GetDefaultInstanceData() || a.SetDefaultInstanceData(e);
            this._initialNonWorld.push(e);
            this._AddInitialObjectClass(a)
        }
    }
    Release()
    {
        for (const a of this._allLayersFlat)
            a.Release();
        C3$jscomp$106.clearArray(this._allLayersFlat);
        this._textureLoadPendingPromises.clear();
        this._runtime = this._layoutManager = this._eventSheet = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetName()
    {
        return this._name
    }
    GetSID()
    {
        return this._sid
    }
    GetIndex()
    {
        return this._index
    }
    GetEffectList()
    {
        return this._effectList
    }
    GetEffectChain()
    {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    _MaybeRebuildEffectChainSteps()
    {
        const a = "low" === this._runtime.GetCanvasManager().GetCurrentFullscreenScalingQuality();
        if (this._needsRebuildEffectChainSteps || this._wasFullScreenQualityLow !== a || this._effectChain.NeedsRebuild()) {
            var b = this.GetEffectList().GetActiveEffectTypes();
            this._effectChain.BuildSteps(b.map(c => c.GetShaderProgram()), {
                indexMap: b.map(c => c.GetIndex()),
                forcePostDraw: a,
                useFullSurface: !0
            });
            this._needsRebuildEffectChainSteps = !1;
            this._wasFullScreenQualityLow = a
        }
    }
    UpdateActiveEffects()
    {
        this.GetEffectList().UpdateActiveEffects();
        this._needsRebuildEffectChainSteps = !0
    }
    GetMinLayerScale()
    {
        let a = this._allLayersFlat[0].GetNormalScale();
        for (let b = 1, c = this._allLayersFlat.length; b < c; ++b) {
            const d = this._allLayersFlat[b];
            if (0 !== d.GetParallaxX() || 0 !== d.GetParallaxY())
                a = Math.min(a, d.GetNormalScale())
        }
        return a
    }
    _GetScrollBoundMarginHorizontal()
    {
        return .5 * this._runtime.GetViewportWidth() / this.GetMinLayerScale()
    }
    _GetScrollBoundMarginVertical()
    {
        return .5 * this._runtime.GetViewportHeight() / this.GetMinLayerScale()
    }
    GetScrollLeftBound()
    {
        return this.IsUnboundedScrolling() ?
        -Infinity : this._GetScrollBoundMarginHorizontal()
    }
    GetScrollRightBound()
    {
        return this.IsUnboundedScrolling() ? Infinity : this.GetWidth() - this._GetScrollBoundMarginHorizontal()
    }
    GetScrollTopBound()
    {
        return this.IsUnboundedScrolling() ? -Infinity : this._GetScrollBoundMarginVertical()
    }
    GetScrollBottomBound()
    {
        return this.IsUnboundedScrolling() ? Infinity : this.GetHeight() - this._GetScrollBoundMarginVertical()
    }
    SetScrollX(a)
    {
        const b = this.GetScrollLeftBound(),
            c = this.GetScrollRightBound();
        a > c && (a = c);
        a < b && (a = b);
        this._scrollX !==
        a && (this._scrollX = a, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    GetScrollX()
    {
        return this._scrollX
    }
    SetScrollY(a)
    {
        const b = this.GetScrollTopBound(),
            c = this.GetScrollBottomBound();
        a > c && (a = c);
        a < b && (a = b);
        this._scrollY !== a && (this._scrollY = a, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    GetScrollY()
    {
        return this._scrollY
    }
    IsUnboundedScrolling()
    {
        return this._isUnboundedScrolling
    }
    BoundScrolling()
    {
        this.SetScrollX(this.GetScrollX());
        this.SetScrollY(this.GetScrollY());
        for (const a of this._allLayersFlat)
            a.IsOwnScrollPositionEnabled() &&
            (a.SetScrollX(a.GetScrollX()), a.SetScrollY(a.GetScrollY()))
    }
    SetVanishingPointXY(a, b)
    {
        if (this._vanishingPointX !== a || this._vanishingPointY !== b)
            this._vanishingPointX = a,
            this._vanishingPointY = b,
            this.IsPerspectiveProjection() && (this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    GetVanishingPointX()
    {
        return this.IsOrthographicProjection() ? .5 : this._vanishingPointX
    }
    GetVanishingPointY()
    {
        return this.IsOrthographicProjection() ? .5 : this._vanishingPointY
    }
    HasVanishingPointOutsideViewport()
    {
        const a =
            this.GetVanishingPointX(),
            b = this.GetVanishingPointY();
        return 0 > a || 1 < a || 0 > b || 1 < b
    }
    SetPerspectiveProjection()
    {
        this._isOrthographicProjection && (this._isOrthographicProjection = !1, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    SetOrthographicProjection()
    {
        this._isOrthographicProjection || (this._isOrthographicProjection = !0, this._SetAllLayersProjectionChanged(), this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    IsOrthographicProjection()
    {
        return this._isOrthographicProjection
    }
    IsPerspectiveProjection()
    {
        return !this.IsOrthographicProjection()
    }
    Set3DCameraEnabled(a)
    {
        a =
        !!a;
        this._is3dCameraEnabled !== a && (this._is3dCameraEnabled = a, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    Is3DCameraEnabled()
    {
        return this._is3dCameraEnabled
    }
    Set3DCameraOrientation(a, b, c, d, e, f, g, h, k)
    {
        vec3EqualsXYZ(this._cam3dposition, a, b, c) && vec3EqualsXYZ(this._cam3dlook, d, e, f) && vec3EqualsXYZ(this._cam3dup, g, h, k) || (vec3$jscomp$6.set(this._cam3dposition, a, b, c), vec3$jscomp$6.set(this._cam3dlook, d, e, f), vec3$jscomp$6.set(this._cam3dup, g, h, k), this.Set3DCameraChanged())
    }
    Set3DCameraChanged()
    {
        this._SetAllLayersMVChanged();
        this._runtime.UpdateRender()
    }
    Get3DCameraPosition()
    {
        return this._cam3dposition
    }
    Get3DCameraLookAt()
    {
        return this._cam3dlook
    }
    Get3DCameraUpVector()
    {
        return this._cam3dup
    }
    GetScale()
    {
        return this._scale
    }
    SetScale(a)
    {
        this._scale !== a && (this._scale = a, this._SetAllLayersMVChanged(), this.BoundScrolling(), this._runtime.UpdateRender())
    }
    SetAngle(a)
    {
        a = C3$jscomp$106.clampAngle(a);
        this._angle !== a && (this._angle = a, this._SetAllLayersMVChanged(), this._runtime.UpdateRender())
    }
    GetAngle()
    {
        return this._angle
    }
    GetWidth()
    {
        return this._width
    }
    SetWidth(a)
    {
        !isFinite(a) ||
        1 > a || (this._width = a)
    }
    GetHeight()
    {
        return this._height
    }
    SetHeight(a)
    {
        !isFinite(a) || 1 > a || (this._height = a)
    }
    GetEventSheet()
    {
        return this._eventSheet
    }
    _GetRootLayers()
    {
        return this._rootLayers
    }
    *allLayers()
    {
        for (const a of this._rootLayers)
            yield *a.selfAndAllSubLayers()
    }
    GetLayers()
    {
        return this._allLayersFlat
    }
    GetLayerCount()
    {
        return this._allLayersFlat.length
    }
    GetLayer(a)
    {
        return "number" === typeof a ? this.GetLayerByIndex(a) : this.GetLayerByName(a.toString())
    }
    GetLayerByIndex(a)
    {
        a = C3$jscomp$106.clamp(Math.floor(a), 0, this._allLayersFlat.length -
        1);
        return this._allLayersFlat[a]
    }
    GetLayerByName(a)
    {
        return this._layersByName.get(a.toLowerCase()) || null
    }
    HasLayerByName(a)
    {
        return !!this.GetLayerByName(a)
    }
    GetLayerBySID(a)
    {
        return this._layersBySid.get(a) || null
    }
    _SetAllLayersProjectionChanged()
    {
        for (const a of this._allLayersFlat)
            a._SetProjectionMatrixChanged()
    }
    _SetAllLayersMVChanged()
    {
        for (const a of this._allLayersFlat)
            a._SetMVMatrixChanged()
    }
    AddLayer(a, b, c)
    {
        if (this.HasLayerByName(a))
            throw Error(`layer name '${a}' already in use`);
        if (!b && 2 > c)
            throw Error("invalid insert position");
        const d = 2 <= c ? b : b.GetParentLayer();
        a = C3$jscomp$106.New(C3$jscomp$106.Layer, this, d, {
            name: a,
            sid: Math.floor(1E15 * Math.random()),
            isDynamic: !0
        });
        this._InsertLayer(a, b, c);
        this.GetRuntime().UpdateRender();
        this._ReindexAndUpdateAllLayers()
    }
    MoveLayer(a, b, c)
    {
        if (!b && 2 > c)
            throw Error("invalid insert position");
        a === b && 2 > c || (this._RemoveLayer(a), this._InsertLayer(a, b, c), this.GetRuntime().UpdateRender(), this._ReindexAndUpdateAllLayers())
    }
    RemoveLayer(a)
    {
        if (this._RemoveLayer(a)) {
            const b = this._runtime.GetEventSheetManager();
            b.BlockFlushingInstances(!0);
            a.Release();
            b.BlockFlushingInstances(!1);
            this.GetRuntime().UpdateRender();
            this._ReindexAndUpdateAllLayers()
        }
    }
    RemoveAllDynamicLayers()
    {
        const a = new Set;
        for (var b of this.allLayers())
            b.IsDynamic() && !b.HasAnyDynamicParentLayer() && a.add(b);
        if (0 !== a.size) {
            b = this._runtime.GetEventSheetManager();
            b.BlockFlushingInstances(!0);
            for (const c of a)
                this._RemoveLayer(c),
                c.Release();
            b.BlockFlushingInstances(!1);
            this.GetRuntime().UpdateRender();
            this._ReindexAndUpdateAllLayers()
        }
    }
    _InsertLayer(a,
    b, c)
    {
        if (2 <= c)
            if (b) {
                if (b === a || b.HasParentLayer(a))
                    throw Error(`cannot move layer '${a.GetName()}' to sub-layer of itself`);
                b._AddSubLayer(a, 2 === c);
                a._SetParentLayer(b)
            } else
                2 === c ? this._rootLayers.push(a) : this._rootLayers.unshift(a),
                a._SetParentLayer(null);
        else {
            const d = b.GetParentLayer();
            if (d) {
                if (b.HasParentLayer(a))
                    throw Error(`cannot move layer '${a.GetName()}' to sub-layer of itself`);
                d._InsertSubLayer(a, b, 0 === c);
                a._SetParentLayer(d)
            } else {
                b = this._rootLayers.indexOf(b);
                if (-1 === b)
                    throw Error("cannot find layer to insert by");
                0 === c && ++b;
                this._rootLayers.splice(b, 0, a);
                a._SetParentLayer(null)
            }
        }
    }
    _RemoveLayer(a)
    {
        const b = a.GetParentLayer();
        if (b)
            return b._RemoveSubLayer(a), !0;
        if (1 < this._rootLayers.length) {
            a = this._rootLayers.indexOf(a);
            if (-1 === a)
                throw Error("cannot find layer to remove");
            this._rootLayers.splice(a, 1);
            return !0
        }
        return !1
    }
    _ReindexLayers()
    {
        this._allLayersFlat = [...this.allLayers()];
        this._layersByName.clear();
        this._layersBySid.clear();
        for (let a = 0, b = this._allLayersFlat.length; a < b; ++a) {
            const c = this._allLayersFlat[a];
            c._SetIndex(a);
            this._layersByName.set(c.GetName().toLowerCase(), c);
            this._layersBySid.set(c.GetSID(), c)
        }
    }
    _ReindexHTMLLayers()
    {
        let a = 0;
        for (const b of this._rootLayers) {
            for (const c of b.selfAndAllSubLayers())
                c._SetHTMLIndex(a);
            b.IsHTMLElementsLayer() && a++
        }
    }
    GetHTMLLayerCount()
    {
        return this._rootLayers.at(-1).GetHTMLIndex() + 1
    }
    async _ReindexAndUpdateAllLayers()
    {
        this._ReindexLayers();
        this._ReindexHTMLLayers();
        this._pendingSetHTMLLayerCount = this.GetHTMLLayerCount()
    }
    _GetPendingSetHTMLLayerCount()
    {
        return this._pendingSetHTMLLayerCount
    }
    _ResetPendingHTMLLayerCount()
    {
        this._pendingSetHTMLLayerCount =
        -1
    }
    GetRootLayersForHTMLLayer(a)
    {
        const b = [];
        for (const c of this._rootLayers) {
            const d = c.GetHTMLIndex();
            if (d === a)
                b.push(c);
            else if (d > a)
                break
        }
        return b
    }
    SaveTransform()
    {
        return {
            scrollX: this.GetScrollX(),
            scrollY: this.GetScrollY(),
            scale: this.GetScale(),
            angle: this.GetAngle(),
            vpX: this.GetVanishingPointX(),
            vpY: this.GetVanishingPointY()
        }
    }
    RestoreTransform(a)
    {
        this.SetScrollX(a.scrollX);
        this.SetScrollY(a.scrollY);
        this.SetScale(a.scale);
        this.SetAngle(a.angle);
        this.SetVanishingPointXY(a.vpX, a.vpY)
    }
    GetLayoutBackgroundColor()
    {
        let a =
        this._rootLayers.filter(b => b.ShouldDraw())[0];
        for (; a;) {
            if (!a.IsTransparent())
                return tempColor$jscomp$4.copyRgb(a.GetBackgroundColor()), tempColor$jscomp$4.setA(1), tempColor$jscomp$4;
            if (a.UsesOwnTexture())
                return tempColor$jscomp$4.setRgba(0, 0, 0, 0), tempColor$jscomp$4;
            a = a.GetSubLayers().filter(b => b.ShouldDraw())[0]
        }
        tempColor$jscomp$4.setRgba(0, 0, 0, 0);
        return tempColor$jscomp$4
    }
    IsFirstVisit()
    {
        return this._isFirstVisit
    }
    _GetInitialObjectClasses()
    {
        return [...this._initialObjectClasses]
    }
    _AddInitialObjectClass(a)
    {
        if (a.IsInContainer())
            for (const b of a.GetContainer().GetObjectTypes())
                this._initialObjectClasses.add(b);
        else
            this._initialObjectClasses.add(a)
    }
    _GetTextureLoadedObjectTypes()
    {
        return [...this._textureLoadedTypes]
    }
    _Load(a, b)
    {
        if (a === this || !b)
            return Promise.resolve();
        a && (C3$jscomp$106.CopySet(this._textureLoadedTypes, a._textureLoadedTypes), a._textureLoadedTypes.clear());
        a = [];
        for (const c of this._initialObjectClasses)
            this._textureLoadedTypes.has(c) || (a.push(c.LoadTextures(b)), this._textureLoadedTypes.add(c));
        return Promise.all(a)
    }
    async MaybeLoadTexturesFor(a)
    {
        if (a.IsFamily())
            throw Error("cannot load textures for family");
        var b = this._runtime.GetRenderer();
        !b || b.IsContextLost() || this._textureLoadedTypes.has(a) || (this._textureLoadedTypes.add(a), b = a.LoadTextures(b), this._AddPendingTextureLoadPromise(b), await b, a.OnDynamicTextureLoadComplete(), this._runtime.UpdateRender())
    }
    _AddPendingTextureLoadPromise(a)
    {
        this._textureLoadPendingPromises.add(a);
        a.then(() => this._textureLoadPendingPromises.delete(a)).catch(() => this._textureLoadPendingPromises.delete(a))
    }
    WaitForPendingTextureLoadsToComplete()
    {
        return Promise.all([...this._textureLoadPendingPromises])
    }
    MaybeUnloadTexturesFor(a)
    {
        if (a.IsFamily() ||
        0 < a.GetInstanceCount())
            throw Error("cannot unload textures");
        const b = this._runtime.GetRenderer();
        b && this._textureLoadedTypes.has(a) && (this._textureLoadedTypes.delete(a), a.ReleaseTextures(b))
    }
    _Unload(a, b)
    {
        if (a !== this && b)
            for (const c of this._textureLoadedTypes)
                c.IsGlobal() || a._initialObjectClasses.has(c) || (c.ReleaseTextures(), this._textureLoadedTypes.delete(c))
    }
    _OnRendererContextLost()
    {
        this._textureLoadedTypes.clear()
    }
    async _StartRunning(a)
    {
        const b = this._runtime,
            c = this._layoutManager,
            d = b.GetEventSheetManager();
        this._eventSheetName && (this._eventSheet = d.GetEventSheetByName(this._eventSheetName), this._eventSheet._UpdateDeepIncludes());
        c._SetMainRunningLayout(this);
        this._width = this._originalWidth;
        this._height = this._originalHeight;
        this._scrollX = b.GetOriginalViewportWidth() / 2;
        this._scrollY = b.GetOriginalViewportHeight() / 2;
        this.BoundScrolling();
        this._SetAllLayersProjectionChanged();
        this._SetAllLayersMVChanged();
        this._ReindexHTMLLayers();
        await this._runtime.GetCanvasManager().SetHTMLLayerCount(this.GetHTMLLayerCount(),
        !0);
        this._MoveGlobalObjectsToThisLayout(a);
        this._runtime.SetUsingCreatePromises(!0);
        this._CreateInitialInstances();
        this._isFirstVisit || this._CreatePersistedInstances();
        this._CreateAndLinkContainerInstances(this._createdInstances);
        this._CreateAndLinkContainerInstances(this._createdPersistedInstances);
        this._CreateInitialNonWorldInstances();
        c.ClearPendingChangeLayout();
        b.FlushPendingInstances();
        this._runtime.SetUsingCreatePromises(!1);
        var e = this._runtime.GetCreatePromises();
        await Promise.all(e);
        C3$jscomp$106.clearArray(e);
        if (!b.IsLoadingState()) {
            for (const f of this._createdInstances)
                f.SetupInitialSceneGraphConnections();
            for (const f of this._createdPersistedInstances)
                f.SetupPersistedSceneGraphConnections(this._createdPersistedInstancesToDataMap, this._createdPersistedIndexToInstanceMap);
            for (const [f, g] of Object.entries(this._persistData))
                (e = this._runtime.GetObjectClassBySID(parseInt(f, 10))) && !e.IsFamily() && e.HasPersistBehavior() && C3$jscomp$106.clearArray(g);
            for (const f of this._createdInstances)
                f._TriggerOnCreated();
            for (const f of this._createdPersistedInstances)
                f._TriggerOnCreated()
        }
        C3$jscomp$106.clearArray(this._createdInstances);
        C3$jscomp$106.clearArray(this._createdPersistedInstances);
        this._createdPersistedInstancesToDataMap.clear();
        this._createdPersistedIndexToInstanceMap.clear();
        await Promise.all([...this._initialObjectClasses].map(f => f.PreloadTexturesWithInstances(this._runtime.GetRenderer())));
        a && (b.Dispatcher().dispatchEvent(new C3$jscomp$106.Event("beforefirstlayoutstart")), await b.DispatchUserScriptEventAsyncWait(new C3$jscomp$106.Event("beforeprojectstart")));
        await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$106.Event("beforeanylayoutstart"));
        b.Dispatcher().dispatchEvent(new C3$jscomp$106.Event("beforelayoutstart"));
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$106.Event("beforelayoutstart"));
        b.IsLoadingState() || await b.TriggerAsync(C3$jscomp$106.Plugins.System.Cnds.OnLayoutStart, null, null);
        b.Dispatcher().dispatchEvent(new C3$jscomp$106.Event("afterlayoutstart"));
        await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$106.Event("afterlayoutstart"));
        await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$106.Event("afteranylayoutstart"));
        a && (b.Dispatcher().dispatchEvent(new C3$jscomp$106.Event("afterfirstlayoutstart")), await b.DispatchUserScriptEventAsyncWait(new C3$jscomp$106.Event("afterprojectstart")));
        d._RunQueuedTriggers(c);
        await this.WaitForPendingTextureLoadsToComplete();
        this._isFirstVisit = !1
    }
    _MoveGlobalObjectsToThisLayout(a)
    {
        for (const c of this._runtime.GetAllObjectClasses())
            if (!c.IsFamily() && c.IsWorldType())
                for (const d of c.GetInstances()) {
                    const e =
                    d.GetWorldInfo();
                    var b = e.GetLayer();
                    b = C3$jscomp$106.clamp(b.GetIndex(), 0, this._allLayersFlat.length - 1);
                    b = this._allLayersFlat[b];
                    e._SetLayer(b, !0);
                    b._MaybeAddInstance(d)
                }
        if (!a)
            for (const c of this._allLayersFlat)
                c._SortInstancesByLastCachedZIndex(!1)
    }
    _CreateInitialInstances()
    {
        for (const a of this._allLayersFlat)
            a.CreateInitialInstances(this._createdInstances),
            a._Start()
    }
    _CreatePersistedInstances()
    {
        let a = !1;
        for (const [c, d] of Object.entries(this._persistData)) {
            const e = this._runtime.GetObjectClassBySID(parseInt(c,
            10));
            if (e && !e.IsFamily() && e.HasPersistBehavior())
                for (const f of d) {
                    var b = null;
                    if (e.IsWorldType() && (b = f.hasOwnProperty("instJson") ? this.GetLayerBySID(f.instJson.w.l) : this.GetLayerBySID(f.w.l), !b))
                        continue;
                    b = this._runtime.CreateInstanceFromData(e, b, !1, 0, 0, !0);
                    f.hasOwnProperty("instJson") ? b.LoadFromJson(f.instJson) : b.LoadFromJson(f);
                    a = !0;
                    this._createdPersistedInstances.push(b);
                    f.hasOwnProperty("instJson") && (this._createdPersistedInstancesToDataMap.set(b, f), this._createdPersistedIndexToInstanceMap.set(f.index,
                    b))
                }
        }
        for (const c of this._allLayersFlat)
            c._SortInstancesByLastCachedZIndex(!0),
            c.SetZIndicesChanged();
        a && (this._runtime.FlushPendingInstances(), this._runtime._RefreshUidMap())
    }
    _CreateAndLinkContainerInstances(a)
    {
        for (const c of a) {
            if (!c.IsInContainer())
                continue;
            const d = c.GetWorldInfo(),
                e = c.GetIID();
            for (const f of c.GetObjectClass().GetContainer().objectTypes())
                if (f !== c.GetObjectClass()) {
                    var b = f.GetInstances();
                    b.length > e ? c._AddSibling(b[e]) : (b = d ? this._runtime.CreateInstanceFromData(f, d.GetLayer(), !0,
                    d.GetX(), d.GetY(), !0) : this._runtime.CreateInstanceFromData(f, null, !0, 0, 0, !0), this._runtime.FlushPendingInstances(), f._UpdateIIDs(), c._AddSibling(b), a.push(b))
                }
        }
    }
    _CreateInitialNonWorldInstances()
    {
        for (const a of this._initialNonWorld)
            this._runtime.GetObjectClassByIndex(a[1]).IsInContainer() || this._runtime.CreateInstanceFromData(a, null, !0)
    }
    _CreateGlobalNonWorlds()
    {
        const a = [],
            b = this._initialNonWorld;
        let c = 0;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d],
                g = this._runtime.GetObjectClassByIndex(f[1]);
            g.IsGlobal() ?
            g.IsInContainer() && g.GetContainer().HasAnyWorldType() || a.push(this._runtime.CreateInstanceFromData(f, null, !0)) : (b[c] = f, ++c)
        }
        C3$jscomp$106.truncateArray(b, c);
        this._runtime.FlushPendingInstances();
        this._CreateAndLinkContainerInstances(a)
    }
    RecreateInitialObjects(a, b, c, d, e, f, g)
    {
        if (c)
            return c.RecreateInitialObjects(a, b, e, f, d, g);
        c = [];
        for (const h of this._allLayersFlat)
            c.push(h.RecreateInitialObjects(a, b, e, f, d, g));
        return c.flat()
    }
    async _StopRunning()
    {
        const a = this._layoutManager;
        this._runtime.IsLoadingState() ||
        (await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$106.Event("beforeanylayoutend")), await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$106.Event("beforelayoutend")), await this._runtime.TriggerAsync(C3$jscomp$106.Plugins.System.Cnds.OnLayoutEnd, null, null), await this.DispatchUserScriptEventAsyncWait(new C3$jscomp$106.Event("afterlayoutend")), await this.DispatchRuntimeUserScriptEventAsyncWait(new C3$jscomp$106.Event("afteranylayoutend")));
        a.SetIsEndingLayout(!0);
        this._runtime.GetEventSheetManager().ClearAllScheduledWaits();
        this._isFirstVisit || this._SavePersistData();
        for (const b of this._allLayersFlat)
            b._End();
        for (const b of this._runtime.GetAllObjectClasses())
            if (!(b.IsGlobal() || b.IsWorldType() || b.GetPlugin().IsSingleGlobal() || b.IsFamily())) {
                for (const c of b.GetInstances())
                    this._runtime.DestroyInstance(c);
                this._runtime.FlushPendingInstances()
            }
        a.SetIsEndingLayout(!1);
        a.GetMainRunningLayout() === this && a._SetMainRunningLayout(null)
    }
    _SaveInstanceToPersist(a, b)
    {
        var c = a.GetObjectClass().GetSID().toString();
        this._persistData.hasOwnProperty(c) ||
        (this._persistData[c] = []);
        c = this._persistData[c];
        b = {
            index: b,
            instJson: a.SaveToJson(),
            sceneGraphJson: {
                children: []
            }
        };
        c.push(b);
        this._persistedIntances.set(a, b)
    }
    _SaveSceneGraphInfoToPersist(a)
    {
        const b = this._persistedIntances.get(a);
        for (const c of a.GetChildren())
            (a = this._persistedIntances.get(c)) && b.sceneGraphJson.children.push({
                index: a.index,
                flags: C3$jscomp$106.SceneGraphInfo._GetFlagsNumber(c.GetWorldInfo())
            })
    }
    _SavePersistData()
    {
        this._persistedIntances.clear();
        var a = 0;
        for (const b of this._allLayersFlat) {
            b._UpdateZIndices();
            for (const c of b._GetInstances()) {
                const d = c.GetObjectClass();
                !d.IsGlobal() && d.HasPersistBehavior() && (this._SaveInstanceToPersist(c, a), a++)
            }
        }
        for (const b of this._allLayersFlat)
            for (const c of b._GetInstances())
                a = c.GetObjectClass(),
                !a.IsGlobal() && a.HasPersistBehavior() && this._SaveSceneGraphInfoToPersist(c);
        this._persistedIntances.clear()
    }
    ResetPersistData()
    {
        this._persistData = {};
        this._isFirstVisit = !0
    }
    GetRenderTarget()
    {
        return this._curRenderTarget
    }
    UsesOwnTexture()
    {
        const a = this._runtime,
            b = a.GetRenderer().IsWebGL();
        return "low" === a.GetCanvasManager().GetCurrentFullscreenScalingQuality() || b && a.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect() || b && a.Uses3DFeatures()
    }
    _MaybeStartDrawToOwnTexture(a)
    {
        const b = this._runtime.GetCanvasManager();
        this.UsesOwnTexture() ? (a.SetRenderTarget(null), a.ClearRgba(0, 0, 0, 0), a = {
            sampling: this._runtime.GetSampling(),
            isSampled: a.IsWebGPU() || this._runtime.UsesAnyBackgroundBlending() || this._effectList.HasAnyActiveEffect(),
            canReadPixels: a.IsWebGPU() ? this._runtime.UsesAnyBackgroundBlending() :
            !1
        }, "low" === b.GetCurrentFullscreenScalingQuality() && (a.width = b.GetDrawWidth(), a.height = b.GetDrawHeight()), this._curRenderTarget = this._runtime.GetAdditionalRenderTarget(a)) : this._curRenderTarget = null
    }
    _MaybeCopyOwnTextureToBackbuffer(a)
    {
        this._runtime._NeedsHTMLLayerCompositing(a) && (a.SetDepthEnabled(!1), a.SetRenderTarget(null), a.SetTextureFillMode(), a.CopyRenderTarget(this._curRenderTarget))
    }
    _MaybeEndDrawToOwnTexture(a)
    {
        this.UsesOwnTexture() && (a.SetDepthEnabled(!1), this._DrawLayoutOwnTextureToRenderTarget(a,
        this._curRenderTarget))
    }
    DrawMain(a)
    {
        a.SetRenderTarget(this._curRenderTarget);
        a.Clear(this.GetLayoutBackgroundColor());
        this._runtime.Uses3DFeatures() && a.ClearDepth();
        const b = this.GetRootLayersForHTMLLayer(0);
        this._DrawLayerList(a, this._curRenderTarget, b, !0);
        a.IsWebGPU() && a.StartMeasuringRenderPassTime(0, 1);
        this._MaybeEndDrawToOwnTexture(a);
        this._curRenderTarget = null
    }
    DrawForHTMLLayerIndex(a, b)
    {
        let c = null;
        this._runtime._NeedsHTMLLayerCompositing(a) && (c = this._curRenderTarget);
        a.SetRenderTarget(c);
        a.ClearRgba(0,
        0, 0, 0);
        this._runtime.Uses3DFeatures() && a.ClearDepth();
        const d = this.GetRootLayersForHTMLLayer(b);
        this._DrawLayerList(a, c, d, !0);
        this._MaybeCopyOwnTextureToBackbuffer(a);
        a.EndBatch();
        this._runtime.GetCanvasManager().BlitMainCanvasToHTMLLayerCanvas(b)
    }
    _DrawLayerList(a, b, c, d)
    {
        c = c.filter(e => e.ShouldDraw());
        for (let e = 0, f = c.length; e < f;) {
            const g = c[e];
            if (g.SelfAndAllSubLayersHave3DCamera() && !g.SelfOrAnySubLayerUsesOwnTexture()) {
                tempRender3dList.push(g);
                for (let h = e + 1; h < f; ++h) {
                    const k = c[h];
                    if (k.SelfAndAllSubLayersHave3DCamera() &&
                    !k.SelfOrAnySubLayerUsesOwnTexture())
                        tempRender3dList.push(c[h]);
                    else
                        break
                }
                if (2 <= tempRender3dList.length || 1 === tempRender3dList.length && tempRender3dList[0].HasAnyVisibleSubLayer()) {
                    this._Draw3DLayers(a, b, tempRender3dList);
                    e += tempRender3dList.length;
                    C3$jscomp$106.clearArray(tempRender3dList);
                    continue
                }
                C3$jscomp$106.clearArray(tempRender3dList)
            }
            g.Draw(a, b, d && 0 === e);
            ++e
        }
    }
    _DrawLayoutOwnTextureToRenderTarget(a, b)
    {
        const c = this._effectList.GetActiveEffectTypes(),
            d = this._runtime;
        0 === c.length ? (a.SetRenderTarget(null),
        a.SetTextureFillMode(), a.CopyRenderTarget(b), a.InvalidateRenderTarget(b), d.ReleaseAdditionalRenderTarget(b)) : (tempLayoutRect.set(0, 0, d.GetViewportWidth(), d.GetViewportHeight()), this.GetEffectChain().Render(a, null, {
            contentObject: this,
            blendMode: 3,
            devicePixelRatio: this._runtime.GetEffectDevicePixelRatioParam(),
            layerScale: this._runtime.GetEffectLayerScaleParam() * this.GetScale(),
            layerAngle: this.GetAngle(),
            layoutRect: tempLayoutRect,
            drawSurfaceRect: null,
            invalidateRenderTargets: !0
        }))
    }
    _Draw3DLayers(a, b, c)
    {
        c[0].IsTransparent() ||
        (tempColor$jscomp$4.copyRgb(c[0].GetBackgroundColor()), tempColor$jscomp$4.setA(1), a.Clear(tempColor$jscomp$4));
        this._runtime.GetCanvasManager();
        a.SetDepthEnabled(!0);
        for (var d of c)
            d._UpdateZIndices(),
            d._AppendAllInstancesIncludingSubLayersInDrawOrder(tempInstanceList1$jscomp$1);
        d = c[0];
        c = d._MaybeStartWebGLProfiling(a);
        d._MaybeStartWebGPUProfiling(a);
        for (let k = 0, l = tempInstanceList1$jscomp$1.length; k < l;) {
            var e = tempInstanceList1$jscomp$1[k],
                f = e.GetWorldInfo(),
                g = f.GetLayer();
            if (f.IsVisible() && f.IsInViewport3D(g._GetViewFrustum())) {
                (!e.RendersToOwnZPlane() ||
                0 < f.GetDepth()) && tempInstanceList3.push(e);
                var h = e.GetWorldInfo().GetTotalZElevation();
                tempInstanceList2$jscomp$1.push(e);
                for (d = k + 1; d < l; ++d) {
                    const m = tempInstanceList1$jscomp$1[d],
                        n = m.GetWorldInfo();
                    if (n.IsVisible() && n.IsInViewport3D(n.GetLayer()._GetViewFrustum())) {
                        if (n.GetTotalZElevation() !== h)
                            break;
                        m.RendersToOwnZPlane() ? (0 < n.GetDepth() && tempInstanceList3.push(m), tempInstanceList2$jscomp$1.push(m)) : tempInstanceList3.push(m)
                    }
                }
                if (1 !== tempInstanceList2$jscomp$1.length || tempInstanceList2$jscomp$1[0].MustMitigateZFighting()) {
                    this._Draw3DLayersCoplanarInstances(a,
                    b, tempInstanceList2$jscomp$1);
                    for (let m = 0, n = tempInstanceList3.length; m < n; ++m)
                        e = tempInstanceList3[m],
                        f = e.GetWorldInfo(),
                        g = f.GetLayer(),
                        f._SetDrawNonBackFacesOnly(!0),
                        MaybePrepareLayerDraw(g, a),
                        g._DrawInstanceMaybeWithEffects(e, f, a, b),
                        f._SetDrawNonBackFacesOnly(!1)
                } else {
                    MaybePrepareLayerDraw(g, a);
                    g._DrawInstanceMaybeWithEffects(e, f, a, b);
                    for (let m = 0, n = tempInstanceList3.length; m < n; ++m)
                        f = tempInstanceList3[m],
                        f !== e && (g = f.GetWorldInfo(), h = g.GetLayer(), MaybePrepareLayerDraw(h, a), h._DrawInstanceMaybeWithEffects(f,
                        g, a, b))
                }
                k = d;
                C3$jscomp$106.clearArray(tempInstanceList2$jscomp$1);
                C3$jscomp$106.clearArray(tempInstanceList3)
            } else
                ++k
        }
        c && a.EndQuery(c);
        C3$jscomp$106.clearArray(tempInstanceList1$jscomp$1);
        lastLayerPreparedForDrawing = null
    }
    _Draw3DLayersCoplanarInstances(a, b, c)
    {
        a.CoplanarStartStencilPass();
        for (let g = 0, h = c.length; g < h; ++g) {
            var d = c[g],
                e = d.GetWorldInfo(),
                f = e.GetLayer();
            e._SetDrawBackFaceOnly(!0);
            MaybePrepareLayerDraw(f, a);
            f._DrawInstance(d, e, a)
        }
        a.CoplanarStartColorPass();
        for (let g = 0, h = c.length; g < h; ++g)
            d =
            c[g],
            e = d.GetWorldInfo(),
            f = e.GetLayer(),
            MaybePrepareLayerDraw(f, a),
            f._DrawInstanceMaybeWithEffects(d, e, a, b),
            e._SetDrawBackFaceOnly(!1);
        a.CoplanarRestoreStandardRendering()
    }
    _SaveToJson()
    {
        const a = {
            sx: this.GetScrollX(),
            sy: this.GetScrollY(),
            s: this.GetScale(),
            a: this.GetAngle(),
            w: this.GetWidth(),
            h: this.GetHeight(),
            ortho: this.IsOrthographicProjection(),
            vpX: this.GetVanishingPointX(),
            vpY: this.GetVanishingPointY(),
            fv: this._isFirstVisit,
            persist: this._persistData,
            fx: this._effectList.SaveToJson(),
            layers: {},
            dynamicLayers: []
        };
        for (const b of this._allLayersFlat)
            if (b.IsDynamic()) {
                const c = b.GetParentLayer();
                a.dynamicLayers.push({
                    sid: b.GetSID(),
                    name: b.GetName(),
                    parentSid: c ? c.GetSID() : null,
                    siblingIndex: b._GetSiblingIndex(),
                    data: b._SaveToJson()
                })
            } else
                a.layers[b.GetSID().toString()] = b._SaveToJson();
        return a
    }
    _LoadFromJson(a)
    {
        this._scrollX = a.sx;
        this._scrollY = a.sy;
        this._scale = a.s;
        this._angle = a.a;
        this._width = a.w;
        this._height = a.h;
        this._isOrthographicProjection = !!a.ortho;
        a.hasOwnProperty("vpX") && (this._vanishingPointX = a.vpX);
        a.hasOwnProperty("vpY") &&
        (this._vanishingPointY = a.vpY);
        this._isFirstVisit = !!a.fv;
        this._persistData = a.persist;
        this._effectList.LoadFromJson(a.fx);
        this._needsRebuildEffectChainSteps = !0;
        for (const [h, k] of Object.entries(a.layers)) {
            var b = parseInt(h, 10);
            (b = this.GetLayerBySID(b)) && b._LoadFromJson(k)
        }
        if (a.hasOwnProperty("dynamicLayers")) {
            this.RemoveAllDynamicLayers();
            this._runtime.FlushPendingInstances();
            b = new Map;
            a = a.dynamicLayers;
            for (var c = a.length - 1; 0 <= c; --c) {
                var d = a[c],
                    e = d.sid,
                    f = d.name,
                    g = d.parentSid;
                const h = d.siblingIndex;
                d =
                d.data;
                this._ReindexLayers();
                if (this.HasLayerByName(f) || this.GetLayerBySID(e))
                    continue;
                let k;
                if (null === g)
                    k = null,
                    g = this._rootLayers;
                else {
                    k = this.GetLayerBySID(g);
                    if (!k)
                        continue;
                    g = k.GetSubLayers()
                }
                e = C3$jscomp$106.New(C3$jscomp$106.Layer, this, k, {
                    name: f,
                    sid: e,
                    isDynamic: !0
                });
                g.push(e);
                f = b.get(g);
                f || (f = [], b.set(g, f));
                f.push({
                    layer: e,
                    siblingIndex: h
                });
                e._LoadFromJson(d)
            }
            for (const [h, k] of b) {
                k.sort((l, m) => l.siblingIndex - m.siblingIndex);
                for (const l of k)
                    b = l.layer,
                    a = l.siblingIndex,
                    c = h.indexOf(b),
                    h.splice(c, 1),
                    h.splice(a, 0, b)
            }
        }
        this._ReindexAndUpdateAllLayers();
        this._SetAllLayersProjectionChanged();
        this._SetAllLayersMVChanged()
    }
    GetILayout()
    {
        return this._iLayout
    }
    UserScriptDispatcher()
    {
        return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(a)
    {
        a.layout = this.GetILayout();
        var b = this._runtime;
        (b = b.IsDebug() && !b.GetEventSheetManager().IsInEventEngine()) && C3Debugger.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(a)
    {
        a.layout =
        this.GetILayout();
        return this._userScriptDispatcher.dispatchEventAndWaitAsync(a)
    }
    DispatchRuntimeUserScriptEventAsyncWait(a)
    {
        a.layout = this.GetILayout();
        return this._runtime.DispatchUserScriptEventAsyncWait(a)
    }
    _LogLayerTree()
    {
        this._LogLayerList(this._rootLayers)
    }
    _LogLayerList(a, b=0)
    {
        a = a.slice(0);
        a.reverse();
        for (const c of a)
            console.log(`${"\t".repeat(b)}- ${c.GetName()}`),
            this._LogLayerList(c.GetSubLayers(), b + 1)
    }
}
;
"use strict";
const C3$jscomp$107 = self.C3;
C3$jscomp$107.LayoutManager = class  extends C3$jscomp$107.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a;
        this._allLayouts = [];
        this._layoutsByName = new Map;
        this._layoutsBySid = new Map;
        this._mainRunningLayout = null;
        this._runningSubLayouts = [];
        this._firstLayout = null;
        this._isEndingLayout = 0;
        this._pendingChangeLayout = null
    }
    Release()
    {
        this._pendingChangeLayout = this._firstLayout = this._mainRunningLayout = this._runtime = null;
        C3$jscomp$107.clearArray(this._allLayouts);
        this._layoutsByName.clear();
        this._layoutsBySid.clear();
        C3$jscomp$107.clearArray(this._runningSubLayouts)
    }
    Create(a)
    {
        a = C3$jscomp$107.New(C3$jscomp$107.Layout, this, this._allLayouts.length, a);
        this._allLayouts.push(a);
        this._layoutsByName.set(a.GetName().toLowerCase(), a);
        this._layoutsBySid.set(a.GetSID(), a)
    }
    GetRuntime()
    {
        return this._runtime
    }
    SetFirstLayout(a)
    {
        this._firstLayout = a
    }
    GetFirstLayout()
    {
        if (this._firstLayout)
            return this._firstLayout;
        if (this._allLayouts.length)
            return this._allLayouts[0];
        throw Error("no first layout");
    }
    GetLayoutByName(a)
    {
        return this._layoutsByName.get(a.toLowerCase()) ||
            null
    }
    GetLayoutBySID(a)
    {
        return this._layoutsBySid.get(a) || null
    }
    GetLayoutByIndex(a)
    {
        a = C3$jscomp$107.clamp(Math.floor(a), 0, this._allLayouts.length - 1);
        return this._allLayouts[a]
    }
    GetLayout(a)
    {
        return "number" === typeof a ? this.GetLayoutByIndex(a) : this.GetLayoutByName(a.toString())
    }
    GetAllLayouts()
    {
        return this._allLayouts
    }
    _SetMainRunningLayout(a)
    {
        this._mainRunningLayout = a
    }
    GetMainRunningLayout()
    {
        return this._mainRunningLayout
    }
    _AddRunningSubLayout(a)
    {
        if (this._runningSubLayouts.includes(a))
            throw Error("layout already running");
        this._runningSubLayouts.push(a)
    }
    _RemoveRunningSubLayout(a)
    {
        a = this._runningSubLayouts.indexOf(a);
        if (-1 === a)
            throw Error("layout not running");
        this._runningSubLayouts.splice(a, 1)
    }
    *runningLayouts()
    {
        this._mainRunningLayout && (yield this._mainRunningLayout);
        this._runningSubLayouts.length && (yield *this._runningSubLayouts)
    }
    IsLayoutRunning(a)
    {
        return this._mainRunningLayout === a || this._runningSubLayouts.includes(a)
    }
    SetIsEndingLayout(a)
    {
        if (a)
            this._isEndingLayout++;
        else {
            if (0 >= this._isEndingLayout)
                throw Error("already unset");
            this._isEndingLayout--
        }
    }
    IsEndingLayout()
    {
        return 0 < this._isEndingLayout
    }
    ChangeMainLayout(a)
    {
        this._pendingChangeLayout = a
    }
    ClearPendingChangeLayout()
    {
        this._pendingChangeLayout = null
    }
    IsPendingChangeMainLayout()
    {
        return !!this._pendingChangeLayout
    }
    GetPendingChangeMainLayout()
    {
        return this._pendingChangeLayout
    }
    SetAllLayerProjectionChanged()
    {
        const a = this.GetMainRunningLayout();
        a && a._SetAllLayersProjectionChanged()
    }
    SetAllLayerMVChanged()
    {
        const a = this.GetMainRunningLayout();
        a && a._SetAllLayersMVChanged()
    }
}
;
"use strict";
const C3$jscomp$108 = self.C3,
    NAMES_REGEXP = RegExp("<(.+?)>", "g");
C3$jscomp$108.TimelineManager = class  extends C3$jscomp$108.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a;
        this._timelineDataManager = C3$jscomp$108.New(C3$jscomp$108.TimelineDataManager);
        this._pluginInstance = null;
        this._timelines = [];
        this._timelinesByName = new Map;
        this._objectClassToTimelineMap = new Map;
        this._timelinesCreatedByTemplate = new Map;
        this._scheduledTimelines = [];
        this._playingTimelines = [];
        this._markedForRemovalTimelines = [];
        this._isTickingTimelines = this._changingLayout = this._hasRuntimeListeners =
        !1;
        this._tickFunc = () => this._OnTick();
        this._tick2Func = () => this._OnTick2();
        this._beforeLayoutChange = () => this._OnBeforeChangeLayout();
        this._layoutChange = () => this._OnAfterChangeLayout();
        this._instanceDestroy = b => this._OnInstanceDestroy(b.instance);
        this._beforeLoad = b => this._OnBeforeLoad();
        this._afterLoad = b => this._OnAfterLoad();
        this._afterLayoutStart = b => this._OnAfterLayoutStart();
        this._destroyedWhileLoadingState = [];
        this._renderChange = 0
    }
    Release()
    {
        this.RemoveRuntimeListeners();
        this._afterLoad = this._instanceDestroy =
        this._layoutChange = this._beforeLayoutChange = this._tick2Func = this._tickFunc = null;
        for (const a of this._timelines)
            a.Stop(),
            a.Release();
        C3$jscomp$108.clearArray(this._timelines);
        this._timelines = null;
        this._timelineDataManager.Release();
        this._timelineDataManager = null;
        C3$jscomp$108.clearArray(this._scheduledTimelines);
        this._scheduledTimelines = null;
        C3$jscomp$108.clearArray(this._playingTimelines);
        this._playingTimelines = null;
        C3$jscomp$108.clearArray(this._markedForRemovalTimelines);
        this._markedForRemovalTimelines =
        null;
        this._timelinesByName.clear();
        this._timelinesByName = null;
        this._objectClassToTimelineMap.clear();
        this._objectClassToTimelineMap = null;
        this._timelinesCreatedByTemplate.clear();
        this._timelinesCreatedByTemplate = null;
        C3$jscomp$108.clearArray(this._destroyedWhileLoadingState);
        this._runtime = this._destroyedWhileLoadingState = null
    }
    AddRuntimeListeners()
    {
        const a = this._runtime.Dispatcher();
        a.addEventListener("pretick", this._tickFunc);
        a.addEventListener("tick2", this._tick2Func);
        a.addEventListener("beforelayoutchange",
        this._beforeLayoutChange);
        a.addEventListener("layoutchange", this._layoutChange);
        a.addEventListener("instancedestroy", this._instanceDestroy);
        a.addEventListener("beforeload", this._beforeLoad);
        a.addEventListener("afterload", this._afterLoad);
        a.addEventListener("afterlayoutstart", this._afterLayoutStart)
    }
    RemoveRuntimeListeners()
    {
        const a = this._runtime.Dispatcher();
        a.removeEventListener("pretick", this._tickFunc);
        a.removeEventListener("tick2", this._tick2Func);
        a.removeEventListener("beforelayoutchange", this._beforeLayoutChange);
        a.removeEventListener("layoutchange", this._layoutChange);
        a.removeEventListener("instancedestroy", this._instanceDestroy);
        a.removeEventListener("beforeload", this._beforeLoad);
        a.removeEventListener("afterload", this._afterLoad);
        a.removeEventListener("afterlayoutstart", this._afterLayoutStart)
    }
    Create(a)
    {
        this._timelineDataManager.Add(a);
        a = C3$jscomp$108.TimelineState.CreateInitial(a, this);
        this.Add(a);
        this.SetTimelineObjectClassesToMap(a);
        this._timelinesCreatedByTemplate.set(a.GetName(), 0)
    }
    CreateFromTemplate(a)
    {
        var b =
        this.GetTimelineDataManager();
        a = a.GetTemplateName();
        b = b.Get(a);
        b = C3$jscomp$108.TimelineState.CreateFromTemplate(`${a}:${this._timelinesCreatedByTemplate.get(a)}`, b, this);
        this._IncreaseTemplateTimelinesCount(a);
        this.Add(b);
        return b
    }
    _IncreaseTemplateTimelinesCount(a)
    {
        this._timelinesCreatedByTemplate.set(a, this._timelinesCreatedByTemplate.get(a) + 1)
    }
    _SetCreatedTemplateTimelinesCount()
    {
        for (const a of this._timelines) {
            if (a.IsTemplate())
                continue;
            const b = a.GetTemplateName();
            this._IncreaseTemplateTimelinesCount(b)
        }
    }
    _ClearCreatedTemplateTimelinesCount()
    {
        for (const a of this._timelinesCreatedByTemplate.keys())
            this._timelinesCreatedByTemplate.set(a,
            0)
    }
    Add(a)
    {
        this._timelines.push(a);
        this._timelinesByName.set(a.GetName().toLowerCase(), a)
    }
    Remove(a)
    {
        a.Removed();
        a.IsTemplate() || (C3$jscomp$108.arrayFindRemove(this._timelines, a), C3$jscomp$108.arrayFindRemove(this._scheduledTimelines, a), C3$jscomp$108.arrayFindRemove(this._playingTimelines, a), C3$jscomp$108.arrayFindRemove(this._markedForRemovalTimelines, a), this._timelinesByName.delete(a.GetName().toLowerCase()), this.RemoveTimelineFromObjectClassMap(a), a.IsReleased() || a.Release())
    }
    Trigger(a)
    {
        this._runtime.Trigger(a,
        this._pluginInstance, null)
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetTimelineDataManager()
    {
        return this._timelineDataManager
    }
    SetPluginInstance(a)
    {
        this._pluginInstance = a
    }
    GetPluginInstance()
    {
        return this._pluginInstance
    }
    *GetTimelines()
    {
        for (const a of this._timelines)
            yield a
    }
    *GetPlayingTimelines()
    {
        for (const a of this._playingTimelines)
            yield a
    }
    SetTimelineObjectClassToMap(a, b)
    {
        this._objectClassToTimelineMap.has(a) || this._objectClassToTimelineMap.set(a, new Set);
        this._objectClassToTimelineMap.get(a).add(b)
    }
    SetTimelineObjectClassesToMap(a)
    {
        for (const b of a.GetObjectClasses())
            this.SetTimelineObjectClassToMap(b,
            a)
    }
    RemoveTimelineFromObjectClassMap(a)
    {
        for (const [b, c] of this._objectClassToTimelineMap.entries())
            c.has(a) && (c.delete(a), 0 === c.size && this._objectClassToTimelineMap.delete(b))
    }
    GetTimelinesForObjectClass(a)
    {
        if (this._objectClassToTimelineMap.has(a))
            return this._objectClassToTimelineMap.get(a)
    }
    GetTimelineOfTemplateForInstances(a, b)
    {
        if (b)
            for (const c of this._timelines)
                if (b.every(d => c.HasTrackInstance(d.instance, d.trackId)) && c.GetName().includes(a.GetName()))
                    return c
    }
    GetTimelineByName(a)
    {
        return this._timelinesByName.get(a.toLowerCase()) ||
            null
    }
    GetScheduledOrPlayingTimelineByName(a)
    {
        for (const b of this._scheduledTimelines)
            if (b.GetName() === a)
                return b;
        for (const b of this._playingTimelines)
            if (b.GetName() === a)
                return b;
        return null
    }
    *GetTimelinesByName(a)
    {
        if (NAMES_REGEXP.test(a)) {
            NAMES_REGEXP.lastIndex = 0;
            let c;
            var b = new Set;
            do if (c = NAMES_REGEXP.exec(a)) {
                const d = c[1].split(",");
                for (const e of d)
                    b.add(e)
            }
            while (c);
            for (const d of b.values())
                (a = this.GetTimelineByName(d)) && (yield a);
            b.clear()
        } else
            (b = this.GetTimelineByName(a)) && (yield b)
    }
    *GetTimelinesByTags(a)
    {
        for (const b of this._timelines)
            b.HasTags(a) &&
            (yield b)
    }
    AddScheduledTimeline(a)
    {
        this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a);
        this._MaybeEnableRuntimeListeners()
    }
    RemovePlayingTimeline(a)
    {
        C3$jscomp$108.arrayFindRemove(this._playingTimelines, a);
        this._MaybeDisableRuntimeListeners()
    }
    ScheduleTimeline(a)
    {
        this._playingTimelines.includes(a) ? (a.SetPlaying(!0), a.SetScheduled(!1), a.SetMarkedForRemoval(!1)) : (a.SetPlaying(!1), a.SetScheduled(!0), a.SetMarkedForRemoval(!1), this._scheduledTimelines.includes(a) || this._scheduledTimelines.push(a));
        this._MaybeEnableRuntimeListeners()
    }
    DeScheduleTimeline(a)
    {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        a.ResolvePlayPromise();
        C3$jscomp$108.arrayFindRemove(this._scheduledTimelines, a);
        this._MaybeDisableRuntimeListeners()
    }
    CompleteTimeline(a)
    {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        this._playingTimelines.includes(a) && (a.SetMarkedForRemoval(!0), this._markedForRemovalTimelines.push(a), C3$jscomp$108.arrayFindRemove(this._playingTimelines, a));
        this._scheduledTimelines.includes(a) && a.SetMarkedForRemoval(!0)
    }
    CompleteTimelineBeforeChangeOfLayout(a)
    {
        a.SetPlaying(!1);
        a.SetScheduled(!1);
        a.SetMarkedForRemoval(!1);
        a.SetPlaybackRate(1);
        C3$jscomp$108.arrayFindRemove(this._playingTimelines, a)
    }
    CompleteTimelineAndResolve(a)
    {
        this.CompleteTimeline(a);
        a.ResolvePlayPromise()
    }
    _OnTick()
    {
        if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            for (this._isTickingTimelines = !0; this._scheduledTimelines.length;) {
                var a = this._scheduledTimelines.pop();
                a.IsMarkedForRemoval() ? (a.SetInitialStateForce(), this._markedForRemovalTimelines.push(a)) : (a.SetInitialState(),
                this._playingTimelines.push(a));
                0 !== a.GetRenderChange() && (this._renderChange = 1)
            }
            a = this._runtime._GetDtFast();
            var b = this._runtime.GetDt1(),
                c = this._runtime.GetTimeScale();
            for (let d = this._playingTimelines.length - 1; 0 <= d; d--) {
                const e = this._playingTimelines[d];
                e && e.Tick(a, c, b)
            }
            this._isTickingTimelines = !1;
            0 !== this._renderChange && this.GetRuntime().UpdateRender()
        }
    }
    _OnTick2()
    {
        if (!this.GetRuntime().IsLoadingState() && this._hasRuntimeListeners && !this._changingLayout) {
            var a;
            for (let b = 0, c = this._markedForRemovalTimelines.length; b <
            c; b++) {
                const d = this._markedForRemovalTimelines[b];
                a || (a = new Set);
                d.Removed();
                this._MaybeExecuteTimelineFinishTriggers(d);
                a.add(d)
            }
            if (a) {
                C3$jscomp$108.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
                this._renderChange = 0;
                for (let b = 0, c = this._playingTimelines.length; b < c; b++)
                    if (0 !== this._playingTimelines[b].GetRenderChange()) {
                        this._renderChange = 1;
                        break
                    }
            }
            this._MaybeDisableRuntimeListeners()
        }
    }
    _MaybeExecuteTimelineFinishTriggers(a)
    {
        a.IsReleased() || a.HasValidTracks() && a.IsComplete() && a.InitialStateSet() &&
        a.FinishTriggers()
    }
    _MaybeEnableRuntimeListeners()
    {
        this._hasRuntimeListeners || (this._hasRuntimeListeners = !0)
    }
    _MaybeDisableRuntimeListeners()
    {
        this._markedForRemovalTimelines.length || this._playingTimelines.length || this._scheduledTimelines.length || this._isTickingTimelines || (this._hasRuntimeListeners = !1)
    }
    _OnBeforeChangeLayout()
    {
        for (this._changingLayout = !0; this._scheduledTimelines.length;)
            this.DeScheduleTimeline(this._scheduledTimelines.pop());
        const a = new Set;
        for (const b of this._playingTimelines)
            b._OnBeforeChangeLayout() &&
            (b.Removed(), a.add(b));
        C3$jscomp$108.arrayRemoveAllInSet(this._playingTimelines, a);
        a.clear();
        for (const b of this._markedForRemovalTimelines)
            b._OnBeforeChangeLayout() && (b.Removed(), a.add(b));
        C3$jscomp$108.arrayRemoveAllInSet(this._markedForRemovalTimelines, a);
        this._MaybeDisableRuntimeListeners();
        for (const b of this._timelines)
            b.CleanCaches()
    }
    _OnAfterChangeLayout()
    {
        this._changingLayout = !1
    }
    _OnInstanceDestroy(a)
    {
        var b = a.GetObjectClass();
        if (b = this.GetTimelinesForObjectClass(b))
            if (this._runtime.IsLoadingState())
                this._destroyedWhileLoadingState.push(a);
            else
                for (const c of b)
                    c.IsTemplate() || (c.IsReleased() ? this.Remove(c) : c.HasValidTracks() || (this._MaybeExecuteTimelineFinishTriggers(c), this.Remove(c)))
    }
    _OnBeforeLoad()
    {
        for (const a of this._scheduledTimelines.map(b => b))
            this._MaybeExecuteTimelineFinishTriggers(a),
            this.Remove(a);
        for (const a of this._playingTimelines.map(b => b))
            this._MaybeExecuteTimelineFinishTriggers(a),
            this.Remove(a)
    }
    _OnAfterLoad()
    {
        for (const a of this._destroyedWhileLoadingState)
            this._OnInstanceDestroy(a);
        C3$jscomp$108.clearArray(this._destroyedWhileLoadingState);
        for (const a of this._timelines)
            a._OnAfterLoad()
    }
    _OnAfterLayoutStart()
    {
        const a = this._runtime.GetLayoutManager().GetMainRunningLayout();
        if (a)
            for (const b of this._timelines) {
                const c = b.GetStartOnLayout();
                c && a.GetName() === c && this.ScheduleTimeline(b)
            }
    }
    _SaveToJson()
    {
        return {
            timelinesJson: this._SaveTimelinesToJson(),
            scheduledTimelinesJson: this._SaveScheduledTimelinesToJson(),
            playingTimelinesJson: this._SavePlayingTimelinesToJson(),
            markedForRemovalTimelinesJson: this._SaveMarkedForRemovalTimelinesToJson(),
            hasRuntimeListeners: this._hasRuntimeListeners,
            changingLayout: this._changingLayout,
            isTickingTimelines: this._isTickingTimelines
        }
    }
    _LoadFromJson(a)
    {
        a && (this._ClearCreatedTemplateTimelinesCount(), this._LoadTimelinesFromJson(a.timelinesJson), this._LoadScheduledTimelinesFromJson(a.scheduledTimelinesJson), this._LoadPlayingTimelinesFromJson(a.playingTimelinesJson), this._LoadMarkedForRemovalTimelinesFromJson(a.markedForRemovalTimelinesJson), this._hasRuntimeListeners = !a.hasRuntimeListeners, this._changingLayout = !!a.changingLayout, this._isTickingTimelines =
        !!a.isTickingTimelines, this._SetCreatedTemplateTimelinesCount(), this._MaybeEnableRuntimeListeners(), this._MaybeDisableRuntimeListeners())
    }
    _SaveTimelinesToJson()
    {
        return this._timelines.map(a => a._SaveToJson())
    }
    _LoadTimelinesFromJson(a)
    {
        for (const b of a) {
            a = this.GetTimelineByName(b.name);
            if (!a) {
                a = this._GetTemplateNameFromJson(b);
                if (!a)
                    continue;
                a = this.GetTimelineByName(a);
                a = this.CreateFromTemplate(a)
            }
            a._LoadFromJson(b);
            a.HasTracks() || this.Remove(a)
        }
    }
    _GetTemplateNameFromJson(a)
    {
        return (a = a.name.split(":")) &&
        2 === a.length ? a[0] : null
    }
    _SaveScheduledTimelinesToJson()
    {
        return this._SaveTimelines(this._scheduledTimelines)
    }
    _LoadScheduledTimelinesFromJson(a)
    {
        this._LoadTimelines(a, this._scheduledTimelines)
    }
    _SavePlayingTimelinesToJson()
    {
        return this._SaveTimelines(this._playingTimelines)
    }
    _LoadPlayingTimelinesFromJson(a)
    {
        this._LoadTimelines(a, this._playingTimelines)
    }
    _SaveMarkedForRemovalTimelinesToJson()
    {
        return this._SaveTimelines(this._markedForRemovalTimelines)
    }
    _LoadMarkedForRemovalTimelinesFromJson(a)
    {
        this._LoadTimelines(a,
        this._markedForRemovalTimelines)
    }
    _IsTimelineInJson(a, b)
    {
        if (!b)
            return !1;
        for (const c of b)
            if (c === a.GetName())
                return !0;
        return !1
    }
    _SaveTimelines(a)
    {
        return a.map(b => b.GetName())
    }
    _LoadTimelines(a, b)
    {
        var c = new Set;
        for (const d of b)
            this._IsTimelineInJson(d, a) || c.add(d);
        C3$jscomp$108.arrayRemoveAllInSet(b, c);
        if (a) {
            c = d => e => e.GetName() === d;
            for (const d of a)
                (a = this.GetTimelineByName(d)) && (b.find(c(d)) || b.push(a))
        }
    }
}
;
"use strict";
const C3$jscomp$109 = self.C3,
    TANGENT_RESULT = [0, 0],
    MAP_RESULT = [0, 0],
    SHORT_PROJECTION_RESULT = [0, 0],
    PROJECTION_RESULT = [0, 0, 0, 0, 0],
    REFINE_LUT = Array(4),
    REFINE_LUT_OBJECTS = [{
        x: 0,
        y: 0,
        t: 0,
        distance: 0
    }, {
        x: 0,
        y: 0,
        t: 0,
        distance: 0
    }, {
        x: 0,
        y: 0,
        t: 0,
        distance: 0
    }],
    REFINE_RESULT = {
        x: 0,
        y: 0,
        t: 0,
        distance: 0
    };
C3$jscomp$109.TimelineInfo = class {
    constructor(a, b)
    {
        this._initialized = !1;
        this._timeline = a;
        this._segments = [];
        if (b = b ? this._timeline.GetTrackById(b) : C3$jscomp$109.first(this._timeline.GetTracks()))
            if (a = b.GetPropertyTrack("offsetX"), b = b.GetPropertyTrack("offsetY"), a && b) {
                this._xTrack = a;
                this._yTrack = b;
                a = a.GetPropertyKeyframeDataItemArrayIncludingDisabled();
                b = b.GetPropertyKeyframeDataItemArrayIncludingDisabled();
                for (let c = 1, d = Math.min(a.length, b.length); c < d; ++c) {
                    const e = a[c];
                    e.GetNext();
                    const f = e.GetPrevious(),
                        g = b[c];
                    g.GetNext();
                    const h = g.GetPrevious();
                    f && "cubic-bezier" === f.GetPathMode() && h && "cubic-bezier" === h.GetPathMode() ? this._segments.push(C3$jscomp$109.New(C3$jscomp$109.TimelineCubicBezierSegmentInfo, f, h, e, g, this._segments.length)) : (f && "line" === f.GetPathMode() && h && h.GetPathMode(), this._segments.push(C3$jscomp$109.New(C3$jscomp$109.TimelineLineSegmentInfo, e, g, this._segments.length)))
                }
                this._initialized = !0
            }
    }
    Release()
    {
        for (const a of this._segments)
            a.Release();
        C3$jscomp$109.clearArray(this._segments);
        this._yTrack =
        this._xTrack = this._timeline = this._segments = null
    }
    WasInitialized()
    {
        return this._initialized
    }
    segments()
    {
        return this._segments
    }
    SetOrigin(a)
    {
        const b = "relative" === this._xTrack.GetResultMode() ? a.GetX() : 0;
        a = "relative" === this._yTrack.GetResultMode() ? a.GetY() : 0;
        for (const c of this._segments)
            c.SetOrigin(b, a)
    }
    Project(a, b, c)
    {
        c = NaN;
        let d = this._segments.length;
        for (let e = 0; e < d; e++) {
            const f = this._segments[e];
            if ("cubic-bezier" === f.GetType()) {
                const g = f.Project(a, b);
                isNaN(c) ? (c = g[3], SHORT_PROJECTION_RESULT[0] = g[2], SHORT_PROJECTION_RESULT[1] =
                f.GetIndex()) : g[3] < c && (c = g[3], SHORT_PROJECTION_RESULT[0] = g[2], SHORT_PROJECTION_RESULT[1] = f.GetIndex())
            }
        }
        return SHORT_PROJECTION_RESULT
    }
    ProjectWithOptions(a, b, c)
    {
        c = c.tRange;
        C3$jscomp$109.IsFiniteNumber(c[0]) || (c[0] = 0);
        C3$jscomp$109.IsFiniteNumber(c[1]) || (c[1] = 1);
        let d = NaN,
            e = this._segments.length;
        for (let f = 0; f < e; f++) {
            const g = this._segments[f];
            if ("cubic-bezier" === g.GetType()) {
                const h = g.ProjectWithRange(a, b, c);
                isNaN(d) ? (d = h[3], SHORT_PROJECTION_RESULT[0] = h[2], SHORT_PROJECTION_RESULT[1] = g.GetIndex()) : h[3] <
                d && (d = h[3], SHORT_PROJECTION_RESULT[0] = h[2], SHORT_PROJECTION_RESULT[1] = g.GetIndex())
            }
        }
        return SHORT_PROJECTION_RESULT
    }
    Tangent(a, b)
    {
        return this._segments[b].Tangent(a)
    }
    TangentAngle(a, b)
    {
        return this._segments[b].TangentAngle(a)
    }
}
;
C3$jscomp$109.TimelineCubicBezierSegmentInfo = class {
    constructor(a, b, c, d, e)
    {
        this._index = e;
        e = a.GetAddOn("cubic-bezier");
        const f = c.GetAddOn("cubic-bezier"),
            g = b.GetAddOn("cubic-bezier"),
            h = d.GetAddOn("cubic-bezier");
        this._aX = a.GetValueWithResultMode();
        this._aY = b.GetValueWithResultMode();
        this._bX = a.GetValueWithResultMode() + e.GetStartAnchor();
        this._bY = b.GetValueWithResultMode() + g.GetStartAnchor();
        this._cX = c.GetValueWithResultMode() + f.GetEndAnchor();
        this._cY = d.GetValueWithResultMode() + h.GetEndAnchor();
        this._dX =
        c.GetValueWithResultMode();
        this._dY = d.GetValueWithResultMode();
        this._y3Factor = this._y2Factor = this._y1Factor = this._x3Factor = this._x2Factor = this._x1Factor = this._d2y = this._d2x = this._d1y = this._d1x = this._d0y = this._d0x = this._dYO = this._dXO = this._cYO = this._cXO = this._bYO = this._bXO = this._aYO = this._aXO = 0;
        this._lutIndex = NaN;
        this._initialized = !1;
        this._len = 100;
        this._arcLengths = Array(this._len + 1);
        this._length = this._arcLengths[0] = 0;
        this._lut = [];
        this._lutObjects = [];
        for (a = 0; 100 > a; a++)
            this._lutObjects.push({
                x: 0,
                y: 0,
                t: 0,
                distance: 0
            });
        this._CalculateLength()
    }
    Release()
    {
        C3$jscomp$109.clearArray(this._arcLengths);
        this._arcLengths = null;
        C3$jscomp$109.clearArray(this._lut);
        this._lut = null;
        C3$jscomp$109.clearArray(this._lutObjects);
        this._lutObjects = null
    }
    GetType()
    {
        return "cubic-bezier"
    }
    GetIndex()
    {
        return this._index
    }
    GetStepCount()
    {
        return Math.floor(this._length / 25)
    }
    GetStepIncrement()
    {
        return 1 / this.GetStepCount()
    }
    SetOrigin(a, b)
    {
        this._originX = a;
        this._originY = b;
        this._arcLengths = Array(this._len + 1);
        this._arcLengths[0] = 0;
        this._CalculateLength();
        this._aXO = this._aX + this._originX;
        this._aYO = this._aY + this._originY;
        this._bXO = this._bX + this._originX;
        this._bYO = this._bY + this._originY;
        this._cXO = this._cX + this._originX;
        this._cYO = this._cY + this._originY;
        this._dXO = this._dX + this._originX;
        this._dYO = this._dY + this._originY;
        this._d0x = 3 * (this._bXO - this._aXO);
        this._d0y = 3 * (this._bYO - this._aYO);
        this._d1x = 3 * (this._cXO - this._bXO);
        this._d1y = 3 * (this._cYO - this._bYO);
        this._d2x = 3 * (this._dXO - this._cXO);
        this._d2y = 3 * (this._dYO - this._cYO);
        this._x1Factor = 3 * (this._bXO - this._aXO);
        this._x2Factor = 3 * (this._aXO + this._cXO - 2 * this._bXO);
        this._x3Factor = this._dXO - this._aXO + 3 * (this._bXO - this._cXO);
        this._y1Factor = 3 * (this._bYO - this._aYO);
        this._y2Factor = 3 * (this._aYO + this._cYO - 2 * this._bYO);
        this._y3Factor = this._dYO - this._aYO + 3 * (this._bYO - this._cYO)
    }
    Map(a)
    {
        if (!this._initialized)
            return NaN;
        a = this._Map(a);
        MAP_RESULT[0] = this._X(a);
        MAP_RESULT[1] = this._Y(a);
        return MAP_RESULT
    }
    Project(a, b)
    {
        const c = this._GenerateLUT(100),
            d = this._FindClosestFromLUT(a, b, c);
        a = this._RefineProjection(a, b, c, d);
        PROJECTION_RESULT[0] =
        a.x;
        PROJECTION_RESULT[1] = a.y;
        PROJECTION_RESULT[2] = a.t;
        PROJECTION_RESULT[3] = a.distance;
        return PROJECTION_RESULT
    }
    ProjectWithRange(a, b, c)
    {
        const d = this._GenerateLUT(100);
        c = this._FindClosestFromLUTWithRange(a, b, d, c);
        a = this._RefineProjection(a, b, d, c);
        PROJECTION_RESULT[0] = a.x;
        PROJECTION_RESULT[1] = a.y;
        PROJECTION_RESULT[2] = a.t;
        PROJECTION_RESULT[3] = a.distance;
        return PROJECTION_RESULT
    }
    Tangent(a)
    {
        var b = 1 - a,
            c = b * b;
        b = 2 * b * a;
        const d = a * a;
        a = c * this._d0x + b * this._d1x + d * this._d2x;
        c = c * this._d0y + b * this._d1y + d * this._d2y;
        b =
        Math.hypot(a, c);
        TANGENT_RESULT[0] = a / b;
        TANGENT_RESULT[1] = c / b;
        return TANGENT_RESULT
    }
    TangentAngle(a)
    {
        var b = 1 - a;
        const c = b * b;
        b = 2 * b * a;
        a *= a;
        return Math.atan2(c * this._d0y + b * this._d1y + a * this._d2y, c * this._d0x + b * this._d1x + a * this._d2x)
    }
    _Map(a)
    {
        if (this._initialized) {
            a *= this._arcLengths[this._len];
            for (var b = 0, c = this._len, d = 0; b < c;)
                d = b + ((c - b) / 2 | 0),
                this._arcLengths[d] < a ? b = d + 1 : c = d;
            this._arcLengths[d] > a && d--;
            b = this._arcLengths[d];
            return b === a ? d / this._len : (d + (a - b) / (this._arcLengths[d + 1] - b)) / this._len
        }
    }
    _X(a)
    {
        return this._initialized ?
        self.Ease.GetRuntimeEase("cubicbezier")(a, this._aX + this._originX, this._bX + this._originX, this._cX + this._originX, this._dX + this._originX) : NaN
    }
    _Y(a)
    {
        return this._initialized ? self.Ease.GetRuntimeEase("cubicbezier")(a, this._aY + this._originY, this._bY + this._originY, this._cY + this._originY, this._dY + this._originY) : NaN
    }
    _GenerateLUT(a)
    {
        a = a || 100;
        if (this._lut.length >= a)
            return this._lut;
        this._lut = Array(a);
        a++;
        for (let b = 0; b < a - 1; b++) {
            const c = b / (a - 1),
                d = c ** 2,
                e = c ** 3,
                f = this._aYO + this._y1Factor * c + this._y2Factor * d + this._y3Factor *
                e;
            this._lutObjects[b].x = this._aXO + this._x1Factor * c + this._x2Factor * d + this._x3Factor * e;
            this._lutObjects[b].y = f;
            this._lutObjects[b].t = c;
            this._lutObjects[b].distance = 0;
            this._lut[b] = this._lutObjects[b]
        }
        return this._lut
    }
    _FindClosestFromLUT(a, b, c, d, e=Number.MAX_SAFE_INTEGER)
    {
        d = 0;
        if (isNaN(this._lutIndex))
            for (var f = 0; 100 > f; f++) {
                var g = c[f],
                    h = g.x - a,
                    k = g.y - b;
                g.distance = h * h + k * k;
                g.distance < e && (e = g.distance, d = f)
            }
        else {
            for (f = this._lutIndex; f < this._lutIndex + 5 && !(f >= c.length); f++)
                g = c[f],
                h = g.x - a,
                k = g.y - b,
                g.distance = h *
                h + k * k,
                g.distance < e && (e = g.distance, d = f);
            for (f = this._lutIndex; f > this._lutIndex - 5 && !(0 > f); f--)
                g = c[f],
                h = g.x - a,
                k = g.y - b,
                g.distance = h * h + k * k,
                g.distance < e && (e = g.distance, d = f)
        }
        return this._lutIndex = d
    }
    _FindClosestFromLUTWithRange(a, b, c, d, e=Number.MAX_SAFE_INTEGER)
    {
        let f = 0;
        if (isNaN(this._lutIndex))
            for (var g = 0; 100 > g; g++) {
                var h = c[g],
                    k = h.x - a,
                    l = h.y - b;
                h.distance = k * k + l * l;
                h.t >= d[0] && h.t <= d[1] && h.distance < e && (e = h.distance, f = g)
            }
        else {
            for (g = this._lutIndex; g < this._lutIndex + 5 && !(g >= c.length); g++)
                h = c[g],
                k = h.x - a,
                l = h.y - b,
                h.distance =
                k * k + l * l,
                h.t >= d[0] && h.t <= d[1] && h.distance < e && (e = h.distance, f = g);
            for (g = this._lutIndex; g > this._lutIndex - 5 && !(0 > g); g--)
                h = c[g],
                k = h.x - a,
                l = h.y - b,
                h.distance = k * k + l * l,
                h.t >= d[0] && h.t <= d[1] && h.distance < e && (e = h.distance, f = g)
        }
        return this._lutIndex = f
    }
    _RefineProjection(a, b, c, d)
    {
        let e = c[d],
            f = 1,
            g = Number.MAX_SAFE_INTEGER;
        a:
        do {
            var h = c.length,
                k = 0 === d ? 0 : d - 1;
            h = d === h - 1 ? h - 1 : d + 1;
            let p = c[k].t,
                q = (c[h].t - p) / 4;
            if (.001 > q)
                break;
            REFINE_LUT[0] = c[k];
            for (k = 1; 2 >= k; k++) {
                const r = p + k * q;
                var l = r ** 2,
                    m = r ** 3;
                const t = this._aXO + this._x1Factor *
                r + this._x2Factor * l + this._x3Factor * m;
                l = this._aYO + this._y1Factor * r + this._y2Factor * l + this._y3Factor * m;
                m = t - a;
                var n = l - b;
                m = m * m + n * n;
                if (m < g) {
                    REFINE_RESULT.x = t;
                    REFINE_RESULT.y = l;
                    REFINE_RESULT.t = r;
                    REFINE_RESULT.distance = m;
                    e = REFINE_RESULT;
                    break a
                }
                n = REFINE_LUT_OBJECTS[k - 1];
                n.x = t;
                n.y = l;
                n.t = r;
                n.distance = m;
                REFINE_LUT[k] = n
            }
            REFINE_LUT[3] = c[h];
            c = REFINE_LUT
        } while (20 > f++);
        return e
    }
    _CalculateLength()
    {
        this._initialized = !0;
        let a = this._X(0),
            b = this._Y(0),
            c = 0;
        for (let d = 1; d <= this._len; d++) {
            const e = this._X(.01 * d),
                f = this._Y(.01 *
                d);
            c += Math.hypot(a - e, b - f);
            this._arcLengths[d] = c;
            a = e;
            b = f
        }
        this._length = c
    }
}
;
C3$jscomp$109.TimelineLineSegmentInfo = class {
    constructor(a, b, c)
    {
        this._index = c;
        this._targetX = a.GetValueWithResultMode();
        this._targetY = b.GetValueWithResultMode();
        this._originY = this._originX = 0
    }
    Release() {}
    GetType()
    {
        return "line"
    }
    GetIndex()
    {
        return this._index
    }
    SetOrigin(a, b)
    {
        this._originX = a;
        this._originY = b
    }
    GetX()
    {
        return this._targetX + this._originX
    }
    GetY()
    {
        return this._targetY + this._originY
    }
}
;
"use strict";
const C3$jscomp$110 = self.C3;
C3$jscomp$110.TimelineState = class  extends C3$jscomp$110.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._runtime = c.GetRuntime();
        this._timelineManager = c;
        this._timelineDataItem = b;
        this._name = a;
        this._tracks = [];
        this._tracksLength = 0;
        this._beforeAndAfterTracks = null;
        this._beforeAndAfterTracksLength = 0;
        this.CreateTrackStates();
        this._playResolve = this._playPromise = null;
        this._overshoot = this._playheadTime = 0;
        this._playbackRate = 1;
        this._pingPongState = 0;
        this._currentRepeatCount = 1;
        this._initialStateSet = this._isScheduled =
        this._isPlaying = !1;
        this._complete = !0;
        this._markedForRemoval = this._released = !1;
        this._completedTick = -1;
        this._firstTick = this._finishedTriggers = this._isTemplate = this._implicitPause = !1;
        this._lastDelta = NaN;
        this._tags = [""];
        this._stringTags = "";
        this._tagsChanged = !1;
        this._hasNestedContent = this._renderChange = 0;
        this._iTimelineState = null
    }
    static CreateInitial(a, b)
    {
        var c = b.GetTimelineDataManager();
        const d = c.GetNameId();
        c = c.Get(a[d]);
        a = C3$jscomp$110.New(C3$jscomp$110.TimelineState, a[d], c, b);
        a.SetIsTemplate(!0);
        return a
    }
    static CreateFromTemplate(a,
    b, c)
    {
        return C3$jscomp$110.New(C3$jscomp$110.TimelineState, a, b, c)
    }
    Release()
    {
        if (!this.IsReleased()) {
            var a = this._runtime.Dispatcher();
            this._timelineManager.DeScheduleTimeline(this);
            this._timelineManager.CompleteTimelineAndResolve(this);
            for (const b of this._tracks)
                b.Release();
            C3$jscomp$110.clearArray(this._tracks);
            this._timelineDataItem = this._timelineManager = this._runtime = this._tracks = null;
            this._released = !0;
            this._playResolve = this._playPromise = null;
            this.FireReleaseEvent(a)
        }
    }
    FireReleaseEvent(a)
    {
        const b =
        C3$jscomp$110.New(C3$jscomp$110.Event, "timelinestatereleased");
        b.timelineState = this;
        a.dispatchEvent(b)
    }
    GetType()
    {
        return 0
    }
    CreateTrackStates()
    {
        for (const a of this._timelineDataItem.GetTrackData().trackDataItems())
            this._tracksLength = this._tracks.push(C3$jscomp$110.TrackState.Create(this, a))
    }
    GetTimelineManager()
    {
        return this._timelineManager
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetTracks()
    {
        return this._tracks
    }
    GetSimilarPropertyTracks(a, b, c, d)
    {
        if (this._hasNestedContent) {
            var e;
            for (let g = 0; g < this._tracks.length; g++) {
                var f =
                this._tracks[g];
                a === f.GetInstance() && (f = f.GetPropertyTrack(c)) && b.constructor === f.GetSourceAdapter().constructor && f.GetResultMode() === d.GetResultMode() && (e || (e = []), e.push(f))
            }
            return e
        }
    }
    HasTracks()
    {
        return !!this._tracks.length
    }
    GetTrackById(a)
    {
        for (const b of this._tracks)
            if (C3$jscomp$110.equalsNoCase(b.GetId(), a))
                return b;
        return null
    }
    GetTrackByName(a)
    {
        for (const b of this._tracks)
            if (!b.IsInstanceTrack() && C3$jscomp$110.equalsNoCase(b.GetName(), a))
                return b;
        return null
    }
    SetName(a)
    {
        this._name = a
    }
    GetName()
    {
        return this._name
    }
    GetTimelineDataItem()
    {
        return this._timelineDataItem
    }
    GetTemplateName()
    {
        return this._timelineDataItem.GetName()
    }
    GetTotalTime()
    {
        return this._timelineDataItem.GetTotalTime()
    }
    SetTotalTime(a)
    {
        this._timelineDataItem.SetTotalTime(a)
    }
    GetStep()
    {
        return this._timelineDataItem.GetStep()
    }
    SetStep(a)
    {
        this._timelineDataItem.SetStep(a)
    }
    GetInterpolationMode()
    {
        return this._timelineDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a)
    {
        this._timelineDataItem.SetInterpolationMode(a)
    }
    GetResultMode()
    {
        return this._timelineDataItem.GetResultMode()
    }
    SetResultMode(a)
    {
        this._timelineDataItem.GetResultMode(a)
    }
    SetEase(a)
    {
        for (const b of this.GetTracks())
            b.SetEase(a)
    }
    GetLoop()
    {
        return this._timelineDataItem.GetLoop()
    }
    SetLoop(a)
    {
        return this._timelineDataItem.SetLoop(a)
    }
    GetPingPong()
    {
        return this._timelineDataItem.GetPingPong()
    }
    SetPingPong(a)
    {
        return this._timelineDataItem.SetPingPong(a)
    }
    GetRepeatCount()
    {
        return this._timelineDataItem.GetRepeatCount()
    }
    SetRepeatCount(a)
    {
        return this._timelineDataItem.SetRepeatCount(a)
    }
    SetPlaybackRate(a)
    {
        return this._playbackRate =
        a
    }
    GetPlaybackRate()
    {
        return this._playbackRate
    }
    GetStartOnLayout()
    {
        return this._timelineDataItem.GetStartOnLayout()
    }
    GetTransformWithSceneGraph()
    {
        return this._timelineDataItem.GetTransformWithSceneGraph()
    }
    GetUseSystemTimescale()
    {
        return this._timelineDataItem.GetUseSystemTimescale()
    }
    GetPingPongState()
    {
        return this._pingPongState
    }
    IsForwardPlayBack()
    {
        return this.IsPlaying() ? 0 < this._playbackRate : !0
    }
    GetPlayPromise()
    {
        return this._playPromise ? this._playPromise : this._playPromise = new Promise(a => {
            this._playResolve =
            a
        })
    }
    ResolvePlayPromise()
    {
        this._playPromise && (this._playResolve(), this._playResolve = this._playPromise = null)
    }
    SetTags(a)
    {
        this._tags = C3$jscomp$110.TimelineState._GetTagArray(a);
        this._tagsChanged = !0
    }
    GetTags()
    {
        return this._tags
    }
    GetStringTags()
    {
        this._tagsChanged && (this._stringTags = this._tags.join(" "));
        this._tagsChanged = !1;
        return this._stringTags
    }
    HasTags(a)
    {
        return this._tags && this._tags.length ? (a = C3$jscomp$110.TimelineState._GetTagArray(a)) && a.length ? a.every(C3$jscomp$110.TimelineState._HasTag, this) : !1 :
        !1
    }
    OnStarted()
    {
        C3$jscomp$110.Plugins.Timeline && this.constructor === C3$jscomp$110.TimelineState && (C3$jscomp$110.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimelineStarted), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimelineStartedByName), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimelineStartedByTags), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnAnyTimelineStarted),
        C3$jscomp$110.Plugins.Timeline.Cnds.PopTriggerTimeline())
    }
    OnCompleted()
    {
        this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers()
    {
        this._finishedTriggers || (this._finishedTriggers = !0, C3$jscomp$110.Plugins.Timeline && this.constructor === C3$jscomp$110.TimelineState && (C3$jscomp$110.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimelineFinished), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimelineFinishedByName),
        this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimelineFinishedByTags), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnAnyTimelineFinished), C3$jscomp$110.Plugins.Timeline.Cnds.PopTriggerTimeline()))
    }
    SetPlaying(a)
    {
        this._isPlaying = a
    }
    IsCompletedTick()
    {
        return this._completedTick === this._runtime.GetTickCount()
    }
    IsPlaying(a=!1)
    {
        return this.IsCompletedTick() || this.IsScheduled() && !a ? !0 : this._isPlaying
    }
    _IsPlaying()
    {
        return this.IsPlaying(!0)
    }
    IsPaused()
    {
        return this._IsPaused()
    }
    _IsPaused()
    {
        return this.IsReleased() ||
        this.IsScheduled() || this._IsPlaying() || this.IsComplete() ? !1 : !0
    }
    SetScheduled(a)
    {
        this._isScheduled = a
    }
    IsScheduled()
    {
        return this._isScheduled
    }
    SetComplete(a)
    {
        this._complete = a;
        a = this.GetTime();
        if (0 >= a || a >= this.GetTotalTime())
            this._complete = !0
    }
    IsComplete()
    {
        return this._complete
    }
    IsReleased()
    {
        return this._released
    }
    SetMarkedForRemoval(a)
    {
        this._markedForRemoval = a
    }
    IsMarkedForRemoval()
    {
        return this._markedForRemoval
    }
    SetImplicitPause(a)
    {
        this._implicitPause = a
    }
    IsImplicitPause()
    {
        return this._implicitPause
    }
    SetIsTemplate(a)
    {
        this._isTemplate =
        !!a
    }
    IsTemplate()
    {
        return this._isTemplate
    }
    InitialStateSet()
    {
        return this._initialStateSet
    }
    GetTime()
    {
        return this._playheadTime
    }
    SetTime(a)
    {
        const b = this.GetTime();
        this._SetTime(a);
        this.SetComplete(!1);
        this.IsComplete() || this.SetImplicitPause(!0);
        if (this._IsPlaying() || this.IsScheduled() || !this._initialStateSet)
            this._IsPlaying() || this.IsScheduled() || this._initialStateSet ? this._IsPlaying() ? this.Stop() : this.IsScheduled() && (this._timelineManager.DeScheduleTimeline(this), this.SetInitialStateFromSetTime()) : this.SetInitialStateFromSetTime();
        this._SetUpdateStateBefore();
        this._Interpolate(this.GetTime(), !1, !0, !0, b);
        this._SetUpdateStateAfter();
        this._renderChange && this.GetRuntime().UpdateRender();
        this._OnSetTime()
    }
    _SetTime(a)
    {
        C3$jscomp$110.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a
    }
    _SetTimeAndReset(a)
    {
        C3$jscomp$110.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() :
        this._playheadTime = a;
        for (const b of this._tracks)
            b.SetResetState()
    }
    _OnSetTime()
    {
        C3$jscomp$110.Plugins.Timeline && this.constructor === C3$jscomp$110.TimelineState && (C3$jscomp$110.Plugins.Timeline.Cnds.PushTriggerTimeline(this), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimeSet), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimeSetByName), this._timelineManager.Trigger(C3$jscomp$110.Plugins.Timeline.Cnds.OnTimeSetByTags), C3$jscomp$110.Plugins.Timeline.Cnds.PopTriggerTimeline())
    }
    _CanResume()
    {
        if (!this.GetLoop())
            if (this.GetPingPong() &&
            1 === this._pingPongState)
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime())
                        return !1
                } else {
                    if (0 >= this.GetTime())
                        return !1
                }
            else if (!this.GetLoop() && !this.GetPingPong())
                if (this.IsForwardPlayBack()) {
                    if (this.GetTime() >= this.GetTotalTime())
                        return !1
                } else if (0 >= this.GetTime())
                    return !1;
        return !0
    }
    Resume()
    {
        this.IsReleased() || this._CanResume() && this.Play(!0)
    }
    Play(a=!1)
    {
        return this.IsReleased() || this.IsScheduled() ? !1 : this._IsPlaying() && this.IsCompletedTick() ? this._SchedulePlayingTimeline() : this._IsPlaying() ||
        !this.IsComplete() && !a && !this.IsImplicitPause() ? !1 : this._ScheduleStoppedTimeline()
    }
    _SchedulePlayingTimeline()
    {
        this.SetImplicitPause(!1);
        this._timelineManager.RemovePlayingTimeline(this);
        this._timelineManager.ScheduleTimeline(this);
        this.GetPlayPromise();
        return !0
    }
    _ScheduleStoppedTimeline()
    {
        this.SetImplicitPause(!1);
        this._timelineManager.ScheduleTimeline(this);
        this.GetPlayPromise();
        return !0
    }
    Stop(a=!1)
    {
        this.IsReleased() || (this.SetComplete(a), this._timelineManager.CompleteTimeline(this), this.IsComplete() &&
        this.ResolvePlayPromise())
    }
    Reset(a=!0, b=!1)
    {
        if (!this.IsReleased()) {
            if (!this._IsPlaying() && this.IsScheduled())
                return this._timelineManager.DeScheduleTimeline(this);
            if (!this.IsComplete()) {
                this.Stop(!0);
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                var c = this.GetTime();
                this._SetUpdateStateBefore();
                b ? this._InterpolateBeforeChangeLayout(c) : this._Interpolate(c, !1, !1, !0);
                a && this._OnSetTime();
                this._SetUpdateStateAfter();
                this._renderChange && a && this.GetRuntime().UpdateRender()
            }
        }
    }
    ResetBeforeChangeLayout()
    {
        this.Reset(!1,
        !0)
    }
    _InterpolateBeforeChangeLayout(a)
    {
        this._Interpolate(a, !1, !1, !0, NaN, !1, !0)
    }
    _OnBeforeChangeLayout()
    {
        if (this.IsReleased())
            return !0;
        if (!this.GetRuntime().IsLoadingState() && this.HasValidGlobalTracks())
            return !1;
        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
        this.GetRuntime().IsLoadingState() || this.ResetBeforeChangeLayout();
        return !0
    }
    SetInitialStateFromSetTime()
    {
        this.SetInitialState(!0)
    }
    SetInitialStateForce()
    {
        this.SetInitialState(!1, !0);
        this.SetPlaying(!1);
        this.SetScheduled(!1)
    }
    SetInitialState(a=
    !1, b=!1)
    {
        if (!this.IsMarkedForRemoval() || b) {
            if (a) {
                this._finishedTriggers = !1;
                this._firstTick = this._initialStateSet = !0;
                this._SetUpdateStateBefore();
                for (const c of this._tracks)
                    c.SetInitialState()
            } else if (this.SetPlaying(!0), this.SetScheduled(!1), this.OnStarted(), this.IsComplete()) {
                this._completedTick = -1;
                0 !== this._pingPongState && (this._playbackRate = Math.abs(this._playbackRate));
                this._pingPongState = 0;
                this._currentRepeatCount = 1;
                this._finishedTriggers = this._complete = !1;
                this._firstTick = this._initialStateSet =
                !0;
                this.IsForwardPlayBack() ? this._SetTime(0) : this._SetTime(this.GetTotalTime());
                this._SetUpdateStateBefore();
                for (const c of this._tracks)
                    c.SetInitialState()
            } else {
                this._firstTick = !0;
                this._finishedTriggers = !1;
                this._SetUpdateStateBefore();
                for (const c of this._tracks)
                    c.SetResumeState()
            }
            this._SetUpdateStateAfter()
        }
    }
    GetRenderChange()
    {
        return this._renderChange
    }
    _SetUpdateStateBefore()
    {
        this._hasNestedContent = 0;
        for (const a of this._tracks)
            a.IsNested() && (this._hasNestedContent = 1)
    }
    _SetUpdateStateAfter()
    {
        this._renderChange =
        0;
        for (const a of this._tracks)
            a._SetUpdateState(),
            0 === this._renderChange && 1 === a.GetRenderChange() && (this._renderChange = 1),
            this._beforeAndAfterTracks || 1 !== a.GetNeedsBeforeAndAfter() || (this._beforeAndAfterTracks || (this._beforeAndAfterTracks = []), this._beforeAndAfterTracksLength = this._beforeAndAfterTracks.push(a))
    }
    Tick(a, b, c)
    {
        if (this.GetUseSystemTimescale()) {
            if (0 === a && 0 === this._lastDelta)
                return;
            this._lastDelta = a;
            a = c
        } else {
            if (0 === c && 0 === this._lastDelta)
                return;
            a = this._lastDelta = c;
            b = 1
        }
        c = this._playheadTime +
        this._overshoot;
        b = c + a * b * this._playbackRate;
        a = this._timelineDataItem._totalTime;
        0 > b ? (this._playheadTime = 0, this._overshoot = -b) : b >= a ? (this._playheadTime = a, this._overshoot = this._playheadTime - b) : (this._playheadTime = b, this._overshoot = 0);
        var d = !1;
        b = !1;
        var e = this.GetLoop(),
            f = this.GetPingPong();
        e || f ? e && !f ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTimeAndReset(0), b = !0) : 0 >= this._playheadTime && (this._SetTimeAndReset(a), b = !0) : !e && f ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 *
        this.GetPlaybackRate()), b = !0, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : d = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), b = !0, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._pingPongState = 0) : d = !0 : 0 === this._pingPongState && (this._pingPongState = 1)) : e && f && (0 < this._playbackRate ?
        this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), b = !0, this._pingPongState++, C3$jscomp$110.wrap(this._pingPongState, 0, 2)) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), b = !0, this._pingPongState++, C3$jscomp$110.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), b = !0) : (this._SetTime(a), d = !0)) : 0 >=
        this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(a), b = !0) : (this._SetTime(0), d = !0));
        e = this._tracksLength;
        if (d) {
            for (d = 0; d < e; d++)
                this._tracks[d].SetEndState();
            this.Stop(!0);
            this.OnCompleted()
        } else {
            f = this._beforeAndAfterTracksLength;
            for (d = 0; d < f; d++)
                this._beforeAndAfterTracks[d].BeforeInterpolate();
            if (1 === this._hasNestedContent)
                for (d = 0; d < e; d++) {
                    const g = this._tracks[d],
                        h = g.GetStartOffset(),
                        k = c - h;
                    0 > this._playheadTime - h && 0 < k ? (this._playheadTime =
                    0 > h ? 0 : h >= a ? a : h, g.Interpolate(h, !0, !1, b, this._firstTick, !1)) : g.Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1)
                }
            else
                for (d = 0; d < e; d++)
                    this._tracks[d].Interpolate(this._playheadTime, !0, !1, b, this._firstTick, !1);
            for (d = 0; d < f; d++)
                this._beforeAndAfterTracks[d].AfterInterpolate();
            this._firstTick && (this._firstTick = !1)
        }
    }
    _Interpolate(a, b=!1, c=!1, d=!1, e=NaN, f=!1, g=!1)
    {
        for (var h of this._tracks)
            h.BeforeInterpolate();
        for (const k of this._tracks) {
            h = a;
            if ("number" === typeof e && !isNaN(e)) {
                const l = this.GetTime() -
                    k.GetStartOffset(),
                    m = e - k.GetStartOffset();
                0 > l && 0 < m && (h = k.GetStartOffset(), this._SetTime(h))
            }
            k.Interpolate(h, b, c, d, this._firstTick, g)
        }
        for (const k of this._tracks)
            k.AfterInterpolate();
        this._firstTick && f && (this._firstTick = !1)
    }
    AddTrack()
    {
        var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
        a = C3$jscomp$110.TrackState.Create(this, a);
        this._tracksLength = this._tracks.push(a);
        return a
    }
    Removed()
    {
        if (!this.IsReleased())
            for (const a of this._tracks)
                a.TimelineRemoved()
    }
    CleanCaches()
    {
        for (const a of this._tracks)
            a.CleanCaches()
    }
    ClearTrackInstances()
    {
        for (const a of this._tracks)
            a.ClearInstance()
    }
    SetTrackInstance(a,
    b, c)
    {
        if (b)
            if ("number" === typeof c && 0 <= c) {
                if (a = this._tracks[c])
                    a.SetInstance(b),
                    this._timelineManager.SetTimelineObjectClassToMap(b.GetObjectClass(), this)
            } else
                for (const d of this._tracks)
                    if (d.IsInstanceTrack()) {
                        if (a) {
                            if (d.GetId() !== a)
                                continue
                        } else if (d.HasInstance())
                            continue;
                        d.SetInstance(b);
                        this._timelineManager.SetTimelineObjectClassToMap(b.GetObjectClass(), this);
                        break
                    }
    }
    HasTrackInstance(a, b)
    {
        for (const c of this._tracks)
            if (c.IsInstanceTrack())
                if (b) {
                    if (b === c.GetId() && a === c.GetInstance())
                        return !0
                } else if (a ===
                c.GetInstance())
                    return !0;
        return !1
    }
    HasValidTracks()
    {
        return this._tracks.some(a => a.IsInstanceTrack() ? a.CanInstanceBeValid() : !0)
    }
    HasValidGlobalTracks()
    {
        return this._tracks.some(a => a.IsInstanceTrack() ? a.CanInstanceBeValid() ? (a = a.GetObjectClass()) ? a.IsGlobal() : !1 : !1 : !1)
    }
    GetPropertyTrack(a)
    {
        for (const b of this.GetTracks())
            for (const c of b.GetPropertyTracks())
                if (c.GetPropertyName() === a)
                    return c
    }
    GetTrackFromInstance(a)
    {
        for (const b of this._tracks)
            if (a === b.GetInstance())
                return b;
        return null
    }
    GetKeyframeWithTags(a)
    {
        a =
        a ? a.split(" ") : [];
        a = [...(new Set(a.map(b => b.toLowerCase().trim()))).values()];
        for (const b of this.GetTracks())
            for (const c of b.GetKeyframeDataItems())
                if (a.every(d => c.HasTag(d)))
                    return c
    }
    GetObjectClasses()
    {
        const a = [];
        for (const b of this.GetTracks())
            a.push(b.GetObjectClass());
        return a.filter(b => b)
    }
    _OnAfterLoad()
    {
        for (const a of this.GetTracks())
            a._OnAfterLoad()
    }
    _SaveToJson()
    {
        return {
            tracksJson: this._SaveTracksToJson(),
            name: this._name,
            playheadTime: this.GetTime(),
            playbackRate: this._playbackRate,
            pingPongState: this._pingPongState,
            currentRepeatCount: this._currentRepeatCount,
            isPlaying: this._isPlaying,
            isScheduled: this._isScheduled,
            initialStateSet: this._initialStateSet,
            finishedTriggers: this._finishedTriggers,
            complete: this._complete,
            released: this._released,
            markedForRemoval: this._markedForRemoval,
            completedTick: this._completedTick,
            implicitPause: this._implicitPause,
            isTemplate: this._isTemplate,
            tags: this._tags.join(" "),
            stringTags: this._stringTags,
            tagsChanged: this._tagsChanged,
            firstTick: this._firstTick
        }
    }
    _LoadFromJson(a)
    {
        a && (this._LoadTracksFromJson(a.tracksJson),
        this._name = a.name, this._playheadTime = a.playheadTime, this._playbackRate = a.playbackRate, this._pingPongState = a.pingPongState, this._currentRepeatCount = a.currentRepeatCount, this._isPlaying = !!a.isPlaying, this._isScheduled = !!a.isScheduled, this._initialStateSet = !!a.initialStateSet, this._finishedTriggers = a.hasOwnProperty("finishedTriggers") ? !!a.finishedTriggers : !1, this._complete = !!a.complete, this._released = !!a.released, this._markedForRemoval = !!a.markedForRemoval, this._completedTick = a.completedTick, this._implicitPause =
        !!a.implicitPause, this._isTemplate = !!a.isTemplate, this._tags = a.tags.split(" "), this._stringTags = a.stringTags, this._tagsChanged = !!a.tagsChanged, this._firstTick = !!a.firstTick)
    }
    _SaveTracksToJson()
    {
        return this._tracks.map(a => a._SaveToJson())
    }
    _LoadTracksFromJson(a)
    {
        this.ClearTrackInstances();
        a.forEach((b, c) => {
            this._tracks[c]._LoadFromJson(b)
        });
        this._tracks.filter(b => b.CanInstanceBeValid())
    }
    static _HasTag(a)
    {
        const b = this.GetTags();
        return "" === a ? 1 === b.length && "" === b[0] : b.map(c => c.toLowerCase()).includes(a.toLowerCase())
    }
    static _GetTagArray(a)
    {
        if (C3$jscomp$110.IsArray(a))
            return a.slice(0);
        if (C3$jscomp$110.IsString(a))
            return a.split(" ");
        throw Error("invalid tags");
    }
    GetITimelineState()
    {
        this._iTimelineState || (this._iTimelineState = C3$jscomp$110.New(self.ITimelineState, this));
        return this._iTimelineState
    }
}
;
"use strict";
const C3$jscomp$111 = self.C3;
C3$jscomp$111.TrackState = class  extends C3$jscomp$111.DefendedBase{
    constructor(a, b)
    {
        super();
        this._timeline = a;
        this._trackDataItem = b;
        this._trackData = b.GetTrackData();
        this._objectClassIndex = this._instanceUid = NaN;
        this._worldInfo = this._instance = null;
        this._cleared = !1;
        this._isNested = 0 < b.GetStartOffset();
        this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
        this._instanceUidToLoad = NaN;
        this._lastKeyframeDataItem = null;
        this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray();
        this._propertyTracks = [];
        this.CreatePropertyTrackStates();
        this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0
    }
    static Create(a, b)
    {
        return C3$jscomp$111.New(C3$jscomp$111.TrackState, a, b)
    }
    Release()
    {
        this._keyframeDataItems = null;
        for (const a of this._propertyTracks)
            a.Release();
        C3$jscomp$111.clearArray(this._propertyTracks);
        this._lastKeyframeDataItem = this._trackDataItem = this._worldInfo = this._instance = this._timeline = this._propertyTracks = null
    }
    CreatePropertyTrackStates()
    {
        for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())
            this._propertyTracks.push(C3$jscomp$111.PropertyTrackState.Create(this,
            a))
    }
    TimelineRemoved()
    {
        for (const a of this._propertyTracks)
            a.TimelineRemoved()
    }
    CleanCaches()
    {
        for (const a of this._propertyTracks)
            a.CleanCaches();
        this._worldInfo = this._instance = null
    }
    GetTimeline()
    {
        return this._timeline
    }
    GetRuntime()
    {
        return this._timeline.GetRuntime()
    }
    GetKeyframeDataItems()
    {
        return this._keyframeDataItems ? this._keyframeDataItems : this._keyframeDataItems = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemArray()
    }
    GetPropertyTracks()
    {
        return this._propertyTracks
    }
    GetPropertyTrack(a)
    {
        for (let b =
        0; b < this._propertyTracks.length; b++) {
            const c = this._propertyTracks[b];
            if (c.GetPropertyName() === a)
                return c
        }
    }
    MaybeGetInstance()
    {
        this._instance || this.GetInstance()
    }
    IsInstanceValid()
    {
        return this._instance ? !this._instance.IsDestroyed() : !1
    }
    CanInstanceBeValid()
    {
        if (!this.IsInstanceTrack())
            return !1;
        var a = this.GetInstanceUID();
        return (a = this.GetRuntime().GetInstanceByUID(a)) ? !a.IsDestroyed() : !1
    }
    GetObjectClass()
    {
        if (this.IsInstanceTrack()) {
            var a = this.GetObjectClassIndex();
            if (-1 !== a)
                return this.GetRuntime().GetObjectClassByIndex(a)
        }
    }
    GetTrackIndexInTimeline()
    {
        return this._timeline.GetTracks().indexOf(this)
    }
    ClearInstance()
    {
        this._instance =
        null;
        this._instanceUid = NaN;
        this._worldInfo = null;
        this._objectClassIndex = NaN;
        this._cleared = !0
    }
    HasInstance()
    {
        return !!this._instance
    }
    GetInstance()
    {
        if (!this._cleared) {
            if (this._instance && this.IsInstanceValid())
                return this._instance;
            var a = this.GetInstanceUID();
            return this._instance = this.GetRuntime().GetInstanceByUID(a)
        }
    }
    SetInstance(a)
    {
        this._cleared = !1;
        if (this._instance !== a) {
            this.CleanCaches();
            this._instance = a;
            this._objectClassIndex = a.GetObjectClass().GetIndex();
            this._instanceUid = a.GetUID();
            this._worldInfo =
            a.GetWorldInfo();
            for (const f of this.propertyTrackItems()) {
                const g = f.sourceAdapter;
                switch (f.propertyTrack.GetSourceAdapterId()) {
                case "instance-variable":
                    g.GetEditorIndex();
                    var b = a.GetObjectClass(),
                        c = b.GetInstanceVariableIndexByName(f.name),
                        d = b.GetInstanceVariableName(c);
                    b = b.GetInstanceVariableType(c);
                    d === f.name && b === f.type && g.UpdateInstanceVariableIndex(c);
                    break;
                case "behavior":
                    var e = f.behaviorType;
                    c = this.GetObjectClass();
                    d = a.GetObjectClass();
                    b = g.GetBehaviorType(d);
                    e && b && (e = e.GetName(), c.GetBehaviorIndexByName(e),
                    d.GetBehaviorIndexByName(e), g.GetEditorIndex(), g.UpdateBehaviorTypeSid(b.GetSID()))
                }
            }
        }
    }
    *propertyTrackItems()
    {
        for (const c of this._propertyTracks) {
            var a = c.GetSourceAdapter(),
                b = this.GetObjectClass();
            const d = {
                propertyTrack: c,
                sourceAdapter: a
            };
            switch (c.GetSourceAdapterId()) {
            case "world-instance":
                d.property = c.GetPropertyName();
                break;
            case "instance-variable":
                a = a.GetEditorIndex();
                d.name = b.GetInstanceVariableName(a);
                d.type = b.GetInstanceVariableType(a);
                break;
            case "effect":
                b = b.GetEffectList();
                a = a.GetEffectType(b);
                d.effectType = a;
                break;
            case "behavior":
                a = a.GetBehaviorType(b);
                d.behaviorType = a;
                break;
            case "plugin":
                d.plugin = b.GetPlugin()
            }
            yield d
        }
    }
    GetWorldInfo()
    {
        if (this._worldInfo && this.IsInstanceValid())
            return this._worldInfo;
        const a = this.GetInstance();
        a && (this._worldInfo = a.GetWorldInfo());
        return this._worldInfo
    }
    GetTrackDataItem()
    {
        return this._trackDataItem
    }
    GetInstanceUID()
    {
        return isNaN(this._instanceUid) ? this._trackDataItem.GetInstanceUID() : this._instanceUid
    }
    SetInstanceUID(a)
    {
        this._trackDataItem.SetInstanceUID(a)
    }
    GetInterpolationMode()
    {
        return this._trackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a)
    {
        this._trackDataItem.SetInterpolationMode(a)
    }
    GetResultMode()
    {
        return this._trackDataItem.GetResultMode()
    }
    GetId()
    {
        return this._trackDataItem.GetId()
    }
    GetStartOffset()
    {
        return this._trackDataItem.GetStartOffset()
    }
    GetLocalTotalTime()
    {
        return this._trackDataItem.GetLocalTotalTime()
    }
    SetLocalTotalTime(a)
    {
        this._trackDataItem.SetLocalTotalTime(a)
    }
    SetResultMode(a)
    {
        this._trackDataItem.SetResultMode(a)
    }
    SetEase(a)
    {
        for (const b of this.GetKeyframeDataItems())
            b.SetEase(a);
        for (const b of this.GetPropertyTracks())
            b.SetEase(a)
    }
    GetEnable()
    {
        return this._trackDataItem.GetEnable()
    }
    SetEnable(a)
    {
        this._trackDataItem.SetEnable(a)
    }
    GetObjectClassIndex()
    {
        return isNaN(this._objectClassIndex) ? this._trackDataItem.GetObjectClassIndex() : this._objectClassIndex
    }
    SetObjectClassIndex(a)
    {
        this._trackDataItem.SetObjectClassIndex(a)
    }
    SetOriginalWidth(a)
    {
        this._trackDataItem.SetOriginalWidth(a)
    }
    GetOriginalWidth()
    {
        const a = this.GetInstance();
        return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalWidth() :
        this._trackDataItem.GetOriginalWidth()
    }
    SetOriginalHeight(a)
    {
        this._trackDataItem.SetOriginalHeight(a)
    }
    GetOriginalHeight()
    {
        const a = this.GetInstance();
        return a && a.GetSdkInstance().IsOriginalSizeKnown() ? a.GetSdkInstance().GetOriginalHeight() : this._trackDataItem.GetOriginalHeight()
    }
    GetType()
    {
        return this._trackDataItem.GetType()
    }
    GetName()
    {
        return this._trackDataItem.GetName()
    }
    IsInstanceTrack()
    {
        return 0 === this.GetType()
    }
    IsValueTrack()
    {
        return 1 === this.GetType()
    }
    IsAudioTrack()
    {
        return 2 === this.GetType()
    }
    GetWorldInfoChange()
    {
        return this._worldInfoChange
    }
    GetRenderChange()
    {
        return this._renderChange
    }
    GetNeedsBeforeAndAfter()
    {
        return this._needsBeforeAndAfter
    }
    IsNested()
    {
        return this._isNested
    }
    SetResetState()
    {
        for (const a of this._propertyTracks)
            a.SetResetState()
    }
    SetInitialState()
    {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
            for (const b of this._propertyTracks)
                b.SetInitialState(a),
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b => b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this.Interpolate(a);
            this.OnKeyframeReached(this._GetLastKeyFrameBeforeTime(a))
        }
    }
    SetResumeState()
    {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            this._timeline.IsForwardPlayBack();
            var a = this._timeline.GetTime() - this.GetStartOffset();
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            for (const b of this._propertyTracks)
                b.SetResumeState(a)
        }
    }
    SetEndState()
    {
        if (!(this.GetTimeline().IsComplete() || (this.MaybeGetInstance(),
        !this.IsInstanceValid() && this.IsInstanceTrack() || this._isNested))) {
            const a = this._timeline.GetTime(),
                b = this.GetStartOffset() + this.GetLocalTotalTime();
            a >= b ? this.Interpolate(this.GetLocalTotalTime(), !0, !1, !0, !1, !1, !0) : 0 >= a && this.Interpolate(0, !0, !1, !0, !1, !1, !0)
        }
    }
    _SetUpdateState()
    {
        for (let a = 0, b = this._propertyTracks.length; a < b; a++) {
            const c = this._propertyTracks[a];
            c._SetUpdateState();
            0 === this._worldInfoChange && 1 === c.GetWorldInfoChange() && (this._worldInfoChange = 1);
            0 === this._renderChange && 1 === c.GetRenderChange() &&
            (this._renderChange = 1)
        }
    }
    BeforeInterpolate()
    {
        const a = this._propertyTracks.length;
        for (let b = 0; b < a; b++)
            this._propertyTracks[b].BeforeInterpolate()
    }
    Interpolate(a, b=!1, c=!1, d=!1, e=!1, f=!1, g=!1)
    {
        this._instance || this.GetInstance();
        const h = this._instance && !this._instance.IsDestroyed(),
            k = 0 === this._trackDataItem._type;
        if (!(!h && k || f && k && this.GetObjectClass().IsGlobal() || (a -= this.GetStartOffset(), 0 > a))) {
            this.MaybeSetInitialStateOfNestedTrack(a, b);
            this.MaybeTriggerKeyframeReachedConditions(a, b, e);
            for (let l = 0,
                m = this._propertyTracks.length; l < m; l++)
                this._propertyTracks[l].Interpolate(a, c, d, g);
            this.MaybeSetEndStateOfNestedTrack(a, b);
            0 !== this._worldInfoChange && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged())
        }
    }
    AfterInterpolate()
    {
        const a = this._propertyTracks.length;
        for (let b = 0; b < a; b++)
            this._propertyTracks[b].AfterInterpolate()
    }
    MaybeSetInitialStateOfNestedTrack(a, b)
    {
        if (b && this._isNested && !this._initialStateOfNestedSet) {
            if (this.GetTimeline().IsForwardPlayBack()) {
                if (0 >
                a)
                    return
            } else if (a > this.GetLocalTotalTime())
                return;
            for (const c of this._propertyTracks)
                c.SetInitialState();
            this._initialStateOfNestedSet = !0
        }
    }
    MaybeSetEndStateOfNestedTrack(a, b)
    {
        if (b && this._isNested && !this._endStateOfNestedSet)
            if (this.GetTimeline().IsForwardPlayBack()) {
                if (a >= this.GetLocalTotalTime()) {
                    for (const c of this._propertyTracks)
                        c.Interpolate(this.GetLocalTotalTime(), !1, !0);
                    this._endStateOfNestedSet = !0
                }
            } else if (0 >= a) {
                for (const c of this._propertyTracks)
                    c.Interpolate(0, !1, !0);
                this._endStateOfNestedSet =
                !0
            }
    }
    MaybeTriggerKeyframeReachedConditions(a, b, c)
    {
        if (!c && b && C3$jscomp$111.Plugins.Timeline) {
            b = this.GetTimeline();
            c = this._lastKeyframeDataItem.GetNext();
            var d = this._lastKeyframeDataItem.GetTime(),
                e = c ? c.GetTime() : b.GetTotalTime();
            if (a <= d || a >= e)
                this._lastKeyframeDataItem = this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem),
                b.IsForwardPlayBack() ? c && this.OnKeyframeReached(this._lastKeyframeDataItem) : (a = this._lastKeyframeDataItem.GetNext()) && this.OnKeyframeReached(a)
        }
    }
    _GetLastKeyFrameBeforeTime(a)
    {
        const b =
        this._trackData.GetKeyFrameDataItemAtTime(a, this._trackDataItem);
        return b ? b : this._trackData.GetFirstKeyFrameDataItemLowerOrEqualThan(a, this._trackDataItem)
    }
    OnKeyframeReached(a)
    {
        if (C3$jscomp$111.Plugins.Timeline) {
            var b = this.GetTimeline(),
                c = b.GetTimelineManager();
            C3$jscomp$111.Plugins.Timeline.Cnds.PushTriggerTimeline(b);
            C3$jscomp$111.Plugins.Timeline.Cnds.PushTriggerKeyframe(a);
            c.Trigger(C3$jscomp$111.Plugins.Timeline.Cnds.OnAnyKeyframeReached);
            c.Trigger(C3$jscomp$111.Plugins.Timeline.Cnds.OnKeyframeReached);
            C3$jscomp$111.Plugins.Timeline.Cnds.PopTriggerTimeline(b);
            C3$jscomp$111.Plugins.Timeline.Cnds.PopTriggerKeyframe(a)
        }
    }
    AddKeyframe()
    {
        return this._trackDataItem.GetKeyframeData().AddEmptyKeyframeDataItem()
    }
    AddPropertyTrack()
    {
        var a = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
        a = C3$jscomp$111.PropertyTrackState.Create(this, a);
        this._propertyTracks.push(a);
        return a
    }
    DeleteKeyframes(a)
    {
        this._trackDataItem.GetKeyframeData().DeleteKeyframeDataItems(a)
    }
    DeletePropertyKeyframes(a)
    {
        for (const b of this._propertyTracks)
            b.DeletePropertyKeyframes(a)
    }
    SaveState()
    {
        for (const a of this._propertyTracks)
            a.SaveState()
    }
    CompareInitialStateWithCurrent()
    {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack())
            for (const a of this._propertyTracks)
                a.CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent()
    {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = !1;
            for (const b of this._propertyTracks) {
                const c = b.CompareSaveStateWithCurrent();
                !a && c && (a = !0)
            }
            a && (a = this.AddKeyframe(), a.SetTime(this.GetTimeline().GetTime()), a.SetEase("noease"), a.SetEnable(!0), a.SetTags(""))
        }
    }
    _OnAfterLoad()
    {
        isNaN(this._instanceUidToLoad) || this._LoadInstanceFromJson(this._instanceUidToLoad);
        this._instanceUidToLoad = NaN
    }
    _SaveToJson()
    {
        var a = this.GetInstance();
        a = a ? a.GetUID() : this.GetInstanceUID();
        return {
            propertyTracksJson: this._SavePropertyTracksToJson(),
            lastKeyframeDataItemJson: this._SaveLastKeyframeDataItemToJson(),
            initialStateOfNestedSet: this._initialStateOfNestedSet,
            endStateOfNestedSet: this._endStateOfNestedSet,
            instanceUid: a,
            cleared: this._cleared
        }
    }
    _LoadFromJson(a)
    {
        if (a) {
            this._LoadPropertyTracksFromJson(a.propertyTracksJson);
            this._LoadLastKeyframeDataItemFromJson(a.lastKeyframeDataItemJson);
            this._instanceUidToLoad = a.instanceUid;
            this._initialStateOfNestedSet = !1;
            a.hasOwnProperty.initialStateOfNestedSet && (this._initialStateOfNestedSet = a.initialStateOfNestedSet);
            this._endStateOfNestedSet = !1;
            a.hasOwnProperty.endStateOfNestedSet && (this._endStateOfNestedSet = a.endStateOfNestedSet);
            this._cleared = a.hasOwnProperty("cleared") ? a.cleared : !1;
            for (const b of this._propertyTracks)
                0 === this._worldInfoChange && 1 === b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() &&
                (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b => b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1)
        }
    }
    _SaveLastKeyframeDataItemToJson()
    {
        return this._trackDataItem.GetKeyframeData().GetKeyframeDataItemIndex(this._lastKeyframeDataItem)
    }
    _SavePropertyTracksToJson()
    {
        return this._propertyTracks.map(a => a._SaveToJson())
    }
    _LoadPropertyTracksFromJson(a)
    {
        a.forEach((b, c) => {
            this._propertyTracks[c]._LoadFromJson(b)
        })
    }
    _LoadInstanceFromJson(a)
    {
        C3$jscomp$111.IsFiniteNumber(a) &&
        (a = this.GetRuntime().GetInstanceByUID(a)) && this.GetTimeline().SetTrackInstance(this._trackDataItem.GetId(), a, this.GetTrackIndexInTimeline())
    }
    _LoadLastKeyframeDataItemFromJson(a)
    {
        this._lastKeyframeDataItem = this._trackDataItem.GetKeyframeData().GetKeyframeDataItemFromIndex(a)
    }
}
;
"use strict";
const C3$jscomp$112 = self.C3;
C3$jscomp$112.PropertyTrackState = class  extends C3$jscomp$112.DefendedBase{
    constructor(a, b)
    {
        super();
        this._track = a;
        this._propertyTrackDataItem = b;
        this._propertyTrackData = b.GetPropertyTrackData();
        this._needsBeforeAndAfter = this._renderChange = this._worldInfoChange = 0;
        this._sourceAdapter = this.GetSourceAdapter();
        this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        this._absoluteValueObject = this._lastPropertyKeyframeDataItem = null
    }
    static Create(a,
    b)
    {
        return C3$jscomp$112.New(C3$jscomp$112.PropertyTrackState, a, b)
    }
    Release()
    {
        this._track = null;
        this._sourceAdapter && (this._sourceAdapter.Release(), this._sourceAdapter = null);
        this._propertyTrackData = this._propertyTrackDataItem = this._propertyKeyframeDataItems = null
    }
    GetWorldInfoChange()
    {
        return this._worldInfoChange
    }
    GetRenderChange()
    {
        return this._renderChange
    }
    GetNeedsBeforeAndAfter()
    {
        return this._needsBeforeAndAfter
    }
    HasAbsoluteValueObject()
    {
        return !!this._absoluteValueObject
    }
    SetAbsoluteValueObject(a)
    {
        this._absoluteValueObject =
        a
    }
    GetAbsoluteValueObject()
    {
        return this._absoluteValueObject
    }
    GetTrack()
    {
        return this._track
    }
    GetPropertyTrackDataItem()
    {
        return this._propertyTrackDataItem
    }
    GetPropertyTrackData()
    {
        return this._propertyTrackData
    }
    GetTimeline()
    {
        return this._track.GetTimeline()
    }
    GetRuntime()
    {
        return this._track.GetRuntime()
    }
    GetInstance()
    {
        return this._track.GetInstance()
    }
    GetSourceAdapter()
    {
        if (this._sourceAdapter)
            return this._sourceAdapter;
        let a;
        switch (this._propertyTrackDataItem.GetSourceAdapterId()) {
        case "behavior":
            a = new C3$jscomp$112.PropertyTrackState.BehaviorSourceAdapter(this);
            break;
        case "effect":
            a = new C3$jscomp$112.PropertyTrackState.EffectSourceAdapter(this);
            this._renderChange = 1;
            break;
        case "instance-variable":
            a = new C3$jscomp$112.PropertyTrackState.InstanceVariableSourceAdapter(this);
            break;
        case "plugin":
            a = new C3$jscomp$112.PropertyTrackState.PluginSourceAdapter(this);
            this._renderChange = 1;
            break;
        case "world-instance":
            a = new C3$jscomp$112.PropertyTrackState.PropertySourceAdapter(this);
            this._worldInfoChange = this._renderChange = 1;
            break;
        case "value":
            a = new C3$jscomp$112.PropertyTrackState.ValueSourceAdapter(this);
            break;
        case "audio":
            a = new C3$jscomp$112.PropertyTrackState.AudioSourceAdapter(this)
        }
        return this._sourceAdapter = a
    }
    GetSourceAdapterId()
    {
        return this._propertyTrackDataItem.GetSourceAdapterId()
    }
    SetSourceAdapterId(a)
    {
        this._propertyTrackDataItem.SetSourceAdapterId(a)
    }
    GetSourceAdapterArgs()
    {
        return this._propertyTrackDataItem.GetSourceAdapterArguments()
    }
    SetSourceAdapterArgs(a)
    {
        this._propertyTrackDataItem.SetSourceAdapterArguments(a)
    }
    GetSourceAdapterValue()
    {
        return this.GetSourceAdapter().GetValue()
    }
    GetPropertyName()
    {
        return this._propertyTrackDataItem.GetProperty()
    }
    SetPropertyName(a)
    {
        this._propertyTrackDataItem.SetProperty(a)
    }
    GetPropertyType()
    {
        return this._propertyTrackDataItem.GetType()
    }
    SetPropertyType(a)
    {
        this._propertyTrackDataItem.SetType(a)
    }
    GetPropertyKeyframeType()
    {
        return this.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem).GetType()
    }
    GetMin()
    {
        return this._propertyTrackDataItem.GetMin()
    }
    SetMin(a)
    {
        this._propertyTrackDataItem.SetMin(a)
    }
    GetMax()
    {
        return this._propertyTrackDataItem.GetMax()
    }
    SetMax(a)
    {
        this._propertyTrackDataItem.SetMax(a)
    }
    GetEnable()
    {
        return this._propertyTrackDataItem.GetEnable()
    }
    SetEnable(a)
    {
        this._propertyTrackDataItem.SetEnable(a)
    }
    GetInterpolationMode()
    {
        return this._propertyTrackDataItem.GetInterpolationMode()
    }
    SetInterpolationMode(a)
    {
        this._propertyTrackDataItem.SetInterpolationMode(a)
    }
    GetResultMode()
    {
        return this._propertyTrackDataItem.GetResultMode()
    }
    SetResultMode(a)
    {
        this._propertyTrackDataItem.SetResultMode(a)
    }
    SetEase(a)
    {
        for (const b of this.GetPropertyKeyframeDataItems())
            b.SetEase(a)
    }
    CanHavePropertyKeyframes()
    {
        return this._propertyTrackDataItem.CanHavePropertyKeyframes()
    }
    GetPropertyKeyframeDataItems()
    {
        return this._propertyKeyframeDataItems ?
        this._propertyKeyframeDataItems : this._propertyKeyframeDataItems = this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled()
    {
        return this._propertyTrackDataItem.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArrayIncludingDisabled()
    }
    GetPropertyKeyFrameDataItemAtTime(a)
    {
        return this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem)
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a)
    {
        return this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a,
        this._propertyTrackDataItem)
    }
    GetPropertyKeyframeDataItemPairForTime(a)
    {
        let b = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem);
        b ? a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherThan(a, this._propertyTrackDataItem) : (b = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem), a = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, this._propertyTrackDataItem));
        return {
            start: b,
            end: a
        }
    }
    *GetPropertyKeyframeValues()
    {
        for (const a of this.GetPropertyKeyframeDataItems())
            yield a.GetValueWithResultMode()
    }
    *GetPropertyKeyframeTimes()
    {
        for (const a of this.GetPropertyKeyframeDataItems())
            yield a.GetTime()
    }
    TimelineRemoved()
    {
        this.GetSourceAdapter().TimelineRemoved()
    }
    CleanCaches()
    {
        this.GetSourceAdapter().CleanCaches()
    }
    GetCurrentState()
    {
        return this.GetSourceAdapter().GetCurrentState()
    }
    SetResetState()
    {
        this.GetSourceAdapter().SetResetState()
    }
    SetInitialState(a)
    {
        this.GetSourceAdapter().SetInitialState();
        this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a);
        this._SetUpdateState()
    }
    SetResumeState(a)
    {
        this.GetSourceAdapter().SetResumeState();
        this._lastPropertyKeyframeDataItem = this._GetLastPropertyKeyFrameBeforeTime(a)
    }
    _SetUpdateState()
    {
        var a = this.GetTrack();
        this._needsBeforeAndAfter = 0;
        if (a.IsInstanceTrack()) {
            var b = this.GetTimeline();
            a = a.GetInstance();
            const c = this.GetSourceAdapter(),
                d = this.GetPropertyName();
            c.MayNeedBeforeAndAfterInterpolate() ? (b = b.GetSimilarPropertyTracks(a, c,
            d, this)) && b.length && (this._needsBeforeAndAfter = 1) : this._needsBeforeAndAfter = 0
        }
    }
    _GetLastPropertyKeyFrameBeforeTime(a)
    {
        const b = this.GetTimeline(),
            c = this._propertyTrackData.GetPropertyKeyFrameDataItemAtTime(a, this._propertyTrackDataItem);
        return c ? c : b.IsForwardPlayBack() ? this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem) : this._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, this._propertyTrackDataItem)
    }
    BeforeInterpolate()
    {
        this._sourceAdapter.BeforeInterpolate()
    }
    Interpolate(a,
    b=!1, c=!1, d=!1)
    {
        let e,
            f = !1;
        if (b)
            var g = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
        else {
            if (this._lastPropertyKeyframeDataItem) {
                var h = this.GetTimeline();
                const k = this._lastPropertyKeyframeDataItem.GetNext();
                g = this._lastPropertyKeyframeDataItem.GetTime();
                h = k ? k.GetTime() : h.GetTotalTime();
                if (a <= g || a >= h)
                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem),
                    f = !0
            } else
                this._lastPropertyKeyframeDataItem =
                this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem),
                f = !0;
            g = this._lastPropertyKeyframeDataItem
        }
        g && (e = g.GetNext());
        this._sourceAdapter.Interpolate(a, g, e, b, c, d, f)
    }
    GetInterpolatedValue(a)
    {
        if (this._lastPropertyKeyframeDataItem) {
            var b = this.GetTimeline();
            const d = this._lastPropertyKeyframeDataItem.GetNext();
            var c = this._lastPropertyKeyframeDataItem.GetTime();
            b = d ? d.GetTime() : b.GetTotalTime();
            if (a <= c || a >= b)
                this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a,
                this._propertyTrackDataItem)
        } else
            this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
        c = this._lastPropertyKeyframeDataItem;
        b = c.GetNext();
        return this._sourceAdapter.GetInterpolatedValue(a, c, b)
    }
    GetInterpolatedValueFast(a, b, c)
    {
        return this._sourceAdapter.GetInterpolatedValue(a, b, c)
    }
    AfterInterpolate()
    {
        this._sourceAdapter.AfterInterpolate()
    }
    static GetStartPropertyKeyframeForTime(a, b)
    {
        const c = b.GetPropertyTrackDataItem();
        return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, c)
    }
    static GetEndPropertyKeyframeForTime(a, b)
    {
        const c = b.GetPropertyTrackDataItem();
        return b._propertyTrackData.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, c)
    }
    AddPropertyKeyframe()
    {
        const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
        this._lastPropertyKeyframeDataItem = null;
        return a
    }
    DeletePropertyKeyframes(a)
    {
        this._lastPropertyKeyframeDataItem = null;
        this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a)
    }
    SaveState()
    {
        this.GetSourceAdapter().SaveState()
    }
    CompareInitialStateWithCurrent()
    {
        if (this.GetSourceAdapter().CompareInitialStateWithCurrent()) {
            const a =
                this._propertyTrackData.GetFirstPropertyKeyframeDataItem(this._propertyTrackDataItem),
                b = this.GetSourceAdapter().GetCurrentState();
            a.SetAbsoluteValue(b)
        }
    }
    CompareSaveStateWithCurrent()
    {
        const a = this.GetSourceAdapter().CompareSaveStateWithCurrent();
        a && this.AddPropertyKeyframeAtCurrentTime();
        this.GetSourceAdapter().ClearSaveState();
        return a
    }
    AddPropertyKeyframeAtCurrentTime()
    {
        const a = this.GetTimeline().GetTime(),
            b = this.GetSourceAdapter(),
            c = C3$jscomp$112.PropertyTrackState.GetStartPropertyKeyframeForTime(a,
            this),
            d = this.AddPropertyKeyframe();
        d.SetType(c.GetType());
        d.SetTime(a);
        d.SetEase(c.GetEase());
        d.SetEnable(!0);
        d.SetValue(b.GetValueAtTime());
        d.SetAbsoluteValue(b.GetCurrentState())
    }
    _SaveToJson()
    {
        return {
            sourceAdapterJson: this.GetSourceAdapter()._SaveToJson()
        }
    }
    _LoadFromJson(a)
    {
        a && this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson)
    }
}
;
"use strict";
const NS = self.C3.PropertyTrackState;
NS.PropertySourceAdapter = class {
    constructor(a)
    {
        this._propertyTrack = a;
        this._propertyAdapter = null;
        this.GetPropertyAdapter()
    }
    Release()
    {
        this._propertyAdapter && (this._propertyAdapter.Release(), this._propertyAdapter = null);
        this._propertyTrack = null
    }
    MayNeedBeforeAndAfterInterpolate()
    {
        return this._propertyAdapter.MayNeedBeforeAndAfterInterpolate()
    }
    GetPropertyTrack()
    {
        return this._propertyTrack
    }
    TimelineRemoved()
    {
        this._propertyAdapter && this._propertyAdapter.TimelineRemoved()
    }
    CleanCaches()
    {
        this._propertyAdapter &&
        this._propertyAdapter.CleanCaches()
    }
    GetPropertyAdapter()
    {
        return this._propertyAdapter ? this._propertyAdapter : this._propertyAdapter = this._CreatePropertyAdapter()
    }
    GetEditorIndex() {}
    GetIndex()
    {
        return this.GetEditorIndex()
    }
    GetTarget() {}
    SetResetState()
    {
        this.GetPropertyAdapter().SetResetState()
    }
    SetInitialState()
    {
        this.GetPropertyAdapter().SetInitialState()
    }
    SetResumeState()
    {
        this.GetPropertyAdapter().SetResumeState()
    }
    BeforeInterpolate()
    {
        this._propertyAdapter.BeforeChangeProperty()
    }
    Interpolate(a, b, c, d, e, f, g)
    {
        let h;
        switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
            h = NS.NumericTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "angle":
            h = NS.AngleTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "boolean":
            h = NS.BooleanTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "color":
            h = NS.ColorTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
            break;
        case "text":
            h = NS.TextTypeAdapter.Interpolate(a, b, c, this._propertyTrack)
        }
        this._propertyAdapter.ChangeProperty(a, h, b, c, d,
        e, f, g)
    }
    GetInterpolatedValue(a, b, c)
    {
        switch (this._propertyTrack.GetPropertyKeyframeType()) {
        case "numeric":
            return NS.NumericTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "angle":
            return NS.AngleTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "boolean":
            return NS.BooleanTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "color":
            return NS.ColorTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        case "text":
            return NS.TextTypeAdapter.Interpolate(a, b, c, this._propertyTrack)
        }
    }
    AfterInterpolate()
    {
        this._propertyAdapter.AfterChangeProperty()
    }
    SaveState()
    {
        this.GetPropertyAdapter().SetSaveState()
    }
    ClearSaveState()
    {
        this.GetPropertyAdapter().ClearSaveState()
    }
    GetCurrentState()
    {
        return this.GetPropertyAdapter().GetCurrentState()
    }
    CompareInitialStateWithCurrent()
    {
        return this.GetPropertyAdapter().CompareInitialStateWithCurrent()
    }
    CompareSaveStateWithCurrent()
    {
        return this.GetPropertyAdapter().CompareSaveStateWithCurrent()
    }
    GetValueAtTime()
    {
        const a =
            this._propertyTrack,
            b = a.GetTrack().GetTimeline().GetTime(),
            c = NS.GetStartPropertyKeyframeForTime(b, a),
            d = c.GetNext();
        switch (a.GetPropertyKeyframeType()) {
        case "numeric":
            return NS.NumericTypeAdapter.Interpolate(b, c, d, a);
        case "angle":
            return NS.AngleTypeAdapter.Interpolate(b, c, d, a);
        case "boolean":
            return NS.BooleanTypeAdapter.Interpolate(b, c, d, a);
        case "color":
            return NS.ColorTypeAdapter.Interpolate(b, c, d, a);
        case "text":
            return NS.TextTypeAdapter.Interpolate(b, c, d, a)
        }
    }
    _CreatePropertyAdapter()
    {
        const a = this._propertyTrack;
        switch (a.CanHavePropertyKeyframes() ? a.GetPropertyKeyframeType() : "") {
        case "combo":
        case "boolean":
        case "text":
        case "string":
            return new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this);
        case "numeric":
        case "number":
        case "angle":
            return "combo" === this._propertyTrack.GetPropertyType() ? new NS.PropertyInterpolationAdapter.NoInterpolationAdapter(this) : new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this);
        case "color":
        case "offsetColor":
            return new NS.PropertyInterpolationAdapter.ColorInterpolationAdapter(this);
        default:
            return new NS.PropertyInterpolationAdapter.NumericInterpolationAdapter(this)
        }
    }
    _SaveToJson()
    {
        return {
            propertyAdapterJson: this.GetPropertyAdapter()._SaveToJson()
        }
    }
    _LoadFromJson(a)
    {
        a && this.GetPropertyAdapter()._LoadFromJson(a.propertyAdapterJson)
    }
}
;
"use strict";
const C3$jscomp$114 = self.C3;
class InstanceVariableSourceAdapter extends C3$jscomp$114.PropertyTrackState.PropertySourceAdapter {
    constructor(a)
    {
        super(a);
        this._updatedIndex = NaN
    }
    GetEditorIndex()
    {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
    }
    GetIndex()
    {
        return this._updatedIndex ? this._updatedIndex : super.GetIndex()
    }
    GetTarget()
    {
        return this._propertyTrack.GetTrack().GetInstance()
    }
    UpdateInstanceVariableIndex(a)
    {
        this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._updatedIndex =
        a)
    }
    Interpolate(a, b, c, d, e, f, g)
    {
        this.GetPropertyAdapter().CanChange(b.GetValue()) && super.Interpolate(a, b, c, d, e, f, g)
    }
    GetInterpolatedValue(a, b, c)
    {
        if (this.GetPropertyAdapter().CanChange(b.GetValue()))
            return super.GetInterpolatedValue(a, b, c)
    }
    _SaveToJson()
    {
        return Object.assign(super._SaveToJson(), {
            index: this._updatedIndex
        })
    }
    _LoadFromJson(a)
    {
        a && (super._LoadFromJson(a), this._updatedIndex = a.index)
    }
}
C3$jscomp$114.PropertyTrackState.InstanceVariableSourceAdapter = InstanceVariableSourceAdapter;
"use strict";
const C3$jscomp$115 = self.C3;
class BehaviorSourceAdapter extends C3$jscomp$115.PropertyTrackState.PropertySourceAdapter {
    constructor(a)
    {
        super(a);
        this._sid = NaN
    }
    GetEditorIndex()
    {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget()
    {
        var a = this._propertyTrack.GetPropertyTrackDataItem(),
            b = this._propertyTrack.GetTrack();
        a = this._sid ? this._sid : a.GetSourceAdapterArguments()[0];
        b = b.GetInstance();
        a = b.GetBehaviorIndexBySID(a);
        return b.GetBehaviorInstances()[a].GetSdkInstance()
    }
    GetBehaviorType(a)
    {
        const b = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[2];
        return a.GetBehaviorTypeByName(b)
    }
    UpdateBehaviorTypeSid(a)
    {
        this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0] !== a && (this._sid = a)
    }
    Interpolate(a, b, c, d, e, f, g)
    {
        const h = this._propertyTrack.GetTrack().GetInstance();
        this.GetBehaviorType(h.GetObjectClass()) && super.Interpolate(a, b, c, d, e, f, g)
    }
    GetInterpolatedValue(a, b, c)
    {
        const d = this._propertyTrack.GetTrack().GetInstance();
        if (this.GetBehaviorType(d.GetObjectClass()))
            return super.GetInterpolatedValue(a, b, c)
    }
    _SaveToJson()
    {
        return Object.assign(super._SaveToJson(),
        {
            sid: this._sid
        })
    }
    _LoadFromJson(a)
    {
        a && (super._LoadFromJson(a), this._sid = a.sid)
    }
}
C3$jscomp$115.PropertyTrackState.BehaviorSourceAdapter = BehaviorSourceAdapter;
"use strict";
const C3$jscomp$116 = self.C3;
class EffectSourceAdapter extends C3$jscomp$116.PropertyTrackState.PropertySourceAdapter {
    constructor(a)
    {
        super(a)
    }
    GetEditorIndex()
    {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[1]
    }
    GetTarget()
    {
        const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
        var b = a.GetEffectList();
        b = this.GetEffectType(b).GetIndex();
        return a.IsEffectIndexActive(b) ? a.GetEffectParametersForIndex(b) : null
    }
    GetEffectType(a)
    {
        const b = this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0];
        return a.GetEffectTypeByName(b)
    }
    Interpolate(a, b, c, d, e, f, g)
    {
        this._IsEffectActive() && super.Interpolate(a, b, c, d, e, f, g)
    }
    GetInterpolatedValue(a, b, c)
    {
        if (this._IsEffectActive())
            return super.GetInterpolatedValue(a, b, c)
    }
    _IsEffectActive()
    {
        const a = this._propertyTrack.GetTrack().GetWorldInfo().GetInstanceEffectList();
        var b = a.GetEffectList();
        if (b = this.GetEffectType(b))
            return b = b.GetIndex(), a.IsEffectIndexActive(b)
    }
}
C3$jscomp$116.PropertyTrackState.EffectSourceAdapter = EffectSourceAdapter;
"use strict";
const C3$jscomp$117 = self.C3;
class PluginSourceAdapter extends C3$jscomp$117.PropertyTrackState.PropertySourceAdapter {
    constructor(a)
    {
        super(a)
    }
    GetEditorIndex()
    {
        return this._propertyTrack.GetPropertyTrackDataItem().GetSourceAdapterArguments()[0]
    }
    GetTarget()
    {
        return this._propertyTrack.GetTrack().GetInstance().GetSdkInstance()
    }
    Interpolate(a, b, c, d, e, f, g)
    {
        var h = this._propertyTrack.GetTrack();
        const k = h.GetObjectClass().GetPlugin();
        h = h.GetInstance().GetObjectClass().GetPlugin();
        k === h && super.Interpolate(a, b, c, d, e, f, g)
    }
    GetInterpolatedValue(a,
    b, c)
    {
        var d = this._propertyTrack.GetTrack();
        const e = d.GetObjectClass().GetPlugin();
        d = d.GetInstance().GetObjectClass().GetPlugin();
        if (e === d)
            return super.GetInterpolatedValue(a, b, c)
    }
    GetOptionalCallbacks()
    {
        const a = this._propertyTrack.GetTrack().GetObjectClass().GetPlugin();
        if (C3$jscomp$117.Plugins.Sprite && a instanceof C3$jscomp$117.Plugins.Sprite && ("initial-frame" === this._propertyTrack.GetPropertyName() || "initial-animation" === this._propertyTrack.GetPropertyName()))
            switch (this._propertyTrack.GetResultMode()) {
            case "relative":
                return null;
            case "absolute":
                return null
            }
    }
}
C3$jscomp$117.PropertyTrackState.PluginSourceAdapter = PluginSourceAdapter;
"use strict";
const C3$jscomp$118 = self.C3;
class ValueSourceAdapter extends C3$jscomp$118.PropertyTrackState.PropertySourceAdapter {
    constructor(a)
    {
        super(a);
        this._value = 0;
        this._init = !1
    }
    MayNeedBeforeAndAfterInterpolate()
    {
        return !1
    }
    SetInitialState()
    {
        const a = this._propertyTrack.GetPropertyTrackData();
        let b = this._propertyTrack.GetPropertyTrackDataItem();
        b = a.GetFirstPropertyKeyframeDataItem(b);
        this._value = b.GetValueWithResultMode()
    }
    SetResumeState() {}
    GetValue()
    {
        this._init || this._propertyTrack.Interpolate(0);
        return this._value
    }
    Interpolate(a, b, c, d, e,
    f, g)
    {
        this._value = C3$jscomp$118.PropertyTrackState.NumericTypeAdapter.Interpolate(a, b, c, this._propertyTrack);
        this._init = !0
    }
    SaveState() {}
    ClearSaveState() {}
    GetCurrentState()
    {
        return this._value
    }
    CompareInitialStateWithCurrent()
    {
        return !1
    }
    CompareSaveStateWithCurrent()
    {
        return !1
    }
    _SaveToJson()
    {
        return {
            value: this._value,
            init: this._init
        }
    }
    _LoadFromJson(a)
    {
        a && (this._value = a.value, this._init = a.hasOwnProperty("init") ? a.init : !0)
    }
}
C3$jscomp$118.PropertyTrackState.ValueSourceAdapter = ValueSourceAdapter;
"use strict";
const C3$jscomp$119 = self.C3;
class AudioSourceAdapter extends C3$jscomp$119.PropertyTrackState.PropertySourceAdapter {
    constructor(a)
    {
        super(a);
        this._audioPlaybackStarted = !1;
        this._expressions = this._actions = this._sdkInstance = null;
        this._timeline = this._propertyTrack.GetTimeline();
        this._track = this._propertyTrack.GetTrack();
        this._sourceAdapterArgs = this._propertyTrack.GetSourceAdapterArgs();
        this._fileArgs = this._sourceAdapterArgs[0];
        this._startOffsetTime = this._sourceAdapterArgs[1];
        this._audioTag = this._sourceAdapterArgs[3] ? this._sourceAdapterArgs[3] :
        Math.random().toString(36).slice(2);
        this._volume = this._pauseVolume = this._pauseTime = NaN;
        this._audioSource = null;
        this._Initialize()
    }
    Release()
    {
        super.Release();
        this._audioSource = this._fileArgs = this._sourceAdapterArgs = this._track = this._timeline = this._expressions = this._actions = this._sdkInstance = null
    }
    _Initialize()
    {
        if (self.C3.Plugins.Audio) {
            var a = this._propertyTrack.GetRuntime().GetSingleGlobalObjectClassByCtor(self.C3.Plugins.Audio);
            a && (this._sdkInstance = a.GetSingleGlobalInstance().GetSdkInstance());
            this._actions =
            self.C3.Plugins.Audio.Acts;
            this._expressions = self.C3.Plugins.Audio.Exps
        }
    }
    _MaybeSetAudioSource()
    {
        if (!this._audioSource) {
            var a = this._propertyTrack.GetTrack().GetPropertyTrack("audioSource");
            a && (this._audioSource = a.GetSourceAdapter())
        }
    }
    _GetPauseVolume()
    {
        const a = this._propertyTrack.GetTrack().GetPropertyTrack("volume");
        return a ? a.GetSourceAdapter()._pauseVolume : this._pauseVolume
    }
    TimelineRemoved()
    {
        super.TimelineRemoved();
        this._audioPlaybackStarted = !1;
        this._sdkInstance && (this._expressions && (this._pauseTime =
        this._expressions.PlaybackTime.call(this._sdkInstance, this._audioTag), this._pauseVolume = this._expressions.Volume.call(this._sdkInstance, this._audioTag)), this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag))
    }
    GetAudioTag()
    {
        return this._audioTag
    }
    GetVolume()
    {
        return this._volume
    }
    SetVolume(a)
    {
        this._volume = a
    }
    SetInitialState()
    {
        super.SetInitialState();
        this._pauseTime = NaN;
        this._audioPlaybackStarted = !1
    }
    SetResumeState()
    {
        super.SetResumeState();
        const a = this._propertyTrack.GetTimeline().GetTime();
        this._pauseTime = a - this._startOffsetTime;
        switch (this._propertyTrack.GetPropertyName()) {
        case "volume":
            this._pauseVolume = this._propertyTrack.GetInterpolatedValue(a)
        }
        this._audioPlaybackStarted = !1
    }
    Interpolate(a, b, c, d, e, f, g)
    {
        if (this._sdkInstance)
            switch (this._propertyTrack.GetPropertyName()) {
            case "audioSource":
                if (!this._timeline.IsForwardPlayBack())
                    break;
                if (d) {
                    this._actions && this._actions.Stop.call(this._sdkInstance, this._audioTag);
                    break
                }
                if (a < this._startOffsetTime) {
                    this._audioPlaybackStarted = !1;
                    break
                }
                b =
                this._expressions.PlaybackRate.call(this._sdkInstance, this._audioTag);
                c = this._timeline.GetPlaybackRate();
                c !== b && this._actions.SetPlaybackRate.call(this._sdkInstance, this._audioTag, c);
                if (this._audioPlaybackStarted)
                    break;
                if (!this._propertyTrack.GetTimeline().IsPlaying())
                    break;
                this._audioPlaybackStarted = !0;
                isNaN(this._pauseTime) ? (b = self.performance.now(), c = a - this._startOffsetTime, "suspended" === this._sdkInstance.GetAudioContextState() ? this._audioPlaybackStarted = !1 : (a = self.performance.now(), a = c + (a - b) /
                1E3, this._actions && (b = this.GetVolume(), isNaN(b) ? (this.SetVolume(0), b = 0) : this.SetVolume(b), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, b, this._audioTag, a)))) : (a = this._pauseTime, this._pauseTime = NaN, b = this._GetPauseVolume(), this._pauseVolume = NaN, "suspended" === this._sdkInstance.GetAudioContextState() ? this._audioPlaybackStarted = !1 : this._actions && (this.SetVolume(b), this._actions.PlayFromTimeline.call(this._sdkInstance, this._fileArgs, b, this._audioTag, a)));
                break;
            case "volume":
                this._MaybeSetAudioSource(),
                super.Interpolate(a, b, c, d, e, f, g)
            }
    }
    GetInterpolatedValue(a, b, c)
    {
        if (this._sdkInstance)
            switch (this._propertyTrack.GetPropertyName()) {
            case "volume":
                return this._MaybeSetAudioSource(), super.GetInterpolatedValue(a, b, c)
            }
    }
    Getter(a, b)
    {
        return this._audioSource ? this._audioSource.GetVolume() : 0
    }
    Setter(a, b, c, d)
    {
        this._audioSource && this._audioSource.SetVolume(this.Getter() + b);
        this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())
    }
    AbsoluteSetter(a,
    b, c)
    {
        this._audioSource && this._audioSource.SetVolume(b);
        this._actions && this._audioSource && this._actions.SetVolume.call(this._sdkInstance, this._audioSource.GetAudioTag(), this._audioSource.GetVolume())
    }
    DoesRounding()
    {
        return !0
    }
    _SaveToJson()
    {
        return {
            audioPlaybackStarted: this._audioPlaybackStarted,
            audioTag: this._audioTag,
            pauseTime: this._pauseTime,
            pauseVolume: this._pauseVolume,
            volume: this._volume
        }
    }
    _LoadFromJson(a)
    {
        a && (this._audioPlaybackStarted = a.audioPlaybackStarted, this._audioTag = a.audioTag, this._pauseTime =
        a.pauseTime, this._pauseVolume = a.pauseVolume, this._volume = a.volume, this._Initialize())
    }
}
C3$jscomp$119.PropertyTrackState.AudioSourceAdapter = AudioSourceAdapter;
"use strict";
self.C3.PropertyTrackState.PropertyInterpolationAdapter = class {
    constructor(a)
    {
        this._sourceAdapter = a;
        this._propertyTrack = a.GetPropertyTrack();
        this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo();
        this._property = this._propertyTrack.GetPropertyName();
        this._firstAbsoluteUpdate = !1;
        this._target = this._saveState = null
    }
    Release()
    {
        this._target = this._saveState = this._worldInfo = this._propertyTrack = this._sourceAdapter = null
    }
    MayNeedBeforeAndAfterInterpolate()
    {
        return !1
    }
    TimelineRemoved() {}
    CleanCaches()
    {
        this._target =
        this._saveState = this._worldInfo = null
    }
    GetSourceAdapter()
    {
        return this._sourceAdapter
    }
    GetPropertyTrack()
    {
        return this._propertyTrack
    }
    GetWorldInfo()
    {
        return this._worldInfo ? this._worldInfo : this._worldInfo = this._propertyTrack.GetTrack().GetWorldInfo()
    }
    SetFirstAbsoluteUpdate(a)
    {
        this._firstAbsoluteUpdate = !!a
    }
    GetFirstAbsoluteUpdate()
    {
        return this._firstAbsoluteUpdate
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    SetSaveState()
    {
        this._saveState = this.GetCurrentState()
    }
    ClearSaveState()
    {
        this._saveState = null
    }
    GetCurrentState() {}
    CompareInitialStateWithCurrent() {}
    CompareSaveStateWithCurrent() {}
    CanChange(a)
    {
        return typeof this._Getter() ===
        typeof a
    }
    BeforeChangeProperty() {}
    ChangeProperty(a, b, c, d, e, f, g, h) {}
    AfterChangeProperty() {}
    _FirstKeyframeGetter()
    {
        return this._PickTimelinePlaybackMode(() => {
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyframeDataItem(a)
        }, () => {
            const a = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a)
        }).GetAbsoluteValue()
    }
    _CurrentKeyframeGetter()
    {
        const a = this._propertyTrack.GetTimeline().GetTime() -
        this._propertyTrack.GetTrack().GetStartOffset();
        return this._PickTimelinePlaybackMode(() => {
            const b = this._propertyTrack.GetPropertyTrackDataItem();
            return this._propertyTrack.GetPropertyTrackData().GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, b)
        }, () => {
            const b = this._propertyTrack.GetPropertyTrackDataItem(),
                c = this._propertyTrack.GetPropertyTrackData(),
                d = c.GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, b);
            return d ? d : c.GetLastPropertyKeyframeDataItem(b)
        }).GetAbsoluteValue()
    }
    _PickTimelinePlaybackMode(a,
    b)
    {
        return this._propertyTrack.GetTimeline().IsForwardPlayBack() ? a() : b()
    }
    _PickResultMode(a, b)
    {
        return "relative" === this._propertyTrack.GetResultMode() ? a() : b()
    }
    _PickFirstAbsoluteUpdate(a, b)
    {
        return this.GetFirstAbsoluteUpdate() ? (this.SetFirstAbsoluteUpdate(!1), a()) : b()
    }
    _GetAbsoluteInitialValue(a) {}
    _GetIndex()
    {
        return this._sourceAdapter.GetIndex()
    }
    _GetTarget()
    {
        return this._target ? this._target : this._target = this._sourceAdapter.GetTarget()
    }
    _PickSource(a, b, c, d, e, f)
    {
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            return a();
        case "effect":
            return b();
        case "instance-variable":
            return c();
        case "plugin":
            return d();
        case "world-instance":
            return e();
        case "audio":
            return f()
        }
    }
    _SaveToJson()
    {
        return {
            firstAbsoluteUpdate: this._firstAbsoluteUpdate,
            saveState: this._saveState
        }
    }
    _LoadFromJson(a)
    {
        a && (this._firstAbsoluteUpdate = a.firstAbsoluteUpdate, this._saveState = a.saveState)
    }
    _GetPropertyKeyframeStubs(a, b=!1)
    {
        const c = [];
        for (const d of a) {
            a = d.GetTrack().GetStartOffset();
            for (const e of d.GetPropertyKeyframeDataItems())
                b && 0 === e.GetTime() ? c.push({
                    time: a +
                    e.GetTime(),
                    value: e.GetAbsoluteValue()
                }) : b || c.push({
                    time: a + e.GetTime(),
                    value: e.GetAbsoluteValue()
                })
        }
        return c.sort((d, e) => d.time - e.time)
    }
    _GetLastPropertyKeyframeStub(a, b, c)
    {
        return this._GetPropertyKeyframeStubLowerThanPlayhead(b, c)
    }
    _GetPropertyKeyframeStubLowerThanPlayhead(a, b)
    {
        for (let c = b.length - 1; 0 <= c; c--)
            if (b[c].time <= a)
                return b[c];
        return null
    }
}
;
"use strict";
const C3$jscomp$121 = self.C3,
    TMP_COLORS_MAP = new Map,
    TMP_COLOR = [0, 0, 0];
class ColorInterpolationAdapter extends C3$jscomp$121.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a)
    {
        super(a)
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState()
    {
        const a = this._propertyTrack.GetSourceAdapterId(),
            b = this._GetTarget(),
            c = this._GetIndex();
        switch (a) {
        case "behavior":
            return this._ToColorArray(b.GetPropertyValueByIndex(c));
        case "effect":
            return this._ToColorArray(b[c]);
        case "plugin":
            return this._ToColorArray(b.GetPropertyValueByIndex(c));
        case "world-instance":
            return this._ToColorArray(this._Getter())
        }
    }
    CompareInitialStateWithCurrent()
    {
        const a =
        this._FirstKeyframeGetter();
        return !this._CompareColors(a, this._Getter())
    }
    CompareSaveStateWithCurrent()
    {
        return C3$jscomp$121.IsNullOrUndefined(this._saveState) ? !1 : !this._CompareColors(this._saveState, this._Getter())
    }
    _CompareColors(a, b)
    {
        a = this._GetColorFromArray(a);
        b = this._GetColorFromArray(b);
        return a.equalsIgnoringAlpha(b)
    }
    _FirstKeyframeGetter()
    {
        const a = super._FirstKeyframeGetter();
        return this._GetColorFromArray(a)
    }
    _CurrentKeyframeGetter()
    {
        const a = super._CurrentKeyframeGetter();
        return this._GetColorFromArray(a)
    }
    _GetAbsoluteInitialValue(a) {}
    _ToColorArray(a)
    {
        return C3$jscomp$121.IsInstanceOf(a,
        C3$jscomp$121.Color) ? a.toArray().slice(0, 3) : a.slice(0, 3)
    }
    _GetColorFromArray(a)
    {
        return C3$jscomp$121.IsInstanceOf(a, C3$jscomp$121.Color) ? a : new C3$jscomp$121.Color(a[0], a[1], a[2], 1)
    }
    CanChange(a)
    {
        return !0
    }
    MayNeedBeforeAndAfterInterpolate()
    {
        return !0
    }
    BeforeChangeProperty()
    {
        var a = this._propertyTrack.GetTimeline(),
            b = this._propertyTrack.GetInstance();
        const c = this._propertyTrack.GetSourceAdapter();
        (a = a.GetSimilarPropertyTracks(b, c, this._property, this._propertyTrack)) && 1 < a.length && (TMP_COLORS_MAP.has(b) || TMP_COLORS_MAP.set(b,
        new Map), b = TMP_COLORS_MAP.get(b), a = this._propertyTrack.GetSourceAdapterId(), b.has(a) || b.set(a, new Map), b = b.get(a), b.has(this._property) || b.set(this._property, {
            used: !1,
            color: new C3$jscomp$121.Color(0, 0, 0, 1)
        }))
    }
    _GetTmpColor(a, b, c)
    {
        a = TMP_COLORS_MAP.get(a).get(b).get(c);
        a.used = !0;
        return a.color
    }
    ChangeProperty(a, b, c, d, e, f, g, h)
    {
        e = this._propertyTrack.GetTimeline();
        d = this._propertyTrack.GetTrack();
        a = this._propertyTrack.GetInstance();
        f = this._propertyTrack.GetSourceAdapter();
        c = this._propertyTrack.GetSourceAdapterId();
        if ((f = e.GetSimilarPropertyTracks(a, f, this._property, this._propertyTrack)) && 1 < f.length) {
            if (f = this._GetPropertyKeyframeStubs(f, !0), e = this._GetLastPropertyKeyframeStub(e, e.GetTime(), f))
                d = d.GetStartOffset(),
                f = e.time - d,
                0 === f ? this._GetTmpColor(a, c, this._property).addRgb(b[0], b[1], b[2]) : 0 > f || (e = b[0], d = b[1], b = b[2], f = this._propertyTrack.Interpolate(f, !1, !0), e = C3$jscomp$121.Color.DiffChannel(e, f[0]), d = C3$jscomp$121.Color.DiffChannel(d, f[1]), b = C3$jscomp$121.Color.DiffChannel(b, f[2]), this._GetTmpColor(a, c, this._property).addRgb(e,
                d, b))
        } else
            this._Setter(b[0], b[1], b[2])
    }
    AfterChangeProperty()
    {
        const a = this._propertyTrack.GetInstance();
        if (TMP_COLORS_MAP.has(a)) {
            var b = TMP_COLORS_MAP.get(a),
                c = this._propertyTrack.GetSourceAdapterId();
            if (b.has(c)) {
                var d = b.get(c);
                if (d.has(this._property)) {
                    var e = d.get(this._property),
                        f = e.color;
                    e.used && this._Setter(f.getR(), f.getG(), f.getB());
                    0 === d.size && b.delete(c);
                    0 === b.size && TMP_COLORS_MAP.delete(a)
                }
            }
        }
    }
    _Getter()
    {
        const a = this._propertyTrack.GetSourceAdapterId(),
            b = this._GetTarget(),
            c = this._GetIndex();
        switch (a) {
        case "behavior":
            return this._GetColorFromArray(b.GetPropertyValueByIndex(c));
        case "effect":
            return b[c].clone();
        case "plugin":
            return this._GetColorFromArray(b.GetPropertyValueByIndex(c));
        case "world-instance":
            return this.GetWorldInfo().GetUnpremultipliedColor().clone()
        }
    }
    _Setter(a, b, c)
    {
        const d = this._propertyTrack.GetSourceAdapterId(),
            e = this._GetTarget(),
            f = this._GetIndex();
        switch (d) {
        case "behavior":
            TMP_COLOR[0] = a;
            TMP_COLOR[1] = b;
            TMP_COLOR[2] = c;
            e.SetPropertyValueByIndex(f, TMP_COLOR);
            break;
        case "effect":
            e[f].setRgb(a,
            b, c);
            break;
        case "plugin":
            TMP_COLOR[0] = a;
            TMP_COLOR[1] = b;
            TMP_COLOR[2] = c;
            e.SetPropertyValueByIndex(f, TMP_COLOR);
            break;
        case "world-instance":
            this.GetWorldInfo().SetUnpremultipliedColorRGB(a, b, c)
        }
    }
    _SaveToJson() {}
    _LoadFromJson(a) {}
}
C3$jscomp$121.PropertyTrackState.PropertyInterpolationAdapter.ColorInterpolationAdapter = ColorInterpolationAdapter;
"use strict";
const C3$jscomp$122 = self.C3,
    NS$jscomp$1 = C3$jscomp$122.PropertyTrackState;
class NoInterpolationAdapter extends C3$jscomp$122.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a)
    {
        super(a)
    }
    SetResetState() {}
    SetInitialState() {}
    SetResumeState() {}
    GetCurrentState()
    {
        return this._Getter()
    }
    CompareInitialStateWithCurrent()
    {
        return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent()
    {
        return C3$jscomp$122.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    MayNeedBeforeAndAfterInterpolate()
    {
        return !1
    }
    ChangeProperty(a,
    b, c, d, e, f, g, h)
    {
        c = this._propertyTrack;
        f = c.GetTrack();
        d = c.GetSourceAdapterId();
        e = c.GetTimeline();
        g = f.GetInstance();
        h = c.GetSourceAdapter();
        (g = e.GetSimilarPropertyTracks(g, h, this._property, c)) && 1 < g.length && (g = this._GetPropertyKeyframeStubs(g), a += f.GetStartOffset(), a = this._GetLastPropertyKeyframeStub(e, a, g)) && (b = a.value);
        switch (c.GetPropertyKeyframeType()) {
        case "numeric":
            if (!NS$jscomp$1.NumericTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return;
            break;
        case "angle":
            if (!NS$jscomp$1.AngleTypeAdapter.WillChange(this._GetIndex(),
            this._GetTarget(), b, d))
                return;
            break;
        case "boolean":
            if (!NS$jscomp$1.BooleanTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return;
            break;
        case "color":
            if (!NS$jscomp$1.ColorTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return;
            break;
        case "text":
            if (!NS$jscomp$1.TextTypeAdapter.WillChange(this._GetIndex(), this._GetTarget(), b, d))
                return
        }
        this._Setter(b)
    }
    _Getter()
    {
        const a = this._propertyTrack.GetSourceAdapterId(),
            b = this._GetTarget(),
            c = this._GetIndex();
        switch (a) {
        case "behavior":
            return b.GetPropertyValueByIndex(c);
        case "effect":
            return b[c];
        case "instance-variable":
            return b.GetInstanceVariableValue(c);
        case "plugin":
            return b.GetPropertyValueByIndex(c)
        }
    }
    _Setter(a)
    {
        const b = this._propertyTrack.GetSourceAdapterId(),
            c = this._GetTarget(),
            d = this._GetIndex();
        switch (b) {
        case "behavior":
            c.SetPropertyValueByIndex(d, a);
            break;
        case "effect":
            c[d] = a;
            break;
        case "instance-variable":
            c.SetInstanceVariableValue(d, a);
            break;
        case "plugin":
            c.SetPropertyValueByIndex(d, a)
        }
    }
}
C3$jscomp$122.PropertyTrackState.PropertyInterpolationAdapter.NoInterpolationAdapter = NoInterpolationAdapter;
"use strict";
const C3$jscomp$123 = self.C3,
    INSTANCE_FUNC_MAP = new Map,
    add$jscomp$1 = (a, b, c, d, e, f=!1, g=null, h=null) => {
        INSTANCE_FUNC_MAP.set(a, {
            setter: b,
            absolute_setter: c,
            getter: d,
            round: e,
            fRound: f,
            init: g,
            reset: h
        })
    };
add$jscomp$1("offsetX", (a, b, c, d) => {
    "relative" === d._propertyTrack.GetResultMode() ? a.OffsetX(b, c.GetTimeline().GetTransformWithSceneGraph()) : a.OffsetX(b)
}, (a, b) => a.SetX(b), a => a.GetX(), !0);
add$jscomp$1("offsetY", (a, b, c, d) => {
    "relative" === d._propertyTrack.GetResultMode() ? a.OffsetY(b, c.GetTimeline().GetTransformWithSceneGraph()) : a.OffsetY(b)
}, (a, b) => a.SetY(b), a => a.GetY(), !0);
add$jscomp$1("offsetWidth", (a, b, c, d, e) => {
    if (0 !== b) {
        var f = "relative" === d._propertyTrack.GetResultMode(),
            g = 1 === d._typeAdapter.GetType();
        if ((f || g) && a.HasParent() && a.GetTransformWithParentWidth()) {
            if (isNaN(d._absoluteToFactor)) {
                f = [];
                for (var h = a.GetParent(); h;)
                    f.push(h),
                    h = h.GetParent();
                f.reverse();
                h = (n, p) => {
                    if (p = p.GetTimeline().GetTrackFromInstance(n.GetInstance()))
                        return p.GetOriginalWidth();
                    p = n.GetInstance().GetSdkInstance();
                    return p.IsOriginalSizeKnown() ? p.GetOriginalWidth() : n._GetSceneGraphInfo()._GetStartWidth()
                };
                const m = (n, p, q, r=0) => {
                    n = p.GetTimeline().GetTrackFromInstance(n.GetInstance());
                    if (!n)
                        return r;
                    q = n.GetPropertyTrack(q);
                    if (!q)
                        return r;
                    q = q.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                    return q ? (q = q.GetLastPropertyKeyframeDataItem()) ? q.GetValue() : r : r
                };
                if (g)
                    var k = f[f.length - 1].GetWidth();
                else {
                    g = f[0];
                    k = g._GetSceneGraphInfo()._GetStartWidth();
                    var l = g._GetSceneGraphInfo().GetStartScaleX();
                    k *= l;
                    k += m(g, c, "offsetWidth");
                    k += h(g, c) * m(g, c, "offsetScaleX");
                    for (l = 1; l < f.length; l++) {
                        g = f[l];
                        const n = g._GetSceneGraphInfo().GetStartScaleX();
                        k *= n;
                        k += m(g, c, "offsetWidth");
                        k += h(g, c) * m(g, c, "offsetScaleX")
                    }
                }
                d._absoluteToFactor = 0 === k ? Number.EPSILON : k
            }
            e || a.OffsetWidth(b / d._absoluteToFactor, !0)
        } else
            a.OffsetWidth(b)
    }
}, (a, b) => a.SetWidth(b), a => a.GetWidth(), !0);
add$jscomp$1("offsetHeight", (a, b, c, d, e) => {
    if (0 !== b) {
        var f = "relative" === d._propertyTrack.GetResultMode(),
            g = 1 === d._typeAdapter.GetType();
        if ((f || g) && a.HasParent() && a.GetTransformWithParentHeight()) {
            if (isNaN(d._absoluteToFactor)) {
                f = [];
                for (var h = a.GetParent(); h;)
                    f.push(h),
                    h = h.GetParent();
                f.reverse();
                h = (n, p) => {
                    if (p = p.GetTimeline().GetTrackFromInstance(n.GetInstance()))
                        return p.GetOriginalHeight();
                    p = n.GetInstance().GetSdkInstance();
                    return p.IsOriginalSizeKnown() ? p.GetOriginalHeight() : n._GetSceneGraphInfo()._GetStartHeight()
                };
                const m = (n, p, q, r=0) => {
                    n = p.GetTimeline().GetTrackFromInstance(n.GetInstance());
                    if (!n)
                        return r;
                    q = n.GetPropertyTrack(q);
                    if (!q)
                        return r;
                    q = q.GetPropertyTrackDataItem().GetPropertyKeyframeData();
                    return q ? (q = q.GetLastPropertyKeyframeDataItem()) ? q.GetValue() : r : r
                };
                if (g)
                    var k = f[f.length - 1].GetHeight();
                else {
                    g = f[0];
                    k = g._GetSceneGraphInfo()._GetStartHeight();
                    var l = g._GetSceneGraphInfo().GetStartScaleY();
                    k *= l;
                    k += m(g, c, "offsetHeight");
                    k += h(g, c) * m(g, c, "offsetScaleY");
                    for (l = 1; l < f.length; l++) {
                        g = f[l];
                        const n = g._GetSceneGraphInfo().GetStartScaleY();
                        k *= n;
                        k += m(g, c);
                        k += h(g, c) * m(g, c, "offsetScaleY")
                    }
                }
                d._absoluteToFactor = 0 === k ? Number.EPSILON : k
            }
            e || a.OffsetHeight(b / d._absoluteToFactor, !0)
        } else
            a.OffsetHeight(b)
    }
}, (a, b) => a.SetHeight(b), a => a.GetHeight(), !0);
add$jscomp$1("offsetAngle", (a, b, c, d, e) => {
    a.OffsetAngle(b)
}, (a, b) => a.SetAngle(b), a => a.GetAngle(), !1, !0);
add$jscomp$1("offsetOpacity", (a, b, c, d, e) => {
    b /= d._opacityFactor ? d._opacityFactor : 1;
    c = a.GetOpacity() + b;
    0 === d._clampAccumulator ? (1 < c ? d._clampAccumulator += c - 1 : 0 > c && (d._clampAccumulator += c), a.OffsetOpacity(b)) : (c = a.GetOpacity() + b, 0 < b && 0 < d._clampAccumulator ? 1 < c && (d._clampAccumulator += c - 1) : 0 < b && 0 > d._clampAccumulator ? (d._clampAccumulator += b, 0 < d._clampAccumulator && (a.OffsetOpacity(d._clampAccumulator), d._clampAccumulator = 0)) : 0 > b && 0 < d._clampAccumulator ? (d._clampAccumulator += b, 0 > d._clampAccumulator && (a.OffsetOpacity(d._clampAccumulator),
    d._clampAccumulator = 0)) : 0 > b && 0 > d._clampAccumulator && 0 > c && (d._clampAccumulator += c))
}, (a, b) => {
    a.SetOpacity(b)
}, a => a.GetOpacity(), !1, !0, (a, b, c) => {
    a._clampAccumulator = 0;
    switch (a._propertyTrack.GetResultMode()) {
    case "relative":
        a._propertyTrack.GetPropertyTrackData();
        var d = a._propertyTrack.GetPropertyTrackDataItem().GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray(),
            e = a.GetWorldInfo().GetOpacity(),
            f = e;
        for (var g of d)
            f = g.GetTime(),
            f = a._propertyTrack.GetInterpolatedValue(f),
            f = e + f,
            f = C3$jscomp$123.clamp(f,
            0, 1);
        a._totalForewardOpacityDelta = e - f;
        a._totalForewardOpacityDelta = Math.round(100 * (a._totalForewardOpacityDelta + Number.EPSILON)) / 100;
        f = e;
        for (e = d.length - 1; 0 <= e; e--)
            g = d[e].GetTime(),
            g = a._propertyTrack.GetInterpolatedValue(g),
            f -= g,
            f = C3$jscomp$123.clamp(f, 0, 1);
        a._totalBackwardOpacityDelta = f;
        a._totalBackwardOpacityDelta = Math.round(100 * (a._totalBackwardOpacityDelta + Number.EPSILON)) / 100
    }
    d = "relative" === a._propertyTrack.GetResultMode();
    f = 1 === a._typeAdapter.GetType();
    if ((d || f) && b.HasParent() && b.GetTransformWithParentOpacity()) {
        d =
        [];
        for (b = b.GetParent(); b;)
            d.push(b),
            b = b.GetParent();
        d.reverse();
        b = (h, k, l) => {
            h = k.GetTimeline().GetTrackFromInstance(h.GetInstance());
            if (!h)
                return 0;
            l = h.GetPropertyTrack(l);
            if (!l)
                return 0;
            l = l.GetPropertyTrackDataItem().GetPropertyKeyframeData();
            return l ? (l = l.GetLastPropertyKeyframeDataItem()) ? l.GetValue() : 0 : 0
        };
        f = d[0]._GetSceneGraphInfo().GetStartOpacity();
        f += b(d[0], c, "offsetOpacity");
        for (e = 1; e < d.length; e++)
            f += b(d[e], c, "offsetOpacity");
        a._opacityFactor = 0 === f ? 1 : f
    }
}, a => {
    switch (a._propertyTrack.GetResultMode()) {
    case "relative":
        a._clampAccumulator =
        0;
        const b = a.GetWorldInfo();
        let c = b.GetOpacity();
        c = Math.round(100 * (c + Number.EPSILON)) / 100;
        a._propertyTrack.GetTimeline().IsForwardPlayBack() ? (b.SetOpacity(c + a._totalForewardOpacityDelta), a._lastValue = 0) : (b.SetOpacity(c - a._totalBackwardOpacityDelta), a._lastValue = a.GetSourceAdapter().GetValueAtTime())
    }
});
add$jscomp$1("offsetOriginX", (a, b) => a.OffsetOriginX(b), (a, b) => a.SetOriginX(b), a => a.GetOriginX(), !1);
add$jscomp$1("offsetOriginY", (a, b) => a.OffsetOriginY(b), (a, b) => a.SetOriginY(b), a => a.GetOriginY(), !1);
add$jscomp$1("offsetZElevation", (a, b) => a.OffsetZElevation(b), (a, b) => a.SetZElevation(b), a => a.GetZElevation(), !0);
add$jscomp$1("offsetScaleX", (a, b, c, d) => {
    if (0 !== b) {
        var e = 0 > a.GetWidth() ? -1 : 1;
        "relative" === d._propertyTrack.GetResultMode() && a.HasParent() && a.GetTransformWithParentWidth() ? (b *= c.GetOriginalWidth() * e, isNaN(d._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetWidth").setter(a, 1, c, d, !0), a.OffsetWidth(b / d._absoluteToFactor, !0)) : a.OffsetWidth(c.GetOriginalWidth() * e * b)
    }
}, (a, b, c) => {
    a.SetWidth(c.GetOriginalWidth() * b)
}, (a, b) => {
    const c = 0 > a.GetWidth() ? -1 : 1;
    if (a.GetTransformWithParentWidth()) {
        var d = a.GetParent(),
            e = b.GetTimeline().GetTrackFromInstance(d.GetInstance());
        e ? d = d.GetWidth() / e.GetOriginalWidth() : (e = d.GetInstance().GetSdkInstance(), d = e.IsOriginalSizeKnown() ? d.GetWidth() / e.GetOriginalWidth() : 1);
        return a.GetWidth() * c / (b.GetOriginalWidth() * d)
    }
    return a.GetWidth() * c / b.GetOriginalWidth()
}, !1);
add$jscomp$1("offsetScaleY", (a, b, c, d) => {
    if (0 !== b) {
        var e = 0 > a.GetHeight() ? -1 : 1;
        "relative" === d._propertyTrack.GetResultMode() && a.HasParent() && a.GetTransformWithParentHeight() ? (b *= c.GetOriginalHeight() * e, isNaN(d._absoluteToFactor) && INSTANCE_FUNC_MAP.get("offsetHeight").setter(a, 1, c, d, !0), a.OffsetHeight(b / d._absoluteToFactor, !0)) : a.OffsetHeight(c.GetOriginalHeight() * e * b)
    }
}, (a, b, c) => {
    a.SetHeight(c.GetOriginalHeight() * b)
}, (a, b) => {
    const c = 0 > a.GetHeight() ? -1 : 1;
    if (a.GetTransformWithParentHeight()) {
        var d = a.GetParent(),
            e = b.GetTimeline().GetTrackFromInstance(d.GetInstance());
        e ? d = d.GetHeight() / e.GetOriginalHeight() : (e = d.GetInstance().GetSdkInstance(), d = e.IsOriginalSizeKnown() ? d.GetHeight() / e.GetOriginalHeight() : 1);
        return a.GetHeight() * c / (b.GetOriginalHeight() * d)
    }
    return a.GetHeight() * c / b.GetOriginalHeight()
}, !1);
class NumericInterpolationAdapter extends C3$jscomp$123.PropertyTrackState.PropertyInterpolationAdapter {
    constructor(a)
    {
        super(a);
        this._totalBackwardOpacityDelta = this._totalForewardOpacityDelta = this._clampAccumulator = this._lastValue = 0;
        this._absoluteToFactor = this._opacityFactor = NaN;
        this._angleReflectMirrorAndFlip = this._angleReflectMirrorOrFlip = void 0;
        this._source_adapter_absolute_setter = this._source_adapter_setter = this._source_adapter_getter = this._init_action = this._reset_action = this._instance_absolute_setter =
        this._instance_setter = this._instance_getter = null;
        this._fRound = this._round = !1;
        C3$jscomp$123.IsInstanceOf(this._propertyTrack.GetTimeline(), C3$jscomp$123.TweenState) ? this._typeAdapter = new C3$jscomp$123.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween(this) : this._typeAdapter = new C3$jscomp$123.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline(this);
        const b = this._propertyTrack.GetPropertyName();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "world-instance":
            a =
            INSTANCE_FUNC_MAP.get(b);
            this._instance_getter = a.getter;
            this._instance_setter = a.setter;
            this._instance_absolute_setter = a.absolute_setter;
            this._round = a.round;
            this._fRound = a.fRound;
            this._init_action = a.init;
            this._reset_action = a.reset;
            break;
        case "audio":
            this._source_adapter_getter = a.Getter,
            this._source_adapter_setter = a.Setter,
            this._source_adapter_absolute_setter = a.AbsoluteSetter,
            this._round = !!a.DoesRounding(),
            this._fRound = !1
        }
    }
    Release()
    {
        this._source_adapter_absolute_setter = this._source_adapter_setter = this._source_adapter_getter =
        this._init_action = this._reset_action = this._instance_absolute_setter = this._instance_setter = this._instance_getter = this._typeAdapter = null;
        super.Release()
    }
    MayNeedBeforeAndAfterInterpolate()
    {
        return this._typeAdapter.MayNeedBeforeAndAfterInterpolate()
    }
    GetLastValue()
    {
        return this._lastValue
    }
    SetLastValue(a)
    {
        this._lastValue = a
    }
    SetResetState()
    {
        this._reset_action && this._reset_action(this)
    }
    SetInitialState()
    {
        var a = this._typeAdapter.SetInitialState();
        "number" === typeof a && (this._lastValue = a);
        if (this._init_action) {
            a =
            this.GetWorldInfo();
            const b = this._propertyTrack.GetTrack();
            this._init_action(this, a, b)
        }
    }
    SetResumeState()
    {
        const a = this._typeAdapter.SetResumeState();
        "number" === typeof a && (this._lastValue = a)
    }
    GetCurrentState()
    {
        return this._Getter()
    }
    CompareInitialStateWithCurrent()
    {
        return this._FirstKeyframeGetter() !== this.GetCurrentState()
    }
    CompareSaveStateWithCurrent()
    {
        return C3$jscomp$123.IsNullOrUndefined(this._saveState) ? !1 : this._saveState !== this.GetCurrentState()
    }
    BeforeChangeProperty()
    {
        this._typeAdapter.BeforeChangeProperty()
    }
    ChangeProperty(a,
    b, c, d, e, f, g, h)
    {
        return this._typeAdapter.ChangeProperty(a, b, c, d, e, f, g, h)
    }
    AfterChangeProperty()
    {
        this._typeAdapter.AfterChangeProperty()
    }
    _Getter()
    {
        const a = this._GetTarget(),
            b = this._GetIndex(),
            c = this.GetWorldInfo(),
            d = this._propertyTrack.GetTrack();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            return a.GetPropertyValueByIndex(b);
        case "effect":
            return a[b];
        case "instance-variable":
            return a.GetInstanceVariableValue(b);
        case "plugin":
            return a.GetPropertyValueByIndex(b);
        case "world-instance":
            return this._instance_getter(c,
            d);
        case "audio":
            return this._source_adapter_getter.call(this.GetSourceAdapter(), c, d)
        }
    }
    _Setter(a, b, c)
    {
        b = this._GetTarget();
        c = this._GetIndex();
        const d = this.GetWorldInfo(),
            e = this._propertyTrack.GetTrack();
        switch (this._propertyTrack.GetSourceAdapterId()) {
        case "behavior":
            b.OffsetPropertyValueByIndex(c, a);
            break;
        case "effect":
            b[c] += a;
            break;
        case "instance-variable":
            b.SetInstanceVariableOffset(c, a);
            break;
        case "plugin":
            b.OffsetPropertyValueByIndex(c, a, this.GetSourceAdapter().GetOptionalCallbacks());
            break;
        case "world-instance":
            this._instance_setter(d,
            a, e, this);
            break;
        case "audio":
            this._source_adapter_setter.call(this.GetSourceAdapter(), d, a, e, this)
        }
    }
    _SetterAbsolute(a, b, c)
    {
        var d = this._propertyTrack.GetInterpolationMode();
        d = "default" === d ? "continuous" : d;
        if ("discrete" !== d || b) {
            if ("discrete" === d && c && (b = this._propertyTrack.GetTimeline().GetTime(), !this._propertyTrack.GetPropertyKeyFrameDataItemAtTime(b)))
                return;
            b = this._GetTarget();
            c = this._GetIndex();
            d = this.GetWorldInfo();
            var e = this._propertyTrack.GetTrack();
            switch (this._propertyTrack.GetSourceAdapterId()) {
            case "behavior":
                b.SetPropertyValueByIndex(c,
                a);
                break;
            case "effect":
                b[c] = a;
                break;
            case "instance-variable":
                b.SetInstanceVariableValue(c, a);
                break;
            case "plugin":
                b.SetPropertyValueByIndex(c, a, this.GetSourceAdapter().GetOptionalCallbacks());
                break;
            case "world-instance":
                this._instance_absolute_setter(d, a, e);
                break;
            case "audio":
                this._source_adapter_absolute_setter.call(this.GetSourceAdapter(), d, a, e)
            }
        }
    }
    _MaybeEnsureValue(a, b, c, d, e, f, g, h)
    {
        this._typeAdapter._MaybeEnsureValue(a, b, c, d, e, f, g, h)
    }
    _AddDelta(a, b, c, d, e)
    {
        switch (this._propertyTrack.GetPropertyType()) {
        case "angle":
            a =
            C3$jscomp$123.toDegrees(a)
        }
        d = (a.toString().split(".")[1] || "").length;
        a = this._Getter();
        if (0 === d)
            if (this._round)
                d = Math.round(a);
            else if (this._fRound)
                switch (this._propertyTrack.GetPropertyType()) {
                case "angle":
                    d = C3$jscomp$123.toRadians(Math.round(C3$jscomp$123.toDegrees(a)));
                    break;
                default:
                    d = Number(C3$jscomp$123.toFixed(a, 2))
                }
            else
                d = a;
        else
            d = this._round ? Number(C3$jscomp$123.toFixed(a, d)) : a;
        this._Setter(d - a, b, c);
        switch (this._propertyTrack.GetPropertyName()) {
        case "offsetWidth":
        case "offsetScaleX":
            b = this.GetWorldInfo();
            c = b.GetWidth();
            a = Number(C3$jscomp$123.toFixed(c, 2));
            b.OffsetWidth(a - c);
            break;
        case "offsetHeight":
        case "offsetScaleY":
            b = this.GetWorldInfo(),
            c = b.GetHeight(),
            a = Number(C3$jscomp$123.toFixed(c, 2)),
            b.OffsetHeight(a - c)
        }
    }
    _SaveToJson()
    {
        return Object.assign(super._SaveToJson(), {
            v: this._lastValue,
            a: this._clampAccumulator,
            fod: this._totalForewardOpacityDelta,
            bod: this._totalBackwardOpacityDelta,
            of: this._opacityFactor,
            sf: this._absoluteToFactor,
            armorf: this._angleReflectMirrorOrFlip,
            armandf: this._angleReflectMirrorAndFlip
        })
    }
    _LoadFromJson(a)
    {
        a &&
        (super._LoadFromJson(a), this._lastValue = a.v, this._clampAccumulator = a.a, this._totalForewardOpacityDelta = C3$jscomp$123.IsFiniteNumber(a.fod) ? a.fod : 0, this._totalBackwardOpacityDelta = C3$jscomp$123.IsFiniteNumber(a.bod) ? a.bod : 0, this._opacityFactor = C3$jscomp$123.IsFiniteNumber(a.of) ? a.of : NaN, this._absoluteToFactor = C3$jscomp$123.IsFiniteNumber(a.sf) ? a.sf : NaN, this._angleReflectMirrorOrFlip = C3$jscomp$123.IsFiniteNumber(a.armorf) ? a.armorf : void 0, this._angleReflectMirrorAndFlip = C3$jscomp$123.IsFiniteNumber(a.armandf) ?
        a.armandf : void 0)
    }
}
C3$jscomp$123.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapter = NumericInterpolationAdapter;
"use strict";
class AbsoluteValueObject {
    constructor(a)
    {
        this._used = !1;
        this._value = 0;
        this._endState = this._propertyKeyframeReached = !1;
        this._propertyTracks = a;
        for (let b = 0, c = this._propertyTracks.length; b < c; b++)
            this._propertyTracks[b].SetAbsoluteValueObject(this)
    }
    GetPropertyTracks()
    {
        return this._propertyTracks
    }
    SetUsed()
    {
        this._used = !0
    }
    GetUsed()
    {
        return this._used
    }
    SetValue(a)
    {
        this._value = a
    }
    GetValue()
    {
        return this._value
    }
    SetPropertyKeyframeReached(a)
    {
        this._propertyKeyframeReached = a
    }
    GetPropertyKeyframeReached()
    {
        return this._propertyKeyframeReached
    }
    SetEndState(a)
    {
        this._endState =
        a
    }
    GetEndState()
    {
        return this._endState
    }
    Reset()
    {
        this._used = !1;
        this._value = 0;
        this._endState = this._propertyKeyframeReached = !1
    }
}
class NumericInterpolationAdapterForTimeline {
    constructor(a)
    {
        this._numericInterpolationAdapter = a
    }
    Release()
    {
        this._numericInterpolationAdapter = null
    }
    GetType()
    {
        return 0
    }
    SetInitialState()
    {
        const a = this._numericInterpolationAdapter;
        this._numericInterpolationAdapter.GetPropertyTrack();
        return a._PickResultMode(() => a._PickTimelinePlaybackMode(() => 0, () => a.GetSourceAdapter().GetValueAtTime()), () => {})
    }
    SetResumeState() {}
    MayNeedBeforeAndAfterInterpolate()
    {
        switch (this._numericInterpolationAdapter.GetPropertyTrack().GetResultMode()) {
        case "relative":
            return !1;
        case "absolute":
            return !0
        }
    }
    BeforeChangeProperty()
    {
        var a = this._numericInterpolationAdapter.GetPropertyTrack();
        const b = a.GetPropertyName();
        switch (a.GetResultMode()) {
        case "absolute":
            if (a.HasAbsoluteValueObject())
                a.GetAbsoluteValueObject().Reset();
            else {
                const c = a.GetTimeline(),
                    d = a.GetInstance(),
                    e = a.GetSourceAdapter();
                (a = c.GetSimilarPropertyTracks(d, e, b, a)) && 1 < a.length && new AbsoluteValueObject(a)
            }
        }
    }
    ChangeProperty(a, b, c, d, e, f, g, h)
    {
        var k = this._numericInterpolationAdapter,
            l = this._numericInterpolationAdapter.GetPropertyTrack();
        switch (l.GetResultMode()) {
        case "relative":
            g = k.GetLastValue();
            k._Setter(b - g, c, d);
            f && this._MaybeEnsureValue(a, c, d, e, g, b);
            k.SetLastValue(b);
            break;
        case "absolute":
            if (d = l.GetTimeline(), c = l.GetTrack(), l.GetInstance(), l.GetSourceAdapter(), l.HasAbsoluteValueObject()) {
                if (a = l.GetAbsoluteValueObject(), e = a.GetPropertyTracks(), e = k._GetPropertyKeyframeStubs(e, !0), k = k._GetLastPropertyKeyframeStub(d, d.GetTime(), e))
                    c = c.GetStartOffset(),
                    k = k.time - c,
                    0 === k ? (a.SetEndState(g), a.SetPropertyKeyframeReached(h), a.SetUsed(),
                    a.SetValue(a.GetValue() + b)) : 0 > k || (l = l.GetInterpolatedValue(k), a.SetEndState(g), a.SetPropertyKeyframeReached(h), a.SetUsed(), a.SetValue(a.GetValue() + (b - l)))
            } else
                k._SetterAbsolute(b, h, g)
        }
    }
    AfterChangeProperty()
    {
        const a = this._numericInterpolationAdapter;
        var b = this._numericInterpolationAdapter.GetPropertyTrack();
        switch (b.GetResultMode()) {
        case "absolute":
            b.HasAbsoluteValueObject() && (b = b.GetAbsoluteValueObject(), b.GetUsed() && a._SetterAbsolute(b.GetValue(), b.GetPropertyKeyframeReached(), b.GetEndState()))
        }
    }
    _MaybeEnsureValue(a,
    b, c, d, e, f)
    {
        const g = this._numericInterpolationAdapter;
        d || (b && a === b.GetTime() ? g._AddDelta(b.GetValueWithResultMode(), b, c) : c && a === c.GetTime() ? g._AddDelta(c.GetValueWithResultMode(), b, c) : 0 === f - e && g._AddDelta(b.GetValueWithResultMode(), b, c))
    }
}
self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTimeline = NumericInterpolationAdapterForTimeline;
"use strict";
class NumericInterpolationAdapterForTween {
    constructor(a)
    {
        this._numericInterpolationAdapter = a
    }
    Release()
    {
        this._numericInterpolationAdapter = null
    }
    GetType()
    {
        return 1
    }
    SetInitialState()
    {
        const a = this._numericInterpolationAdapter;
        a.SetFirstAbsoluteUpdate(!0);
        return this._GetAbsoluteInitialValue(a._FirstKeyframeGetter())
    }
    SetResumeState()
    {
        const a = this._numericInterpolationAdapter;
        if (a._FirstKeyframeGetter() !== a._CurrentKeyframeGetter())
            return a.SetFirstAbsoluteUpdate(!0), this._GetAbsoluteInitialValue(a._CurrentKeyframeGetter())
    }
    MayNeedBeforeAndAfterInterpolate()
    {
        return !1
    }
    BeforeChangeProperty() {}
    ChangeProperty(a,
    b, c, d, e, f, g, h)
    {
        h = this._numericInterpolationAdapter;
        const k = h.GetLastValue();
        switch (h.GetPropertyTrack().GetResultMode()) {
        case "relative":
            h._Setter(b - k, c, d);
            f && this._MaybeEnsureValue(a, c, d, e, k, b, !1, g);
            break;
        case "absolute":
            h.GetFirstAbsoluteUpdate() ? (h.SetFirstAbsoluteUpdate(!1), h._Setter(k, c, d)) : 0 === a && 0 === h.GetPropertyTrack().GetTimeline().GetTotalTime() ? h._SetterAbsolute(b, !0, !1) : (h._Setter(b - k, c, d), f && this._MaybeEnsureValue(a, c, d, e, k, b, this._ForceEndValue(), g))
        }
        h.SetLastValue(b)
    }
    AfterChangeProperty() {}
    _GetAbsoluteInitialValue(a)
    {
        return a -
        this._numericInterpolationAdapter.GetCurrentState()
    }
    _ForceEndValue()
    {
        var a = this._numericInterpolationAdapter;
        const b = a.GetWorldInfo().GetInstance();
        a = a.GetPropertyTrack().GetRuntime().GetTimelineManager();
        let c = 0;
        for (const d of a.GetPlayingTimelines())
            0 === d.GetType() ? d.HasTrackInstance(b) && c++ : 1 === d.GetType() && d.GetInstance() === b && c++;
        return 1 >= c
    }
    _MaybeEnsureValue(a, b, c, d, e, f, g, h)
    {
        const k = this._numericInterpolationAdapter;
        d ? b && a === b.GetTime() ? k._AddDelta(b.GetValueWithResultMode(), b, c, g, h) : c && a ===
        c.GetTime() ? k._AddDelta(c.GetValueWithResultMode(), b, c, g, h) : c || k._AddDelta(b.GetValueWithResultMode(), b, c, g, h) : b && a === b.GetTime() ? k._AddDelta(b.GetValueWithResultMode(), b, c, g, h) : c && a === c.GetTime() ? k._AddDelta(c.GetValueWithResultMode(), b, c, g, h) : 0 === f - e && k._AddDelta(b.GetValueWithResultMode(), b, c, g, h)
    }
}
self.C3.PropertyTrackState.PropertyInterpolationAdapter.NumericInterpolationAdapterForTween = NumericInterpolationAdapterForTween;
"use strict";
const C3$jscomp$126 = self.C3,
    Ease$jscomp$1 = self.Ease;
C3$jscomp$126.PropertyTrackState.NumericTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d)
    {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === c ? !1 : !0
    }
    static Interpolate(a, b, c, d)
    {
        if (!c) {
            var e = d.GetPropertyTrackDataItem();
            e = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e);
            return e.GetValueWithResultMode()
        }
        let f = d.GetInterpolationMode();
        "default" === f && (f = "continuous");
        "combo" === d.GetPropertyType() && (f = "discrete");
        if ("discrete" === f)
            return b.GetValueWithResultMode();
        if ("continuous" === f || "step" === f) {
            const h = d.GetTimeline().GetStep();
            "step" === f && 0 !== h && (e = 1 / h, a = Math.floor(a * e) / e);
            e = b.GetValueWithResultMode();
            const k = c.GetValueWithResultMode(),
                l = b.GetAddOn("cubic-bezier"),
                m = c.GetAddOn("cubic-bezier");
            var g = l && l.GetStartEnable() && m && m.GetEndEnable();
            if (!g && e === k)
                return e;
            const n = b.GetTime();
            c = c.GetTime();
            "step" === f && 0 !== h && (a = C3$jscomp$126.clamp(a,
            n, c));
            a = C3$jscomp$126.normalize(a, n, c);
            b = b.GetEase();
            g ? (g = c - n, b = Ease$jscomp$1.GetRuntimeEase(b)(g * a, 0, 1, g), b = Ease$jscomp$1.GetRuntimeEase("cubicbezier")(b, e, e + l.GetStartAnchor(), k + m.GetEndAnchor(), k)) : b = Ease$jscomp$1.GetRuntimeEase(b)((c - n) * a, e, k - e, c - n);
            return "integer" === d.GetPropertyType() ? Math.floor(b) : b
        }
    }
}
;
"use strict";
const C3$jscomp$127 = self.C3;
C3$jscomp$127.PropertyTrackState.AngleTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d)
    {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === c ? !1 : !0
    }
    static Interpolate(a, b, c, d)
    {
        if (!c)
            return b = d.GetPropertyTrackDataItem(), b = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(b), b.GetValueWithResultMode();
        var e = d.GetInterpolationMode();
        "default" === e && (e = "continuous");
        "combo" === d.GetPropertyType() && (e = "discrete");
        if ("discrete" === e)
            return b.GetValueWithResultMode();
        if ("continuous" === e || "step" === e) {
            var f = d.GetTimeline().GetStep();
            "step" === e && 0 !== f && (d = 1 / f, a = Math.floor(a * d) / d);
            const g = b.GetTime(),
                h = c.GetTime();
            d = b.GetValueWithResultMode();
            c = c.GetValueWithResultMode();
            "step" === e && 0 !== f && (a = C3$jscomp$127.clamp(a, g, h));
            if (e = b.GetAddOn("angle")) {
                f = e.GetRevolutions();
                if (d === c && 0 === f)
                    return d;
                a = C3$jscomp$127.normalize(a, g, h);
                b = self.Ease.GetRuntimeEase(b.GetEase())(a,
                0, 1, 1);
                switch (e.GetDirection()) {
                case "closest":
                    return C3$jscomp$127.angleLerp(d, c, b, f);
                case "clockwise":
                    return C3$jscomp$127.angleLerpClockwise(d, c, b, f);
                case "anti-clockwise":
                    return C3$jscomp$127.angleLerpAntiClockwise(d, c, b, f)
                }
            } else {
                if (d === c)
                    return d;
                a = C3$jscomp$127.normalize(a, g, h);
                b = self.Ease.GetRuntimeEase(b.GetEase());
                return C3$jscomp$127.angleLerp(d, c, b(a, 0, 1, 1))
            }
        }
    }
}
;
"use strict";
self.C3.PropertyTrackState.BooleanTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d)
    {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return !!e === !!c ? !1 : !0
    }
    static Interpolate(a, b, c, d)
    {
        return c ? b.GetValueWithResultMode() ? 1 : 0 : (a = d.GetPropertyTrackDataItem(), a = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a), a.GetValueWithResultMode() ?
        1 : 0)
    }
}
;
"use strict";
const C3$jscomp$129 = self.C3,
    TEMP_COLOR_ARRAY = [0, 0, 0],
    TEMP_COLOR_ARRAY_2 = [0, 0, 0],
    TEMP_COLOR_ARRAY_3 = [0, 0, 0];
C3$jscomp$129.PropertyTrackState.ColorTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d)
    {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        Array.isArray(c) ? (TEMP_COLOR_ARRAY[0] = c[0], TEMP_COLOR_ARRAY[1] = c[1], TEMP_COLOR_ARRAY[2] = c[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(c), TEMP_COLOR_ARRAY[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()),
        TEMP_COLOR_ARRAY[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB()));
        Array.isArray(e) ? (TEMP_COLOR_ARRAY_2[0] = e[0], TEMP_COLOR_ARRAY_2[1] = e[1], TEMP_COLOR_ARRAY_2[2] = e[2]) : (TEMP_COLOR_ARRAY_3.parseCommaSeparatedRgb(e), TEMP_COLOR_ARRAY_2[0] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getR()), TEMP_COLOR_ARRAY_2[1] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getG()), TEMP_COLOR_ARRAY_2[2] = Math.floor(255 * TEMP_COLOR_ARRAY_3.getB()));
        return TEMP_COLOR_ARRAY[0] !== TEMP_COLOR_ARRAY_2[0] ||
        TEMP_COLOR_ARRAY[1] !== TEMP_COLOR_ARRAY_2[1] || TEMP_COLOR_ARRAY[2] !== TEMP_COLOR_ARRAY_2[2] ? !0 : !1
    }
    static Interpolate(a, b, c, d)
    {
        if (!c) {
            var e = d.GetPropertyTrackDataItem();
            e = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(e);
            d = e.GetValueWithResultMode();
            TEMP_COLOR_ARRAY[0] = d[0];
            TEMP_COLOR_ARRAY[1] = d[1];
            TEMP_COLOR_ARRAY[2] = d[2];
            return TEMP_COLOR_ARRAY
        }
        var f = d.GetInterpolationMode();
        "default" === f && (f = "continuous");
        if ("discrete" === f)
            return d = b.GetValueWithResultMode(), TEMP_COLOR_ARRAY[0] = d[0], TEMP_COLOR_ARRAY[1] =
            d[1], TEMP_COLOR_ARRAY[2] = d[2], TEMP_COLOR_ARRAY;
        if ("continuous" === f || "step" === f) {
            var g = d.GetTimeline().GetStep();
            "step" === f && 0 !== g && (d = 1 / g, a = Math.floor(a * d) / d);
            d = b.GetTime();
            e = c.GetTime();
            var h = b.GetValueWithResultMode();
            c = c.GetValueWithResultMode();
            "step" === f && 0 !== g && (a = C3$jscomp$129.clamp(a, d, e));
            a = C3$jscomp$129.normalize(a, d, e);
            var k = b.GetEase();
            b = h[0];
            f = h[1];
            h = h[2];
            g = c[0];
            const l = c[1];
            c = c[2];
            k = self.Ease.GetRuntimeEase(k);
            d = e - d;
            e = d * a;
            TEMP_COLOR_ARRAY[0] = b === g ? b : k(e, b, g - b, d);
            TEMP_COLOR_ARRAY[1] =
            f === l ? f : k(e, f, l - f, d);
            TEMP_COLOR_ARRAY[2] = h === c ? h : k(e, h, c - h, d);
            return TEMP_COLOR_ARRAY
        }
    }
}
;
"use strict";
self.C3.PropertyTrackState.TextTypeAdapter = class {
    constructor() {}
    static WillChange(a, b, c, d)
    {
        let e;
        switch (d) {
        case "behavior":
            e = b.GetPropertyValueByIndex(a);
            break;
        case "effect":
            e = b[a];
            break;
        case "instance-variable":
            e = b.GetInstanceVariableValue(a);
            break;
        case "plugin":
            e = b.GetPropertyValueByIndex(a)
        }
        return e === c ? !1 : !0
    }
    static Interpolate(a, b, c, d)
    {
        return c ? b.GetValueWithResultMode() : (a = d.GetPropertyTrackDataItem(), a = d.GetPropertyTrackData().GetLastPropertyKeyframeDataItem(a), a.GetValueWithResultMode())
    }
}
;
"use strict";
const C3$jscomp$131 = self.C3;
C3$jscomp$131.TimelineDataManager = class {
    constructor()
    {
        this._timelineDataItems = new Map
    }
    Release()
    {
        for (const a of this._timelineDataItems.values())
            a.Release();
        this._timelineDataItems.clear();
        this._timelineDataItems = null
    }
    Add(a)
    {
        a = new C3$jscomp$131.TimelineDataItem(a);
        const b = a.GetName();
        this._timelineDataItems.set(b, a)
    }
    Get(a)
    {
        return this._timelineDataItems.get(a)
    }
    GetNameId()
    {
        return 0
    }
    static _CreateDataItems(a, b, c, d)
    {
        if (b)
            for (const e of b)
                C3$jscomp$131.TimelineDataManager._CreateDataItem("create", e, a,
                c, d)
    }
    static _CreateDataItemsIncludingDisabled(a, b, c, d)
    {
        if (b)
            for (const e of b)
                C3$jscomp$131.TimelineDataManager._CreateDataItem("create-including-disabled", e, a, c, d)
    }
    static _LoadDataItemsFromJson(a, b, c, d)
    {
        a.length ? b.forEach((e, f) => {
            a[f]._LoadFromJson(e)
        }) : b.forEach(e => {
            C3$jscomp$131.TimelineDataManager._CreateDataItem("load", e, a, c, d)
        })
    }
    static _CreateDataItem(a, b, c, d, e)
    {
        let f;
        if ("function" === typeof d)
            switch (a) {
            case "load":
                f = new d(null, e);
                break;
            case "create":
                f = new d(b, e);
                break;
            case "create-including-disabled":
                f =
                new d(b, e)
            }
        else if ("object" === typeof d)
            switch (d = d.map.get(b[d.prop]), a) {
            case "load":
                f = new d(null, e);
                break;
            case "create":
                f = new d(b, e);
                break;
            case "create-including-disabled":
                f = new d(b, e)
            }
        switch (a) {
        case "load":
            f._LoadFromJson(b);
            c.push(f);
            break;
        case "create":
            if ("function" === typeof f.GetEnable && !f.GetEnable())
                return f.Release();
            c.push(f);
            break;
        case "create-including-disabled":
            c.push(f)
        }
    }
}
;
"use strict";
const C3$jscomp$132 = self.C3;
C3$jscomp$132.TimelineDataItem = class {
    constructor(a)
    {
        this._name = "";
        this._totalTime = NaN;
        this._step = 0;
        this._resultMode = this._interpolationMode = "default";
        this._pingPong = this._loop = !1;
        this._repeatCount = 1;
        this._trackData = null;
        this._startOnLayout = "";
        this._transformWithSceneGraph = !1;
        this._useSystemTimescale = !0;
        a && (this._name = a[0], this._totalTime = a[1], this._step = a[2], this._interpolationMode = a[3], this._resultMode = a[4], this._loop = !!a[6], this._pingPong = !!a[7], this._repeatCount = a[8], this._startOnLayout = a[9], this._transformWithSceneGraph =
        !!a[10], this._useSystemTimescale = !!a[11], this._trackData = new C3$jscomp$132.TrackData(a[5], this))
    }
    Release()
    {
        this._trackData.Release();
        this._trackData = null
    }
    GetTrackData()
    {
        this._trackData || (this._trackData = new C3$jscomp$132.TrackData(null, this));
        return this._trackData
    }
    GetName()
    {
        return this._name
    }
    SetName(a)
    {
        this._name = a
    }
    GetTotalTime()
    {
        return this._totalTime
    }
    SetTotalTime(a)
    {
        this._totalTime = a
    }
    GetStep()
    {
        return this._step
    }
    SetStep(a)
    {
        this._step = a
    }
    GetInterpolationMode()
    {
        return this._interpolationMode
    }
    SetInterpolationMode(a)
    {
        this._interpolationMode =
        a
    }
    GetResultMode()
    {
        return this._resultMode
    }
    SetResultMode(a)
    {
        this._resultMode = a
    }
    GetLoop()
    {
        return this._loop
    }
    SetLoop(a)
    {
        this._loop = a
    }
    GetPingPong()
    {
        return this._pingPong
    }
    SetPingPong(a)
    {
        this._pingPong = a
    }
    GetRepeatCount()
    {
        return this._repeatCount
    }
    SetRepeatCount(a)
    {
        this._repeatCount = a
    }
    GetStartOnLayout()
    {
        return this._startOnLayout
    }
    GetTransformWithSceneGraph()
    {
        return this._transformWithSceneGraph
    }
    GetUseSystemTimescale()
    {
        return this._useSystemTimescale
    }
    _SaveToJson()
    {
        return {
            trackDataJson: this._trackData._SaveToJson(),
            name: this._name,
            totalTime: this._totalTime,
            step: this._step,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            loop: this._loop,
            pingPong: this._pingPong,
            repeatCount: this._repeatCount,
            startOnLayout: this._startOnLayout,
            transformWithSceneGraph: !!this._transformWithSceneGraph,
            useSystemTimescale: this._useSystemTimescale
        }
    }
    _LoadFromJson(a)
    {
        a && (this.GetTrackData()._LoadFromJson(a.trackDataJson), this._name = a.name, this._totalTime = a.totalTime, this._step = a.step, this._interpolationMode = a.interpolationMode,
        this._resultMode = a.resultMode, this._loop = a.loop, this._pingPong = a.pingPong, this._repeatCount = a.repeatCount, this._startOnLayout = a.startOnLayout, this._transformWithSceneGraph = !!a.transformWithSceneGraph, this._useSystemTimescale = !!a.useSystemTimescale)
    }
}
;
"use strict";
const C3$jscomp$133 = self.C3;
class TrackDataItem {
    constructor(a, b)
    {
        this._trackData = b;
        this._additionalInstanceData = this._instanceData = null;
        this._objectClassIndex = this._instanceUid = NaN;
        this._resultMode = this._interpolationMode = "default";
        this._enabled = !1;
        this._propertyTrackData = this._keyframeData = null;
        this._id = "";
        this._nestedData = null;
        this._startOffset = 0;
        this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime();
        this._type = 0;
        this._name = "";
        a && (a[0] && (this._instanceData = a[0], this._instanceUid = a[0][2], this._objectClassIndex =
        a[0][1]), this._interpolationMode = a[1], this._resultMode = a[2], this._enabled = !!a[3], a[6] && (this._id = a[6]), a[7] && (this._nestedData = a[7], this._startOffset = a[7][0], this._localTotalTime = a[7][1]), a[8] && (this._additionalInstanceData = a[8]), a[8] && (this._additionalInstanceData = a[8]), a[9] && (this._type = a[9]), a[10] && (this._name = a[10]), this._keyframeData = new C3$jscomp$133.KeyframeData(a[4], this), this._propertyTrackData = new C3$jscomp$133.PropertyTrackData(a[5], this))
    }
    Release()
    {
        this._trackData = this._instanceData = null;
        this._keyframeData && (this._keyframeData.Release(), this._keyframeData = null);
        this._propertyTrackData && (this._propertyTrackData.Release(), this._propertyTrackData = null);
        this._nestedData = null
    }
    GetTrackData()
    {
        return this._trackData
    }
    GetKeyframeData()
    {
        this._keyframeData || (this._keyframeData = new C3$jscomp$133.KeyframeData(null, this));
        return this._keyframeData
    }
    GetPropertyTrackData()
    {
        this._propertyTrackData || (this._propertyTrackData = new C3$jscomp$133.PropertyTrackData(null, this));
        return this._propertyTrackData
    }
    GetInstanceData()
    {
        return this._instanceData
    }
    GetObjectClassIndex()
    {
        return this._objectClassIndex
    }
    SetObjectClassIndex(a)
    {
        this._objectClassIndex =
        a
    }
    GetInstanceUID()
    {
        return this._instanceUid
    }
    SetInstanceUID(a)
    {
        this._instanceUid = a
    }
    GetInterpolationMode()
    {
        return this._interpolationMode
    }
    SetInterpolationMode(a)
    {
        this._interpolationMode = a
    }
    GetResultMode()
    {
        return this._resultMode
    }
    SetResultMode(a)
    {
        this._resultMode = a
    }
    GetEnable()
    {
        return this._enabled
    }
    SetEnable(a)
    {
        this._enabled = !!a
    }
    GetId()
    {
        return this._id
    }
    GetStartOffset()
    {
        return this._startOffset
    }
    GetLocalTotalTime()
    {
        return this._localTotalTime
    }
    SetLocalTotalTime(a)
    {
        this._localTotalTime = a
    }
    GetOriginalWidth()
    {
        return this._additionalInstanceData[0]
    }
    SetOriginalWidth(a)
    {
        this._additionalInstanceData ||
        (this._additionalInstanceData = []);
        this._additionalInstanceData[0] = a
    }
    GetOriginalHeight()
    {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        return this._additionalInstanceData[1]
    }
    SetOriginalHeight(a)
    {
        this._additionalInstanceData || (this._additionalInstanceData = []);
        this._additionalInstanceData[1] = a
    }
    GetType()
    {
        return this._type
    }
    GetName()
    {
        return this._name
    }
    _SaveToJson()
    {
        return {
            keyframeDataJson: this._keyframeData._SaveToJson(),
            propertyTrackDataJson: this._propertyTrackData._SaveToJson(),
            instanceData: this._instanceData,
            additionalInstanceData: this._additionalInstanceData,
            instanceUid: this._instanceUid,
            objectClassIndex: this._objectClassIndex,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            enabled: this._enabled,
            id: this._id,
            nestedData: this._nestedData,
            type: this._type,
            name: this._name
        }
    }
    _LoadFromJson(a)
    {
        a && (this._instanceData = a.instanceData, this._instanceUid = a.instanceUid, this._objectClassIndex = a.objectClassIndex, this._interpolationMode = a.interpolationMode, this._resultMode = a.resultMode, this._enabled =
        a.enabled, this._id = a.id, this._type = a.type ? a.type : 0, this._name = a.name ? a.name : "", this._localTotalTime = this._trackData.GetTimelineDataItem().GetTotalTime(), a.nestedData && (this._nestedData = a.nestedData, this._startOffset = this._nestedData[0], this._localTotalTime = this._nestedData[1]), a.additionalInstanceData && (this._additionalInstanceData = a.additionalInstanceData), this.GetKeyframeData()._LoadFromJson(a.keyframeDataJson), this.GetPropertyTrackData()._LoadFromJson(a.propertyTrackDataJson))
    }
}
C3$jscomp$133.TrackData = class {
    constructor(a, b)
    {
        this._timelineDataItem = b;
        this._trackDataItems = [];
        C3$jscomp$133.TimelineDataManager._CreateDataItems(this._trackDataItems, a, TrackDataItem, this)
    }
    Release()
    {
        this._timelineDataItem = null;
        for (const a of this._trackDataItems)
            a.Release();
        C3$jscomp$133.clearArray(this._trackDataItems);
        this._trackDataItems = null
    }
    GetTimelineDataItem()
    {
        return this._timelineDataItem
    }
    AddEmptyTrackDataItem()
    {
        const a = new TrackDataItem(null, this);
        this._trackDataItems.push(a);
        return a
    }
    GetFirstKeyframeDataItem(a)
    {
        return a.GetKeyframeData().GetKeyframeDataItemArray()[0]
    }
    GetLastKeyframeDataItem(a)
    {
        return a.GetKeyframeData().GetKeyframeDataItemArray().at(-1)
    }
    GetKeyFrameDataItemAtTime(a,
    b)
    {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() === a)
                return e
        }
    }
    GetFirstKeyFrameDataItemHigherThan(a, b)
    {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() > a)
                return e
        }
    }
    GetFirstKeyFrameDataItemHigherOrEqualThan(a, b)
    {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() >= a)
                return e
        }
    }
    GetFirstKeyFrameDataItemLowerOrEqualThan(a,
    b)
    {
        b = b.GetKeyframeData().GetKeyframeDataItemArray();
        for (let c = b.length - 1; 0 <= c; c--) {
            const d = b[c];
            if (d.GetTime() <= a)
                return d
        }
    }
    *trackDataItems()
    {
        for (const a of this._trackDataItems)
            yield a
    }
    _SaveToJson()
    {
        return {
            trackDataItemsJson: this._trackDataItems.map(a => a._SaveToJson())
        }
    }
    _LoadFromJson(a)
    {
        a && C3$jscomp$133.TimelineDataManager._LoadDataItemsFromJson(this._trackDataItems, a.trackDataItemsJson, TrackDataItem, this)
    }
}
;
"use strict";
const C3$jscomp$134 = self.C3;
class PropertyTrackDataItem {
    constructor(a, b)
    {
        this._propertyTrackData = b;
        this._sourceAdapterId = "";
        this._type = this._property = this._sourceAdapterArguments = null;
        this._max = this._min = NaN;
        this._resultMode = this._interpolationMode = "default";
        this._enabled = !1;
        this._propertyKeyframeData = null;
        this._canHavePropertyKeyframes = !0;
        a && (this._sourceAdapterId = a[0][0], this._sourceAdapterArguments = a[0].slice(1), this._property = a[1], this._type = a[2], this._min = a[3], this._max = a[4], this._interpolationMode = a[5], this._resultMode =
        a[6], this._enabled = !!a[7], this._propertyKeyframeData = new C3$jscomp$134.PropertyKeyframeData(a[8], this), this._canHavePropertyKeyframes = a[9])
    }
    Release()
    {
        this._propertyKeyframeData.Release();
        this._sourceAdapterArguments = this._propertyTrackData = this._propertyKeyframeData = null
    }
    GetPropertyTrackData()
    {
        return this._propertyTrackData
    }
    GetPropertyKeyframeData()
    {
        this._propertyKeyframeData || (this._propertyKeyframeData = new C3$jscomp$134.PropertyKeyframeData(null, this));
        return this._propertyKeyframeData
    }
    GetSourceAdapterId()
    {
        return this._sourceAdapterId
    }
    SetSourceAdapterId(a)
    {
        this._sourceAdapterId =
        a
    }
    GetSourceAdapterArguments()
    {
        return this._sourceAdapterArguments
    }
    SetSourceAdapterArguments(a)
    {
        this._sourceAdapterArguments = a
    }
    GetProperty()
    {
        return this._property
    }
    SetProperty(a)
    {
        this._property = a
    }
    GetType()
    {
        return this._type
    }
    SetType(a)
    {
        this._type = a
    }
    GetMin()
    {
        return this._min
    }
    SetMin(a)
    {
        this._min = a
    }
    GetMax()
    {
        return this._max
    }
    SetMax(a)
    {
        this._max = a
    }
    GetInterpolationMode()
    {
        return this._interpolationMode
    }
    SetInterpolationMode(a)
    {
        this._interpolationMode = a
    }
    GetResultMode()
    {
        return this._resultMode
    }
    SetResultMode(a)
    {
        this._resultMode =
        a
    }
    GetEnable()
    {
        return this._enabled
    }
    SetEnable(a)
    {
        this._enabled = !!a
    }
    CanHavePropertyKeyframes()
    {
        return !!this._canHavePropertyKeyframes
    }
    _SaveToJson()
    {
        return {
            propertyKeyframeDataJson: this._propertyKeyframeData._SaveToJson(),
            sourceAdapterId: this._sourceAdapterId,
            sourceAdapterArguments: this._sourceAdapterArguments,
            property: this._property,
            type: this._type,
            min: this._min,
            max: this._max,
            interpolationMode: this._interpolationMode,
            resultMode: this._resultMode,
            enabled: this._enabled,
            canHavePropertyKeyframes: this._canHavePropertyKeyframes
        }
    }
    _LoadFromJson(a)
    {
        a &&
        (this._sourceAdapterId = a.sourceAdapterId, this._sourceAdapterArguments = a.sourceAdapterArguments, this._property = a.property, this._type = a.type, this._min = a.min, this._max = a.max, this._interpolationMode = a.interpolationMode, this._resultMode = a.resultMode, this._enabled = a.enabled, this._canHavePropertyKeyframes = a.canHavePropertyKeyframes, this.GetPropertyKeyframeData()._LoadFromJson(a.propertyKeyframeDataJson))
    }
}
C3$jscomp$134.PropertyTrackData = class {
    constructor(a, b)
    {
        this._trackDataItem = b;
        this._propertyTrackDataItems = [];
        C3$jscomp$134.TimelineDataManager._CreateDataItems(this._propertyTrackDataItems, a, PropertyTrackDataItem, this)
    }
    Release()
    {
        this._trackDataItem = null;
        for (const a of this._propertyTrackDataItems)
            a.Release();
        C3$jscomp$134.clearArray(this._propertyTrackDataItems);
        this._propertyTrackDataItems = null
    }
    GetTrackDataItem()
    {
        return this._trackDataItem
    }
    AddEmptyPropertyTrackDataItem()
    {
        const a = new PropertyTrackDataItem(null,
        this);
        this._propertyTrackDataItems.push(a);
        return a
    }
    GetFirstPropertyKeyframeDataItem(a)
    {
        return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray()[0]
    }
    GetLastPropertyKeyframeDataItem(a)
    {
        return a.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray().at(-1)
    }
    GetPropertyKeyFrameDataItemAtTime(a, b)
    {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() === a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemHigherThan(a,
    b)
    {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() > a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemHigherOrEqualThan(a, b)
    {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        const c = b.length;
        for (let d = 0; d < c; d++) {
            const e = b[d];
            if (e.GetTime() >= a)
                return e
        }
    }
    GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, b)
    {
        b = b.GetPropertyKeyframeData().GetPropertyKeyframeDataItemArray();
        for (let c = b.length - 1; 0 <= c; c--) {
            const d =
            b[c];
            if (d.GetTime() <= a)
                return d
        }
    }
    *propertyTrackDataItems()
    {
        for (const a of this._propertyTrackDataItems)
            yield a
    }
    _SaveToJson()
    {
        return {
            propertyTrackDataItemsJson: this._propertyTrackDataItems.map(a => a._SaveToJson())
        }
    }
    _LoadFromJson(a)
    {
        a && C3$jscomp$134.TimelineDataManager._LoadDataItemsFromJson(this._propertyTrackDataItems, a.propertyTrackDataItemsJson, PropertyTrackDataItem, this)
    }
}
;
"use strict";
const C3$jscomp$135 = self.C3;
class KeyframeDataItem {
    constructor(a, b)
    {
        this._keyframeData = b;
        this._time = -1;
        this._ease = "noease";
        this._enable = !1;
        this._lowerTags = this._tags = null;
        a && (this._time = a[0], this._ease = a[1], this._enable = !!a[2], this._tags = (a = a[3]) ? a.split(" ") : [], this._lowerTags = new Set(this._tags.map(c => c.toLowerCase())), this._next = null)
    }
    Release()
    {
        this._keyframeData = null;
        C3$jscomp$135.clearArray(this._tags);
        this._tags = null;
        this._lowerTags.clear();
        this._next = this._lowerTags = null
    }
    GetKeyframeData()
    {
        return this._keyframeData
    }
    GetNext()
    {
        return this._next
    }
    SetNext(a)
    {
        this._next =
        a
    }
    GetTime()
    {
        return this._time
    }
    SetTime(a)
    {
        this._time = a;
        this._keyframeData._LinkKeyframeDataItems()
    }
    GetEase()
    {
        return this._ease
    }
    SetEase(a)
    {
        this._ease = a
    }
    GetEnable()
    {
        return this._enable
    }
    SetEnable(a)
    {
        this._enable = !!a
    }
    GetTags()
    {
        return this._tags
    }
    SetTags(a)
    {
        this._tags = a ? a.split(" ") : [];
        this._lowerTags = new Set(this._tags.map(b => b.toLowerCase()))
    }
    GetLowerTags()
    {
        return this._lowerTags
    }
    HasTag(a)
    {
        return this._lowerTags.has(a.toLowerCase())
    }
    _SaveToJson()
    {
        return {
            time: this._time,
            ease: this._ease,
            enable: this._enable,
            tags: this._tags
        }
    }
    _LoadFromJson(a)
    {
        a && (this._time = a.time, this._ease = a.ease, this._enable = a.enable, this._tags = a.tags, this._lowerTags = new Set(this._tags.map(b => b.toLowerCase())))
    }
}
C3$jscomp$135.KeyframeData = class {
    constructor(a, b)
    {
        this._trackDataItem = b;
        this._keyframeDataItems = [];
        C3$jscomp$135.TimelineDataManager._CreateDataItems(this._keyframeDataItems, a, KeyframeDataItem, this);
        this._LinkKeyframeDataItems()
    }
    Release()
    {
        this._trackDataItem = null;
        for (const a of this._keyframeDataItems)
            a.Release();
        C3$jscomp$135.clearArray(this._keyframeDataItems);
        this._keyframeDataItems = null
    }
    _LinkKeyframeDataItems()
    {
        this._keyframeDataItems.sort((a, b) => a.GetTime() - b.GetTime());
        for (let a = 0; a < this._keyframeDataItems.length; a++)
            this._keyframeDataItems[a].SetNext(this._keyframeDataItems[a +
            1])
    }
    GetTrackDataItem()
    {
        return this._trackDataItem
    }
    GetKeyframeDataItemCount()
    {
        return this._keyframeDataItems.length
    }
    GetKeyframeDataItemArray()
    {
        return this._keyframeDataItems
    }
    AddEmptyKeyframeDataItem()
    {
        const a = new KeyframeDataItem(null, this);
        this._keyframeDataItems.push(a);
        this._LinkKeyframeDataItems();
        return a
    }
    DeleteKeyframeDataItems(a)
    {
        for (const b of this._keyframeDataItems) {
            if (!a(b))
                continue;
            const c = this._keyframeDataItems.indexOf(b);
            -1 !== c && (b.Release(), this._keyframeDataItems.splice(c, 1))
        }
        this.SortKeyframeDataItems();
        this._LinkKeyframeDataItems()
    }
    SortKeyframeDataItems()
    {
        this._keyframeDataItems.sort((a, b) => a.GetTime() - b.GetTime())
    }
    GetKeyframeDataItemIndex(a)
    {
        return this._keyframeDataItems.indexOf(a)
    }
    GetKeyframeDataItemFromIndex(a)
    {
        return this._keyframeDataItems[a]
    }
    *keyframeDataItems()
    {
        for (const a of this._keyframeDataItems)
            yield a
    }
    *keyframeDataItemsReverse()
    {
        for (let a = this._keyframeDataItems.length - 1; 0 <= a; a--)
            yield this._keyframeDataItems[a]
    }
    _SaveToJson()
    {
        return {
            keyframeDataItemsJson: this._keyframeDataItems.map(a =>
            a._SaveToJson())
        }
    }
    _LoadFromJson(a)
    {
        a && (C3$jscomp$135.TimelineDataManager._LoadDataItemsFromJson(this._keyframeDataItems, a.keyframeDataItemsJson, KeyframeDataItem, this), this._LinkKeyframeDataItems())
    }
}
;
"use strict";
const C3$jscomp$136 = self.C3;
class PropertyKeyframeDataItem {
    constructor(a, b)
    {
        this._propertyKeyframeData = b;
        this._aValue = this._value = null;
        this._type = "";
        this._time = NaN;
        this._ease = "noease";
        this._enable = !1;
        this._addonData = null;
        this._addonInstance = void 0;
        this._pathMode = "line";
        a && (this._value = a[0][0], this._aValue = a[0][1], this._type = a[0][2], this._time = a[1], this._ease = a[2], this._enable = !!a[3], this._pathMode = a[5], this._addonData = null, a[4] && (this._addonData = new C3$jscomp$136.AddonData(a[4], this)), this._prev = this._next = null)
    }
    Release()
    {
        this._propertyKeyframeData =
        null;
        this._addonData && (this._addonData.Release(), this._addonData = null);
        this._prev = this._next = null
    }
    GetAddonData()
    {
        return this._addonData
    }
    SetNext(a)
    {
        this._next = a
    }
    GetNext()
    {
        return this._next
    }
    SetPrevious(a)
    {
        this._prev = a
    }
    GetPrevious()
    {
        return this._prev
    }
    GetValue()
    {
        return this._value
    }
    SetValue(a)
    {
        "color" === this._type && C3$jscomp$136.IsFiniteNumber(a) ? (this._value[0] = C3$jscomp$136.GetRValue(a), this._value[1] = C3$jscomp$136.GetGValue(a), this._value[2] = C3$jscomp$136.GetBValue(a)) : this._value = a
    }
    GetAbsoluteValue()
    {
        return this._aValue
    }
    SetAbsoluteValue(a)
    {
        "color" ===
        this._type && C3$jscomp$136.IsFiniteNumber(a) ? (this._aValue[0] = C3$jscomp$136.GetRValue(a), this._aValue[1] = C3$jscomp$136.GetGValue(a), this._aValue[2] = C3$jscomp$136.GetBValue(a)) : this._aValue = a
    }
    GetValueWithResultMode()
    {
        const a = this._propertyKeyframeData.GetPropertyTrackDataItem().GetResultMode();
        if ("relative" === a)
            return this.GetValue();
        if ("absolute" === a)
            return this.GetAbsoluteValue()
    }
    GetType()
    {
        return this._type
    }
    SetType(a)
    {
        this._type = a
    }
    GetTime()
    {
        return this._time
    }
    SetTime(a)
    {
        this._time = a;
        this._propertyKeyframeData._LinkPropertyKeyframeDataItems()
    }
    GetEase()
    {
        return this._ease
    }
    SetEase(a)
    {
        this._ease =
        a
    }
    GetEnable()
    {
        return this._enable
    }
    SetEnable(a)
    {
        this._enable = !!a
    }
    GetPathMode()
    {
        return this._pathMode
    }
    GetAddOn(a)
    {
        if (this._addonData) {
            if (this._addonInstance || null === this._addonInstance)
                return this._addonInstance;
            var b = this._addonData.GetAddDataItemArray();
            if (!b)
                return this._addonInstance = null;
            var c = b.length;
            for (let d = 0; d < c; d++) {
                const e = b[d];
                if (e.GetId() === a)
                    return this._addonInstance = e
            }
            return this._addonInstance = null
        }
    }
    _SaveToJson()
    {
        const a = this._addonData;
        return {
            addonDataJson: a ? a._SaveToJson() : a,
            value: this._value,
            aValue: this._aValue,
            type: this._type,
            time: this._time,
            ease: this._ease,
            enable: this._enable
        }
    }
    _LoadFromJson(a)
    {
        a && (a.addonDataJson && this._addonData._SetFromJson(a.addonDataJson), this._value = a.value, this._aValue = a.aValue, this._type = a.type, this._time = a.time, this._ease = a.ease, this._enable = a.enable)
    }
}
C3$jscomp$136.PropertyKeyframeData = class {
    constructor(a, b)
    {
        this._propertyTrackDataItem = b;
        this._propertyKeyframeDataItems = [];
        this._propertyKeyframeDataItemsIncludingDisabled = [];
        C3$jscomp$136.TimelineDataManager._CreateDataItems(this._propertyKeyframeDataItems, a, PropertyKeyframeDataItem, this);
        C3$jscomp$136.TimelineDataManager._CreateDataItemsIncludingDisabled(this._propertyKeyframeDataItemsIncludingDisabled, a, PropertyKeyframeDataItem, this);
        this._LinkPropertyKeyframeDataItems()
    }
    Release()
    {
        this._propertyTrackDataItem =
        null;
        for (const a of this._propertyKeyframeDataItems)
            a.Release();
        C3$jscomp$136.clearArray(this._propertyKeyframeDataItems);
        this._propertyKeyframeDataItems = null;
        for (const a of this._propertyKeyframeDataItemsIncludingDisabled)
            a.Release();
        C3$jscomp$136.clearArray(this._propertyKeyframeDataItemsIncludingDisabled);
        this._propertyKeyframeDataItemsIncludingDisabled = null
    }
    _LinkPropertyKeyframeDataItems()
    {
        let a = this._propertyKeyframeDataItems;
        a.sort((d, e) => d.GetTime() - e.GetTime());
        for (var b = 0; b < a.length; b++) {
            var c =
            a[b];
            b + 1 < a.length && c.SetNext(a[b + 1]);
            0 <= b - 1 && c.SetPrevious(a[b - 1])
        }
        a = this._propertyKeyframeDataItemsIncludingDisabled;
        a.sort((d, e) => d.GetTime() - e.GetTime());
        for (b = 0; b < a.length; b++)
            c = a[b],
            b + 1 < a.length && c.SetNext(a[b + 1]),
            0 <= b - 1 && c.SetPrevious(a[b - 1])
    }
    AddEmptyPropertyKeyframeDataItem()
    {
        const a = new PropertyKeyframeDataItem(null, this);
        this._propertyKeyframeDataItems.push(a);
        this._LinkPropertyKeyframeDataItems();
        return a
    }
    DeletePropertyKeyframeDataItems(a)
    {
        for (const b of this._propertyKeyframeDataItems) {
            if (!a(b))
                continue;
            const c = this._propertyKeyframeDataItems.indexOf(b);
            -1 !== c && (b.Release(), this._propertyKeyframeDataItems.splice(c, 1))
        }
        this.SortPropertyKeyFrameDataItems();
        this._LinkPropertyKeyframeDataItems()
    }
    SortPropertyKeyFrameDataItems()
    {
        this._propertyKeyframeDataItems.sort((a, b) => a.GetTime() - b.GetTime())
    }
    GetPropertyTrackDataItem()
    {
        return this._propertyTrackDataItem
    }
    GetPropertyKeyframeDataItemCount()
    {
        return this._propertyKeyframeDataItems.length
    }
    GetLastPropertyKeyframeDataItem()
    {
        return this._propertyKeyframeDataItems[this._propertyKeyframeDataItems.length -
        1]
    }
    GetPropertyKeyframeDataItemArray()
    {
        return this._propertyKeyframeDataItems
    }
    GetPropertyKeyframeDataItemArrayIncludingDisabled()
    {
        return this._propertyKeyframeDataItemsIncludingDisabled
    }
    *propertyKeyframeDataItems()
    {
        for (const a of this._propertyKeyframeDataItems)
            yield a
    }
    *propertyKeyframeDataItemsReverse()
    {
        for (let a = this._propertyKeyframeDataItems.length - 1; 0 <= a; a--)
            yield this._propertyKeyframeDataItems[a]
    }
    _SaveToJson()
    {
        const a = this._propertyKeyframeDataItemsIncludingDisabled;
        return {
            propertyKeyframeDataItemsJson: this._propertyKeyframeDataItems.map(b =>
            b._SaveToJson()),
            propertyKeyframeDataItemsIncludingDisabledJson: a.map(b => b._SaveToJson())
        }
    }
    _LoadFromJson(a)
    {
        a && (C3$jscomp$136.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItems, a.propertyKeyframeDataItemsJson, PropertyKeyframeDataItem, this), C3$jscomp$136.TimelineDataManager._LoadDataItemsFromJson(this._propertyKeyframeDataItemsIncludingDisabled, a.propertyKeyframeDataItemsIncludingDisabledJson, PropertyKeyframeDataItem, this), this._LinkPropertyKeyframeDataItems())
    }
}
;
"use strict";
const C3$jscomp$137 = self.C3;
class AddonDataItem {
    constructor(a, b)
    {
        this._addonData = b;
        this._id = a[0];
        this._data = a[1]
    }
    Release()
    {
        this._data = this._addonData = null
    }
    GetAddonData()
    {
        return this._addonData
    }
    GetId()
    {
        return this._id
    }
    _SaveToJson()
    {
        return {
            id: this._id,
            data: this._data
        }
    }
    _LoadFromJson(a)
    {
        a && (this._id = a.id, this._data = a.data)
    }
}
class AddonDataCubicBezierItem extends AddonDataItem {
    constructor(a, b)
    {
        super(a, b);
        this._startAnchor = this._data[0];
        this._startEnable = !!this._data[1];
        this._endAnchor = this._data[2];
        this._endEnable = !!this._data[3]
    }
    Release()
    {
        super.Release()
    }
    GetStartAnchor()
    {
        return this._startAnchor
    }
    GetStartEnable()
    {
        return this._startEnable
    }
    GetEndAnchor()
    {
        return this._endAnchor
    }
    GetEndEnable()
    {
        return this._endEnable
    }
    _SaveToJson()
    {
        return Object.assign(super._SaveToJson(), {
            startAnchor: this._startAnchor,
            startEnable: !!this._startEnable,
            endAnchor: this._endAnchor,
            endEnable: !!this._endEnable
        })
    }
    _LoadFromJson(a)
    {
        a && (super._LoadFromJson(a), this._startAnchor = a.startAnchor, this._startEnable = !!a.startEnable, this._endAnchor = a.endAnchor, this._endEnable = !!a.endEnable)
    }
}
class AddonDataAngleItem extends AddonDataItem {
    constructor(a, b)
    {
        super(a, b);
        this._direction = this._data[0];
        this._revolutions = this._data[1]
    }
    Release()
    {
        super.Release()
    }
    GetDirection()
    {
        return this._direction
    }
    GetRevolutions()
    {
        return this._revolutions
    }
    _SaveToJson()
    {
        return Object.assign(super._SaveToJson(), {
            direction: this._direction,
            revolutions: this._revolutions
        })
    }
    _LoadFromJson(a)
    {
        a && (super._LoadFromJson(a), this._direction = a.direction, this._revolutions = a.revolutions)
    }
}
C3$jscomp$137.AddonData = class {
    constructor(a, b)
    {
        this._propertyKeyframeDataItem = b;
        this._addonDataItems = [];
        C3$jscomp$137.TimelineDataManager._CreateDataItems(this._addonDataItems, a, {
            prop: 0,
            map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])
        }, this)
    }
    Release()
    {
        this._propertyKeyframeDataItem = null;
        for (const a of this._addonDataItems)
            a.Release();
        C3$jscomp$137.clearArray(this._addonDataItems);
        this._addonDataItems = null
    }
    GetPropertyKeyframeDataItem()
    {
        return this._propertyKeyframeDataItem
    }
    GetAddDataItemArray()
    {
        return this._addonDataItems
    }
    *addonDataItems()
    {
        for (const a of this._addonDataItems)
            yield a
    }
    _SaveToJson()
    {
        return {
            addonDataItemsJson: this._addonDataItems.map(a =>
            a._SaveToJson())
        }
    }
    _LoadFromJson(a)
    {
        a && C3$jscomp$137.TimelineDataManager._LoadDataItemsFromJson(this._addonDataItems, a.addonDataItemsJson, {
            prop: "id",
            map: new Map([["cubic-bezier", AddonDataCubicBezierItem], ["angle", AddonDataAngleItem]])
        }, this)
    }
}
;
"use strict";
const C3$jscomp$138 = self.C3;
let createdTweens = 0;
C3$jscomp$138.TweenState = class  extends C3$jscomp$138.TimelineState{
    constructor(a, b)
    {
        super(`tween-${createdTweens++}`, a, b);
        this._id = "";
        this._destroyInstanceOnComplete = !1;
        this._initialValueMode = "start-value";
        this._iTweenState = this._track = this._on_started_callbacks = this._on_completed_callbacks = this._instance = null
    }
    FireReleaseEvent(a)
    {
        const b = C3$jscomp$138.New(C3$jscomp$138.Event, "tweenstatereleased");
        b.tweenState = this;
        a.dispatchEvent(b)
    }
    GetType()
    {
        return 1
    }
    CreateTrackStates()
    {
        for (const a of this._timelineDataItem.GetTrackData().trackDataItems())
            this._tracks.push(C3$jscomp$138.TweenTrackState.Create(this,
            a));
        this._track = this._tracks[0]
    }
    AddTrack()
    {
        var a = this._timelineDataItem.GetTrackData().AddEmptyTrackDataItem();
        a = C3$jscomp$138.TweenTrackState.Create(this, a);
        this._tracks.push(a);
        this._CacheTrack();
        return a
    }
    _CacheTrack()
    {
        this._track = this._tracks[0]
    }
    GetPropertyTrack(a)
    {
        return this._track.GetPropertyTracks()[0]
    }
    SetPropertyType(a)
    {
        this._propertyType = a
    }
    GetInstance()
    {
        var a = this.GetTracks();
        if (a && a.length && (this._track = a = a[0])) {
            var b = a.GetInstance();
            return a.IsInstanceValid() ? b : void 0
        }
    }
    AddStartedCallback(a)
    {
        this._on_started_callbacks ||
        (this._on_started_callbacks = []);
        this._on_started_callbacks.push(a)
    }
    AddCompletedCallback(a)
    {
        this._on_completed_callbacks || (this._on_completed_callbacks = []);
        this._on_completed_callbacks.push(a)
    }
    RemoveStartedCallback(a)
    {
        this._on_started_callbacks && (a = this._on_started_callbacks.indexOf(a), -1 !== a && this._on_started_callbacks.splice(a, 1))
    }
    RemoveCompletedCallback(a)
    {
        this._on_completed_callbacks && (a = this._on_completed_callbacks.indexOf(a), -1 !== a && this._on_completed_callbacks.splice(a, 1))
    }
    SetStartValue(a, b)
    {
        for (const d of this._tracks)
            for (const e of d._propertyTracks) {
                if (e.GetPropertyName() !==
                b)
                    continue;
                var c = e.GetPropertyTrackData();
                const f = e.GetPropertyTrackDataItem();
                c = c.GetFirstPropertyKeyframeDataItem(f);
                c.SetValue(a);
                c.SetAbsoluteValue(a)
            }
    }
    _GetPropertyTrackState(a)
    {
        for (const b of this._tracks)
            for (const c of b._propertyTracks)
                if (c.GetPropertyName() === a)
                    return c
    }
    BeforeSetEndValues(a)
    {
        for (const d of a)
            a = this._GetPropertyTrackState(d),
            this.SetStartValue(a.GetCurrentState(), d);
        if (this.IsForwardPlayBack()) {
            var b = this.GetTotalTime() - this.GetTime();
            this.SetTotalTime(b);
            for (var c of this._tracks)
                c.SetLocalTotalTime(b);
            this._SetTime(0)
        } else {
            c = this.GetTime();
            this.SetTotalTime(c);
            for (b of this._tracks)
                b.SetLocalTotalTime(c);
            this._SetTime(c)
        }
        this.SetInitialStateFromSetTime()
    }
    SetEndValue(a, b)
    {
        var c = this._GetPropertyTrackState(b);
        b = c.GetPropertyTrackData();
        c = c.GetPropertyTrackDataItem();
        b = b.GetLastPropertyKeyframeDataItem(c);
        b.SetTime(this.GetTotalTime());
        b.SetValue(a);
        b.SetAbsoluteValue(a)
    }
    SetId(a)
    {
        this._id = a
    }
    GetId()
    {
        return this._id
    }
    SetInitialValueMode(a)
    {
        this._initialValueMode = a
    }
    GetInitialValueMode()
    {
        return this._initialValueMode
    }
    SetDestroyInstanceOnComplete(a)
    {
        this._destroyInstanceOnComplete =
        a
    }
    GetDestroyInstanceOnComplete()
    {
        return this._destroyInstanceOnComplete
    }
    OnStarted()
    {
        if (this._on_started_callbacks)
            for (const a of this._on_started_callbacks)
                a(this);
        if (!this.IsComplete())
            for (const a of this._tracks)
                a.CompareSaveStateWithCurrent()
    }
    OnCompleted()
    {
        this._completedTick = this._runtime.GetTickCount()
    }
    FinishTriggers()
    {
        if (!this._finishedTriggers && (this._finishedTriggers = !0, this._on_completed_callbacks))
            for (const a of this._on_completed_callbacks)
                a(this)
    }
    SetTime(a)
    {
        this._DeleteIntermediateKeyframes();
        super.SetTime(a)
    }
    _SetTimeAndReset(a)
    {
        C3$jscomp$138.IsFiniteNumber(a) || (a = this.GetTotalTime());
        0 > a ? this._playheadTime = 0 : a >= this.GetTotalTime() ? this._playheadTime = this.GetTotalTime() : this._playheadTime = a;
        this._track.SetResetState()
    }
    SetInitialState(a)
    {
        if (!this.InitialStateSet() && "current-state" === this.GetInitialValueMode())
            for (const b of this._tracks)
                b.CompareInitialStateWithCurrent();
        super.SetInitialState(a)
    }
    Stop(a=!1)
    {
        super.Stop(a);
        if (!this.IsComplete())
            for (const b of this._tracks)
                b.SaveState()
    }
    Reset(a=
    !0, b=!1)
    {
        this._DeleteIntermediateKeyframes();
        super.Reset(a, b)
    }
    _DeleteIntermediateKeyframes()
    {
        for (const a of this._tracks) {
            const b = c => {
                c = c.GetTime();
                const d = this.GetTotalTime();
                return 0 !== c && c !== d
            };
            a.DeleteKeyframes(b);
            a.DeletePropertyKeyframes(b)
        }
    }
    _OnBeforeChangeLayout()
    {
        if (this.IsReleased())
            return !0;
        const a = this.GetInstance();
        if (a && a.GetObjectClass().IsGlobal())
            return !1;
        this._timelineManager.CompleteTimelineBeforeChangeOfLayout(this);
        this.ResetBeforeChangeLayout();
        return !0
    }
    Tick(a, b, c)
    {
        this._instance ||
        (this._instance = this.GetInstance());
        if (!this._instance || this._instance.IsDestroyed())
            this.Stop(!0),
            this.OnCompleted();
        else if (b = this._instance.GetTimeScale(), -1 !== b && (a = c * b), 0 !== a || 0 !== this._lastDelta) {
            this._lastDelta = a;
            c = this._playheadTime + this._overshoot + a * this._playbackRate;
            a = this._timelineDataItem._totalTime;
            0 > c ? (this._playheadTime = 0, this._overshoot = -c) : c >= a ? (this._playheadTime = a, this._overshoot = this._playheadTime - c) : (this._playheadTime = c, this._overshoot = 0);
            b = c = !1;
            var d = this.GetLoop(),
                e = this.GetPingPong();
            d || e ? d && !e ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTimeAndReset(0), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), b = !0) : 0 >= this._playheadTime && (this._SetTimeAndReset(a), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), b = !0) : !d && e ? 0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 *
            this.GetPlaybackRate()), b = !0, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = 0) : (this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong), c = !0) : 0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = 1)) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), b = !0, 1 === this._pingPongState ? this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong), this._pingPongState = 0) : (c = !0, this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong)) : 0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong),
            this._pingPongState = 1)) : d && e && (0 < this._playbackRate ? this._playheadTime >= a && (this._SetTime(a), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), b = !0, 0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong),
            this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState++, this._pingPongState = C3$jscomp$138.wrap(this._pingPongState, 0, 2)) : 0 >= this._playheadTime && (this._SetTime(0), this.SetPlaybackRate(-1 * this.GetPlaybackRate()), b = !0, 0 === this._pingPongState && (this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong)), 1 === this._pingPongState && (this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenPingPong), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensPingPong)), this._pingPongState++, this._pingPongState = C3$jscomp$138.wrap(this._pingPongState, 0, 2))) : 0 < this._playbackRate ? this._playheadTime >= a && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(0), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop),
            this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), b = !0) : (this._SetTime(a), c = !0)) : 0 >= this._playheadTime && (this._currentRepeatCount < this.GetRepeatCount() ? (this._currentRepeatCount++, this._SetTimeAndReset(a), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnAnyTweenLoop), this._TweenTrigger(C3$jscomp$138.Behaviors.Tween.Cnds.OnTweensLoop), b = !0) : (this._SetTime(0), c = !0));
            c ? (this._track.SetEndState(), this.Stop(!0), this.OnCompleted()) : (this._track.Interpolate(this._playheadTime, !0,
            !1, b, this._firstTick, !1), this._firstTick && (this._firstTick = !1))
        }
    }
    _TweenTrigger(a)
    {
        const b = this.GetInstance(),
            c = b.GetBehaviorSdkInstanceFromCtor(C3$jscomp$138.Behaviors.Tween);
        c.PushTriggerTween(this);
        this._runtime.Trigger(a, b, c.GetBehaviorType());
        c.PopTriggerTween()
    }
    _SaveToJson()
    {
        const a = super._SaveToJson(),
            b = this.GetTimelineDataItem();
        return Object.assign(a, {
            tweenDataItemJson: b._SaveToJson(),
            id: this._id,
            destroyInstanceOnComplete: this._destroyInstanceOnComplete,
            initialValueMode: this._initialValueMode
        })
    }
    _LoadFromJson(a)
    {
        a &&
        (this.GetTimelineDataItem()._LoadFromJson(a.tweenDataItemJson), super._LoadFromJson(a), this._id = a.id, this._destroyInstanceOnComplete = a.destroyInstanceOnComplete, this._initialValueMode = a.initialValueMode, this._CacheTrack())
    }
    static IsPlaying(a)
    {
        return a.IsPlaying()
    }
    static IsPaused(a)
    {
        return a.IsPaused()
    }
    static IsPing(a)
    {
        return a.GetPingPong() ? 0 === a.GetPingPongState() : !1
    }
    static IsPong(a)
    {
        return a.GetPingPong() ? 1 === a.GetPingPongState() : !1
    }
    static Build(a)
    {
        var b = a.runtime.GetTimelineManager(),
            c = new C3$jscomp$138.TimelineDataItem;
        if (a.json) {
            c._LoadFromJson(a.json.tweenDataItemJson);
            var d = new C3$jscomp$138.TweenState(c, b);
            d._LoadFromJson(a.json);
            return d
        }
        b = new C3$jscomp$138.TweenState(c, b);
        C3$jscomp$138.IsArray(a.propertyTracksConfig) || (a.propertyTracksConfig = [a.propertyTracksConfig]);
        b.SetId(a.id);
        b.SetTags(a.tags);
        b.SetInitialValueMode(a.initialValueMode);
        b.SetDestroyInstanceOnComplete(a.releaseOnComplete);
        b.SetLoop(a.loop);
        b.SetPingPong(a.pingPong);
        b.SetTotalTime(a.time);
        b.SetStep(0);
        b.SetInterpolationMode("default");
        b.SetResultMode(a.propertyTracksConfig[0].resultMode);
        b.SetRepeatCount(a.repeatCount);
        c = b.AddTrack();
        c.SetInstanceUID(a.instance.GetUID());
        c.SetInterpolationMode("default");
        c.SetResultMode(a.propertyTracksConfig[0].resultMode);
        c.SetEnable(!0);
        c.SetObjectClassIndex(a.instance.GetObjectClass().GetIndex());
        var e = a.instance.GetSdkInstance(),
            f = e.IsOriginalSizeKnown() ? e.GetOriginalWidth() : a.instance.GetWorldInfo().GetWidth();
        e = e.IsOriginalSizeKnown() ? e.GetOriginalHeight() : a.instance.GetWorldInfo().GetHeight();
        c.SetOriginalWidth(f);
        c.SetOriginalHeight(e);
        f =
        c.AddKeyframe();
        f.SetTime(0);
        f.SetEase("noease");
        f.SetEnable(!0);
        f.SetTags("");
        f = c.AddKeyframe();
        f.SetTime(a.time);
        f.SetEase("noease");
        f.SetEnable(!0);
        f.SetTags("");
        for (d of a.propertyTracksConfig)
            f = c.AddPropertyTrack(),
            f.SetSourceAdapterId(d.sourceId),
            f.SetSourceAdapterArgs(d.sourceArgs),
            f.SetPropertyName(d.property),
            f.SetPropertyType(d.type),
            f.SetMin(NaN),
            f.SetMax(NaN),
            f.SetInterpolationMode("default"),
            f.SetResultMode(d.resultMode),
            f.SetEnable(!0),
            e = f.AddPropertyKeyframe(),
            e.SetType(d.valueType),
            e.SetTime(0),
            e.SetEase(d.ease),
            e.SetEnable(!0),
            e.SetValue(d.startValue),
            e.SetAbsoluteValue(d.startValue),
            e = f.AddPropertyKeyframe(),
            e.SetType(d.valueType),
            e.SetTime(a.time),
            e.SetEase(d.ease),
            e.SetEnable(!0),
            e.SetValue(d.endValue),
            e.SetAbsoluteValue(d.endValue),
            f.GetSourceAdapter();
        return b
    }
    static SetInstanceUID(a, b)
    {
        if (!isNaN(b))
            for (const c of a.GetTracks())
                c.SetInstanceUID(b)
    }
    GetITweenState(a, b)
    {
        this._iTweenState || (this._iTweenState = C3$jscomp$138.New(self.ITweenState, this, a, b));
        return this._iTweenState
    }
}
;
"use strict";
const C3$jscomp$139 = self.C3;
C3$jscomp$139.TweenTrackState = class  extends C3$jscomp$139.TrackState{
    constructor(a, b)
    {
        super(a, b);
        this._secondPropertyTrack = this._firstPropertyTrack = null
    }
    static Create(a, b)
    {
        return C3$jscomp$139.New(C3$jscomp$139.TweenTrackState, a, b)
    }
    _CachePropertyTracks()
    {
        1 === this._propertyTracks.length ? this._firstPropertyTrack = this._propertyTracks[0] : (this._firstPropertyTrack = this._propertyTracks[0], this._secondPropertyTrack = this._propertyTracks[1])
    }
    CreatePropertyTrackStates()
    {
        for (const a of this._trackDataItem.GetPropertyTrackData().propertyTrackDataItems())
            this._propertyTracks.push(C3$jscomp$139.TweenPropertyTrackState.Create(this, a));
        this._CachePropertyTracks()
    }
    AddPropertyTrack()
    {
        var a = this._trackDataItem.GetPropertyTrackData().AddEmptyPropertyTrackDataItem();
        a = C3$jscomp$139.TweenPropertyTrackState.Create(this, a);
        this._propertyTracks.push(a);
        this._CachePropertyTracks();
        return a
    }
    SetInitialState()
    {
        this.MaybeGetInstance();
        if (this.IsInstanceValid() || !this.IsInstanceTrack()) {
            var a = this.GetTimeline().IsForwardPlayBack() ? 0 : this.GetLocalTotalTime();
            for (const b of this._propertyTracks)
                b.SetInitialState(a),
                0 === this._worldInfoChange && 1 ===
                b.GetWorldInfoChange() && (this._worldInfoChange = 1),
                0 === this._renderChange && 1 === b.GetRenderChange() && (this._renderChange = 1);
            this._needsBeforeAndAfter = 0;
            this._propertyTracks.some(b => b.GetNeedsBeforeAndAfter()) && (this._needsBeforeAndAfter = 1);
            this._lastKeyframeDataItem = this._GetLastKeyFrameBeforeTime(a);
            this._endStateOfNestedSet = this._initialStateOfNestedSet = !1;
            this.Interpolate(a)
        }
    }
    BeforeInterpolate() {}
    Interpolate(a, b, c=!1, d=!1, e, f=!1, g=!1)
    {
        this._instance || this.GetInstance();
        if (this._instance) {
            if (this._instance.IsDestroyed() ||
            f && this.GetObjectClass().IsGlobal())
                return !1;
            this._secondPropertyTrack ? (this._firstPropertyTrack.Interpolate(a, c, d, g), this._secondPropertyTrack.Interpolate(a, c, d, g)) : this._firstPropertyTrack.Interpolate(a, c, d, g);
            0 !== this._firstPropertyTrack.GetWorldInfoChange() && (this._worldInfo || (this._worldInfo = this._instance.GetWorldInfo()), this._worldInfo && this._worldInfo.SetBboxChanged())
        }
    }
    AfterInterpolate() {}
    _LoadFromJson(a)
    {
        super._LoadFromJson(a);
        this._CachePropertyTracks()
    }
}
;
"use strict";
const C3$jscomp$140 = self.C3;
C3$jscomp$140.TweenPropertyTrackState = class  extends C3$jscomp$140.PropertyTrackState{
    constructor(a, b)
    {
        super(a, b);
        this._basic = !1
    }
    static Create(a, b)
    {
        return C3$jscomp$140.New(C3$jscomp$140.TweenPropertyTrackState, a, b)
    }
    Interpolate(a, b=!1, c=!1, d=!1)
    {
        if (this._basic) {
            var e = this._propertyKeyframeDataItems[0];
            var f = this._propertyKeyframeDataItems[1]
        } else {
            if (b)
                e = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
            else {
                if (this._lastPropertyKeyframeDataItem) {
                    f = this.GetTimeline();
                    const g = this._lastPropertyKeyframeDataItem.GetNext();
                    e = this._lastPropertyKeyframeDataItem.GetTime();
                    f = g ? g.GetTime() : f.GetTotalTime();
                    if (a <= e || a >= f)
                        this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem)
                } else
                    this._lastPropertyKeyframeDataItem = this._propertyTrackData.GetFirstPropertyKeyFrameDataItemLowerOrEqualThan(a, this._propertyTrackDataItem);
                e = this._lastPropertyKeyframeDataItem
            }
            f = e.GetNext()
        }
        this._sourceAdapter.Interpolate(a,
        e, f, b, c, d)
    }
    AddPropertyKeyframe()
    {
        const a = this._propertyTrackDataItem.GetPropertyKeyframeData().AddEmptyPropertyKeyframeDataItem();
        this._lastPropertyKeyframeDataItem = null;
        this._basic = 2 >= this.GetPropertyKeyframeDataItems().length;
        return a
    }
    DeletePropertyKeyframes(a)
    {
        this._lastPropertyKeyframeDataItem = null;
        this._propertyTrackDataItem.GetPropertyKeyframeData().DeletePropertyKeyframeDataItems(a);
        this._basic = 2 >= this.GetPropertyKeyframeDataItems().length
    }
    _SaveToJson()
    {
        return {
            sourceAdapterJson: this.GetSourceAdapter()._SaveToJson(),
            basic: this._basic
        }
    }
    _LoadFromJson(a)
    {
        a && (this.GetSourceAdapter()._LoadFromJson(a.sourceAdapterJson), this._basic = a.basic)
    }
}
;
"use strict";
const C3$jscomp$141 = self.C3,
    Ease$jscomp$2 = self.Ease;
C3$jscomp$141.Transition = class  extends C3$jscomp$141.DefendedBase{
    constructor(a, b=!0)
    {
        super();
        this._name = a[0];
        this._linear = a[2];
        this._transitionKeyframes = [];
        for (var c of a[1])
            a = C3$jscomp$141.TransitionKeyframe.Create(this, c),
            this._transitionKeyframes.push(a);
        for (c = 0; c < this._transitionKeyframes.length; c++) {
            a = this._transitionKeyframes[c];
            const d = this._transitionKeyframes[c - 1];
            a.SetNext(this._transitionKeyframes[c + 1]);
            a.SetPrevious(d)
        }
        this._precalculatedSamples = new Map;
        this._transitionKeyframeCache =
        new Map;
        this._PreCalcSamples();
        b && Ease$jscomp$2.AddCustomEase(this._name, (d, e, f, g) => this.Interpolate(d, e, f, g), null, {
            transition: this
        })
    }
    static Create(a)
    {
        return C3$jscomp$141.New(C3$jscomp$141.Transition, a)
    }
    Release()
    {
        for (const a of this._transitionKeyframes)
            a.Release();
        C3$jscomp$141.clearArray(this._transitionKeyframes);
        this._transitionKeyframes = null;
        this._precalculatedSamples.clear();
        this._precalculatedSamples = null;
        this._transitionKeyframeCache.clear();
        this._transitionKeyframeCache = null
    }
    MakeLinear(a)
    {
        this._linear =
        !!a
    }
    GetTransitionKeyFrameAt(a)
    {
        const b = this._transitionKeyframeCache.get(a);
        if (b)
            return b;
        for (const c of this._transitionKeyframes)
            if (c.GetValueX() === a)
                return this._transitionKeyframeCache.set(a, c), c
    }
    GetFirstTransitionKeyFrameLowerOrEqualThan(a)
    {
        for (let c = this._transitionKeyframes.length - 1; 0 <= c; c--) {
            var b = this._transitionKeyframes[c];
            const d = b.GetValueX();
            if (d <= a) {
                if (d < a)
                    return b;
                if (d === a) {
                    for (; b;) {
                        a = b.GetPrevious();
                        if (!a)
                            break;
                        if (a.GetValueX() !== b.GetValueX())
                            break;
                        b = a
                    }
                    return b
                }
            }
        }
    }
    Interpolate(a,
    b, c, d)
    {
        var e = a / d;
        if (this._linear) {
            var f = this.GetTransitionKeyFrameAt(0);
            e = this.GetTransitionKeyFrameAt(1);
            f = b + (b + c) * f.GetValueY();
            b = (b + c) * e.GetValueY() - f;
            return 0 === d ? f + b : Ease$jscomp$2.NoEase(a, f, b, d)
        }
        0 === d && (e = 1);
        a = this.GetFirstTransitionKeyFrameLowerOrEqualThan(e);
        d = a.GetNext();
        d || (d = a.GetPrevious(), f = a, a = d, d = f);
        f = d.GetValueX() - a.GetValueX();
        e = C3$jscomp$141.mapToRange(e, a.GetValueX(), d.GetValueX(), 0, f);
        if (a.IsSegmentLinear() || 0 === f)
            return a = b + (b + c) * a.GetValueY(), b = (b + c) * d.GetValueY() - a, 0 === f ? 1 ===
            e ? a + b : a : Ease$jscomp$2.NoEase(e, a, b, f);
        f = a.GetValueX();
        const g = a.GetValueY(),
            h = a.GetValueX() + a.GetStartAnchorX(),
            k = a.GetValueY() + a.GetStartAnchorY(),
            l = d.GetValueX() + d.GetEndAnchorX(),
            m = d.GetValueY() + d.GetEndAnchorY(),
            n = d.GetValueX();
        d = d.GetValueY();
        e = Ease$jscomp$2.GetRuntimeEase("spline")(e, f, g, h, k, l, m, n, d, this._precalculatedSamples.get(a));
        e += a.GetValueY();
        return (1 - e) * b + e * (b + c)
    }
    _PreCalcSamples()
    {
        this._precalculatedSamples.clear();
        for (let c = 0; c < this._transitionKeyframes.length - 1; c++) {
            var a = this._transitionKeyframes[c];
            if (!a.GetStartEnable())
                continue;
            var b = this._transitionKeyframes[c + 1];
            if (!b.GetEndEnable())
                continue;
            const d = a.GetValueX(),
                e = a.GetValueX() + a.GetStartAnchorX(),
                f = b.GetValueX() + b.GetEndAnchorX();
            b = b.GetValueX();
            this._precalculatedSamples.set(a, Ease$jscomp$2.GetBezierSamples(d, e, f, b))
        }
    }
}
;
"use strict";
const C3$jscomp$142 = self.C3;
C3$jscomp$142.TransitionKeyframe = class  extends C3$jscomp$142.DefendedBase{
    constructor(a, b)
    {
        super();
        this._transition = a;
        this._valueX = b[0];
        this._valueY = b[1];
        this._startAnchorX = b[2];
        this._startAnchorY = b[3];
        this._endAnchorX = b[4];
        this._endAnchorY = b[5];
        this._startEnable = b[6];
        this._endEnable = b[7];
        this._segmentMode = b[8];
        this._prev = this._next = null
    }
    Release()
    {
        this._transition = null
    }
    static Create(a, b)
    {
        return C3$jscomp$142.New(C3$jscomp$142.TransitionKeyframe, a, b)
    }
    SetNext(a)
    {
        this._next = a
    }
    GetNext()
    {
        return this._next
    }
    SetPrevious(a)
    {
        this._prev =
        a
    }
    GetPrevious()
    {
        return this._prev
    }
    GetValueX()
    {
        return this._valueX
    }
    GetValueY()
    {
        return this._valueY
    }
    GetStartAnchorX()
    {
        return this._startAnchorX
    }
    GetStartAnchorY()
    {
        return this._startAnchorY
    }
    GetEndAnchorX()
    {
        return this._endAnchorX
    }
    GetEndAnchorY()
    {
        return this._endAnchorY
    }
    GetStartEnable()
    {
        return this._startEnable
    }
    GetEndEnable()
    {
        return this._endEnable
    }
    IsSegmentLinear()
    {
        return "linear" === this._segmentMode
    }
    IsSegmentCubic()
    {
        return "cubic" === this._segmentMode
    }
}
;
"use strict";
const C3$jscomp$143 = self.C3;
C3$jscomp$143.TransitionManager = class  extends C3$jscomp$143.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a;
        this._transitions = []
    }
    Release()
    {
        for (const a of this._transitions)
            a.Release();
        C3$jscomp$143.clearArray(this._transitions);
        this._transitions = null
    }
    Create(a)
    {
        this._transitions.push(C3$jscomp$143.Transition.Create(a))
    }
}
;
"use strict";
const C3$jscomp$144 = self.C3;
C3$jscomp$144.TemplateManager = class  extends C3$jscomp$144.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a;
        this._instanceToTemplateNameMap = this._templateDataMap = null;
        this._instanceDestroy = b => this._OnInstanceDestroy(b.instance)
    }
    Release()
    {
        this.RemoveRuntimeListeners();
        if (this._templateDataMap) {
            for (const a of this._templateDataMap.values())
                a.clear();
            this._templateDataMap.clear()
        }
        this._runtime = this._templateDataMap = null
    }
    Create(a)
    {
        this._templateDataMap || (this._templateDataMap = new Map);
        if (a) {
            var b = a[0][16][0],
                c = a[1];
            this._templateDataMap.has(c) || this._templateDataMap.set(c, new Map);
            this._templateDataMap.get(c).set(b, a)
        }
    }
    AddRuntimeListeners()
    {
        const a = this._runtime.Dispatcher();
        a && a.addEventListener("instancedestroy", this._instanceDestroy)
    }
    RemoveRuntimeListeners()
    {
        const a = this._runtime.Dispatcher();
        a && a.removeEventListener("instancedestroy", this._instanceDestroy)
    }
    HasTemplates()
    {
        return this._templateDataMap ? 0 !== this._templateDataMap.size : !1
    }
    GetTemplateData(a, b)
    {
        a = a instanceof C3$jscomp$144.ObjectClass ? a.GetIndex() :
        a;
        if (this._templateDataMap.has(a) && (b = this._templateDataMap.get(a).get(b)))
            return JSON.parse(JSON.stringify(b))
    }
    MapInstanceToTemplateName(a, b)
    {
        this._instanceToTemplateNameMap || (this._instanceToTemplateNameMap = new WeakMap);
        this._instanceToTemplateNameMap.has(a) || this._instanceToTemplateNameMap.set(a, b)
    }
    GetInstanceTemplateName(a)
    {
        return this._instanceToTemplateNameMap ? (a = this._instanceToTemplateNameMap.get(a)) ? a : "" : ""
    }
    _OnInstanceDestroy(a)
    {
        this._instanceToTemplateNameMap && this._instanceToTemplateNameMap.has(a) &&
        this._instanceToTemplateNameMap.delete(a)
    }
}
;
"use strict";
const C3$jscomp$145 = self.C3;
C3$jscomp$145.FlowchartManager = class {
    constructor(a)
    {
        this._runtime = a;
        this._flowchartDataManager = new C3$jscomp$145.FlowchartDataManager
    }
    Release()
    {
        this._flowchartDataManager.Release();
        this._runtime = this._flowchartDataManager = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    Create(a)
    {
        this._flowchartDataManager.Add(a)
    }
    GetFlowchartDataItemByName(a)
    {
        return this._flowchartDataManager.Get(a)
    }
    HasFlowcharts()
    {
        return this._flowchartDataManager.HasFlowcharts()
    }
}
;
"use strict";
const C3$jscomp$146 = self.C3;
C3$jscomp$146.FlowchartState = class {
    constructor(a, b, c, d, e, f, g)
    {
        this._runtime = e.GetRuntime();
        this._flowchartManager = e;
        this._flowchartName = a;
        this._startNodeTag = c;
        this._flowchartDataItem = d;
        this._tag = b;
        this._pluginInstance = f;
        this._pluginUID = g ?? f.GetInstance().GetUID();
        this._SetStartFlowchartNode();
        this._currentFlowchartNodeId = this._startFlowchartNode?.GetFlowchartId() ?? -1;
        this._previousFlowchartNodeIds = [];
        this._previousFlowchartState = null;
        this._previousFlowchartStateStartNodeId = NaN;
        this._rootFlowchartState =
        this._currentReferenceFlowchartState = this._referenceFlowchartStates = null;
        this._previousFlowchartStateTag = "";
        this._referenceFlowchartStatesJson = null;
        this._rootFlowchartStateTag = this._currentReferenceFlowchartStateTag = "";
        this._triggerCount = 0;
        this._released = this._markForRelease = !1
    }
    Release()
    {
        this._released || (C3$jscomp$146.clearArray(this._previousFlowchartNodeIds), this._previousFlowchartState = this._pluginInstance = this._flowchartDataItem = this._flowchartManager = this._runtime = this._previousFlowchartNodeIds =
        null, this._previousFlowchartStateStartNodeId = NaN, this._referenceFlowchartStates && this._referenceFlowchartStates.clear(), this._rootFlowchartState = this._currentReferenceFlowchartState = this._referenceFlowchartStates = null, this._previousFlowchartStateTag = "", this._referenceFlowchartStatesJson = null, this._rootFlowchartStateTag = this._currentReferenceFlowchartStateTag = "", this._released = !0)
    }
    WasReleased()
    {
        return this._released
    }
    GetFlowchartManager()
    {
        return this._flowchartManager
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetName()
    {
        return this._flowchartName
    }
    GetFlowchartDataItem()
    {
        return this._flowchartDataItem
    }
    GetTag()
    {
        return this._tag
    }
    GetPluginInstance()
    {
        this._pluginInstance ||
        (this._pluginInstance = this._runtime.GetInstanceByUID(this._pluginUID).GetSdkInstance());
        return this._pluginInstance
    }
    GetCurrentNode()
    {
        return this.GetFlowchartElementById(this._currentFlowchartNodeId)
    }
    GetCurrentNodeTag()
    {
        const a = this.GetCurrentNode();
        return a ? a.GetTag() : ""
    }
    GetCurrentNodeParent(a)
    {
        var b = this.GetCurrentNode();
        if (b) {
            if (C3$jscomp$146.IsFiniteNumber(a)) {
                var c = b.GetParentFlowchartIds();
                c = c ? c[a] : void 0;
                if (C3$jscomp$146.IsFiniteNumber(c))
                    return this.GetFlowchartElementById(c)
            }
            if ("string" ===
            typeof a)
                for (const d of b.GetParentFlowchartIds())
                    if (b = this.GetFlowchartElementById(d), b.GetTag() === a)
                        return this.GetFlowchartElementById(b.GetFlowchartId())
        }
    }
    GetCurrentNodeParentTag(a)
    {
        return (a = this.GetCurrentNodeParent(a)) ? a.GetTag() : ""
    }
    GetCurrentNodeParentIndex(a)
    {
        a = this.GetCurrentNodeParent(a);
        if (!a)
            return -1;
        const b = a.GetParentFlowchartIds();
        return b ? b.indexOf(a.GetFlowchartId()) : -1
    }
    GetCurrentNodeParentCount()
    {
        var a = this.GetCurrentNode();
        return a ? (a = a.GetParentFlowchartIds()) ? a.length : 0 : 0
    }
    GetFlowchartElementById(a)
    {
        return this._flowchartDataItem.GetFlowchartElementById(a)
    }
    Reset()
    {
        this._GetRootFlowchartState()._Reset(!0)
    }
    _Reset(a)
    {
        if (this._GetReferenceFlowchartStates()) {
            for (const [,
            b] of this._GetReferenceFlowchartStates().entries())
                b._Reset(!1);
            this._GetReferenceFlowchartStates().clear()
        }
        this._currentReferenceFlowchartState = this._previousFlowchartStateStartNode = this._previousFlowchartState = this._referenceFlowchartStates = null;
        this._previousFlowchartStateTag = "";
        this._referenceFlowchartStatesJson = null;
        this._rootFlowchartStateTag = this._currentReferenceFlowchartStateTag = "";
        this._previousFlowchartNodeIds = [];
        a ? (this._flowchartManager.SetCurrentFlowchartState(this), a = this._startFlowchartNode.GetFlowchartId(),
        a !== this._currentFlowchartNodeId && this._GotoFlowchartNode(a)) : this._currentFlowchartNodeId = this._startFlowchartNode.GetFlowchartId()
    }
    GetCurrentNodeOutputCount()
    {
        const a = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
        return a ? a.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemCount() : 0
    }
    GetCurrentNodeOutputNameAt(a)
    {
        return (a = this._GetFlowchartNodeOutputAt(a)) ? a.GetName() : ""
    }
    GetCurrentNodeOutputValueAt(a)
    {
        let b;
        C3$jscomp$146.IsFiniteNumber(a) && (b = this._GetFlowchartNodeOutputAt(a));
        "string" === typeof a && (b = this._GetFlowchartNodeOutputByName(a));
        "number" !== typeof a && "string" !== typeof a && console.warn("[Flowcharts] unexpected argument type in GetCurrentNodeOutputValueAt expression");
        return b ? b.GetValue() : ""
    }
    GotoNextFlowchartNode(a)
    {
        let b;
        C3$jscomp$146.IsFiniteNumber(a) && (b = this._GetFlowchartNodeOutputAt(a));
        "string" === typeof a && (b = this._GetFlowchartNodeOutputByName(a));
        a = b.GetConnectedFlowchartNodeFlowchartId();
        C3$jscomp$146.IsFiniteNumber(a) && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId),
        this._GotoFlowchartNode(a))
    }
    GotoAnyFlowchartNode(a)
    {
        if (a = this._flowchartDataItem.GetFlowchartNodeByTag(a))
            if (a = this._flowchartDataItem.GetFlowchartElementById(a.GetFlowchartId()))
                this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId),
                this._GotoFlowchartNode(a.GetFlowchartId())
    }
    GotoPreviousFlowchartNode()
    {
        const a = this._previousFlowchartNodeIds.pop();
        C3$jscomp$146.IsFiniteNumber(a) ? this._GotoFlowchartNode(a) : this._GetPreviousFlowchartState() && (this._flowchartManager.SetCurrentFlowchartState(this._GetPreviousFlowchartState(),
        !0, !1, !1), this._GetPreviousFlowchartState()._GotoFlowchartNode(this._GetPreviousFlowchartStateStartNodeId()), this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(this._GetPreviousFlowchartState()))
    }
    GotoParentFlowchartNode(a)
    {
        const b = this.GetCurrentNode();
        b && (b.GetFlowchartId(), a = this.GetCurrentNodeParent(a)) && (this._previousFlowchartNodeIds.push(this._currentFlowchartNodeId), this._GotoFlowchartNode(a.GetFlowchartId()))
    }
    HasOutput(a)
    {
        if (C3$jscomp$146.IsFiniteNumber(a))
            return !!this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems()[a];
        if ("string" === typeof a) {
            const b = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId).GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
            for (let c = 0; c < b.length; c++)
                if (b[c].GetName() === a)
                    return !0
        }
        return !1
    }
    MarkForRelease()
    {
        this._markForRelease = !0
    }
    IsInTriggerState()
    {
        return 0 < this._triggerCount
    }
    PushIsTriggerState()
    {
        this._triggerCount++
    }
    PopIsTriggerState()
    {
        this._triggerCount--;
        0 === this._triggerCount && this._markForRelease && this._flowchartManager.RemoveFlowchartState(this)
    }
    _GotoFlowchartNode(a)
    {
        var b =
            this._currentFlowchartNodeId,
            c = this.GetPluginInstance().GetInstance();
        this.PushIsTriggerState();
        this._flowchartManager.PushFlowchartState(this);
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChange, c);
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChange, c);
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnBeforeAnyNodeChangeInFlowchart, c);
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnBeforeTaggedNodeChangeInFlowchart,
        c);
        this._currentFlowchartNodeId = a;
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnAnyNodeChange, c);
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnTaggedNodeChange, c);
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnAnyNodeChangeInFlowchart, c);
        this._runtime.Trigger(C3$jscomp$146.Plugins.Flowchart.Cnds.OnTaggedNodeChangeInFlowchart, c);
        this._flowchartManager.PopFlowchartState();
        this.PopIsTriggerState();
        if (!this.WasReleased() && (a = this.GetFlowchartElementById(this._currentFlowchartNodeId),
        "reference" === a.GetType()))
            if (c = a.GetReferenceFlowchartName(), this._HasReferenceFlowchartState(a))
                this._previousFlowchartNodeIds.pop(),
                a = this._GetReferenceFlowchartState(a),
                this._flowchartManager.SetCurrentFlowchartState(a, !0, !0, !1),
                a._SetPreviousFlowchart(this, b),
                this._GetRootFlowchartState()._SetCurrentReferenceFlowchart(a);
            else {
                const e = a.GetReferenceFlowchartStartNodeTag();
                if (c) {
                    this._previousFlowchartNodeIds.pop();
                    let f = a.GetReferenceFlowchartTag();
                    if (f)
                        for (var d = this._flowchartManager.GetFlowchartState(f); d;)
                            f =
                            C3$jscomp$146.IncrementNumberAtEndOf(f),
                            d = this._flowchartManager.GetFlowchartState(f);
                    else
                        for (f = `${c}-ref`, d = this._flowchartManager.GetFlowchartState(f); d;)
                            f = C3$jscomp$146.IncrementNumberAtEndOf(f),
                            d = this._flowchartManager.GetFlowchartState(f);
                    c = this._flowchartManager.AddFlowchartState(c, e, f, this._pluginInstance, !0);
                    c._SetPreviousFlowchart(this, b);
                    this._SetReferenceFlowchartState(a, c);
                    b = this._GetRootFlowchartState();
                    c._SetRootFlowchartState(b);
                    b._SetCurrentReferenceFlowchart(c)
                }
            }
    }
    _GetFlowchartNodeOutputAt(a)
    {
        var b =
        this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
        if (!b)
            return null;
        b = b.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItems();
        return b ? (a = b[a]) ? a : null : null
    }
    _GetFlowchartNodeOutputByName(a)
    {
        const b = this._flowchartDataItem.GetFlowchartElementById(this._currentFlowchartNodeId);
        return b ? (a = b.GetFlowchartNodeOutputData().GetFlowchartNodeOutputDataItemByName(a)) ? a : null : null
    }
    _SetStartFlowchartNode(a)
    {
        "number" === typeof a ? ((a = this.GetFlowchartElementById(a)) || (a = this._flowchartDataItem.GetFlowchartStartNode()),
        this._startFlowchartNode = a) : ((a = this._flowchartDataItem.GetFlowchartNodeByTag(this._startNodeTag)) || (a = this._flowchartDataItem.GetFlowchartStartNode()), this._startFlowchartNode = a)
    }
    _SaveToJson()
    {
        return this._markForRelease ? null : {
            flowchartName: this._flowchartName,
            flowchartTag: this._tag,
            startNodeTag: this._startNodeTag,
            currentNodeId: this._currentFlowchartNodeId,
            previousNodeIds: this._previousFlowchartNodeIds,
            pluginUID: this._pluginInstance.GetInstance().GetUID(),
            reference: {
                previousFlowchartTag: this._GetPreviousFlowchartState() ?
                this._GetPreviousFlowchartState().GetTag() : "",
                previousStartNodeId: C3$jscomp$146.IsFiniteNumber(this._GetPreviousFlowchartStateStartNodeId()) ? this._GetPreviousFlowchartStateStartNodeId() : NaN,
                referencesJson: this._GetFlowchartReferencesJson(),
                currentReferenceFlowchartTag: this.GetCurrentReferenceFlowchart() ? this.GetCurrentReferenceFlowchart().GetTag() : "",
                rootFlowchartTag: this._GetRootFlowchartState() ? this._GetRootFlowchartState().GetTag() : ""
            }
        }
    }
    _GetFlowchartReferencesJson()
    {
        if (!this._HasReferenceFlowchartStates())
            return null;
        const a = [];
        for (const [b, c] of this._GetReferenceFlowchartStates().entries())
            a.push({
                flowchartElementId: b.GetFlowchartId(),
                flowchartStateTag: c.GetTag()
            });
        return a.length ? a : null
    }
    _LoadFromJson(a)
    {
        a && (this._flowchartName = a.flowchartName, this._tag = a.flowchartTag, this._startNodeTag = a.startNodeTag, this._currentFlowchartNodeId = a.currentNodeId, this._previousFlowchartNodeIds = a.previousNodeIds, this._pluginUID = a.pluginUID, a.hasOwnProperty("reference") && (a = a.reference, this._previousFlowchartStateTag = a.previousFlowchartTag,
        this._previousFlowchartStateStartNodeId = a.previousStartNodeId, this._referenceFlowchartStatesJson = a.referencesJson, this._currentReferenceFlowchartStateTag = a.currentReferenceFlowchartTag, this._rootFlowchartStateTag = a.rootFlowchartTag), this._SetStartFlowchartNode())
    }
    _GetPreviousFlowchartState()
    {
        "string" === typeof this._previousFlowchartStateTag && this._previousFlowchartStateTag && (this._previousFlowchartState = this._flowchartManager.GetFlowchartState(this._previousFlowchartStateTag), this._previousFlowchartStateTag =
        "");
        return this._previousFlowchartState
    }
    _GetPreviousFlowchartStateStartNodeId()
    {
        return this._previousFlowchartStateStartNodeId
    }
    _SetPreviousFlowchart(a, b)
    {
        this._previousFlowchartState = a;
        this._previousFlowchartStateStartNodeId = b
    }
    GetCurrentReferenceFlowchart()
    {
        "string" === typeof this._currentReferenceFlowchartStateTag && this._currentReferenceFlowchartStateTag && (this._currentReferenceFlowchartState = this._flowchartManager.GetFlowchartState(this._currentReferenceFlowchartStateTag), this._currentReferenceFlowchartStateTag =
        "");
        return this._currentReferenceFlowchartState
    }
    _SetCurrentReferenceFlowchart(a)
    {
        this._currentReferenceFlowchartState = a;
        this._currentReferenceFlowchartState === this && (this._currentReferenceFlowchartState = null)
    }
    _GetRootFlowchartState()
    {
        "string" === typeof this._rootFlowchartStateTag && this._rootFlowchartStateTag && (this._rootFlowchartState = this._flowchartManager.GetFlowchartState(this._rootFlowchartStateTag), this._rootFlowchartStateTag = "");
        return this._rootFlowchartState ? this._rootFlowchartState : this
    }
    _SetRootFlowchartState(a)
    {
        this._rootFlowchartState =
        a
    }
    _HasReferenceFlowchartStates()
    {
        this._RebuildReferenceFlowchartStates();
        return !!this._referenceFlowchartStates
    }
    _HasReferenceFlowchartState(a)
    {
        this._RebuildReferenceFlowchartStates();
        return this._referenceFlowchartStates && this._referenceFlowchartStates.has(a)
    }
    _RebuildReferenceFlowchartStates()
    {
        if (this._referenceFlowchartStatesJson) {
            this._referenceFlowchartStates && this._referenceFlowchartStates.clear();
            this._referenceFlowchartStates || (this._referenceFlowchartStates = new Map);
            for (const a of this._referenceFlowchartStatesJson) {
                const b =
                    this._flowchartManager.GetFlowchartState(a.flowchartStateTag),
                    c = b.GetFlowchartElementById(a.flowchartElementId);
                this._referenceFlowchartStates.set(c, b)
            }
            this._referenceFlowchartStatesJson = null
        }
    }
    _GetReferenceFlowchartStates()
    {
        this._RebuildReferenceFlowchartStates();
        return this._referenceFlowchartStates
    }
    _GetReferenceFlowchartState(a)
    {
        this._RebuildReferenceFlowchartStates();
        return this._referenceFlowchartStates.get(a)
    }
    _SetReferenceFlowchartState(a, b)
    {
        this._referenceFlowchartStates || (this._referenceFlowchartStates =
        new Map);
        this._referenceFlowchartStates.set(a, b)
    }
}
;
"use strict";
const C3$jscomp$147 = self.C3;
C3$jscomp$147.FlowchartStateManager = class {
    constructor(a)
    {
        this._runtime = a;
        this._flowchartStates = new Map;
        this._currentFlowchartState = null;
        this._flowchartStateStack = [];
        this._on_after_load = () => this._OnAfterLoad();
        this._loadJson = null
    }
    Release()
    {
        C3$jscomp$147.clearArray(this._flowchartStateStack);
        this._flowchartStateStack = null;
        this._flowchartStates.clear();
        this._loadJson = this._runtime = this._currentFlowchartState = this._flowchartStates = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    AddFlowchartState(a, b, c, d, e, f)
    {
        const g =
        this._runtime.GetFlowchartManager().GetFlowchartDataItemByName(a);
        if (g)
            if (this._flowchartStates.has(c))
                console.warn(`[Flowcharts] there already is a flowchart with the tag '${c}'`);
            else
                return a = new C3$jscomp$147.FlowchartState(a, c, b, g, this, d, f), this._flowchartStates.set(c, a), e && this.SetCurrentFlowchartState(a, !0), a;
        else
            console.warn(`[Flowcharts] no flowchart found with name '${a}'`)
    }
    RemoveFlowchartState(a)
    {
        a.MarkForRelease();
        if (!a.IsInTriggerState()) {
            var b = a.GetTag();
            this._flowchartStates.delete(b);
            a.Release();
            this._currentFlowchartState === a && (this._currentFlowchartState = null)
        }
    }
    ResetFlowchartState(a)
    {
        a.Reset()
    }
    GetFlowchartState(a)
    {
        return this._flowchartStates.get(a)
    }
    PushFlowchartState(a)
    {
        this._flowchartStateStack.push(a)
    }
    PopFlowchartState()
    {
        this._flowchartStateStack.pop()
    }
    SetCurrentFlowchartState(a, b=!1, c=!1, d=!0)
    {
        d && (a = (d = a.GetCurrentReferenceFlowchart()) ? d : a);
        a !== this._currentFlowchartState && (this._TriggerBeforeFlowchartChange(), this._TriggerAfterFlowchartChange(a, b, c))
    }
    GetCurrentFlowchartState(a)
    {
        return "string" ===
        typeof a ? this.GetFlowchartState(a) : this._flowchartStateStack.length ? this._flowchartStateStack[this._flowchartStateStack.length - 1] : this._currentFlowchartState
    }
    _TriggerBeforeFlowchartChange()
    {
        if (this._currentFlowchartState && !this._currentFlowchartState.WasReleased()) {
            var a = this._currentFlowchartState.GetPluginInstance().GetInstance();
            this._currentFlowchartState.PushIsTriggerState();
            this.PushFlowchartState(this._currentFlowchartState);
            this._runtime.Trigger(C3$jscomp$147.Plugins.Flowchart.Cnds.OnBeforeFlowchartChange,
            a);
            this.PopFlowchartState();
            this._currentFlowchartState.PopIsTriggerState()
        }
    }
    _TriggerAfterFlowchartChange(a, b=!1, c=!1)
    {
        (this._currentFlowchartState = a) && !this._currentFlowchartState.WasReleased() && (a = this._currentFlowchartState.GetPluginInstance().GetInstance(), this._currentFlowchartState.PushIsTriggerState(), this.PushFlowchartState(this._currentFlowchartState), this._runtime.Trigger(C3$jscomp$147.Plugins.Flowchart.Cnds.OnFlowchartChange, a), !0 !== c && "number" !== typeof c || this._currentFlowchartState._SetStartFlowchartNode(c),
        b && (this._runtime.Trigger(C3$jscomp$147.Plugins.Flowchart.Cnds.OnAnyNodeChange, a), this._runtime.Trigger(C3$jscomp$147.Plugins.Flowchart.Cnds.OnTaggedNodeChange, a)), this.PopFlowchartState(), this._currentFlowchartState.PopIsTriggerState())
    }
    _SaveToJson()
    {
        return {
            flowchartJsonObjects: [...this._flowchartStates.values()].map(a => a._SaveToJson()),
            currentFlowchartTag: this._currentFlowchartState ? this._currentFlowchartState.GetTag() : null
        }
    }
    _LoadFromJson(a)
    {
        if (a) {
            this._loadJson = a;
            a = new Map;
            for (const c of this._loadJson.flowchartJsonObjects) {
                var b =
                c.flowchartTag;
                if (this._flowchartStates.has(b)) {
                    const d = this._flowchartStates.get(b);
                    d._LoadFromJson(c);
                    a.set(b, d)
                } else
                    b = this.AddFlowchartState(c.flowchartName, c.startNodeTag, c.flowchartTag, null, !1, c.pluginUID),
                    b._LoadFromJson(c),
                    a.set(c.flowchartTag, b)
            }
            for (const [c, d] of this._flowchartStates.entries())
                a.has(c) || d.Release();
            this._flowchartStates.clear();
            this._flowchartStates = a;
            this._runtime.IsLoadingState() ? this._runtime.Dispatcher().addEventListener("afterload", this._on_after_load) : this._OnAfterLoad()
        }
    }
    _OnAfterLoad()
    {
        this._runtime.Dispatcher().removeEventListener("afterload",
        this._on_after_load);
        const a = this._flowchartStates.get(this._loadJson.currentFlowchartTag);
        a && this.SetCurrentFlowchartState(a, !0);
        this._loadJson = null
    }
}
;
"use strict";
const C3$jscomp$148 = self.C3;
C3$jscomp$148.FlowchartDataManager = class {
    constructor()
    {
        this._flowchartDataItems = new Map
    }
    Release()
    {
        for (const a of this._flowchartDataItems.values())
            a.Release();
        this._flowchartDataItems.clear();
        this._flowchartDataItems = null
    }
    Add(a)
    {
        a = new C3$jscomp$148.FlowchartDataItem(a);
        const b = a.GetName();
        this._flowchartDataItems.set(b, a)
    }
    Get(a)
    {
        return this._flowchartDataItems.get(a)
    }
    HasFlowcharts()
    {
        return !!this._flowchartDataItems.size
    }
    static CreateDataItems(a, b, c, d)
    {
        if (b)
            for (const e of b)
                b = new c(e, d),
                a.push(b)
    }
}
;
"use strict";
const C3$jscomp$149 = self.C3;
C3$jscomp$149.FlowchartDataItem = class {
    constructor(a)
    {
        this._name = a[0];
        this._flowchartNodeData = new C3$jscomp$149.FlowchartNodeData(a[1], this)
    }
    Release()
    {
        this._flowchartNodeData.Release();
        this._flowchartNodeData = null
    }
    GetFlowchartNodeData()
    {
        return this._flowchartNodeData
    }
    GetFlowchartElementById(a)
    {
        return this._flowchartNodeData.GetFlowchartElementById(a)
    }
    GetFlowchartNodeByTag(a)
    {
        return this._flowchartNodeData.GetFlowchartNodeByTag(a)
    }
    GetFlowchartStartNode()
    {
        return this._flowchartNodeData.GetFlowchartStartNode()
    }
    GetName()
    {
        return this._name
    }
}
;
"use strict";
const C3$jscomp$150 = self.C3;
class FlowchartNodeDataItem {
    constructor(a, b)
    {
        this._flowchartNodeData = b;
        this._type = a[7];
        this._flowchartId = a[0];
        this._tag = a[1];
        this._parentFlowchartIds = a[2];
        this._childrenFlowchartIds = this._parentOutputFlowchartIds = null;
        "dictionary" === this._type && (this._parentOutputFlowchartIds = a[3], this._childrenFlowchartIds = a[4]);
        this._isStart = a[6];
        this._referenceFlowchartTag = this._referenceFlowchartStartNodeTag = this._referenceFlowchartName = null;
        "reference" === this._type && (this._referenceFlowchartName = a[8], this._referenceFlowchartStartNodeTag =
        a[9], this._referenceFlowchartTag = a[10]);
        this._flowchartNodeOutputData = new C3$jscomp$150.FlowchartNodeOutputData(a[5], this)
    }
    Release()
    {
        this._flowchartNodeData = null
    }
    GetFlowchartNodeData()
    {
        return this._flowchartNodeData
    }
    GetFlowchartNodeOutputData()
    {
        return this._flowchartNodeOutputData
    }
    GetFlowchartId()
    {
        return this._flowchartId
    }
    GetTag()
    {
        return this._tag
    }
    GetIsStart()
    {
        return this._isStart
    }
    GetParentFlowchartIds()
    {
        return this._parentFlowchartIds
    }
    GetParentOutputFlowchartIds()
    {
        return this._parentOutputFlowchartIds
    }
    GetChildrenFlowchartIds()
    {
        return this._childrenFlowchartIds
    }
    GetType()
    {
        return this._type
    }
    GetReferenceFlowchartName()
    {
        return this._referenceFlowchartName
    }
    GetReferenceFlowchartStartNodeTag()
    {
        return this._referenceFlowchartStartNodeTag
    }
    GetReferenceFlowchartTag()
    {
        return this._referenceFlowchartTag
    }
}
C3$jscomp$150.FlowchartNodeData = class {
    constructor(a, b)
    {
        this._flowchartDataItem = b;
        this._flowchartNodeItems = [];
        this._flowchartNodeItemsIdMap = new Map;
        this._flowchartNodeItemsTagMap = new Map;
        this._flowchartNodeStartItem = null;
        C3$jscomp$150.FlowchartDataManager.CreateDataItems(this._flowchartNodeItems, a, FlowchartNodeDataItem, this);
        for (const c of this._flowchartNodeItems) {
            a = c.GetFlowchartId();
            b = c.GetTag();
            const d = c.GetIsStart();
            this._flowchartNodeItemsIdMap.set(a, c);
            b && this._flowchartNodeItemsTagMap.set(b,
            c);
            d && (this._flowchartNodeStartItem = c);
            a = c.GetFlowchartNodeOutputData();
            for (const e of a.flowchartNodeOutputDataItems())
                a = e.GetFlowchartId(),
                this._flowchartNodeItemsIdMap.set(a, e)
        }
    }
    Release()
    {
        this._flowchartDataItem = null;
        for (const a of this._flowchartNodeItems)
            a.Release();
        C3$jscomp$150.clearArray(this._flowchartNodeItems);
        this._flowchartNodeItems = null
    }
    GetFlowchartDataItem()
    {
        return this._flowchartDataItem
    }
    GetFlowchartElementById(a)
    {
        return this._flowchartNodeItemsIdMap.get(a)
    }
    GetFlowchartNodeByTag(a)
    {
        return this._flowchartNodeItemsTagMap.get(a)
    }
    GetFlowchartStartNode()
    {
        return this._flowchartNodeStartItem
    }
    *flowchartNodeDataItems()
    {
        for (const a of this._flowchartNodeItems)
            yield a
    }
}
;
"use strict";
const C3$jscomp$151 = self.C3;
class FlowchartNodeDataOutputItem {
    constructor(a, b)
    {
        this._flowchartNodeOutputData = b;
        this._flowchartId = a[0];
        this._name = a[1];
        this._value = a[2];
        this._connectedFlowchartNodeFlowchartId = a[3]
    }
    Release()
    {
        this._flowchartNodeOutputData = null
    }
    GetFlowchartNodeOutputData()
    {
        return this._flowchartNodeOutputData
    }
    GetFlowchartId()
    {
        return this._flowchartId
    }
    GetName()
    {
        return this._name
    }
    GetValue()
    {
        return this._value
    }
    GetConnectedFlowchartNodeFlowchartId()
    {
        return this._connectedFlowchartNodeFlowchartId
    }
}
C3$jscomp$151.FlowchartNodeOutputData = class {
    constructor(a, b)
    {
        this._flowchartDataNodeItem = b;
        this._flowchartNodeOutputItems = [];
        this._flowchartNodeOutputItemsNameMap = new Map;
        C3$jscomp$151.FlowchartDataManager.CreateDataItems(this._flowchartNodeOutputItems, a, FlowchartNodeDataOutputItem, this);
        for (const c of this._flowchartNodeOutputItems)
            this._flowchartNodeOutputItemsNameMap.set(c.GetName(), c)
    }
    Release()
    {
        this._flowchartDataNodeItem = null;
        for (const a of this._flowchartNodeOutputItems)
            a.Release();
        C3$jscomp$151.clearArray(this._flowchartNodeOutputItems);
        this._flowchartNodeOutputItems = null
    }
    GetFlowchartNodeDataItem()
    {
        return this._flowchartDataNodeItem
    }
    GetFlowchartNodeOutputDataItemCount()
    {
        return this._flowchartNodeOutputItems.length
    }
    GetFlowchartNodeOutputDataItems()
    {
        return this._flowchartNodeOutputItems
    }
    GetFlowchartNodeOutputDataItemByName(a)
    {
        return this._flowchartNodeOutputItemsNameMap.get(a)
    }
    *flowchartNodeOutputDataItems()
    {
        for (const a of this._flowchartNodeOutputItems)
            yield a
    }
}
;
"use strict";
const C3$jscomp$152 = self.C3;
C3$jscomp$152.SolStack = class  extends C3$jscomp$152.DefendedBase{
    constructor(a)
    {
        super();
        this._objectClass = a;
        this._stack = [];
        this._stack.push(C3$jscomp$152.New(C3$jscomp$152.Sol, this));
        this._index = 0;
        this._current = this._stack[0]
    }
    Release()
    {
        for (const a of this._stack)
            a.Release();
        C3$jscomp$152.clearArray(this._stack);
        this._objectClass = this._current = null
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetCurrentSol()
    {
        return this._current
    }
    GetOneBelowCurrentSol()
    {
        return this._stack[this._index - 1]
    }
    Clear()
    {
        this.GetCurrentSol().Clear()
    }
    PushClean()
    {
        var a =
            this._stack,
            b = ++this._index;
        b === a.length ? (b = C3$jscomp$152.New(C3$jscomp$152.Sol, this), a.push(b), this._current = b) : (a = a[b], a.Reset(), this._current = a)
    }
    PushCopy()
    {
        const a = this._stack,
            b = ++this._index;
        b === a.length && a.push(C3$jscomp$152.New(C3$jscomp$152.Sol, this));
        const c = a[b];
        c.Copy(a[b - 1]);
        this._current = c
    }
    Pop()
    {
        this._current = this._stack[--this._index]
    }
    RemoveInstances(a)
    {
        const b = this._stack;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].RemoveInstances(a)
    }
}
;
"use strict";
const C3$jscomp$153 = self.C3;
C3$jscomp$153.Sol = class  extends C3$jscomp$153.DefendedBase{
    constructor(a)
    {
        super();
        this._stack = a;
        this._objectClass = this._stack.GetObjectClass();
        this._eventStack = this._objectClass.GetRuntime().GetEventStack();
        this._selectAll = !0;
        this._instances = [];
        this._elseInstances = []
    }
    Release()
    {
        this.ClearArrays();
        this._eventStack = this._objectClass = this._stack = null
    }
    ClearArrays()
    {
        C3$jscomp$153.clearArray(this._instances);
        C3$jscomp$153.clearArray(this._elseInstances)
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    IsSelectAll()
    {
        return this._selectAll
    }
    HasAnyInstances()
    {
        return this._selectAll ?
        !!this._objectClass.GetInstanceCount() : !!this._instances.length
    }
    GetInstances()
    {
        return this._selectAll ? this._objectClass.GetInstances() : this._instances
    }
    HasAnyElseInstances()
    {
        return !!this._elseInstances.length
    }
    GetElseInstances()
    {
        return this._elseInstances
    }
    GetExpressionInstances()
    {
        const a = this.GetInstances();
        return a.length ? a : this._elseInstances
    }
    Reset()
    {
        this._selectAll = !0;
        C3$jscomp$153.clearArray(this._elseInstances)
    }
    Clear()
    {
        this._selectAll = !0
    }
    Copy(a)
    {
        a.IsSelectAll() ? this.Reset() : (this._selectAll = !1,
        C3$jscomp$153.shallowAssignArray(this._instances, a._instances), C3$jscomp$153.clearArray(this._elseInstances))
    }
    _PushInstance(a)
    {
        this._instances.push(a)
    }
    _PushElseInstance(a)
    {
        this._elseInstances.push(a)
    }
    _SetSelectAll(a)
    {
        this._selectAll = !!a
    }
    _GetOwnInstances()
    {
        return this._instances
    }
    _GetOwnElseInstances()
    {
        return this._elseInstances
    }
    SetSinglePicked(a)
    {
        this._selectAll = !1;
        C3$jscomp$153.clearArray(this._instances);
        this._instances.push(a)
    }
    SetArrayPicked(a)
    {
        this._selectAll = !1;
        C3$jscomp$153.shallowAssignArray(this._instances,
        a)
    }
    SetSetPicked(a)
    {
        this._selectAll = !1;
        C3$jscomp$153.clearArray(this._instances);
        for (const b of a)
            this._instances.push(b)
    }
    AddElseInstances(a, b)
    {
        for (const c of b)
            a.has(c) || this._elseInstances.push(c)
    }
    TransferElseInstancesToOwn(a)
    {
        for (const b of a)
            this._instances.push(b);
        C3$jscomp$153.arrayRemoveAllInSet(this._elseInstances, a)
    }
    ClearElseInstances()
    {
        C3$jscomp$153.clearArray(this._elseInstances)
    }
    PickOne(a)
    {
        a && (this._eventStack.GetCurrentStackFrame().GetCurrentEvent().IsOrBlock() ? (this.IsSelectAll() && (C3$jscomp$153.clearArray(this._instances),
        C3$jscomp$153.shallowAssignArray(this._elseInstances, a.GetObjectClass().GetInstances()), this._selectAll = !1), a = this._elseInstances.indexOf(a), -1 !== a && (this._instances.push(this._elseInstances[a]), this._elseInstances.splice(a, 1))) : this.SetSinglePicked(a))
    }
    RemoveInstances(a)
    {
        C3$jscomp$153.arrayRemoveAllInSet(this._instances, a);
        C3$jscomp$153.arrayRemoveAllInSet(this._elseInstances, a)
    }
}
;
"use strict";
const C3$jscomp$154 = self.C3;
C3$jscomp$154.EventStack = class  extends C3$jscomp$154.DefendedBase{
    constructor(a)
    {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._stack.push(C3$jscomp$154.New(C3$jscomp$154.EventStackFrame, this, null));
        this._index = 0;
        this._expFuncStack = []
    }
    Release()
    {
        for (const a of this._stack)
            a.Release();
        C3$jscomp$154.clearArray(this._stack);
        C3$jscomp$154.clearArray(this._expFuncStack);
        this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager()
    {
        return this._eventSheetManager
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetCurrentStackFrame()
    {
        return this._stack[this._index]
    }
    GetAllStackFrames()
    {
        return this._stack
    }
    GetCurrentStackFrameIndex()
    {
        return this._index
    }
    Push(a)
    {
        var b =
        this._stack;
        const c = ++this._index;
        if (c === b.length)
            return a = C3$jscomp$154.New(C3$jscomp$154.EventStackFrame, this, a), b.push(a), a;
        b = b[c];
        b.Reset(a);
        return b
    }
    Pop()
    {
        --this._index
    }
    PushExpFunc(a)
    {
        this._expFuncStack.push(a)
    }
    PopExpFunc()
    {
        this._expFuncStack.pop()
    }
    GetCurrentExpFuncStackFrame()
    {
        const a = this._expFuncStack;
        return 0 === a.length ? null : a.at(-1)
    }
}
;
"use strict";
const C3$jscomp$155 = self.C3;
C3$jscomp$155.EventStackFrame = class  extends C3$jscomp$155.DefendedBase{
    constructor(a, b)
    {
        super();
        this._stack = a;
        this._runtime = this._stack.GetRuntime();
        this._currentEvent = b;
        this._actIndex = this._cndIndex = 0;
        this._elseBranchRan = this._lastEventTrue = !1;
        this._expressionObjectClass = null;
        this._functionReturnValue = this._functionReturnType = 0;
        this._dynamicSolModifiers = null
    }
    Release()
    {
        this.Reset(null);
        this._runtime = this._stack = null
    }
    Reset(a)
    {
        this._currentEvent = a;
        this._actIndex = this._cndIndex = 0;
        this._elseBranchRan =
        this._lastEventTrue = !1;
        this._dynamicSolModifiers = null
    }
    _Restore(a, b)
    {
        this._currentEvent = a;
        this._cndIndex = 0;
        this._actIndex = b
    }
    ResetQuick()
    {
        this._actIndex = this._cndIndex = 0
    }
    GetCurrentEvent()
    {
        return this._currentEvent
    }
    SetCurrentEvent(a)
    {
        this._currentEvent = a
    }
    GetConditionIndex()
    {
        return this._cndIndex
    }
    SetConditionIndex(a)
    {
        this._cndIndex = a
    }
    GetActionIndex()
    {
        return this._actIndex
    }
    SetActionIndex(a)
    {
        this._actIndex = a
    }
    SetLastEventTrue(a)
    {
        this._lastEventTrue = !!a
    }
    GetLastEventTrue()
    {
        return this._lastEventTrue
    }
    SetElseBranchRan(a)
    {
        this._elseBranchRan =
        !!a
    }
    GetElseBranchRan()
    {
        return this._elseBranchRan
    }
    SetExpressionObjectClass(a)
    {
        this._expressionObjectClass = a
    }
    GetExpressionObjectClass()
    {
        return this._expressionObjectClass
    }
    InitCallFunctionExpression(a, b)
    {
        this._functionReturnType = a;
        this._functionReturnValue = b
    }
    GetFunctionReturnType()
    {
        return this._functionReturnType
    }
    SetFunctionReturnValue(a)
    {
        this._functionReturnValue = a
    }
    GetFunctionReturnValue()
    {
        return this._functionReturnValue
    }
    IsSolModifierAfterCnds()
    {
        const a = this._currentEvent;
        return a.IsSolWriterAfterCnds() ?
        !0 : this._cndIndex < a.GetConditionCount() - 1 ? !!a.GetSolModifiers().length : !1
    }
    SetDynamicSolModifiers(a)
    {
        this._dynamicSolModifiers = a
    }
    GetDynamicSolModifiers()
    {
        return this._dynamicSolModifiers
    }
}
;
"use strict";
const C3$jscomp$156 = self.C3;
C3$jscomp$156.LocalVarStack = class  extends C3$jscomp$156.DefendedBase{
    constructor(a)
    {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._index = -1;
        this._current = null;
        this._initialValues = []
    }
    Release()
    {
        C3$jscomp$156.clearArray(this._stack);
        this._runtime = this._eventSheetManager = null
    }
    _SetInitialValues(a)
    {
        this._initialValues = a;
        a = this._initialValues.slice(0);
        this._stack.push(a);
        this._index = 0;
        this._current = a
    }
    GetEventSheetManager()
    {
        return this._eventSheetManager
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetCurrent()
    {
        return this._current
    }
    Push()
    {
        const a =
            ++this._index,
            b = this._stack;
        a === b.length ? b.push(this._initialValues.slice(0)) : C3$jscomp$156.shallowAssignArray(b[a], this._initialValues);
        this._current = b[a]
    }
    Pop()
    {
        this._current = this._stack[--this._index]
    }
}
;
"use strict";
const C3$jscomp$157 = self.C3;
C3$jscomp$157.LoopStack = class  extends C3$jscomp$157.DefendedBase{
    constructor(a)
    {
        super();
        this._eventSheetManager = a;
        this._runtime = this._eventSheetManager.GetRuntime();
        this._stack = [];
        this._index = -1
    }
    Release()
    {
        C3$jscomp$157.clearArray(this._stack);
        this._runtime = this._eventSheetManager = null
    }
    GetEventSheetManager()
    {
        return this._eventSheetManager
    }
    GetRuntime()
    {
        return this._runtime
    }
    IsInLoop()
    {
        return 0 <= this._index
    }
    GetCurrent()
    {
        return this._stack[this._index]
    }
    Push()
    {
        ++this._index;
        if (this._index === this._stack.length) {
            var a =
            C3$jscomp$157.New(C3$jscomp$157.Loop, this);
            this._stack.push(a);
            return a
        }
        a = this._stack[this._index];
        a.Reset();
        return a
    }
    Pop()
    {
        --this._index
    }
    FindByName(a)
    {
        const b = this._stack;
        for (let c = this._index; 0 <= c; --c) {
            const d = b[c];
            if (d.GetName() === a)
                return d
        }
        return null
    }
    _GetStack()
    {
        return this._stack.slice(0, this._index + 1)
    }
}
;
"use strict";
const C3$jscomp$158 = self.C3;
C3$jscomp$158.Loop = class  extends C3$jscomp$158.DefendedBase{
    constructor(a)
    {
        super();
        this._loopStack = a;
        this._name = "";
        this._index = 0;
        this._isStopped = !1;
        this._end = NaN
    }
    Reset()
    {
        this._name = "";
        this._index = 0;
        this._isStopped = !1;
        this._end = NaN
    }
    SetName(a)
    {
        this._name = a
    }
    GetName()
    {
        return this._name
    }
    SetIndex(a)
    {
        this._index = a
    }
    GetIndex()
    {
        return this._index
    }
    Stop()
    {
        this._isStopped = !0
    }
    IsStopped()
    {
        return this._isStopped
    }
    SetEnd(a)
    {
        this._end = a
    }
    GetEnd()
    {
        return this._end
    }
}
;
"use strict";
const C3$jscomp$159 = self.C3;
C3$jscomp$159.ArrayStack = class  extends C3$jscomp$159.DefendedBase{
    constructor()
    {
        super();
        this._stack = [];
        this._index = -1
    }
    Release()
    {
        C3$jscomp$159.clearArray(this._stack)
    }
    GetCurrent()
    {
        return this._stack[this._index]
    }
    Push()
    {
        ++this._index;
        if (this._index === this._stack.length) {
            const a = [];
            this._stack.push(a);
            return a
        }
        return this._stack[this._index]
    }
    Pop()
    {
        --this._index
    }
}
;
"use strict";
const C3$jscomp$160 = self.C3;
function SortSolArray(a, b) {
    return a.GetIndex() - b.GetIndex()
}
function IsSolArrayIdentical(a, b) {
    for (let c = 0, d = a.length; c < d; ++c)
        if (a[c] !== b[c])
            return !1;
    return !0
}
C3$jscomp$160.EventSheetManager = class  extends C3$jscomp$160.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a;
        this._allSheets = [];
        this._sheetsByName = new Map;
        this._allGroups = [];
        this._groupsByName = new Map;
        this._blocksBySid = new Map;
        this._cndsBySid = new Map;
        this._actsBySid = new Map;
        this._allUniqueSolModifiers = new Map;
        this._eventVarsBySid = new Map;
        this._nextLocalVarIndex = 0;
        this._allGlobalVars = [];
        this._allLocalVars = [];
        this._localVarInitialValues = [];
        this._functionBlocksByName = new Map;
        this._customActionBlocksMap =
        new Map;
        this._eventStack = C3$jscomp$160.New(C3$jscomp$160.EventStack, this);
        this._localVarStack = C3$jscomp$160.New(C3$jscomp$160.LocalVarStack, this);
        this._loopStack = C3$jscomp$160.New(C3$jscomp$160.LoopStack, this);
        this._triggersToPostInit = [];
        this._queuedTriggers = [];
        this._queuedDebugTriggers = [];
        this._blockFlushingDepth = this._executingTriggerDepth = this._runningEventsDepth = 0;
        this._scheduledWaits = [];
        this._asyncActionPromises = [];
        this._signalTags = [];
        this._signalPromises = new Map;
        this._instSignals = new Map;
        self.c3_callFunction =
        (b, c) => this._InvokeFunctionFromJS(b, c)
    }
    Release()
    {
        this.ClearAllScheduledWaits();
        this._eventStack.Release();
        this._eventStack = null;
        this._localVarStack.Release();
        this._localVarStack = null;
        C3$jscomp$160.clearArray(this._queuedTriggers);
        C3$jscomp$160.clearArray(this._queuedDebugTriggers);
        this._runtime = null;
        C3$jscomp$160.clearArray(this._allSheets);
        this._sheetsByName.clear()
    }
    Create(a)
    {
        a = C3$jscomp$160.New(C3$jscomp$160.EventSheet, this, a);
        this._allSheets.push(a);
        this._sheetsByName.set(a.GetName().toLowerCase(),
        a)
    }
    _AddTriggerToPostInit(a)
    {
        this._triggersToPostInit.push(a)
    }
    _PostInit()
    {
        for (const a of this._customActionBlocksMap.values())
            a._CheckOverrideState();
        for (const a of this._functionBlocksByName.values())
            a._PostInit();
        for (const a of this._customActionBlocksMap.values())
            a._PostInit();
        for (const a of this._allSheets)
            a._PostInit();
        for (const a of this._allSheets)
            a._UpdateDeepIncludes();
        for (const a of this._triggersToPostInit)
            a._PostInit(!1);
        C3$jscomp$160.clearArray(this._triggersToPostInit);
        this._localVarStack._SetInitialValues(this._localVarInitialValues)
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetEventSheetByName(a)
    {
        return this._sheetsByName.get(a.toLowerCase()) ||
            null
    }
    _RegisterGroup(a)
    {
        this._allGroups.push(a);
        this._groupsByName.set(a.GetGroupName(), a)
    }
    _RegisterEventBlock(a)
    {
        this._blocksBySid.set(a.GetSID(), a)
    }
    _RegisterCondition(a)
    {
        this._cndsBySid.set(a.GetSID(), a)
    }
    _RegisterAction(a)
    {
        this._actsBySid.set(a.GetSID(), a)
    }
    _RegisterFunctionBlock(a)
    {
        switch (a.GetFunctionType()) {
        case 0:
            this._functionBlocksByName.set(a.GetFunctionName().toLowerCase(), a);
            break;
        case 1:
            this._customActionBlocksMap.set(a.GetFunctionName().toLowerCase(), a)
        }
    }
    _RegisterEventVariable(a)
    {
        this._eventVarsBySid.set(a.GetSID(),
        a);
        a.IsGlobal() ? this._allGlobalVars.push(a) : this._allLocalVars.push(a)
    }
    _DeduplicateSolModifierList(a)
    {
        2 <= a.length && a.sort(SortSolArray);
        let b = this._allUniqueSolModifiers.get(a.length);
        b || (b = [], this._allUniqueSolModifiers.set(a.length, b));
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c];
            if (IsSolArrayIdentical(a, e))
                return e
        }
        b.push(a);
        return a
    }
    _GetNextLocalVarIndex(a)
    {
        this._localVarInitialValues.push(a.GetInitialValue());
        return this._nextLocalVarIndex++
    }
    GetEventStack()
    {
        return this._eventStack
    }
    GetCurrentEventStackFrame()
    {
        return this.GetEventStack().GetCurrentStackFrame()
    }
    GetCurrentEvent()
    {
        return this.GetCurrentEventStackFrame().GetCurrentEvent()
    }
    GetCurrentCondition()
    {
        const a =
        this.GetCurrentEventStackFrame();
        return a.GetCurrentEvent().GetConditionAt(a.GetConditionIndex())
    }
    GetCurrentAction()
    {
        const a = this.GetCurrentEventStackFrame();
        return a.GetCurrentEvent().GetActionAt(a.GetActionIndex())
    }
    GetLocalVarStack()
    {
        return this._localVarStack
    }
    GetLoopStack()
    {
        return this._loopStack
    }
    GetAllLocalVariablesInScope(a)
    {
        const b = [];
        for (a = a.GetScopeParent(); a;)
            C3$jscomp$160.appendArray(b, a._GetAllLocalVariablesInScope()),
            a = a.GetScopeParent();
        return b
    }
    _GetLocalVariablesScriptInterface(a)
    {
        const b =
        {};
        for (const c of this.GetAllLocalVariablesInScope(a))
            b[c.GetJsPropName()] = c._GetScriptInterfaceDescriptor();
        return Object.create(Object.prototype, b)
    }
    GetEventVariableBySID(a)
    {
        return this._eventVarsBySid.get(a) || null
    }
    GetEventBlockBySID(a)
    {
        return this._blocksBySid.get(a) || null
    }
    GetConditionBySID(a)
    {
        return this._cndsBySid.get(a) || null
    }
    GetActionBySID(a)
    {
        return this._actsBySid.get(a) || null
    }
    GetFunctionBlockByName(a)
    {
        return this._functionBlocksByName.get(a.toLowerCase()) || null
    }
    GetCustomActionBlockByName(a,
    b)
    {
        let c = this._customActionBlocksMap.get((a.GetName() + "." + b).toLowerCase());
        if (c)
            return c;
        if (!a.IsFamily())
            for (const d of a.GetFamilies())
                if (c = this._customActionBlocksMap.get((d.GetName() + "." + b).toLowerCase()))
                    return c;
        return null
    }
    GetAllGlobalVariables()
    {
        return this._allGlobalVars
    }
    GetAllLocalVariables()
    {
        return this._allLocalVars
    }
    ResetAllGlobalsToInitialValue(a)
    {
        for (const b of this._allGlobalVars)
            b.ResetToInitialValue();
        if (a)
            for (const b of this._allLocalVars)
                b.IsStatic() && b.ResetToInitialValue()
    }
    GetEventGroupByName(a)
    {
        return this._groupsByName.get(a.toLowerCase()) ||
            null
    }
    GetEventGroupBySID(a)
    {
        return (a = this._blocksBySid.get(a)) && a.IsGroup() ? a : null
    }
    GetAllGroups()
    {
        return this._allGroups
    }
    ResetAllGroupsInitialActivation()
    {
        for (const a of this._allGroups)
            a.ResetInitialActivation()
    }
    _ResetAllHasRunFlags()
    {
        for (const a of this._allSheets)
            a._ResetHasRunFlag()
    }
    RunEvents(a)
    {
        this._ResetAllHasRunFlags();
        this._runningEventsDepth++;
        for (const b of a.runningLayouts())
            if (a = b.GetEventSheet())
                this._runtime.PushCurrentLayout(b),
                a.Run(),
                this._runtime.PopCurrentLayout();
        this._runningEventsDepth--
    }
    async DebugRunEvents(a)
    {
        this._ResetAllHasRunFlags();
        this._runningEventsDepth++;
        for (const b of this._DebugRunEventsGen(a))
            await this._runtime.DebugBreak(b);
        this._runningEventsDepth--
    }
    *_DebugRunEventsGen(a)
    {
        for (const b of a.runningLayouts())
            if (a = b.GetEventSheet())
                this._runtime.PushCurrentLayout(b),
                yield *a.DebugRun(),
                this._runtime.PopCurrentLayout()
    }
    _Trigger(a, b, c, d)
    {
        let e = !1;
        if (!a.GetMainRunningLayout())
            return this.QueueTrigger(b, c, d);
        this._executingTriggerDepth++;
        for (const f of a.runningLayouts())
            if (a = f.GetEventSheet()) {
                this._runtime.PushCurrentLayout(f);
                for (const g of a.deepIncludes()) {
                    const h = g._Trigger(b, c, d);
                    e = e || h
                }
                a = a._Trigger(b, c, d);
                e = e || a;
                this._runtime.PopCurrentLayout()
            }
        this._executingTriggerDepth--;
        return e
    }
    *_DebugTrigger(a, b, c, d)
    {
        let e = !1;
        if (!a.GetMainRunningLayout())
            return this.QueueTrigger(b, c, d);
        this._executingTriggerDepth++;
        for (const f of a.runningLayouts())
            if (a = f.GetEventSheet()) {
                this._runtime.PushCurrentLayout(f);
                for (const g of a.deepIncludes()) {
                    const h = yield *g._DebugTrigger(b, c, d);
                    e = e || h
                }
                a = yield *a._DebugTrigger(b, c, d);
                e = e || a;
                this._runtime.PopCurrentLayout()
            }
        this._executingTriggerDepth--;
        return e
    }
    QueueTrigger(a, b, c)
    {
        this._queuedTriggers.push([a, b, c]);
        return !1
    }
    QueueDebugTrigger(a, b, c)
    {
        let d = null;
        const e = new Promise(f => d = f);
        this._queuedDebugTriggers.push([a, b, c, d]);
        return e
    }
    *_RunQueuedDebugTriggersGen()
    {
        if (this._runtime.HitBreakpoint())
            throw Error("should not be in breakpoint");
        const a = this._runtime.GetLayoutManager();
        for (; this._queuedDebugTriggers.length;) {
            const [b, c, d, e] = this._queuedDebugTriggers.shift(),
                f = yield *this._DebugTrigger(a, b, c, d);
            e(f)
        }
    }
    async RunQueuedDebugTriggersAsync()
    {
        for (const a of this._RunQueuedDebugTriggersGen())
            await this._runtime.DebugBreak(a)
    }
    _FastTrigger(a,
    b, c, d)
    {
        let e = !1;
        var f = a.GetMainRunningLayout();
        if (a = f.GetEventSheet()) {
            this._executingTriggerDepth++;
            this._runtime.PushCurrentLayout(f);
            f = a.deepIncludes();
            for (let g = 0, h = f.length; g < h; ++g) {
                const k = f[g]._FastTrigger(b, c, d);
                e = e || k
            }
            b = a._FastTrigger(b, c, d);
            e = e || b;
            this._runtime.PopCurrentLayout();
            this._executingTriggerDepth--;
            return e
        }
    }
    *_DebugFastTrigger(a, b, c, d)
    {
        let e = !1;
        var f = a.GetMainRunningLayout();
        if (a = f.GetEventSheet()) {
            this._executingTriggerDepth++;
            this._runtime.PushCurrentLayout(f);
            f = a.deepIncludes();
            for (let g = 0, h = f.length; g < h; ++g) {
                const k = yield *f[g]._DebugFastTrigger(b, c, d);
                e = e || k
            }
            b = yield *a._DebugFastTrigger(b, c, d);
            e = e || b;
            this._runtime.PopCurrentLayout();
            this._executingTriggerDepth--;
            return e
        }
    }
    GetTriggerDepth()
    {
        return this._executingTriggerDepth
    }
    IsInTrigger()
    {
        return 0 < this.GetTriggerDepth()
    }
    _IncTriggerDepth()
    {
        return ++this._executingTriggerDepth
    }
    _DecTriggerDepth()
    {
        --this._executingTriggerDepth
    }
    IsRunningEvents()
    {
        return 0 < this._runningEventsDepth
    }
    IsInEventEngine()
    {
        return this.IsRunningEvents() ||
            this.IsInTrigger()
    }
    _RunQueuedTriggers(a)
    {
        for (const [b, c, d] of this._queuedTriggers)
            this._Trigger(a, b, c, d);
        C3$jscomp$160.clearArray(this._queuedTriggers)
    }
    BlockFlushingInstances(a)
    {
        a ? this._blockFlushingDepth++ : this._blockFlushingDepth--
    }
    IsFlushingBlocked()
    {
        return 0 < this._blockFlushingDepth
    }
    ClearSol(a)
    {
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].GetSolStack().Clear()
    }
    PushCleanSol(a)
    {
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].GetSolStack().PushClean()
    }
    PushCopySol(a)
    {
        for (let b = 0, c = a.length; b < c; ++b)
            a[b].GetSolStack().PushCopy()
    }
    PopSol(a)
    {
        for (let b =
            0, c = a.length; b < c; ++b)
            a[b].GetSolStack().Pop()
    }
    GetDynamicSolModifiersSet(a)
    {
        const b = new Set,
            c = this._eventStack.GetAllStackFrames(),
            d = this._eventStack.GetCurrentStackFrameIndex();
        for (let e = 0; e <= d; ++e) {
            const f = c[e].GetDynamicSolModifiers();
            if (f)
                for (const g of f)
                    a && a.has(g) || b.add(g)
        }
        return b
    }
    PushCleanSolDynamic(a)
    {
        a = new Set([...a]);
        a = this.GetDynamicSolModifiersSet(a);
        if (0 < a.size) {
            for (const b of a)
                b.GetSolStack().PushClean();
            return [...a]
        }
        return null
    }
    AddScheduledWait()
    {
        const a = C3$jscomp$160.New(C3$jscomp$160.ScheduledWait,
        this);
        this._scheduledWaits.push(a);
        return a
    }
    scheduledWaits()
    {
        return this._scheduledWaits
    }
    RunScheduledWaits()
    {
        if (this._scheduledWaits.length) {
            var a = this.GetCurrentEventStackFrame(),
                b = !1;
            this._runningEventsDepth++;
            for (let c = 0, d = this._scheduledWaits.length; c < d; ++c) {
                const e = this._scheduledWaits[c];
                e._ShouldRun() && e._Run(a);
                e.ShouldRelease() && (b = !0)
            }
            b && (this._FilterScheduledWaitsToRelease(), a.Reset(null));
            this._runningEventsDepth--
        }
    }
    async DebugRunScheduledWaits()
    {
        if (this._scheduledWaits.length) {
            var a =
                this.GetCurrentEventStackFrame(),
                b = !1;
            this._runningEventsDepth++;
            for (let c = 0, d = this._scheduledWaits.length; c < d; ++c) {
                const e = this._scheduledWaits[c];
                e._ShouldRun() && await e._DebugRun(a);
                e.ShouldRelease() && (b = !0)
            }
            b && (this._FilterScheduledWaitsToRelease(), a.Reset(null));
            this._runningEventsDepth--
        }
    }
    _FilterScheduledWaitsToRelease()
    {
        const a = C3$jscomp$160.arrayFilterOut(this._scheduledWaits, b => b.ShouldRelease());
        for (const b of a)
            b.Release()
    }
    ClearAllScheduledWaits()
    {
        for (const a of this._scheduledWaits)
            a.Release();
        C3$jscomp$160.clearArray(this._scheduledWaits)
    }
    _OnInstancesReleased(a)
    {
        for (const b of this._scheduledWaits)
            b.RemoveInstances(a);
        for (const b of a)
            if (a = this._instSignals.get(b), this._instSignals.delete(b), a)
                for (const {resolve: c} of a.signalPromises.values())
                    c(!0)
    }
    AddAsyncActionPromise(a)
    {
        this._asyncActionPromises.push(a)
    }
    ClearAsyncActionPromises()
    {
        C3$jscomp$160.clearArray(this._asyncActionPromises)
    }
    GetPromiseForAllAsyncActions()
    {
        const a = Promise.all(this._asyncActionPromises);
        this._asyncActionPromises =
        [];
        return a
    }
    Signal(a)
    {
        a = a.toLowerCase();
        this._signalTags.push(a);
        this._runtime.Trigger(C3$jscomp$160.Plugins.System.Cnds.OnSignal, null);
        this._signalTags.pop();
        for (var b of this._runtime.GetEventSheetManager().scheduledWaits())
            b.IsSignal() && b.GetSignalTag() === a && b.SetSignalled();
        if (b = this._signalPromises.get(a))
            b.resolve(),
            this._signalPromises.delete(a)
    }
    WaitForSignal(a)
    {
        a = a.toLowerCase();
        var b = this._signalPromises.get(a);
        if (b)
            return b.promise;
        let c = null;
        b = new Promise(d => c = d);
        this._signalPromises.set(a,
        {
            promise: b,
            resolve: c
        });
        return b
    }
    GetCurrentSignalTag()
    {
        if (0 === this._signalTags.length)
            throw Error("not in a signal");
        return this._signalTags.at(-1)
    }
    _GetInstanceSignalState(a)
    {
        let b = this._instSignals.get(a);
        b || (b = {
            signalTags: [],
            signalPromises: new Map
        }, this._instSignals.set(a, b));
        return b
    }
    InstanceSignal(a, b)
    {
        const c = this._GetInstanceSignalState(a);
        b = b.toLowerCase();
        c.signalTags.push(b);
        this._runtime.Trigger(a.GetPlugin().GetConstructor().Cnds.OnInstanceSignal, a);
        c.signalTags.pop();
        for (var d of this._runtime.GetEventSheetManager().scheduledWaits())
            d.IsInstanceSignals() &&
            d.GetSignalTag() === b && d.SetInstanceSignalled(a);
        if (d = c.signalPromises.get(b))
            d.resolve(!1),
            c.signalPromises.delete(b);
        0 === c.signalTags.length && 0 === c.signalPromises.size && this._instSignals.delete(a)
    }
    WaitForInstanceSignal(a, b)
    {
        a = this._GetInstanceSignalState(a);
        b = b.toLowerCase();
        var c = a.signalPromises.get(b);
        if (c)
            return c.promise;
        let d = null;
        c = new Promise(e => d = e);
        a.signalPromises.set(b, {
            promise: c,
            resolve: d
        });
        return c
    }
    GetCurrentInstanceSignalTag(a)
    {
        a = this._GetInstanceSignalState(a);
        if (!a || 0 === a.signalTags.length)
            throw Error("not in a signal");
        return a.signalTags.at(-1)
    }
    _SaveToJson()
    {
        return {
            groups: this._SaveGroupsToJson(),
            cnds: this._SaveCndsToJson(),
            acts: this._SaveActsToJson(),
            vars: this._SaveVarsToJson(),
            waits: this._SaveScheduledWaitsToJson()
        }
    }
    _LoadFromJson(a)
    {
        this._LoadGroupsFromJson(a.groups);
        this._LoadCndsFromJson(a.cnds);
        this._LoadActsFromJson(a.acts);
        this._LoadVarsFromJson(a.vars);
        this._LoadScheduledWaitsFromJson(a.waits)
    }
    _SaveGroupsToJson()
    {
        const a = {};
        for (const b of this.GetAllGroups())
            a[b.GetSID().toString()] = b.IsGroupActive();
        return a
    }
    _LoadGroupsFromJson(a)
    {
        for (const [b,
        c] of Object.entries(a))
            a = parseInt(b, 10),
            (a = this.GetEventGroupBySID(a)) && a.SetGroupActive(c)
    }
    _SaveCndsToJson()
    {
        const a = {};
        for (const [b, c] of this._cndsBySid) {
            const d = c._SaveToJson();
            d && (a[b.toString()] = d)
        }
        return a
    }
    _LoadCndsFromJson(a)
    {
        const b = new Map;
        for (const [c, d] of Object.entries(a))
            b.set(parseInt(c, 10), d);
        for (const [c, d] of this._cndsBySid)
            d._LoadFromJson(b.get(c) || null)
    }
    _SaveActsToJson()
    {
        const a = {};
        for (const [b, c] of this._actsBySid) {
            const d = c._SaveToJson();
            d && (a[b.toString()] = d)
        }
        return a
    }
    _LoadActsFromJson(a)
    {
        const b =
        new Map;
        for (const [c, d] of Object.entries(a))
            b.set(parseInt(c, 10), d);
        for (const [c, d] of this._actsBySid)
            d._LoadFromJson(b.get(c) || null)
    }
    _SaveVarsToJson()
    {
        const a = {};
        for (const [b, c] of this._eventVarsBySid)
            c.IsConstant() || !c.IsGlobal() && !c.IsStatic() || (a[b.toString()] = c.GetValue());
        return a
    }
    _LoadVarsFromJson(a)
    {
        for (const [b, c] of Object.entries(a))
            a = parseInt(b, 10),
            (a = this.GetEventVariableBySID(a)) && a.SetValue(c)
    }
    _SaveScheduledWaitsToJson()
    {
        return this._scheduledWaits.filter(a => !a.IsPromise()).map(a => a._SaveToJson())
    }
    _LoadScheduledWaitsFromJson(a)
    {
        this.ClearAllScheduledWaits();
        for (const b of a)
            (a = C3$jscomp$160.ScheduledWait._CreateFromJson(this, b)) && this._scheduledWaits.push(a)
    }
    _GetPerfRecords()
    {
        return [...this._runtime.GetLayoutManager().runningLayouts()].map(a => a.GetEventSheet()).filter(a => a).map(a => a._GetPerfRecord())
    }
    FindFirstFunctionBlockParent(a)
    {
        for (; a;)
            if (a = a.GetScopeParent(), a instanceof C3$jscomp$160.FunctionBlock)
                return a;
        return null
    }
    _InvokeFunctionFromJS(a, b)
    {
        Array.isArray(b) || (b = []);
        a = this.GetFunctionBlockByName(a.toLowerCase());
        if (!a)
            return null;
        if (!a.IsEnabled())
            return a.GetDefaultReturnValue();
        var c = a.GetFunctionParameters();
        if (b.length < c.length) {
            b = b.slice(0);
            do b.push(c[b.length].GetInitialValue());
            while (b.length < c.length)
        }
        c = a.GetEventBlock();
        return c.RunAsExpressionFunctionCall(c.GetSolModifiersIncludingParents(), !1, a.GetReturnType(), a.GetDefaultReturnValue(), ...b)
    }
}
;
"use strict";
const C3$jscomp$161 = self.C3;
C3$jscomp$161.EventSheet = class  extends C3$jscomp$161.DefendedBase{
    constructor(a, b)
    {
        super();
        this._eventSheetManager = a;
        this._runtime = a.GetRuntime();
        this._name = b[0];
        this._events = [];
        this._triggers = new Map;
        this._fastTriggers = new Map;
        this._eventsByDisplayNumber = new Map;
        this._hasRun = !1;
        this._shallowIncludes = [];
        this._deepIncludes = [];
        this._alreadyIncludedSheets = new Set;
        for (const c of b[1])
            this._CreateEvent(c, null, this._events);
        this._perfRecord = this._runtime.IsDebug() ? {
            type: "sheet",
            name: this._name,
            totalTimeCounter: 0,
            children: []
        } : null
    }
    Release()
    {
        this._runtime = this._eventSheetManager = null
    }
    _CreateEvent(a, b, c)
    {
        switch (a[0]) {
        case 0:
        case 3:
            this._CreateEventBlock(a, b, c);
            break;
        case 1:
            this._CreateEventVariable(a, b, c);
            break;
        case 2:
            this._CreateInclude(a, b, c);
            break;
        case 4:
            this._CreateFunctionBlock(a, b);
            break;
        case 5:
            this._CreateScriptBlock(a, b, c);
            break;
        case 6:
            this._CreateCustomACEBlock(a, b);
            break;
        default:
            throw Error("invalid event type");
        }
    }
    _CreateEventBlock(a, b, c)
    {
        a = C3$jscomp$161.EventBlock.Create(this, b, a);
        if (a.IsOrBlock()) {
            c.push(a);
            c = a.GetConditions();
            for (let d = 0, e = c.length; d < e; ++d)
                c[d].IsTrigger() && this._InitTrigger(a, d)
        } else
            a.IsTrigger() ? this._InitTrigger(a, 0) : c.push(a)
    }
    _CreateFunctionBlock(a, b)
    {
        a = C3$jscomp$161.FunctionBlock.CreateFunctionBlock(this, b, a);
        this._eventSheetManager._RegisterFunctionBlock(a)
    }
    _CreateCustomACEBlock(a, b)
    {
        a = C3$jscomp$161.FunctionBlock.CreateCustomACEBlock(this, b, a);
        this._eventSheetManager._RegisterFunctionBlock(a)
    }
    _CreateEventVariable(a, b, c)
    {
        a = C3$jscomp$161.EventVariable.Create(this, b, a);
        c.push(a)
    }
    _CreateInclude(a,
    b, c)
    {
        a = C3$jscomp$161.EventInclude.Create(this, b, a);
        c.push(a)
    }
    _CreateScriptBlock(a, b, c)
    {
        a = C3$jscomp$161.EventScript.Create(this, b, a);
        c.push(a)
    }
    _InitTrigger(a, b)
    {
        a.IsOrBlock() || this._eventSheetManager._AddTriggerToPostInit(a);
        var c = a.GetConditionAt(b),
            d = c._GetFunc(),
            e = c.GetObjectClass();
        if (c.IsFastTrigger()) {
            var f = this._fastTriggers.get(e);
            f || (f = new Map, this._fastTriggers.set(e, f));
            c = c.GetFastTriggerValue().toLowerCase();
            e = f.get(d);
            e || (e = new Map, f.set(d, e));
            d = e.get(c);
            d || (d = [], e.set(c, d));
            d.push([a,
            b])
        } else
            f = this._triggers.get(e),
            f || (f = {
                methodMap: new Map,
                behaviors: new Map
            }, this._triggers.set(e, f)),
            (e = c.GetBehaviorType()) ? (c = f.behaviors.get(e), c || (c = new Map, f.behaviors.set(e, c))) : c = f.methodMap,
            f = c.get(d),
            f || (f = [], c.set(d, f)),
            f.push([a, b])
    }
    _PostInit()
    {
        const a = this._events;
        for (let b = 0, c = a.length; b < c; ++b) {
            const d = b < c - 1 && a[b + 1] instanceof C3$jscomp$161.EventBlock && a[b + 1].IsElseBlock();
            a[b]._PostInit(d)
        }
    }
    _AddShallowInclude(a)
    {
        this._shallowIncludes.push(a)
    }
    _UpdateDeepIncludes()
    {
        C3$jscomp$161.clearArray(this._deepIncludes);
        this._AddDeepIncludes(this);
        this._alreadyIncludedSheets.clear()
    }
    _AddDeepIncludes(a)
    {
        const b = a._deepIncludes,
            c = a._alreadyIncludedSheets;
        for (const d of this._shallowIncludes) {
            const e = d.GetIncludeSheet();
            d.IsActive() && a !== e && !c.has(e) && (c.add(e), e._AddDeepIncludes(a), b.push(e))
        }
    }
    deepIncludes()
    {
        return this._deepIncludes
    }
    GetEventSheetManager()
    {
        return this._eventSheetManager
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetName()
    {
        return this._name
    }
    _RegisterEventByDisplayNumber(a, b)
    {
        this._eventsByDisplayNumber.set(b,
        a)
    }
    _GetEventByDisplayNumber(a)
    {
        return this._eventsByDisplayNumber.get(a) || null
    }
    _ResetHasRunFlag()
    {
        this._hasRun = !1
    }
    Run()
    {
        if (!this._hasRun) {
            var a = this._runtime,
                b = a.IsCPUProfiling(),
                c = b ? performance.now() : 0;
            this._hasRun = !0;
            var d = this.GetEventSheetManager(),
                e = d.GetCurrentEventStackFrame();
            for (const f of this._events)
                f.Run(e),
                d.ClearSol(f.GetSolModifiers()),
                d.ClearAsyncActionPromises(),
                a.FlushPendingInstances();
            e.Reset(null);
            b && (this._perfRecord.totalTimeCounter += performance.now() - c)
        }
    }
    *DebugRun()
    {
        if (!this._hasRun) {
            this._hasRun =
            !0;
            var a = this._runtime,
                b = this.GetEventSheetManager(),
                c = b.GetCurrentEventStackFrame();
            for (const d of this._events)
                yield *d.DebugRun(c),
                b.ClearSol(d.GetSolModifiers()),
                b.ClearAsyncActionPromises(),
                a.FlushPendingInstances();
            c.Reset(null)
        }
    }
    _Trigger(a, b, c)
    {
        if (b) {
            const d = b.GetObjectClass();
            this._TriggerForClass(a, b, d, c);
            for (const e of d.GetFamilies())
                this._TriggerForClass(a, b, e, c)
        } else
            return this._TriggerForClass(a, b, null, null)
    }
    _TriggerForClass(a, b, c, d)
    {
        c = this._triggers.get(c);
        if (!c)
            return !1;
        d = d ? c.behaviors.get(d) :
        c.methodMap;
        if (!d)
            return !1;
        d = d.get(a);
        if (!d)
            return !1;
        a = !1;
        for (const [e, f] of d)
            d = this._ExecuteTrigger(b, e, f),
            a = a || d;
        return a
    }
    *_DebugTrigger(a, b, c)
    {
        if (b) {
            const d = b.GetObjectClass();
            yield *this._DebugTriggerForClass(a, b, d, c);
            for (const e of d.GetFamilies())
                yield *this._DebugTriggerForClass(a, b, e, c)
        } else
            return yield *this._DebugTriggerForClass(a, b, null, null)
    }
    *_DebugTriggerForClass(a, b, c, d)
    {
        c = this._triggers.get(c);
        if (!c)
            return !1;
        d = d ? c.behaviors.get(d) : c.methodMap;
        if (!d)
            return !1;
        d = d.get(a);
        if (!d)
            return !1;
        a = !1;
        for (const [e, f] of d)
            d = e.DebugCanRunFast() ? this._ExecuteTrigger(b, e, f) : yield *this._DebugExecuteTrigger(b, e, f),
            a = a || d;
        return a
    }
    _FastTrigger(a, b, c)
    {
        b = b.GetObjectClass();
        b = this._fastTriggers.get(b);
        if (!b)
            return !1;
        a = b.get(a);
        if (!a)
            return !1;
        c = a.get(c);
        if (!c)
            return !1;
        a = !1;
        for (let d = 0, e = c.length; d < e; ++d)
            b = c[d],
            b = this._ExecuteTrigger(null, b[0], b[1]),
            a = a || b;
        return a
    }
    *_DebugFastTrigger(a, b, c)
    {
        b = b.GetObjectClass();
        b = this._fastTriggers.get(b);
        if (!b)
            return !1;
        a = b.get(a);
        if (!a)
            return !1;
        c = a.get(c);
        if (!c)
            return !1;
        a = !1;
        for (let e = 0, f = c.length; e < f; ++e) {
            var d = c[e];
            b = d[0];
            d = d[1];
            b = b.DebugCanRunFast() ? this._ExecuteTrigger(null, b, d) : yield *this._DebugExecuteTrigger(null, b, d);
            a = a || b
        }
        return a
    }
    _ExecuteTrigger(a, b, c)
    {
        const d = this._runtime,
            e = this._eventSheetManager,
            f = e.GetCurrentEvent(),
            g = e.GetEventStack(),
            h = e.GetTriggerDepth();
        let k = !1;
        f && e.PushCleanSol(f.GetSolModifiersIncludingParents());
        e.PushCleanSol(b.GetSolModifiersIncludingParents());
        const l = 1 < h;
        l && e.GetLocalVarStack().Push();
        const m = g.Push(b);
        a && (b.GetConditions()[c].GetObjectClass().GetCurrentSol().SetSinglePicked(a),
        a.IsInContainer() && a.SetSiblingsSinglePicked());
        a = !0;
        if (b.GetParent()) {
            const n = b.GetTriggerParents();
            for (let p = 0, q = n.length; p < q; ++p)
                if (!n[p].RunPreTrigger(m)) {
                    a = !1;
                    break
                }
        }
        a && (b.IsOrBlock() ? b.RunOrBlockTrigger(m, c) : b.Run(m), k = m.GetLastEventTrue());
        g.Pop();
        l && e.GetLocalVarStack().Pop();
        e.PopSol(b.GetSolModifiersIncludingParents());
        f && e.PopSol(f.GetSolModifiersIncludingParents());
        f || 1 !== h || (e.ClearAsyncActionPromises(), e.IsFlushingBlocked() || d.FlushPendingInstances());
        return k
    }
    *_DebugExecuteTrigger(a,
    b, c)
    {
        const d = this._runtime,
            e = this._eventSheetManager,
            f = e.GetCurrentEvent(),
            g = e.GetEventStack(),
            h = e.GetTriggerDepth();
        let k = !1;
        f && e.PushCleanSol(f.GetSolModifiersIncludingParents());
        e.PushCleanSol(b.GetSolModifiersIncludingParents());
        const l = 1 < h;
        l && e.GetLocalVarStack().Push();
        const m = g.Push(b);
        a && (b.GetConditions()[c].GetObjectClass().GetCurrentSol().SetSinglePicked(a), a.IsInContainer() && a.SetSiblingsSinglePicked());
        a = !0;
        if (b.GetParent()) {
            const n = b.GetTriggerParents();
            for (let p = 0, q = n.length; p < q; ++p)
                if (!(yield *n[p].DebugRunPreTrigger(m))) {
                    a =
                    !1;
                    break
                }
        }
        a && (b.IsOrBlock() ? yield *b.DebugRunOrBlockTrigger(m, c) : yield *b.DebugRun(m), k = m.GetLastEventTrue());
        g.Pop();
        l && e.GetLocalVarStack().Pop();
        e.PopSol(b.GetSolModifiersIncludingParents());
        f && e.PopSol(f.GetSolModifiersIncludingParents());
        f || 1 !== h || (e.ClearAsyncActionPromises(), e.IsFlushingBlocked() || d.FlushPendingInstances());
        return k
    }
    _GetPerfRecord()
    {
        return this._perfRecord
    }
}
;
"use strict";
const C3$jscomp$162 = self.C3,
    EMPTY_ARRAY = [];
function NoActions(a, b) {
    return !0
}
function* DebugNoActions(a, b) {
    return !0
}
C3$jscomp$162.EventBlock = class  extends C3$jscomp$162.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._eventSheet = a;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._scopeParent = null;
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._solModifiers = [];
        this._solModifiersIncludingParents = [];
        this._hasElseBlock = this._isTopLevelGroup = this._isSolWriterAfterCnds = this._hasGotSolModifiersIncludingParents = !1;
        this._isOrBlock = !!c[2];
        this._isElseBlock = !1;
        this._triggerParents = null;
        this._conditions =
        [];
        this._actions = [];
        this._subEvents = [];
        this._RunActions = NoActions;
        this._DebugRunActions = DebugNoActions;
        this._isInitiallyActive = this._isGroup = !1;
        this._groupName = "";
        this._isGroupActive = !1;
        this._perfRecord = this._containedIncludes = null;
        this._sid = c[4];
        this._displayNumber = c[5];
        this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
        this._debugData = this._runtime.IsDebug() ? {
            isBreakpoint: c[3][0],
            isBreakable: c[3][1],
            canRunAllConditionsFast: !1,
            canRunAllActionsFast: !1,
            canRunAllSubEventsFast: !1,
            canRunSelfFast: !1
        } : null;
        this.GetEventSheetManager()._RegisterEventBlock(this);
        3 === c[0] && this._InitGroup(c[1]);
        a = 0;
        for (var d of c[6])
            b = C3$jscomp$162.Condition.Create(this, d, a++),
            this._conditions.push(b),
            this._AddSolModifier(b.GetObjectClass());
        a = 0;
        for (const e of c[7])
            d = C3$jscomp$162.Action.Create(this, e, a++),
            this._actions.push(d);
        if (9 === c.length) {
            c = c[8];
            for (const e of c)
                this._eventSheet._CreateEvent(e, this, this._subEvents)
        }
        this._conditions.length && (this._isElseBlock = null === this._conditions[0].GetObjectClass() &&
        this._conditions[0]._GetFunc() === C3$jscomp$162.Plugins.System.Cnds.Else);
        0 === this._conditions.length && (this._conditions = EMPTY_ARRAY);
        0 === this._actions.length && (this._actions = EMPTY_ARRAY);
        0 === this._subEvents.length && (this._subEvents = EMPTY_ARRAY)
    }
    static Create(a, b, c)
    {
        return C3$jscomp$162.New(C3$jscomp$162.EventBlock, a, b, c)
    }
    _InitGroup(a)
    {
        this._isGroup = !0;
        this._isGroupActive = this._isInitiallyActive = !!a[0];
        this._groupName = a[1].toLowerCase();
        this._containedIncludes = [];
        this.GetEventSheetManager()._RegisterGroup(this);
        this._runtime.IsDebug() && (this._perfRecord = {
            type: "group",
            name: a[1],
            totalTimeCounter: 0,
            children: []
        })
    }
    _AddContainedInclude(a)
    {
        this._containedIncludes.push(a)
    }
    _AddContainerSolModifierToList(a, b)
    {
        for (const c of a.GetContainer().objectTypes())
            b.includes(c) || b.push(c)
    }
    _AddSolModifierToList(a, b)
    {
        if (a)
            if (b.includes(a) || b.push(a), a.IsFamily())
                for (const c of a.GetFamilyMembers())
                    c.IsInContainer() && this._AddContainerSolModifierToList(c, b);
            else
                a.IsInContainer() && this._AddContainerSolModifierToList(a, b)
    }
    _AddSolModifier(a)
    {
        this._AddSolModifierToList(a,
        this._solModifiers)
    }
    _AddParentSolModifier(a)
    {
        this._AddSolModifierToList(a, this._solModifiersIncludingParents)
    }
    SetAllSolModifiers()
    {
        this._solModifiers = this._runtime.GetAllObjectClasses()
    }
    _PostInit(a)
    {
        this._hasElseBlock = !!a;
        this._IdentifyTopLevelGroup();
        this._IdentifyTriggerParents();
        for (const c of this._conditions)
            c._PostInit();
        if (0 < this._actions.length) {
            a = !1;
            for (var b of this._actions)
                b._PostInit(),
                b.HasReturnType() && (a = !0);
            a ? (this._RunActions = this._RunActions_ReturnValue, this._DebugRunActions = this._DebugRunActions_ReturnValue) :
            (this._RunActions = this._RunActions_Fast, this._DebugRunActions = this._DebugRunActions_Fast)
        }
        b = this._subEvents;
        for (let c = 0, d = b.length; c < d; ++c)
            a = c < d - 1 && b[c + 1] instanceof C3$jscomp$162.EventBlock && b[c + 1].IsElseBlock(),
            b[c]._PostInit(a);
        this._debugData && this._UpdateCanRunFast();
        this._perfRecord && this._GetPerfRecordParent()._GetPerfRecord().children.push(this._perfRecord)
    }
    _GetPerfRecord()
    {
        return this._perfRecord
    }
    _GetPerfRecordParent()
    {
        let a = this.GetParent();
        for (; a;) {
            if (a.IsGroup())
                return a;
            a = a.GetParent()
        }
        return this._eventSheet
    }
    _UpdateCanRunFast()
    {
        const a =
        this._debugData;
        a.canRunAllConditionsFast = this._conditions.every(b => b.DebugCanRunFast());
        a.canRunAllActionsFast = this._actions.every(b => b.DebugCanRunFast());
        a.canRunAllSubEventsFast = this._subEvents.every(b => b.DebugCanRunFast());
        a.canRunSelfFast = a.canRunAllConditionsFast && a.canRunAllActionsFast && a.canRunAllSubEventsFast
    }
    _UpdateCanRunFastRecursive()
    {
        let a = this;
        do a._UpdateCanRunFast(),
        a = a.GetParent();
        while (a)
    }
    _IdentifyTopLevelGroup()
    {
        if (this.IsGroup()) {
            var a = this.GetParent();
            for (this._isTopLevelGroup =
            !0; a;) {
                if (!a.IsGroup()) {
                    this._isTopLevelGroup = !1;
                    break
                }
                a = a.GetParent()
            }
        }
    }
    _IdentifySolModifiersIncludingParents()
    {
        var a = this._runtime.GetAllObjectClasses();
        if (this._solModifiers === a)
            this._solModifiersIncludingParents = a;
        else {
            this._solModifiersIncludingParents = C3$jscomp$162.cloneArray(this._solModifiers);
            for (a = this.GetParent(); a;) {
                for (var b of a._solModifiers)
                    this._AddParentSolModifier(b);
                a = a.GetParent()
            }
            b = this.GetEventSheetManager();
            this._solModifiers = b._DeduplicateSolModifierList(this._solModifiers);
            this._solModifiersIncludingParents = b._DeduplicateSolModifierList(this._solModifiersIncludingParents)
        }
    }
    _IdentifyTriggerParents()
    {
        if (this.HasAnyTriggeredCondition()) {
            this._triggerParents = [];
            for (var a = this.GetParent(); a;)
                this._triggerParents.push(a),
                a = a.GetParent();
            this._triggerParents.reverse()
        }
    }
    SetSolWriterAfterCnds()
    {
        this._isSolWriterAfterCnds = !0;
        this._parent && this._parent.SetSolWriterAfterCnds()
    }
    IsSolWriterAfterCnds()
    {
        return this._isSolWriterAfterCnds
    }
    GetSolModifiers()
    {
        return this._solModifiers
    }
    GetSolModifiersIncludingParents()
    {
        this._hasGotSolModifiersIncludingParents ||
        (this._hasGotSolModifiersIncludingParents = !0, this._IdentifySolModifiersIncludingParents());
        return this._solModifiersIncludingParents
    }
    HasSolModifier(a)
    {
        return this._solModifiers.includes(a)
    }
    GetTriggerParents()
    {
        return this._triggerParents
    }
    GetEventSheet()
    {
        return this._eventSheet
    }
    GetEventSheetManager()
    {
        return this._eventSheet.GetEventSheetManager()
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetParent()
    {
        return this._parent
    }
    _SetScopeParent(a)
    {
        this._scopeParent = a
    }
    GetScopeParent()
    {
        return this._scopeParent || this._parent
    }
    GetDisplayNumber()
    {
        return this._displayNumber
    }
    IsDebugBreakable()
    {
        return this._debugData &&
            this._debugData.isBreakable
    }
    IsDebugBreakpoint()
    {
        return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(a)
    {
        this._debugData.isBreakpoint = !!a;
        this._UpdateCanRunFastRecursive()
    }
    IsGroup()
    {
        return this._isGroup
    }
    IsTopLevelGroup()
    {
        return this._isTopLevelGroup
    }
    IsElseBlock()
    {
        return this._isElseBlock
    }
    HasElseBlock()
    {
        return this._hasElseBlock
    }
    GetGroupName()
    {
        return this._groupName
    }
    IsGroupActive()
    {
        return this._isGroupActive
    }
    ResetInitialActivation()
    {
        this.SetGroupActive(this._isInitiallyActive)
    }
    SetGroupActive(a)
    {
        a =
        !!a;
        if (!this._isGroup)
            throw Error("not a group");
        if (this._isGroupActive !== a) {
            this._isGroupActive = a;
            for (const b of this._containedIncludes)
                b.UpdateActive();
            this._containedIncludes.length && (a = this._runtime.GetCurrentLayout().GetEventSheet()) && a._UpdateDeepIncludes()
        }
    }
    GetSID()
    {
        return this._sid
    }
    IsOrBlock()
    {
        return this._isOrBlock
    }
    IsTrigger()
    {
        return this._conditions.length && this._conditions[0].IsTrigger()
    }
    IsForFunctionBlock()
    {
        return this._scopeParent && this._scopeParent instanceof C3$jscomp$162.FunctionBlock
    }
    HasAnyTriggeredCondition()
    {
        return this.IsForFunctionBlock() ||
            this._conditions.some(a => a.IsTrigger())
    }
    GetConditions()
    {
        return this._conditions
    }
    GetConditionCount()
    {
        return this._conditions.length
    }
    GetConditionAt(a)
    {
        a = Math.floor(a);
        if (0 > a || a >= this._conditions.length)
            throw new RangeError("invalid condition index");
        return this._conditions[a]
    }
    GetConditionByDebugIndex(a)
    {
        return this.GetConditionAt(a)
    }
    IsFirstConditionOfType(a)
    {
        let b = a.GetIndex();
        if (0 === b)
            return !0;
        --b;
        for (a = a.IsSystemOrSingleGlobalCondition() ? a.GetFirstObjectParameterObjectClass() : a.GetObjectClass(); 0 <=
        b; --b) {
            const c = this._conditions[b];
            if (a === c.GetObjectClass() || c.IsSystemOrSingleGlobalCondition() && c.GetFirstObjectParameterObjectClass() === a)
                return !1
        }
        return !0
    }
    GetActions()
    {
        return this._actions
    }
    GetActionCount()
    {
        return this._actions.length
    }
    GetActionAt(a)
    {
        a = Math.floor(a);
        if (0 > a || a >= this._actions.length)
            throw new RangeError("invalid action index");
        return this._actions[a]
    }
    GetActionByDebugIndex(a)
    {
        a = Math.floor(a);
        const b = this._actions.find(c => c.GetDebugIndex() === a);
        if (!b)
            throw new RangeError("invalid action debug index");
        return b
    }
    _HasActionIndex(a)
    {
        a = Math.floor(a);
        return 0 <= a && a < this._actions.length
    }
    GetSubEvents()
    {
        return this._subEvents
    }
    _GetAllLocalVariablesInScope()
    {
        return this._subEvents.filter(a => a instanceof C3$jscomp$162.EventVariable)
    }
    RunPreTrigger(a)
    {
        a.SetCurrentEvent(this);
        const b = this._conditions;
        let c = 0 === b.length;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d];
            a.SetConditionIndex(d);
            if (f.IsLooping())
                throw Error("trigger cannot be used as sub-event to a loop");
            if (f.Run())
                c = !0;
            else if (!this._isOrBlock)
                return !1
        }
        return this._isOrBlock ?
        c : !0
    }
    RunOrBlockTrigger(a, b)
    {
        a.SetCurrentEvent(this);
        a.SetConditionIndex(b);
        this._conditions[b].Run() && (this._RunActions(a, 0) && this._RunSubEvents(a), a.SetLastEventTrue(!0))
    }
    *DebugRunPreTrigger(a)
    {
        a.SetCurrentEvent(this);
        const b = this._conditions;
        let c = 0 === b.length;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d];
            a.SetConditionIndex(d);
            if (f.IsLooping())
                throw Error("trigger cannot be used as sub-event to a loop");
            if (f.DebugCanRunFast() ? f.Run() : yield *f.DebugRun())
                c = !0;
            else if (!this._isOrBlock)
                return !1
        }
        return this._isOrBlock ?
        c : !0
    }
    *DebugRunOrBlockTrigger(a, b)
    {
        a.SetCurrentEvent(this);
        a.SetConditionIndex(b);
        b = this._conditions[b];
        if (b.DebugCanRunFast() ? b.Run() : yield *b.DebugRun())
            (this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield *this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield *this._DebugRunSubEvents()),
            a.SetLastEventTrue(!0)
    }
    Run(a)
    {
        a.SetCurrentEvent(this);
        this._isElseBlock || a.SetElseBranchRan(!1);
        this._isOrBlock ? this._RunOrBlock(a) : this._RunAndBlock(a)
    }
    *DebugRun(a)
    {
        if (this.IsDebugBreakpoint() ||
        this._runtime.DebugBreakNext())
            yield this;
        a.SetCurrentEvent(this);
        this._isElseBlock || a.SetElseBranchRan(!1);
        this._isOrBlock ? yield *this._DebugRunOrBlock(a) : yield *this._DebugRunAndBlock(a)
    }
    _RunOrBlock(a)
    {
        const b = this._conditions;
        let c = 0 === b.length;
        for (let e = 0, f = b.length; e < f; ++e) {
            var d = b[e];
            d.IsTrigger() || (a.SetConditionIndex(e), d = d.Run(), c = c || d)
        }
        a.SetLastEventTrue(c);
        c && (this._RunActions(a, 0) && this._RunSubEvents(a), this._hasElseBlock && a.SetElseBranchRan(!0))
    }
    *_DebugRunOrBlock(a)
    {
        const b = this._conditions;
        let c = 0 === b.length;
        for (let e = 0, f = b.length; e < f; ++e) {
            var d = b[e];
            d.IsTrigger() || (a.SetConditionIndex(e), d = d.DebugCanRunFast() ? d.Run() : yield *d.DebugRun(), c = c || d)
        }
        a.SetLastEventTrue(c);
        c && ((this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield *this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield *this._DebugRunSubEvents()), this._hasElseBlock && a.SetElseBranchRan(!0))
    }
    _RunAndBlock(a)
    {
        const b = this._conditions;
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c];
            a.SetConditionIndex(c);
            if (!e.Run()) {
                a.SetLastEventTrue(!1);
                return
            }
        }
        a.SetLastEventTrue(!0);
        this._RunActions(a, 0) && this._RunSubEvents(a);
        a.GetLastEventTrue() && this._hasElseBlock && a.SetElseBranchRan(!0)
    }
    *_DebugRunAndBlock(a)
    {
        const b = this._conditions;
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c];
            a.SetConditionIndex(c);
            if (e.DebugCanRunFast() ? !e.Run() : !(yield *e.DebugRun())) {
                a.SetLastEventTrue(!1);
                return
            }
        }
        a.SetLastEventTrue(!0);
        (this.DebugCanRunActionsFast() ? this._RunActions(a, 0) : yield *this._DebugRunActions(a, 0)) && (this.DebugCanRunSubEventsFast() ?
        this._RunSubEvents() : yield *this._DebugRunSubEvents());
        a.GetLastEventTrue() && this._hasElseBlock && a.SetElseBranchRan(!0)
    }
    _RunActions_Fast(a, b)
    {
        const c = this._actions;
        for (let d = b, e = c.length; d < e; ++d)
            b = c[d],
            a.SetActionIndex(d),
            b.Run();
        return !0
    }
    *_DebugRunActions_Fast(a, b)
    {
        const c = this._actions;
        for (let d = b, e = c.length; d < e; ++d)
            b = c[d],
            a.SetActionIndex(d),
            b.DebugCanRunFast() ? b.Run() : yield *b.DebugRun();
        return !0
    }
    _RunActions_ReturnValue(a, b)
    {
        const c = this.GetEventSheetManager(),
            d = this._actions;
        for (let e = b, f = d.length; e <
        f; ++e) {
            b = d[e];
            a.SetActionIndex(e);
            const g = b.Run();
            if (b.CanBailOut() && !0 === g)
                return !1;
            b.IsAsync() && g instanceof Promise && c.AddAsyncActionPromise(g)
        }
        return !0
    }
    *_DebugRunActions_ReturnValue(a, b)
    {
        const c = this.GetEventSheetManager(),
            d = this._actions;
        for (let e = b, f = d.length; e < f; ++e) {
            b = d[e];
            a.SetActionIndex(e);
            let g;
            g = b.DebugCanRunFast() ? b.Run() : yield *b.DebugRun();
            if (b.CanBailOut() && !0 === g)
                return !1;
            b.IsAsync() && g instanceof Promise && c.AddAsyncActionPromise(g)
        }
        return !0
    }
    _ResumeActionsAndSubEvents(a)
    {
        this._RunActions(a,
        a.GetActionIndex()) && this._RunSubEvents()
    }
    *_DebugResumeActionsAndSubEvents(a)
    {
        if (yield *this._DebugRunActions(a, a.GetActionIndex()))
            yield *this._DebugRunSubEvents()
    }
    _RunSubEvents()
    {
        if (this._subEvents.length) {
            var a = this.IsGroup() && this._runtime.IsCPUProfiling(),
                b = a ? performance.now() : 0,
                c = this._eventStack,
                d = c.Push(this);
            this._isSolWriterAfterCnds ? this._RunSubEvents_SolWriterAfterCnds(d) : this._RunSubEvents_Fast(d);
            c.Pop();
            a && (this._perfRecord.totalTimeCounter += performance.now() - b)
        }
    }
    _RunSubEvents_SolWriterAfterCnds(a)
    {
        const b =
            this._isGroup,
            c = this._isTopLevelGroup,
            d = this.GetEventSheetManager(),
            e = this._subEvents;
        for (let f = 0, g = e.length, h = g - 1; f < g; ++f) {
            const k = e[f],
                l = k.GetSolModifiers(),
                m = !c || !b && f < h;
            m && d.PushCopySol(l);
            k.Run(a);
            m ? d.PopSol(l) : d.ClearSol(l)
        }
    }
    _RunSubEvents_Fast(a)
    {
        const b = this._subEvents;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].Run(a)
    }
    *_DebugRunSubEvents()
    {
        if (this._subEvents.length) {
            var a = this._eventStack,
                b = a.Push(this);
            this._isSolWriterAfterCnds ? yield *this._DebugRunSubEvents_SolWriterAfterCnds(b) : yield *this._DebugRunSubEvents_Fast(b);
            a.Pop()
        }
    }
    *_DebugRunSubEvents_SolWriterAfterCnds(a)
    {
        const b = this._isGroup,
            c = this._isTopLevelGroup,
            d = this.GetEventSheetManager(),
            e = this._subEvents;
        for (let f = 0, g = e.length, h = g - 1; f < g; ++f) {
            const k = e[f],
                l = k.GetSolModifiers(),
                m = !c || !b && f < h;
            m && d.PushCopySol(l);
            yield *k.DebugRun(a);
            m ? d.PopSol(l) : d.ClearSol(l)
        }
    }
    *_DebugRunSubEvents_Fast(a)
    {
        const b = this._subEvents;
        for (let c = 0, d = b.length; c < d; ++c)
            yield *b[c].DebugRun(a)
    }
    Retrigger(a, b)
    {
        b.ResetQuick();
        const c = this._conditions;
        if (!this.IsOrBlock())
            for (let d = a.GetConditionIndex() +
                1, e = c.length; d < e; ++d)
                if (a = c[d], b.SetConditionIndex(d), !a.Run())
                    return !1;
        this._RunActions(b, 0) && this._RunSubEvents(b);
        return !0
    }
    *DebugRetrigger(a, b)
    {
        b.ResetQuick();
        const c = this._conditions;
        if (!this.IsOrBlock())
            for (let d = a.GetConditionIndex() + 1, e = c.length; d < e; ++d)
                if (a = c[d], b.SetConditionIndex(d), a.DebugCanRunFast() ? !a.Run() : !(yield *a.DebugRun()))
                    return !1;
        (this.DebugCanRunActionsFast() ? this._RunActions(b, 0) : yield *this._DebugRunActions(b, 0)) && (this.DebugCanRunSubEventsFast() ? this._RunSubEvents() : yield *this._DebugRunSubEvents());
        return !0
    }
    DebugCanRunFast()
    {
        return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext() && this._debugData.canRunSelfFast
    }
    DebugCanRunActionsFast()
    {
        return !this._runtime.DebugBreakNext() && this._debugData.canRunAllActionsFast
    }
    DebugCanRunSubEventsFast()
    {
        return !this._runtime.DebugBreakNext() && this._debugData.canRunAllSubEventsFast
    }
    _CheckParentsOKToRun(a)
    {
        if (this.GetParent()) {
            const b = this.GetTriggerParents();
            for (let c = 0, d = b.length; c < d; ++c)
                if (!b[c].RunPreTrigger(a))
                    return !1
        }
        return !0
    }
    *_DebugCheckParentsOKToRun(a)
    {
        if (this.GetParent()) {
            const b =
            this.GetTriggerParents();
            for (let c = 0, d = b.length; c < d; ++c)
                if (!(yield *b[c].DebugRunPreTrigger(a)))
                    return !1
        }
        return !0
    }
    _EvaluateFunctionCallParameters(a, b, c)
    {
        0 < b.length ? c ? (b = b.map(d => d.Get(0)), a.GetLocalVarStack().Push(), this._scopeParent.SetFunctionParameters(b)) : this._scopeParent.EvaluateFunctionParameters(b) : c && a.GetLocalVarStack().Push()
    }
    RunAsFunctionCall(a, b, c, d)
    {
        let e,
            f;
        const g = 0 < a.length;
        let h = null;
        const k = this._eventStack,
            l = this._runtime.GetEventSheetManager(),
            m = 1 < l._IncTriggerDepth();
        this._EvaluateFunctionCallParameters(l,
        b, m);
        g && (c ? l.PushCopySol(a) : l.PushCleanSol(a));
        if (null !== d) {
            if (d.copyFromObjectClass) {
                b = c ? d.copyFromObjectClass.GetCurrentSol() : d.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol();
                const n = d.copyToObjectClass.GetCurrentSol();
                n.SetArrayPicked(b.GetInstances());
                n.ClearElseInstances();
                c || d.copyToObjectClass.ApplySolToContainer()
            } else
                d.pickObjectClass && (b = d.pickObjectClass.GetCurrentSol(), b.SetArrayPicked(d.pickInstances), b.ClearElseInstances());
            d.pushCleanSolDynamic && (h = l.PushCleanSolDynamic(a))
        }
        d =
        k.Push(this);
        c && d.SetDynamicSolModifiers(a);
        this._CheckParentsOKToRun(d) && (d.SetCurrentEvent(this), (c = this._scopeParent.IsAsync()) && ([f, e] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(d), c && this._scopeParent.MaybeFinishAsyncFunctionCall(f));
        k.Pop();
        m && l.GetLocalVarStack().Pop();
        null !== h && l.PopSol(h);
        g && l.PopSol(a);
        l._DecTriggerDepth();
        return e
    }
    *DebugRunAsFunctionCall(a, b, c, d)
    {
        let e,
            f;
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        const g = 0 < a.length;
        let h = null;
        const k = this._eventStack,
            l = this._runtime.GetEventSheetManager(),
            m = 1 < l._IncTriggerDepth();
        this._EvaluateFunctionCallParameters(l, b, m);
        g && (c ? l.PushCopySol(a) : l.PushCleanSol(a));
        if (null !== d) {
            if (d.copyFromObjectClass) {
                b = c ? d.copyFromObjectClass.GetCurrentSol() : d.copyFromObjectClass.GetSolStack().GetOneBelowCurrentSol();
                const n = d.copyToObjectClass.GetCurrentSol();
                n.SetArrayPicked(b.GetInstances());
                n.ClearElseInstances();
                c || d.copyToObjectClass.ApplySolToContainer()
            } else
                d.pickObjectClass && (b = d.pickObjectClass.GetCurrentSol(),
                b.SetArrayPicked(d.pickInstances), b.ClearElseInstances());
            d.pushCleanSolDynamic && (h = l.PushCleanSolDynamic(a))
        }
        d = k.Push(this);
        c && d.SetDynamicSolModifiers(a);
        if (yield *this._DebugCheckParentsOKToRun(d))
            d.SetCurrentEvent(this),
            (c = this._scopeParent.IsAsync()) && ([f, e] = this._scopeParent.StartAsyncFunctionCall()),
            yield *this._DebugRunAndBlock(d),
            c && this._scopeParent.MaybeFinishAsyncFunctionCall(f);
        k.Pop();
        m && l.GetLocalVarStack().Pop();
        null !== h && l.PopSol(h);
        g && l.PopSol(a);
        l._DecTriggerDepth();
        return e
    }
    RunAsMappedFunctionCall(a,
    b)
    {
        const c = this.GetSolModifiersIncludingParents(),
            d = 0 < c.length,
            e = this._eventStack,
            f = this._runtime.GetEventSheetManager(),
            g = 1 < f._IncTriggerDepth();
        g && f.GetLocalVarStack().Push();
        this._scopeParent.SetFunctionParameters(a);
        d && (b ? f.PushCopySol(c) : f.PushCleanSol(c));
        a = e.Push(this);
        this._CheckParentsOKToRun(a) && (a.SetCurrentEvent(this), this._RunAndBlock(a));
        e.Pop();
        g && f.GetLocalVarStack().Pop();
        d && f.PopSol(c);
        f._DecTriggerDepth()
    }
    *DebugRunAsMappedFunctionCall(a, b)
    {
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        const c = this.GetSolModifiersIncludingParents(),
            d = 0 < c.length,
            e = this._eventStack,
            f = this._runtime.GetEventSheetManager(),
            g = 1 < f._IncTriggerDepth();
        g && f.GetLocalVarStack().Push();
        this._scopeParent.SetFunctionParameters(a);
        d && (b ? f.PushCopySol(c) : f.PushCleanSol(c));
        a = e.Push(this);
        if (yield *this._DebugCheckParentsOKToRun(a))
            a.SetCurrentEvent(this),
            yield *this._DebugRunAndBlock(a);
        e.Pop();
        g && f.GetLocalVarStack().Pop();
        d && f.PopSol(c);
        f._DecTriggerDepth()
    }
    RunAsExpressionFunctionCall(a, b, c, d, ...e)
    {
        let f,
            g;
        const h =
            0 < a.length,
            k = this._runtime,
            l = this._eventStack,
            m = k.GetEventSheetManager(),
            n = 1 < m._IncTriggerDepth();
        n && m.GetLocalVarStack().Push();
        0 < e.length && this._scopeParent.SetFunctionParameters(e);
        h && (b ? m.PushCopySol(a) : m.PushCleanSol(a));
        b = l.Push(this);
        b.InitCallFunctionExpression(c, d);
        l.PushExpFunc(b);
        k.SetDebuggingEnabled(!1);
        this._CheckParentsOKToRun(b) && (b.SetCurrentEvent(this), (c = this._scopeParent.IsAsync()) && ([g, f] = this._scopeParent.StartAsyncFunctionCall()), this._RunAndBlock(b), c && this._scopeParent.MaybeFinishAsyncFunctionCall(g));
        k.SetDebuggingEnabled(!0);
        l.Pop();
        l.PopExpFunc();
        n && m.GetLocalVarStack().Pop();
        h && m.PopSol(a);
        m._DecTriggerDepth();
        return f || b.GetFunctionReturnValue()
    }
}
;
"use strict";
const C3$jscomp$163 = self.C3,
    EMPTY_SOL_MODIFIERS = [];
let hadUserScriptException = !1;
C3$jscomp$163.EventScript = class  extends C3$jscomp$163.DefendedBase{
    constructor(a, b, c)
    {
        super();
        const d = a.GetRuntime(),
            e = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = e;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._func = d.GetObjectReference(c[1]);
        this._displayNumber = c[2];
        this._eventSheet._RegisterEventByDisplayNumber(this, this._displayNumber);
        this._debugData = d.IsDebug() ? {
            isBreakpoint: c[3][0],
            isBreakable: c[3][1]
        } : null
    }
    static Create(a, b, c)
    {
        return C3$jscomp$163.New(C3$jscomp$163.EventScript,
        a, b, c)
    }
    _PostInit()
    {
        const a = this._func,
            b = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this);
        this._func = a.bind(null, this._runtime.GetIRuntime(), b)
    }
    GetParent()
    {
        return this._parent
    }
    GetScopeParent()
    {
        return this._parent
    }
    GetEventSheet()
    {
        return this._eventSheet
    }
    GetDisplayNumber()
    {
        return this._displayNumber
    }
    IsDebugBreakable()
    {
        return this._debugData && this._debugData.isBreakable
    }
    IsDebugBreakpoint()
    {
        return this.IsDebugBreakable() && this._debugData.isBreakpoint
    }
    _SetDebugBreakpoint(a)
    {
        this._debugData.isBreakpoint =
        !!a
    }
    IsElseBlock()
    {
        return !1
    }
    GetSolModifiers()
    {
        return EMPTY_SOL_MODIFIERS
    }
    GetSolModifiersIncludingParents()
    {
        return this._parent ? this._parent.GetSolModifiersIncludingParents() : EMPTY_SOL_MODIFIERS
    }
    Run(a)
    {
        a.SetCurrentEvent(this);
        this._eventSheetManager.AddAsyncActionPromise(this._RunUserScript())
    }
    async _RunUserScript()
    {
        try {
            await this._func()
        } catch (a) {
            console.error(`Unhandled exception running script %c${this.GetEventSheet().GetName()}, event ${this.GetDisplayNumber()}:`, "font-size: 1.2em; font-weight: bold;",
            a),
            self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
            hadUserScriptException || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), hadUserScriptException = !0)
        }
    }
    *DebugRun(a)
    {
        a.SetCurrentEvent(this);
        if (this.IsDebugBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        this.Run(a)
    }
    DebugCanRunFast()
    {
        return !this.IsDebugBreakpoint() && !this._runtime.DebugBreakNext()
    }
    static HadUserScriptException()
    {
        return hadUserScriptException
    }
    static SetHadUserScriptException()
    {
        hadUserScriptException =
        !0
    }
}
;
"use strict";
const C3$jscomp$164 = self.C3;
C3$jscomp$164.FunctionBlock = class  extends C3$jscomp$164.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._eventSheet = a;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._functionType = 0;
        this._functionName = "";
        this._returnType = 0;
        this._functionParameters = [];
        this._isEnabled = !0;
        this._aceName = "";
        this._objectClass = null;
        this._hasOverrides = !1;
        this._innerLocalVariables = [];
        this._isAsync = this._isCopyPicked = !1;
        this._nextAsyncId = 0;
        this._currentAsyncId = -1;
        this._asyncMap = new Map;
        this._eventBlock = C3$jscomp$164.EventBlock.Create(a,
        b, c);
        this._eventBlock._SetScopeParent(this)
    }
    InitFunctionBlock(a)
    {
        this._functionType = 0;
        this._functionName = a[0];
        this._returnType = a[1];
        this._functionParameters = a[2].map(b => C3$jscomp$164.EventVariable.Create(this._eventSheet, this, b));
        this._isEnabled = a[3];
        this._isAsync = a[4];
        this._isCopyPicked = a[5]
    }
    InitCustomACEBlock(a)
    {
        this._functionType = 1;
        this._aceName = a[1];
        this._objectClass = this._runtime.GetObjectClassByIndex(a[2]);
        this._eventBlock._AddSolModifier(this._objectClass);
        this._functionName = this._objectClass.GetName() +
        "." + this._aceName;
        this._returnType = a[3];
        this._functionParameters = a[4].map(b => C3$jscomp$164.EventVariable.Create(this._eventSheet, this, b));
        this._isEnabled = a[5];
        this._isAsync = a[6];
        this._isCopyPicked = a[7];
        this._objectClass.AddCustomAction(this)
    }
    static CreateFunctionBlock(a, b, c)
    {
        a = C3$jscomp$164.New(C3$jscomp$164.FunctionBlock, a, b, c);
        a.InitFunctionBlock(c[1]);
        return a
    }
    static CreateCustomACEBlock(a, b, c)
    {
        a = C3$jscomp$164.New(C3$jscomp$164.FunctionBlock, a, b, c);
        a.InitCustomACEBlock(c[1]);
        return a
    }
    _CheckOverrideState()
    {
        if (this._objectClass &&
        this._objectClass.IsFamily())
            for (const a of this._objectClass.GetFamilyMembers())
                if (a.HasOwnCustomActionByName(this._aceName)) {
                    this._hasOverrides = !0;
                    break
                }
    }
    _PostInit()
    {
        for (const a of this._functionParameters)
            a._PostInit();
        this._eventBlock._PostInit(!1)
    }
    GetFunctionType()
    {
        return this._functionType
    }
    _GetAllLocalVariablesInScope()
    {
        return this._functionParameters
    }
    GetFunctionParameters()
    {
        return this._functionParameters
    }
    GetFunctionParameterCount()
    {
        return this._functionParameters.length
    }
    _RegisterLocalVariable(a)
    {
        this._innerLocalVariables.push(a)
    }
    _GetAllInnerLocalVariables()
    {
        return this._innerLocalVariables
    }
    EvaluateFunctionParameters(a)
    {
        const b =
        this._functionParameters;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].SetValue(a[c].Get(0))
    }
    SetFunctionParameters(a)
    {
        const b = this._functionParameters;
        for (let c = 0, d = b.length; c < d; ++c)
            b[c].SetValue(a[c])
    }
    CaptureFunctionParameters()
    {
        return this._functionParameters.map(a => a.GetValue())
    }
    GetParent()
    {
        return this._parent
    }
    GetScopeParent()
    {
        return this._parent
    }
    GetFunctionName()
    {
        return this._functionName
    }
    GetACEName()
    {
        return this._aceName
    }
    HasCustomACEOverrides()
    {
        return this._hasOverrides
    }
    GetReturnType()
    {
        return this._returnType
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    IsEnabled()
    {
        return this._isEnabled
    }
    GetDefaultReturnValue()
    {
        switch (this._returnType) {
        case 0:
            return null;
        case 2:
            return "";
        default:
            return 0
        }
    }
    GetEventBlock()
    {
        return this._eventBlock
    }
    IsCopyPicked()
    {
        return this._isCopyPicked
    }
    IsAsync()
    {
        return this._isAsync
    }
    StartAsyncFunctionCall()
    {
        const a = this._nextAsyncId++;
        this._currentAsyncId = a;
        let b;
        const c = new Promise(d => b = d);
        this._asyncMap.set(a, {
            resolve: b,
            pauseCount: 0
        });
        return [a, c]
    }
    MaybeFinishAsyncFunctionCall(a)
    {
        const b = this._asyncMap.get(a);
        0 === b.pauseCount && (b.resolve(), this._asyncMap.delete(a));
        this._currentAsyncId = -1
    }
    PauseCurrentAsyncFunction()
    {
        this._asyncMap.get(this._currentAsyncId).pauseCount++;
        return this._currentAsyncId
    }
    ResumeAsyncFunction(a)
    {
        this._currentAsyncId = a;
        this._asyncMap.get(a).pauseCount--
    }
    RunAsFamilyCustomActionWithOverrides(a, b)
    {
        var c = new Map,
            d = [];
        for (const e of this._objectClass.GetCurrentSol().GetInstances()) {
            const f = e.GetObjectClass();
            if (f.HasOwnCustomActionByName(this._aceName)) {
                const g = c.get(f);
                Array.isArray(g) ? g.push(e) : c.set(f, [e])
            } else
                d.push(e)
        }
        0 < d.length && this._eventBlock.RunAsFunctionCall(a, b, this._isCopyPicked, {
            pickObjectClass: this._objectClass,
            pickInstances: d
        });
        if (0 < c.size)
            for (const [e, f] of c)
                c = e.GetOwnCustomActionByName(this._aceName).GetEventBlock(),
                d = [...(new Set([...a, ...c.GetSolModifiers()]))],
                c.RunAsFunctionCall(d, b, this._isCopyPicked, {
                    pickObjectClass: e,
                    pickInstances: f
                })
    }
    *DebugRunAsFamilyCustomActionWithOverrides(a, b)
    {
        var c = new Map,
            d = [];
        for (const e of this._objectClass.GetCurrentSol().GetInstances()) {
            const f = e.GetObjectClass();
            if (f.HasOwnCustomActionByName(this._aceName)) {
                const g = c.get(f);
                Array.isArray(g) ? g.push(e) : c.set(f, [e])
            } else
                d.push(e)
        }
        0 < d.length &&
        (yield *this._eventBlock.DebugRunAsFunctionCall(a, b, this._isCopyPicked, {
            pickObjectClass: this._objectClass,
            pickInstances: d
        }));
        if (0 < c.size)
            for (const [e, f] of c)
                c = e.GetOwnCustomActionByName(this._aceName).GetEventBlock(),
                d = [...(new Set([...a, ...c.GetSolModifiers()]))],
                yield *c.DebugRunAsFunctionCall(d, b, this._isCopyPicked, {
                    pickObjectClass: e,
                    pickInstances: f
                })
    }
}
;
"use strict";
const C3$jscomp$165 = self.C3,
    EMPTY_SOL_MODIFIERS$jscomp$1 = [];
C3$jscomp$165.EventVariable = class  extends C3$jscomp$165.DefendedBase{
    constructor(a, b, c)
    {
        super();
        const d = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = d;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._localVarStack = d.GetLocalVarStack();
        this._name = c[1];
        this._type = c[2];
        this._initialValue = c[3];
        this._isStatic = !!c[4];
        this._isConstant = !!c[5];
        this._isFunctionParameter = b instanceof C3$jscomp$165.FunctionBlock;
        this._sid = c[6];
        this._jsPropName = this._runtime.GetJsPropName(c[8]);
        this._scriptSetter =
        e => this.SetValue(e);
        this._scriptGetter = () => this.GetValue();
        this._hasSingleValue = !this._parent || this._isStatic || this._isConstant;
        this._value = this._initialValue;
        this._localIndex = -1;
        this.IsBoolean() && (this._value = this._value ? 1 : 0);
        !this.IsLocal() || this.IsStatic() || this.IsConstant() || (this._localIndex = d._GetNextLocalVarIndex(this));
        d._RegisterEventVariable(this)
    }
    static Create(a, b, c)
    {
        return C3$jscomp$165.New(C3$jscomp$165.EventVariable, a, b, c)
    }
    _PostInit()
    {
        if (this.IsLocal() && !this.IsStatic() && !this.IsConstant() &&
        !this.IsFunctionParameter()) {
            const a = this._eventSheetManager.FindFirstFunctionBlockParent(this);
            a && a._RegisterLocalVariable(this)
        }
    }
    GetName()
    {
        return this._name
    }
    GetJsPropName()
    {
        return this._jsPropName
    }
    GetParent()
    {
        return this._parent
    }
    GetScopeParent()
    {
        return this.GetParent()
    }
    IsGlobal()
    {
        return !this.GetParent()
    }
    IsLocal()
    {
        return !this.IsGlobal()
    }
    IsFunctionParameter()
    {
        return this._isFunctionParameter
    }
    IsStatic()
    {
        return this._isStatic
    }
    IsConstant()
    {
        return this._isConstant
    }
    IsNumber()
    {
        return 0 === this._type
    }
    IsString()
    {
        return 1 ===
        this._type
    }
    IsBoolean()
    {
        return 2 === this._type
    }
    IsElseBlock()
    {
        return !1
    }
    GetSID()
    {
        return this._sid
    }
    GetInitialValue()
    {
        return this._initialValue
    }
    GetSolModifiers()
    {
        return EMPTY_SOL_MODIFIERS$jscomp$1
    }
    Run(a)
    {
        !this.IsLocal() || this.IsStatic() || this.IsConstant() || this.SetValue(this.GetInitialValue())
    }
    DebugCanRunFast()
    {
        return !0
    }
    *DebugRun(a)
    {
        this.Run(a)
    }
    SetValue(a)
    {
        this.IsNumber() ? "number" !== typeof a && (a = parseFloat(a)) : this.IsString() ? "string" !== typeof a && (a = a.toString()) : this.IsBoolean() && (a = a ? 1 : 0);
        this._hasSingleValue ?
        this._value = a : this._localVarStack.GetCurrent()[this._localIndex] = a
    }
    GetValue()
    {
        return this._hasSingleValue ? this._value : this._localVarStack.GetCurrent()[this._localIndex]
    }
    GetTypedValue()
    {
        let a = this.GetValue();
        this.IsBoolean() && (a = !!a);
        return a
    }
    ResetToInitialValue()
    {
        this._value = this._initialValue
    }
    _GetScriptInterfaceDescriptor()
    {
        return {
            configurable: !1,
            enumerable: !0,
            get: this._scriptGetter,
            set: this._scriptSetter
        }
    }
}
;
"use strict";
const C3$jscomp$166 = self.C3,
    EMPTY_SOL_MODIFIERS$jscomp$2 = [];
C3$jscomp$166.EventInclude = class  extends C3$jscomp$166.DefendedBase{
    constructor(a, b, c)
    {
        super();
        const d = a.GetEventSheetManager();
        this._eventSheet = a;
        this._eventSheetManager = d;
        this._runtime = a.GetRuntime();
        this._parent = b;
        this._includeSheet = null;
        this._includeSheetName = c[1];
        this._isActive = !0
    }
    static Create(a, b, c)
    {
        return C3$jscomp$166.New(C3$jscomp$166.EventInclude, a, b, c)
    }
    _PostInit()
    {
        this._includeSheet = this._eventSheetManager.GetEventSheetByName(this._includeSheetName);
        this._eventSheet._AddShallowInclude(this);
        let a = this.GetParent();
        for (; a;)
            a instanceof C3$jscomp$166.EventBlock && a.IsGroup() && a._AddContainedInclude(this),
            a = a.GetParent();
        this.UpdateActive();
        this._runtime.IsDebug() && this._eventSheet._GetPerfRecord().children.push(this._includeSheet._GetPerfRecord())
    }
    GetParent()
    {
        return this._parent
    }
    GetSolModifiers()
    {
        return EMPTY_SOL_MODIFIERS$jscomp$2
    }
    GetIncludeSheet()
    {
        return this._includeSheet
    }
    Run(a)
    {
        a = !!this.GetParent();
        const b = this._runtime.GetAllObjectClasses();
        a && this._eventSheetManager.PushCleanSol(b);
        this._includeSheet.Run();
        a && this._eventSheetManager.PopSol(b)
    }
    *DebugRun(a)
    {
        a = !!this.GetParent();
        const b = this._runtime.GetAllObjectClasses();
        a && this._eventSheetManager.PushCleanSol(b);
        yield *this._includeSheet.DebugRun();
        a && this._eventSheetManager.PopSol(b)
    }
    DebugCanRunFast()
    {
        return !1
    }
    IsActive()
    {
        return this._isActive
    }
    UpdateActive()
    {
        let a = this.GetParent();
        for (; a;) {
            if (a instanceof C3$jscomp$166.EventBlock && a.IsGroup() && !a.IsGroupActive()) {
                this._isActive = !1;
                return
            }
            a = a.GetParent()
        }
        this._isActive = !0
    }
}
;
"use strict";
const C3$jscomp$167 = self.C3;
C3$jscomp$167.ExpNode = class  extends C3$jscomp$167.DefendedBase{
    constructor(a)
    {
        super();
        this._owner = a;
        this._runtime = a.GetRuntime()
    }
    _PostInit() {}
    static CreateNode(a, b)
    {
        return C3$jscomp$167.New([BehaviorExpressionNode, ObjectExpressionNode, InstVarExpressionNode, EventVarExpNode, SystemExpressionExpNode, CallFunctionExpressionExpNode][b[0]], a, b)
    }
}
;
class SystemExpressionExpNode extends C3$jscomp$167.ExpNode {
    constructor(a, b)
    {
        super(a);
        this._systemPlugin = this._runtime.GetSystemPlugin();
        this._func = this._runtime.GetObjectReference(b[1]);
        this._func !== C3$jscomp$167.Plugins.System.Exps.random && this._func !== C3$jscomp$167.Plugins.System.Exps.choose || this._owner.SetVariesPerInstance()
    }
    GetBoundMethod()
    {
        return this._systemPlugin._GetBoundACEMethod(this._func, this._systemPlugin)
    }
}
class CallFunctionExpressionExpNode extends C3$jscomp$167.ExpNode {
    constructor(a, b)
    {
        super(a);
        this._functionBlock = null;
        this._functionName = b[1];
        this._owner.SetVariesPerInstance()
    }
    _PostInit()
    {
        const a = this._runtime.GetEventSheetManager();
        this._functionBlock = a.GetFunctionBlockByName(this._functionName);
        this._functionName = null;
        const b = this._owner.GetEventBlock(),
            c = this._functionBlock.GetEventBlock();
        this._combinedSolModifiers = [...(new Set([...b.GetSolModifiersIncludingParents(), ...c.GetSolModifiersIncludingParents()]))];
        this._combinedSolModifiers = a._DeduplicateSolModifierList(this._combinedSolModifiers)
    }
    GetBoundMethod()
    {
        const a = this._functionBlock;
        if (a.IsEnabled()) {
            const c = a.GetEventBlock();
            return C3$jscomp$167.EventBlock.prototype.RunAsExpressionFunctionCall.bind(c, this._combinedSolModifiers, a.IsCopyPicked(), a.GetReturnType(), a.GetDefaultReturnValue())
        }
        const b = a.GetDefaultReturnValue();
        return () => b
    }
}
function WrapIndex(a, b) {
    if (a >= b)
        return a % b;
    0 > a && (a <= -b && (a %= b), 0 > a && (a += b));
    return a
}
class ObjectExpressionNode extends C3$jscomp$167.ExpNode {
    constructor(a, b)
    {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._func = this._runtime.GetObjectReference(b[2]);
        this._returnsString = !!b[3];
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._owner._MaybeVaryFor(this._objectClass)
    }
    GetBoundMethod()
    {
        return this._objectClass.GetPlugin()._GetBoundACEMethod(this._func, this._objectClass.GetSingleGlobalInstance().GetSdkInstance())
    }
    ExpObject(...a)
    {
        const b =
            this._objectClass,
            c = b.GetCurrentSol().GetExpressionInstances();
        var d = c.length;
        if (0 === d)
            return this._returnsString ? "" : 0;
        d = WrapIndex(this._owner.GetSolIndex(), d);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(b);
        return this._func.apply(c[d].GetSdkInstance(), a)
    }
    ExpObject_InstExpr(a, ...b)
    {
        const c = this._objectClass,
            d = c.GetInstances(),
            e = d.length;
        if (0 === e)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, e);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(c);
        return this._func.apply(d[a].GetSdkInstance(),
        b)
    }
}
class InstVarExpressionNode extends C3$jscomp$167.ExpNode {
    constructor(a, b)
    {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._varIndex = b[3];
        this._returnsString = !!b[2];
        this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpInstVar()
    {
        const a = this._objectClass.GetCurrentSol().GetExpressionInstances();
        var b = a.length;
        if (0 === b)
            return this._returnsString ? "" : 0;
        b = WrapIndex(this._owner.GetSolIndex(), b);
        return a[b]._GetInstanceVariableValueUnchecked(this._varIndex)
    }
    ExpInstVar_Family()
    {
        var a = this._objectClass,
            b = a.GetCurrentSol().GetExpressionInstances(),
            c = b.length;
        if (0 === c)
            return this._returnsString ? "" : 0;
        c = WrapIndex(this._owner.GetSolIndex(), c);
        b = b[c];
        a = b.GetObjectClass().GetFamilyInstanceVariableOffset(a.GetFamilyIndex());
        return b._GetInstanceVariableValueUnchecked(this._varIndex + a)
    }
    ExpInstVar_InstExpr(a)
    {
        const b = this._objectClass;
        var c = b.GetInstances();
        const d = c.length;
        if (0 === d)
            return this._returnsString ? "" : 0;
        a = WrapIndex(a, d);
        c = c[a];
        a = 0;
        b.IsFamily() && (a = c.GetObjectClass().GetFamilyInstanceVariableOffset(b.GetFamilyIndex()));
        return c._GetInstanceVariableValueUnchecked(this._varIndex + a)
    }
}
class BehaviorExpressionNode extends C3$jscomp$167.ExpNode {
    constructor(a, b)
    {
        super(a);
        this._objectClass = this._runtime.GetObjectClassByIndex(b[1]);
        this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]);
        this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2]);
        this._func = this._runtime.GetObjectReference(b[3]);
        this._returnsString = !!b[4];
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._owner._MaybeVaryFor(this._objectClass)
    }
    ExpBehavior(...a)
    {
        const b = this._objectClass;
        var c = b.GetCurrentSol().GetExpressionInstances(),
            d = c.length;
        if (0 === d)
            return this._returnsString ? "" : 0;
        d = WrapIndex(this._owner.GetSolIndex(), d);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(b);
        c = c[d];
        d = 0;
        b.IsFamily() && (d = c.GetObjectClass().GetFamilyBehaviorOffset(b.GetFamilyIndex()));
        return this._func.apply(c.GetBehaviorInstances()[this._behaviorIndex + d].GetSdkInstance(), a)
    }
    ExpBehavior_InstExpr(a, ...b)
    {
        const c = this._objectClass;
        var d = c.GetInstances();
        const e = d.length;
        if (0 === e)
            return this._returnsString ?
            "" : 0;
        a = WrapIndex(a, e);
        this._eventStack.GetCurrentStackFrame().SetExpressionObjectClass(c);
        d = d[a];
        a = 0;
        c.IsFamily() && (a = d.GetObjectClass().GetFamilyBehaviorOffset(c.GetFamilyIndex()));
        return this._func.apply(d.GetBehaviorInstances()[this._behaviorIndex + a].GetSdkInstance(), b)
    }
}
class EventVarExpNode extends C3$jscomp$167.ExpNode {
    constructor(a, b)
    {
        super(a);
        this._eventVar = null;
        this._eventVarSid = b[1]
    }
    _PostInit()
    {
        this._eventVar = this._runtime.GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetVar()
    {
        return this._eventVar
    }
}
"use strict";
const C3$jscomp$168 = self.C3;
C3$jscomp$168.Parameter = class  extends C3$jscomp$168.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._owner = a;
        this._index = c;
        this._type = b;
        this.Get = null;
        this._isConstant = this._variesPerInstance = !1
    }
    static Create(a, b, c)
    {
        const d = b[0];
        return C3$jscomp$168.New([ExpressionParameter, StringExpressionParameter, FileParameter, ComboParameter, ObjectParameter, LayerExpressionParameter, LayoutParameter, ExpressionParameter, ComboParameter, ComboParameter, InstVarParameter, EventVarParameter, FileParameter, VariadicParameter, StringExpressionParameter,
        TimelineParameter, BooleanParameter, FunctionParameter, EaseParameter, TilemapBrushParameter, TemplateExpressionParameter, FlowchartParameter][d], a, d, c, b)
    }
    _PostInit() {}
    SetVariesPerInstance()
    {
        this._variesPerInstance = !0
    }
    _MaybeVaryFor(a)
    {
        this._variesPerInstance || !a || a.GetPlugin().IsSingleGlobal() || (this._variesPerInstance = !0)
    }
    VariesPerInstance()
    {
        return this._variesPerInstance
    }
    GetIndex()
    {
        return this._index
    }
    GetRuntime()
    {
        return this._owner.GetRuntime()
    }
    GetEventBlock()
    {
        return this._owner.GetEventBlock()
    }
    IsConstant()
    {
        return this._isConstant
    }
    IsObjectParameter()
    {
        return 4 ===
        this._type
    }
}
;
function GetExpressionFunc(a) {
    a = self.C3_ExpressionFuncs[a];
    if (!a)
        throw Error("invalid expression number");
    return a
}
class ExpressionParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._solIndex = 0;
        a = d[1];
        this._expressionNumber = a[0];
        this._numberedNodes = [];
        this._expressionFunc = null;
        for (let e = 1, f = a.length; e < f; ++e)
            this._numberedNodes.push(C3$jscomp$168.ExpNode.CreateNode(this, a[e]));
        this._numberedNodes.length ? this.Get = this.GetExpression : (this.Get = GetExpressionFunc(this._expressionNumber), this._isConstant = !0)
    }
    _GetNode(a)
    {
        if (0 > a || a >= this._numberedNodes.length)
            throw new RangeError("invalid numbered node");
        return this._numberedNodes[a]
    }
    _PostInit()
    {
        for (var a of this._numberedNodes)
            a._PostInit();
        a = GetExpressionFunc(this._expressionNumber);
        this._expressionFunc = this._numberedNodes.length ? a(this) : a
    }
    GetSolIndex()
    {
        return this._solIndex
    }
    GetExpression(a)
    {
        this._solIndex = a;
        return this._expressionFunc()
    }
}
class StringExpressionParameter extends ExpressionParameter {
    constructor(a, b, c, d)
    {
        super(a, b, c, d);
        this.Get = this.GetStringExpression;
        14 === b && (this.GetEventBlock().SetAllSolModifiers(), this._owner instanceof C3$jscomp$168.Action && this.GetEventBlock().SetSolWriterAfterCnds())
    }
    GetStringExpression(a)
    {
        this._solIndex = a;
        a = this._expressionFunc();
        return "string" === typeof a ? a : ""
    }
    _GetFastTriggerValue()
    {
        return GetExpressionFunc(this._expressionNumber)()
    }
}
class LayerExpressionParameter extends ExpressionParameter {
    constructor(a, b, c, d)
    {
        super(a, b, c, d);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetILayer : this.Get = this.GetLayer;
        this._isConstant = !1
    }
    GetLayer(a)
    {
        this._solIndex = a;
        a = this._expressionFunc();
        return this.GetRuntime().GetCurrentLayout().GetLayer(a)
    }
    GetILayer(a)
    {
        return (a = this.GetLayer()) ? a.GetILayer() : null
    }
}
class ComboParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._combo = d[1];
        this.Get = this.GetCombo;
        this._isConstant = !0
    }
    GetCombo()
    {
        return this._combo
    }
}
class BooleanParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._bool = d[1];
        this.Get = this.GetBoolean;
        this._isConstant = !0
    }
    GetBoolean()
    {
        return this._bool
    }
}
class ObjectParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._objectClass = this.GetRuntime().GetObjectClassByIndex(d[1]);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetIObjectClass : this.Get = this.GetObjectClass;
        a = this.GetEventBlock();
        a._AddSolModifier(this._objectClass);
        this._owner instanceof C3$jscomp$168.Action ? a.SetSolWriterAfterCnds() : a.GetParent() && a.GetParent().SetSolWriterAfterCnds();
        this._isConstant = !0
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetIObjectClass()
    {
        return this._objectClass ?
        this._objectClass.GetIObjectClass() : null
    }
}
class LayoutParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._layout = this.GetRuntime().GetLayoutManager().GetLayoutByName(d[1]);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetILayout : this.Get = this.GetLayout;
        this._isConstant = !0
    }
    GetLayout()
    {
        return this._layout
    }
    GetILayout()
    {
        return this._layout ? this._layout.GetILayout() : null
    }
}
class TimelineParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._timeline = this.GetRuntime().GetTimelineManager().GetTimelineByName(d[1]);
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetITimelineState : this.Get = this.GetTimeline;
        this._isConstant = !0
    }
    GetTimeline()
    {
        return this._timeline
    }
    GetITimelineState()
    {
        return this._timeline ? this._timeline.GetITimelineState() : null
    }
}
class FileParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._fileInfo = d[1];
        this.Get = this.GetFile;
        this._isConstant = !0
    }
    GetFile()
    {
        return this._fileInfo
    }
}
class InstVarParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._instVarIndex = d[1];
        a = this._owner.GetObjectClass();
        this._owner instanceof C3$jscomp$168.Condition && this._owner.IsStatic() ? (this.Get = this.GetInstanceVariable, this._isConstant = !0) : a && a.IsFamily() ? (this.Get = this.GetFamilyInstanceVariable, this.SetVariesPerInstance()) : (this.Get = this.GetInstanceVariable, this._isConstant = !0)
    }
    GetInstanceVariable()
    {
        return this._instVarIndex
    }
    GetFamilyInstanceVariable(a)
    {
        a = a || 0;
        const b =
        this._owner.GetObjectClass();
        var c = b.GetCurrentSol();
        const d = c.GetInstances();
        if (d.length)
            a = d[a % d.length].GetObjectClass();
        else if (c.HasAnyElseInstances())
            c = c.GetElseInstances(),
            a = c[a % c.length].GetObjectClass();
        else if (0 < b.GetInstanceCount())
            c = b.GetInstances(),
            a = c[a % c.length].GetObjectClass();
        else
            return 0;
        return this._instVarIndex + a.GetFamilyInstanceVariableOffset(b.GetFamilyIndex())
    }
}
class EventVarParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._eventVarSid = d[1];
        this._eventVar = null;
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetIEventVariable : this.Get = this.GetEventVariable;
        this._isConstant = !0
    }
    _PostInit()
    {
        this._eventVar = this.GetRuntime().GetEventSheetManager().GetEventVariableBySID(this._eventVarSid)
    }
    GetEventVariable()
    {
        return this._eventVar
    }
    GetIEventVariable()
    {
        return null
    }
}
class FunctionParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._functionBlockName = d[1];
        this._functionBlock = null;
        2 <= a.GetImplementationSdkVersion() ? this.Get = this.GetIFunction : this.Get = this.GetFunction;
        this._isConstant = !0
    }
    _PostInit()
    {
        this._functionBlock = this.GetRuntime().GetEventSheetManager().GetFunctionBlockByName(this._functionBlockName);
        this._functionBlockName = null
    }
    GetFunction()
    {
        return this._functionBlock
    }
    GetIFunction()
    {
        return null
    }
}
class VariadicParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._subParams = [];
        this._variadicRet = [];
        this._isConstant = !0;
        for (let e = 1, f = d.length; e < f; ++e)
            a = C3$jscomp$168.Parameter.Create(this._owner, d[e], 0),
            this._subParams.push(a),
            this._variadicRet.push(0),
            a.IsConstant() || (this._isConstant = !1);
        this.Get = this.GetVariadic
    }
    _PostInit()
    {
        for (const a of this._subParams)
            a._PostInit()
    }
    GetVariadic()
    {
        const a = this._subParams,
            b = this._variadicRet;
        for (let c = 0, d = a.length; c < d; ++c)
            b[c] = a[c].Get(0);
        return b
    }
}
class EaseParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._easeIndex = d[1];
        this.Get = this.GetEase;
        this._isConstant = !0
    }
    GetEase()
    {
        return this._easeIndex
    }
}
class TilemapBrushParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._brushIndex = d[1];
        this.Get = this.GetTilemapBrush;
        this._isConstant = !0
    }
    GetTilemapBrush()
    {
        return this._brushIndex
    }
}
class TemplateExpressionParameter extends ExpressionParameter {
    constructor(a, b, c, d)
    {
        super(a, b, c, d);
        this.Get = this.GetTemplateName;
        this._isConstant = !1
    }
    GetTemplateName()
    {
        return this._expressionFunc()
    }
}
class FlowchartParameter extends C3$jscomp$168.Parameter {
    constructor(a, b, c, d)
    {
        super(a, b, c);
        this._flowchartDataItem = this.GetRuntime().GetFlowchartManager().GetFlowchartDataItemByName(d[1]);
        this.Get = this.GetFlowchartName;
        this._isConstant = !0
    }
    GetFlowchartName()
    {
        return this._flowchartDataItem.GetName()
    }
}
"use strict";
const C3$jscomp$169 = self.C3;
function EvalParams(a, b) {
    for (let c = 0, d = a.length; c < d; ++c)
        b[c] = a[c].Get(0)
}
const EMPTY_PARAMS_ARRAY = [],
    noop$jscomp$1 = function() {};
C3$jscomp$169.Condition = class  extends C3$jscomp$169.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._eventBlock = a;
        this._runtime = a.GetRuntime();
        this._index = c;
        this._func = this._runtime.GetObjectReference(b[1]);
        this._isTrigger = 0 < b[3];
        this._isFastTrigger = 2 === b[3];
        this._isLooping = !!b[4];
        this._isInverted = !!b[5];
        this._isStatic = !!b[6];
        this._sid = b[7];
        this._isInOrBlock = this._eventBlock.IsOrBlock();
        this._behaviorType = this._objectClass = null;
        this._behaviorIndex = -1;
        this._systemPlugin = null;
        this.DebugRun = this.Run = noop$jscomp$1;
        this._parameters = [];
        this._results = [];
        this._anyParamVariesPerInstance = !1;
        this._unsavedData = this._savedData = null;
        this._debugData = this._runtime.IsDebug() ? {
            isBreakpoint: b[8][0],
            canDebug: b[8][1]
        } : null;
        -1 === b[0] ? this._systemPlugin = this._runtime.GetSystemPlugin() : (this._objectClass = this._runtime.GetObjectClassByIndex(b[0]), b[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2])), this._eventBlock.GetParent() && this._eventBlock.GetParent().SetSolWriterAfterCnds());
        if (10 === b.length) {
            a = b[9];
            for (let d of a)
                this._parameters.push(C3$jscomp$169.Parameter.Create(this, d, this._parameters.length)),
                this._results.push(0)
        }
        0 === this._parameters.length && (this._results = this._parameters = EMPTY_PARAMS_ARRAY);
        this._eventBlock.GetEventSheetManager()._RegisterCondition(this)
    }
    static Create(a, b, c)
    {
        return C3$jscomp$169.New(C3$jscomp$169.Condition, a, b, c)
    }
    _PostInit()
    {
        for (const a of this._parameters)
            a._PostInit(),
            a.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
        this._isFastTrigger ?
        (this.Run = this._RunFastTrigger, this.DebugRun = this._DebugRunFastTrigger) : this._systemPlugin ? (this._SetSystemRunMethod(), this.DebugRun = this._DebugRunSystem) : this._objectClass.GetPlugin().IsSingleGlobal() ? (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this._isStatic ? (this.Run = this._RunStatic, this.DebugRun = this._DebugRunStatic) : (this.Run = this._RunObject, this.DebugRun = this._DebugRunObject)
    }
    _SetSystemRunMethod()
    {
        this._SetRunMethodForBoundFunc(this._systemPlugin, this._systemPlugin,
        this._RunSystem)
    }
    _SetSingleGlobalRunMethod()
    {
        const a = this._objectClass.GetPlugin(),
            b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        this._SetRunMethodForBoundFunc(a, b, this._RunSingleGlobal)
    }
    _SetRunMethodForBoundFunc(a, b, c)
    {
        const d = this._func,
            e = this._isInverted,
            f = this._parameters;
        if (0 === f.length) {
            const g = a._GetBoundACEMethod(d, b);
            this.Run = e ? function() {
                return C3$jscomp$169.xor(g(), e)
            } : g
        } else if (1 === f.length) {
            const g = f[0];
            if (!e && g.IsConstant())
                this.Run = a._GetBoundACEMethod_1param(d, b, g.Get(0));
            else {
                const h = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return C3$jscomp$169.xor(h(g.Get(0)), e)
                }
            }
        } else if (2 === f.length) {
            const g = f[0],
                h = f[1];
            if (!e && g.IsConstant() && h.IsConstant())
                this.Run = a._GetBoundACEMethod_2params(d, b, g.Get(0), h.Get(0));
            else {
                const k = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return C3$jscomp$169.xor(k(g.Get(0), h.Get(0)), e)
                }
            }
        } else if (3 === f.length) {
            const g = f[0],
                h = f[1],
                k = f[2];
            if (!e && g.IsConstant() && h.IsConstant() && k.IsConstant())
                this.Run = a._GetBoundACEMethod_3params(d, b, g.Get(0),
                h.Get(0), k.Get(0));
            else {
                const l = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return C3$jscomp$169.xor(l(g.Get(0), h.Get(0), k.Get(0)), e)
                }
            }
        } else
            this.Run = c
    }
    GetSID()
    {
        return this._sid
    }
    _GetFunc()
    {
        return this._func
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetBehaviorType()
    {
        return this._behaviorType
    }
    GetImplementationAddon()
    {
        return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null
    }
    GetImplementationSdkVersion()
    {
        const a = this.GetImplementationAddon();
        return a ?
        a.GetSdkVersion() : 1
    }
    GetEventBlock()
    {
        return this._eventBlock
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetIndex()
    {
        return this._index
    }
    GetDebugIndex()
    {
        return this.GetIndex()
    }
    IsTrigger()
    {
        return this._isTrigger
    }
    IsFastTrigger()
    {
        return this._isFastTrigger
    }
    IsInverted()
    {
        return this._isInverted
    }
    IsLooping()
    {
        return this._isLooping
    }
    IsStatic()
    {
        return this._isStatic
    }
    IsBreakpoint()
    {
        return this._debugData.isBreakpoint
    }
    IsSystemCondition()
    {
        return !!this._systemPlugin
    }
    IsSystemOrSingleGlobalCondition()
    {
        return this.IsSystemCondition() ||
            this._objectClass.GetPlugin().IsSingleGlobal()
    }
    GetFirstObjectParameterObjectClass()
    {
        for (const a of this._parameters)
            if (a.IsObjectParameter())
                return a.GetObjectClass();
        return null
    }
    _SetBreakpoint(a)
    {
        this._debugData.isBreakpoint = !!a;
        this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator()
    {
        return this._debugData.canDebug
    }
    DebugCanRunFast()
    {
        return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() && !this._DebugReturnsGenerator()
    }
    GetSavedDataMap()
    {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap()
    {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    _RunSystem()
    {
        const a = this._results;
        EvalParams(this._parameters, a);
        return C3$jscomp$169.xor(this._func.apply(this._systemPlugin, a), this._isInverted)
    }
    *_DebugRunSystem()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            a = this._func.apply(this._systemPlugin, a);
            C3$jscomp$169.IsIterator(a) &&
            (a = yield *a);
            return C3$jscomp$169.xor(a, this._isInverted)
        }
        return this.Run()
    }
    _RunSingleGlobal()
    {
        const a = this._results;
        EvalParams(this._parameters, a);
        const b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        return C3$jscomp$169.xor(this._func.apply(b, a), this._isInverted)
    }
    *_DebugRunSingleGlobal()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            const b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
            a = this._func.apply(b, a);
            C3$jscomp$169.IsIterator(a) && (a = yield *a);
            return C3$jscomp$169.xor(a, this._isInverted)
        }
        return this.Run()
    }
    _RunFastTrigger()
    {
        return !0
    }
    *_DebugRunFastTrigger()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return !0
    }
    _GetStaticConditionThis()
    {
        if (this._behaviorType) {
            if (2 <= this._behaviorType.GetBehavior().GetSdkVersion())
                throw Error("not yet implemented");
            return this._behaviorType
        }
        return 2 <= this._objectClass.GetPlugin().GetSdkVersion() ? this._objectClass.GetIObjectClass() :
        this._objectClass
    }
    _RunStatic()
    {
        var a = this._results;
        EvalParams(this._parameters, a);
        a = this._func.apply(this._GetStaticConditionThis(), a);
        this._objectClass.ApplySolToContainer();
        return a
    }
    *_DebugRunStatic()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams(this._parameters, a);
            a = this._func.apply(this._GetStaticConditionThis(), a);
            C3$jscomp$169.IsIterator(a) && (a = yield *a);
            this._objectClass.ApplySolToContainer();
            return a
        }
        return this.Run()
    }
    _RunObject()
    {
        const a =
            this._parameters,
            b = this._results,
            c = this._objectClass.GetCurrentSol();
        for (let d = 0, e = a.length; d < e; ++d) {
            const f = a[d];
            f.VariesPerInstance() || (b[d] = f.Get(0))
        }
        return c.IsSelectAll() ? this._RunObject_FirstFilter(c) : this._RunObject_NextFilter(c)
    }
    *_DebugRunObject()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return this._RunObject()
    }
    _EvaluateVaryingParameters(a)
    {
        const b = this._parameters,
            c = this._results;
        for (let d = 0, e = b.length; d < e; ++d) {
            const f = b[d];
            f.VariesPerInstance() && (c[d] = f.Get(a))
        }
    }
    _RunObject_FirstFilter(a)
    {
        const b =
            this._objectClass,
            c = b.IsFamily(),
            d = b.GetFamilyIndex(),
            e = this._behaviorIndex,
            f = 0 <= e,
            g = b.GetInstances(),
            h = this._anyParamVariesPerInstance,
            k = this._results,
            l = this._func,
            m = this._isInverted,
            n = this._isInOrBlock && !this._isTrigger;
        a.ClearArrays();
        for (let q = 0, r = g.length; q < r; ++q) {
            const t = g[q];
            h && this._EvaluateVaryingParameters(q);
            var p = void 0;
            f ? (p = c ? t.GetObjectClass().GetFamilyBehaviorOffset(d) : 0, p = l.apply(t.GetBehaviorInstances()[e + p].GetSdkInstance(), k)) : p = l.apply(t.GetSdkInstance(), k);
            C3$jscomp$169.xor(p,
            m) ? a._PushInstance(t) : n && a._PushElseInstance(t)
        }
        b.FinishCondition(!0);
        a._SetSelectAll(!1);
        b.ApplySolToContainer();
        return a.HasAnyInstances()
    }
    _RunObject_NextFilter(a)
    {
        const b = this._objectClass;
        var c = b.IsFamily();
        const d = b.GetFamilyIndex(),
            e = b.IsInContainer(),
            f = this._behaviorIndex,
            g = 0 <= f,
            h = this._anyParamVariesPerInstance,
            k = this._results,
            l = this._func,
            m = this._isInverted,
            n = this._isInOrBlock && !this._isTrigger,
            p = a._GetOwnInstances(),
            q = a._GetOwnElseInstances(),
            r = n && !this._eventBlock.IsFirstConditionOfType(this),
            t = r ? q : p;
        let u = 0,
            v = !1;
        for (let x = 0, y = t.length; x < y; ++x) {
            const z = t[x];
            h && this._EvaluateVaryingParameters(x);
            var w = void 0;
            g ? (w = c ? z.GetObjectClass().GetFamilyBehaviorOffset(d) : 0, w = l.apply(z.GetBehaviorInstances()[f + w].GetSdkInstance(), k)) : w = l.apply(z.GetSdkInstance(), k);
            C3$jscomp$169.xor(w, m) ? (v = !0, r ? (p.push(z), e && z._PushSiblingsToSolInstances()) : (t[u] = z, e && z._SetSiblingsToSolInstancesIndex(u), ++u)) : r ? (t[u] = z, e && z._SetSiblingsToSolElseInstancesIndex(u), ++u) : n && (q.push(z), e && z._PushSiblingsToSolElseInstances())
        }
        C3$jscomp$169.truncateArray(t,
        u);
        e && b._TruncateContainerSols(r, u);
        c = v;
        r && !v && (v = this._OrBlockCheckInstances(p));
        b.FinishCondition(c || n);
        return n ? v : a.HasAnyInstances()
    }
    _OrBlockCheckInstances(a)
    {
        var b = this._objectClass;
        const c = b.IsFamily();
        b = b.GetFamilyIndex();
        const d = this._anyParamVariesPerInstance,
            e = this._behaviorIndex,
            f = 0 <= e,
            g = this._results,
            h = this._func,
            k = this._isInverted;
        for (let m = 0, n = a.length; m < n; ++m) {
            var l = a[m];
            d && this._EvaluateVaryingParameters(m);
            if (f) {
                const p = c ? l.GetObjectClass().GetFamilyBehaviorOffset(b) : 0;
                l = h.apply(l.GetBehaviorInstances()[e +
                p].GetSdkInstance(), g)
            } else
                l = h.apply(l.GetSdkInstance(), g);
            if (C3$jscomp$169.xor(l, k))
                return !0
        }
        return !1
    }
    ReevaluateParameter(a, b)
    {
        return this._parameters[a].Get(b)
    }
    GetFastTriggerValue()
    {
        const a = this._parameters;
        if (!a.length)
            throw Error("no parameters");
        return a[0]._GetFastTriggerValue()
    }
    _SaveToJson()
    {
        if (!this._savedData || !this._savedData.size)
            return null;
        const a = {};
        for (const [b, c] of this._savedData.entries()) {
            let d = c;
            "collmemory" === b && (d = [...c.entries()].map(e => [e[0].GetUID(), e[1].GetUID(), e[2]]));
            a[b] = d
        }
        return {
            ex: a
        }
    }
    _LoadFromJson(a)
    {
        this._savedData && (this._savedData.clear(), this._savedData = null);
        if (a) {
            var b = this._runtime,
                c = a.ex;
            if (c) {
                a = this.GetSavedDataMap();
                a.clear();
                for (const [d, e] of Object.entries(c))
                    c = e,
                    "collmemory" === d && (c = C3$jscomp$169.New(C3$jscomp$169.PairMap, e.map(f => [b.GetInstanceByUID(f[0]), b.GetInstanceByUID(f[1]), f[2]]).filter(f => f[0] && f[1]))),
                    a.set(d, c)
            }
        }
    }
}
;
"use strict";
const C3$jscomp$170 = self.C3;
function EvalParams$jscomp$1(a, b) {
    for (let c = 0, d = a.length; c < d; ++c)
        b[c] = a[c].Get(0)
}
const EMPTY_PARAMS_ARRAY$jscomp$1 = [],
    noop$jscomp$2 = function() {},
    noopGenerator = function* () {};
C3$jscomp$170.Action = class  extends C3$jscomp$170.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._eventBlock = a;
        this._runtime = a = a.GetRuntime();
        this._index = c;
        this._sid = 4 <= b.length ? b[3] : -1;
        this._actionType = 5 <= b.length ? b[4] & 255 : 0;
        this._flags = 5 <= b.length ? b[4] >> 8 : 0;
        this._behaviorType = this._objectClass = this._func = null;
        this._behaviorIndex = -1;
        this._systemPlugin = null;
        this._callFunctionName = "";
        this._callEventBlock = this._callCustomAceObjectClass = null;
        this.DebugRun = this.Run = noop$jscomp$2;
        this._parameters = [];
        this._results =
        [];
        this._anyParamVariesPerInstance = !1;
        this._unsavedData = this._savedData = null;
        const d = (c = -3 === b[0]) ? b[2] : b[5];
        this._debugData = a.IsDebug() || c ? {
            isBreakpoint: d[0],
            canDebug: d[1],
            index: d[2]
        } : null;
        -1 === b[0] ? (this._systemPlugin = a.GetSystemPlugin(), this._func = a.GetObjectReference(b[1])) : -2 === b[0] ? this._callFunctionName = b[1] : c ? (this._func = a.GetObjectReference(b[1]), this.Run = this.RunUserScript, this.DebugRun = this.DebugRunUserScript, this._flags |= 8) : (this._objectClass = a.GetObjectClassByIndex(b[0]), this._flags &
        4 ? (this._callFunctionName = b[1], this._callCustomAceObjectClass = a.GetObjectClassByIndex(b[2])) : (b[2] && (this._behaviorType = this._objectClass.GetBehaviorTypeByName(b[2]), this._behaviorIndex = this._objectClass.GetBehaviorIndexByName(b[2])), this._func = a.GetObjectReference(b[1])));
        if (7 === b.length) {
            b = b[6];
            for (const e of b)
                this._parameters.push(C3$jscomp$170.Parameter.Create(this, e, this._parameters.length)),
                this._results.push(0)
        }
        0 === this._parameters.length && (this._results = this._parameters = EMPTY_PARAMS_ARRAY$jscomp$1);
        this.CanPickAnyObjectClass() && (this._eventBlock.SetAllSolModifiers(), this._eventBlock.SetSolWriterAfterCnds());
        this._eventBlock.GetEventSheetManager()._RegisterAction(this)
    }
    static Create(a, b, c)
    {
        return C3$jscomp$170.New(C3$jscomp$170.Action, a, b, c)
    }
    _PostInit()
    {
        for (var a of this._parameters)
            a._PostInit(),
            a.VariesPerInstance() && (this._anyParamVariesPerInstance = !0);
        if (this._systemPlugin)
            this._SetSystemRunMethod(),
            this.DebugRun = this._DebugRunSystem;
        else if (this._callFunctionName)
            this._flags & 4 ? this._SetCallCustomActionRunMethod() :
            this._SetCallFunctionRunMethod(),
            this._callFunctionName = "",
            this._callCustomAceObjectClass = null;
        else if (this.Run === this.RunUserScript) {
            a = this._func;
            const b = this._runtime.GetEventSheetManager()._GetLocalVariablesScriptInterface(this._eventBlock);
            this._func = a.bind(null, this._runtime.GetIRuntime(), b)
        } else
            this._behaviorType ? this.IsAsync() ? (this.Run = this._RunBehavior_Async, this.DebugRun = this._DebugRunBehavior_Async) : (this.Run = this._RunBehavior, this.DebugRun = this._DebugRunBehavior) : this._objectClass.GetPlugin().IsSingleGlobal() ?
            (this._SetSingleGlobalRunMethod(), this.DebugRun = this._DebugRunSingleGlobal) : this.IsStatic() ? (this.Run = this._RunObject_Static, this.DebugRun = this._DebugRunObject_Static) : this.IsAsync() ? (this.Run = this._RunObject_Async, this.DebugRun = this._DebugRunObject_Async) : this.CallBeforeAfterHooks() ? (this.Run = this._RunObject_BeforeAfterHooks, this.DebugRun = this._DebugRunObject_BeforeAfterHooks) : this._parameters.length ? this._parameters.every(b => b.VariesPerInstance()) ? (this.Run = this._RunObject_AllParamsVary, this.DebugRun =
            this._DebugRunObject_AllParamsVary) : this._anyParamVariesPerInstance ? (this.Run = this._RunObject_SomeParamsVary, this.DebugRun = this._DebugRunObject_SomeParamsVary) : this._parameters.every(b => b.IsConstant()) ? (EvalParams$jscomp$1(this._parameters, this._results), this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst) : (this.Run = this._RunObject_ParamsDontVary, this.DebugRun = this._DebugRunObject_ParamsDontVary) : (this.Run = this._RunObject_ParamsConst, this.DebugRun = this._DebugRunObject_ParamsConst)
    }
    _SetSystemRunMethod()
    {
        this._SetRunMethodForBoundFunc(this._systemPlugin,
        this._systemPlugin, this._RunSystem)
    }
    _SetSingleGlobalRunMethod()
    {
        const a = this._objectClass.GetPlugin(),
            b = this._objectClass.GetSingleGlobalInstance().GetSdkInstance();
        this._SetRunMethodForBoundFunc(a, b, this._RunSingleGlobal)
    }
    _SetCallFunctionRunMethod()
    {
        const a = this._eventBlock.GetEventSheetManager(),
            b = a.GetFunctionBlockByName(this._callFunctionName);
        if (b.IsEnabled()) {
            const c = 0 !== (this._flags & 2);
            this._callEventBlock = b.GetEventBlock();
            let d = [...(new Set([...this._eventBlock.GetSolModifiersIncludingParents(),
            ...this._callEventBlock.GetSolModifiersIncludingParents()]))];
            d = a._DeduplicateSolModifierList(d);
            const e = !b.IsCopyPicked() && this._HasCopyPickedParent() ? {
                pushCleanSolDynamic: !0
            } : null;
            this.Run = C3$jscomp$170.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, d, this._parameters, c, e);
            if (this._runtime.IsDebug()) {
                const f = this;
                this.DebugRun = function* () {
                    if (f.IsBreakpoint() || f._runtime.DebugBreakNext())
                        yield f;
                    return yield *f._callEventBlock.DebugRunAsFunctionCall(d, f._parameters, c, e)
                }
            } else
                this.DebugRun =
                noopGenerator
        } else
            this.Run = noop$jscomp$2,
            this.DebugRun = noopGenerator
    }
    _SetCallCustomActionRunMethod()
    {
        var a = this._eventBlock.GetEventSheetManager();
        const b = a.GetCustomActionBlockByName(this._callCustomAceObjectClass, this._callFunctionName);
        if (b.IsEnabled()) {
            const c = 0 !== (this._flags & 2);
            this._callEventBlock = b.GetEventBlock();
            let d = [...(new Set([...this._eventBlock.GetSolModifiersIncludingParents(), ...this._callEventBlock.GetSolModifiersIncludingParents(), this._objectClass, b.GetObjectClass()]))];
            d = a._DeduplicateSolModifierList(d);
            a = !this._objectClass.IsFamily() && !b.GetObjectClass().IsFamily();
            const e = !this._objectClass.IsFamily() && b.GetObjectClass().IsFamily(),
                f = this._objectClass.IsFamily();
            let g = null;
            !b.IsCopyPicked() && this._HasCopyPickedParent() && (g = g || {}, g.pushCleanSolDynamic = !0);
            if (e || !c)
                g = g || {},
                g.copyFromObjectClass = this._objectClass,
                g.copyToObjectClass = b.GetObjectClass();
            a || e || f && !b.HasCustomACEOverrides() ? this.Run = C3$jscomp$170.EventBlock.prototype.RunAsFunctionCall.bind(this._callEventBlock, d, this._parameters, c, g) :
            f && (this.Run = C3$jscomp$170.FunctionBlock.prototype.RunAsFamilyCustomActionWithOverrides.bind(b, d, this._parameters));
            if (this._runtime.IsDebug()) {
                const h = this;
                a || e || f && !b.HasCustomACEOverrides() ? this.DebugRun = function* () {
                    if (h.IsBreakpoint() || h._runtime.DebugBreakNext())
                        yield h;
                    return yield *h._callEventBlock.DebugRunAsFunctionCall(d, h._parameters, c, g)
                } : f && (this.DebugRun = function* () {
                    if (h.IsBreakpoint() || h._runtime.DebugBreakNext())
                        yield h;
                    return yield *b.DebugRunAsFamilyCustomActionWithOverrides(d, h._parameters)
                })
            } else
                this.DebugRun =
                noopGenerator
        } else
            this.Run = noop$jscomp$2,
            this.DebugRun = noopGenerator
    }
    _SetRunMethodForBoundFunc(a, b, c)
    {
        const d = this._func,
            e = this._parameters;
        if (0 === e.length)
            this.Run = a._GetBoundACEMethod(d, b);
        else if (1 === e.length) {
            const f = e[0];
            if (f.IsConstant())
                this.Run = a._GetBoundACEMethod_1param(d, b, f.Get(0));
            else {
                const g = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return g(f.Get(0))
                }
            }
        } else if (2 === e.length) {
            const f = e[0],
                g = e[1];
            if (f.IsConstant() && g.IsConstant())
                this.Run = a._GetBoundACEMethod_2params(d, b, f.Get(0),
                g.Get(0));
            else {
                const h = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return h(f.Get(0), g.Get(0))
                }
            }
        } else if (3 === e.length) {
            const f = e[0],
                g = e[1],
                h = e[2];
            if (f.IsConstant() && g.IsConstant() && h.IsConstant())
                this.Run = a._GetBoundACEMethod_3params(d, b, f.Get(0), g.Get(0), h.Get(0));
            else {
                const k = a._GetBoundACEMethod(d, b);
                this.Run = function() {
                    return k(f.Get(0), g.Get(0), h.Get(0))
                }
            }
        } else
            this.Run = c
    }
    GetSID()
    {
        return this._sid
    }
    IsAsync()
    {
        return 0 !== (this._flags & 8)
    }
    CanBailOut()
    {
        return 0 !== (this._flags & 16)
    }
    CallBeforeAfterHooks()
    {
        return 1 ===
        this._actionType
    }
    IsStatic()
    {
        return 2 === this._actionType
    }
    CanPickAnyObjectClass()
    {
        return 0 !== (this._flags & 1)
    }
    HasReturnType()
    {
        return this.IsAsync() || this.CanBailOut()
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetImplementationAddon()
    {
        return this._behaviorType ? this._behaviorType.GetBehavior() : this._objectClass ? this._objectClass.GetPlugin() : null
    }
    GetImplementationSdkVersion()
    {
        const a = this.GetImplementationAddon();
        return a ? a.GetSdkVersion() : 1
    }
    GetEventBlock()
    {
        return this._eventBlock
    }
    _HasCopyPickedParent()
    {
        let a =
        this._eventBlock;
        do {
            if (a instanceof C3$jscomp$170.FunctionBlock && a.IsCopyPicked())
                return !0;
            a = a.GetScopeParent()
        } while (a);
        return !1
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetIndex()
    {
        return this._index
    }
    GetDebugIndex()
    {
        return this._debugData.index
    }
    IsBreakpoint()
    {
        return this._debugData.isBreakpoint
    }
    _SetBreakpoint(a)
    {
        this._debugData.isBreakpoint = !!a;
        this._eventBlock._UpdateCanRunFastRecursive()
    }
    _DebugReturnsGenerator()
    {
        return this._debugData.canDebug
    }
    DebugCanRunFast()
    {
        return !this.IsBreakpoint() && !this._runtime.DebugBreakNext() &&
            !this._DebugReturnsGenerator()
    }
    GetSavedDataMap()
    {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap()
    {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    _RunSystem()
    {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._systemPlugin, a)
    }
    *_DebugRunSystem()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters,
            a);
            return yield *this._func.apply(this._systemPlugin, a)
        }
        return this.Run()
    }
    _RunSingleGlobal()
    {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(), a)
    }
    *_DebugRunSingleGlobal()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            return yield *this._func.apply(this._objectClass.GetSingleGlobalInstance().GetSdkInstance(),
            a)
        }
        return this.Run()
    }
    _RunObject_ParamsConst()
    {
        const a = this._results,
            b = this._objectClass.GetCurrentSol().GetInstances();
        for (let c = 0, d = b.length; c < d; ++c)
            this._func.apply(b[c].GetSdkInstance(), a)
    }
    *_DebugRunObject_ParamsConst()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results,
                b = this._objectClass.GetCurrentSol().GetInstances();
            for (let c = 0, d = b.length; c < d; ++c)
                yield *this._func.apply(b[c].GetSdkInstance(), a)
        } else
            this._RunObject_ParamsConst()
    }
    _RunObject_ParamsDontVary()
    {
        const a =
        this._results;
        EvalParams$jscomp$1(this._parameters, a);
        const b = this._objectClass.GetCurrentSol().GetInstances();
        for (let c = 0, d = b.length; c < d; ++c)
            this._func.apply(b[c].GetSdkInstance(), a)
    }
    *_DebugRunObject_ParamsDontVary()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            const b = this._objectClass.GetCurrentSol().GetInstances();
            for (let c = 0, d = b.length; c < d; ++c)
                yield *this._func.apply(b[c].GetSdkInstance(),
                a)
        } else
            this._RunObject_ParamsDontVary()
    }
    _RunObject_AllParamsVary()
    {
        const a = this._parameters,
            b = this._results,
            c = this._func,
            d = this._objectClass.GetCurrentSol().GetInstances();
        for (let e = 0, f = d.length; e < f; ++e) {
            const g = d[e];
            for (let h = 0, k = a.length; h < k; ++h)
                b[h] = a[h].Get(e);
            c.apply(g.GetSdkInstance(), b)
        }
    }
    *_DebugRunObject_AllParamsVary()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._parameters,
                b = this._results,
                c = this._func,
                d = this._objectClass.GetCurrentSol().GetInstances();
            for (let e = 0, f = d.length; e < f; ++e) {
                const g = d[e];
                for (let h = 0, k = a.length; h < k; ++h)
                    b[h] = a[h].Get(e);
                yield *c.apply(g.GetSdkInstance(), b)
            }
        } else
            this._RunObject_AllParamsVary()
    }
    _RunObject_SomeParamsVary()
    {
        const a = this._parameters,
            b = this._results,
            c = this._func,
            d = this._objectClass.GetCurrentSol().GetInstances();
        for (let f = 0, g = a.length; f < g; ++f) {
            var e = a[f];
            e.VariesPerInstance() || (b[f] = e.Get(0))
        }
        for (let f = 0, g = d.length; f < g; ++f) {
            e = d[f];
            for (let h = 0, k = a.length; h < k; ++h) {
                const l = a[h];
                l.VariesPerInstance() && (b[h] = l.Get(f))
            }
            c.apply(e.GetSdkInstance(),
            b)
        }
    }
    *_DebugRunObject_SomeParamsVary()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const b = this._parameters,
                c = this._results,
                d = this._func,
                e = this._objectClass.GetCurrentSol().GetInstances();
            for (let f = 0, g = b.length; f < g; ++f) {
                var a = b[f];
                a.VariesPerInstance() || (c[f] = a.Get(0))
            }
            for (let f = 0, g = e.length; f < g; ++f) {
                a = e[f];
                for (let h = 0, k = b.length; h < k; ++h) {
                    const l = b[h];
                    l.VariesPerInstance() && (c[h] = l.Get(f))
                }
                yield *d.apply(a.GetSdkInstance(), c)
            }
        } else
            this._RunObject_SomeParamsVary()
    }
    _RunObject_BeforeAfterHooks()
    {
        const a =
            this._parameters,
            b = this._results,
            c = this._func;
        var d = this._objectClass;
        const e = d.GetSdkType();
        d = d.GetCurrentSol().GetInstances();
        e.BeforeRunAction(c);
        for (let f = 0, g = d.length; f < g; ++f) {
            const h = d[f];
            for (let k = 0, l = a.length; k < l; ++k)
                b[k] = a[k].Get(f);
            c.apply(h.GetSdkInstance(), b)
        }
        e.AfterRunAction(c)
    }
    *_DebugRunObject_BeforeAfterHooks()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const b = this._parameters,
                c = this._results,
                d = this._func;
            var a = this._objectClass;
            const e = a.GetSdkType();
            a = a.GetCurrentSol().GetInstances();
            e.BeforeRunAction(d);
            for (let f = 0, g = a.length; f < g; ++f) {
                const h = a[f];
                for (let k = 0, l = b.length; k < l; ++k)
                    c[k] = b[k].Get(f);
                yield *d.apply(h.GetSdkInstance(), c)
            }
            e.AfterRunAction(d)
        } else
            this._RunObject_BeforeAfterHooks()
    }
    _RunObject_Static()
    {
        const a = this._results;
        EvalParams$jscomp$1(this._parameters, a);
        return this._func.apply(this._behaviorType || this._objectClass, a)
    }
    *_DebugRunObject_Static()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._results;
            EvalParams$jscomp$1(this._parameters, a);
            a = this._func.apply(this._behaviorType || this._objectClass, a);
            C3$jscomp$170.IsIterator(a) && (a = yield *a);
            return a
        }
        return this._RunObject_Static()
    }
    _RunBehavior()
    {
        var a = this._objectClass;
        const b = a.IsFamily(),
            c = a.GetFamilyIndex(),
            d = this._parameters,
            e = this._anyParamVariesPerInstance,
            f = this._results,
            g = this._func,
            h = this._behaviorIndex;
        a = a.GetCurrentSol().GetInstances();
        for (let m = 0, n = d.length; m < n; ++m) {
            var k = d[m];
            k.VariesPerInstance() ||
            (f[m] = k.Get(0))
        }
        for (let m = 0, n = a.length; m < n; ++m) {
            k = a[m];
            if (e)
                for (let p = 0, q = d.length; p < q; ++p) {
                    var l = d[p];
                    l.VariesPerInstance() && (f[p] = l.Get(m))
                }
            l = b ? k.GetObjectClass().GetFamilyBehaviorOffset(c) : 0;
            g.apply(k.GetBehaviorInstances()[h + l].GetSdkInstance(), f)
        }
    }
    *_DebugRunBehavior()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._objectClass;
            const d = a.IsFamily(),
                e = a.GetFamilyIndex(),
                f = this._parameters,
                g = this._anyParamVariesPerInstance,
                h = this._results,
                k = this._func,
                l = this._behaviorIndex;
            a = a.GetCurrentSol().GetInstances();
            for (let m = 0, n = f.length; m < n; ++m) {
                var b = f[m];
                b.VariesPerInstance() || (h[m] = b.Get(0))
            }
            for (let m = 0, n = a.length; m < n; ++m) {
                b = a[m];
                if (g)
                    for (let p = 0, q = f.length; p < q; ++p) {
                        var c = f[p];
                        c.VariesPerInstance() && (h[p] = c.Get(m))
                    }
                c = d ? b.GetObjectClass().GetFamilyBehaviorOffset(e) : 0;
                yield *k.apply(b.GetBehaviorInstances()[l + c].GetSdkInstance(), h)
            }
        } else
            this._RunBehavior()
    }
    _RunObject_Async()
    {
        const a = this._parameters,
            b = this._results,
            c = this._func,
            d = this._objectClass.GetCurrentSol().GetInstances(),
            e = [];
        for (let f = 0, g = d.length; f < g; ++f) {
            const h = d[f];
            for (let k = 0, l = a.length; k < l; ++k)
                b[k] = a[k].Get(f);
            e.push(c.apply(h.GetSdkInstance(), b))
        }
        return Promise.all(e)
    }
    *_DebugRunObject_Async()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            const a = this._parameters,
                b = this._results,
                c = this._func,
                d = this._objectClass.GetCurrentSol().GetInstances(),
                e = [];
            for (let f = 0, g = d.length; f < g; ++f) {
                const h = d[f];
                for (let k = 0, l = a.length; k < l; ++k)
                    b[k] = a[k].Get(f);
                e.push(yield *c.apply(h.GetSdkInstance(),
                b))
            }
            return Promise.all(e)
        }
        return this._RunObject_Async()
    }
    _RunBehavior_Async()
    {
        var a = this._objectClass;
        const b = a.IsFamily(),
            c = a.GetFamilyIndex(),
            d = this._parameters,
            e = this._results,
            f = this._func,
            g = this._behaviorIndex;
        a = a.GetCurrentSol().GetInstances();
        const h = [];
        for (let k = 0, l = a.length; k < l; ++k) {
            const m = a[k];
            for (let p = 0, q = d.length; p < q; ++p)
                e[p] = d[p].Get(k);
            const n = b ? m.GetObjectClass().GetFamilyBehaviorOffset(c) : 0;
            h.push(f.apply(m.GetBehaviorInstances()[g + n].GetSdkInstance(), e))
        }
        return Promise.all(h)
    }
    *_DebugRunBehavior_Async()
    {
        if (this.IsBreakpoint() ||
        this._runtime.DebugBreakNext())
            yield this;
        if (this._DebugReturnsGenerator()) {
            var a = this._objectClass;
            const b = a.IsFamily(),
                c = a.GetFamilyIndex(),
                d = this._parameters,
                e = this._results,
                f = this._func,
                g = this._behaviorIndex;
            a = a.GetCurrentSol().GetInstances();
            const h = [];
            for (let k = 0, l = a.length; k < l; ++k) {
                const m = a[k];
                for (let p = 0, q = d.length; p < q; ++p)
                    e[p] = d[p].Get(k);
                const n = b ? m.GetObjectClass().GetFamilyBehaviorOffset(c) : 0;
                h.push(yield *f.apply(m.GetBehaviorInstances()[g + n].GetSdkInstance(), e))
            }
            return Promise.all(h)
        }
        return this._RunBehavior_Async()
    }
    async RunUserScript()
    {
        try {
            await this._func()
        } catch (a) {
            console.error(`Unhandled exception running script %c${this._eventBlock.GetEventSheet().GetName()}, event ${this._eventBlock.GetDisplayNumber()}, action ${this.GetDebugIndex() + 1}:`, "font-size: 1.2em; font-weight: bold;", a),
            self.C3Debugger && self.C3Debugger._SetLastErrorScript(this),
            C3$jscomp$170.EventScript.HadUserScriptException() || (console.info("%cTip:%c run this to highlight in Construct the last script that had an error: %cgoToLastErrorScript()", "font-weight: bold; text-decoration: underline", "", "font-weight: bold"), C3$jscomp$170.EventScript.SetHadUserScriptException())
        }
    }
    *DebugRunUserScript()
    {
        if (this.IsBreakpoint() || this._runtime.DebugBreakNext())
            yield this;
        return this.RunUserScript()
    }
    _SaveToJson()
    {
        return this._savedData &&
        this._savedData.size ? {
            ex: C3$jscomp$170.ToSuperJSON(this._savedData)
        } : null
    }
    _LoadFromJson(a)
    {
        this._savedData && (this._savedData.clear(), this._savedData = null);
        a && (a = a.ex) && (this._savedData = C3$jscomp$170.FromSuperJSON(a))
    }
}
;
"use strict";
const C3$jscomp$171 = self.C3,
    tempColor$jscomp$5 = new C3$jscomp$171.Color;
let runtime$jscomp$68 = null;
C3$jscomp$171.CommonACES_SetRuntime = function(a) {
    runtime$jscomp$68 = a
};
function GetInst(a) {
    return a instanceof self.IInstance ? runtime$jscomp$68._UnwrapScriptInterface(a) : a.GetInstance()
}
function GetWorldInfo(a) {
    return GetInst(a).GetWorldInfo()
}
function CompareX(a, b) {
    return C3$jscomp$171.compare(GetWorldInfo(this).GetX(), a, b)
}
function CompareY(a, b) {
    return C3$jscomp$171.compare(GetWorldInfo(this).GetY(), a, b)
}
function IsOnScreen() {
    return GetWorldInfo(this).IsInViewport2()
}
function IsOutsideLayout() {
    var a = GetWorldInfo(this);
    const b = a.GetLayout();
    a = a.GetBoundingBox();
    return 0 > a.getRight() || 0 > a.getBottom() || a.getLeft() > b.GetWidth() || a.getTop() > b.GetHeight()
}
function PickDistance(a, b, c) {
    const d = this.GetCurrentSol(),
        e = d.GetInstances();
    if (!e.length)
        return !1;
    let f = e[0];
    var g = f.GetWorldInfo();
    let h = f,
        k = C3$jscomp$171.distanceSquared(g.GetX(), g.GetY(), b, c);
    for (let l = 1, m = e.length; l < m; ++l)
        if (f = e[l], g = f.GetWorldInfo(), g = C3$jscomp$171.distanceSquared(g.GetX(), g.GetY(), b, c), 0 === a && g < k || 1 === a && g > k)
            k = g,
            h = f;
    d.PickOne(h);
    return !0
}
function SetX(a) {
    const b = GetWorldInfo(this);
    b.GetX() !== a && (b.SetX(a), b.SetBboxChanged())
}
function SetY(a) {
    const b = GetWorldInfo(this);
    b.GetY() !== a && (b.SetY(a), b.SetBboxChanged())
}
function SetPos(a, b) {
    const c = GetWorldInfo(this);
    c.EqualsXY(a, b) || (c.SetXY(a, b), c.SetBboxChanged())
}
function SetPosToObject(a, b) {
    if (a) {
        var c = GetInst(this);
        if (a = a.GetPairedInstance(c)) {
            var [d, e] = a.GetImagePoint(b);
            b = c.GetWorldInfo();
            if (b.GetX() !== d || b.GetY() !== e)
                b.SetXY(d, e),
                b.SetBboxChanged()
        }
    }
}
function MoveForward(a) {
    if (0 !== a) {
        var b = GetWorldInfo(this);
        b.OffsetXY(b.GetCosAngle() * a, b.GetSinAngle() * a);
        b.SetBboxChanged()
    }
}
function MoveAtAngle(a, b) {
    if (0 !== b) {
        var c = GetWorldInfo(this);
        a = C3$jscomp$171.toRadians(a);
        c.OffsetXY(Math.cos(a) * b, Math.sin(a) * b);
        c.SetBboxChanged()
    }
}
function GetX() {
    return GetWorldInfo(this).GetX()
}
function GetY() {
    return GetWorldInfo(this).GetY()
}
function GetDt() {
    const a = GetInst(this);
    return a.GetRuntime().GetDt(a)
}
function CompareWidth(a, b) {
    return C3$jscomp$171.compare(GetWorldInfo(this).GetWidth(), a, b)
}
function CompareHeight(a, b) {
    return C3$jscomp$171.compare(GetWorldInfo(this).GetHeight(), a, b)
}
function SetWidth(a) {
    const b = GetWorldInfo(this);
    b.GetWidth() !== a && (b.SetWidth(a), b.SetBboxChanged())
}
function SetHeight(a) {
    const b = GetWorldInfo(this);
    b.GetHeight() !== a && (b.SetHeight(a), b.SetBboxChanged())
}
function SetSize(a, b) {
    const c = GetWorldInfo(this);
    if (c.GetWidth() !== a || c.GetHeight() !== b)
        c.SetSize(a, b),
        c.SetBboxChanged()
}
function GetWidth() {
    return GetWorldInfo(this).GetWidth()
}
function GetHeight() {
    return GetWorldInfo(this).GetHeight()
}
function GetBboxLeft() {
    return GetWorldInfo(this).GetBoundingBox().getLeft()
}
function GetBboxTop() {
    return GetWorldInfo(this).GetBoundingBox().getTop()
}
function GetBboxRight() {
    return GetWorldInfo(this).GetBoundingBox().getRight()
}
function GetBboxBottom() {
    return GetWorldInfo(this).GetBoundingBox().getBottom()
}
function GetBboxMidX() {
    const a = GetWorldInfo(this).GetBoundingBox();
    return (a.getLeft() + a.getRight()) / 2
}
function GetBboxMidY() {
    const a = GetWorldInfo(this).GetBoundingBox();
    return (a.getTop() + a.getBottom()) / 2
}
function IsAngleWithin(a, b) {
    return C3$jscomp$171.angleDiff(GetWorldInfo(this).GetAngle(), C3$jscomp$171.toRadians(b)) <= C3$jscomp$171.toRadians(a)
}
function IsAngleClockwiseFrom(a) {
    return C3$jscomp$171.angleClockwise(GetWorldInfo(this).GetAngle(), C3$jscomp$171.toRadians(a))
}
function IsBetweenAngles(a, b) {
    a = C3$jscomp$171.toRadians(a);
    b = C3$jscomp$171.toRadians(b);
    const c = GetWorldInfo(this).GetAngle();
    return C3$jscomp$171.angleClockwise(b, a) ? C3$jscomp$171.angleClockwise(c, a) && !C3$jscomp$171.angleClockwise(c, b) : !(!C3$jscomp$171.angleClockwise(c, a) && C3$jscomp$171.angleClockwise(c, b))
}
function SetAngle(a) {
    const b = GetWorldInfo(this);
    a = C3$jscomp$171.clampAngle(C3$jscomp$171.toRadians(a));
    isNaN(a) || b.GetAngle() === a || (b.SetAngle(a), b.SetBboxChanged())
}
function RotateClockwise(a) {
    if (!isNaN(a) && 0 !== a) {
        var b = GetWorldInfo(this);
        b.SetAngle(b.GetAngle() + C3$jscomp$171.toRadians(a));
        b.SetBboxChanged()
    }
}
function RotateCounterclockwise(a) {
    if (!isNaN(a) && 0 !== a) {
        var b = GetWorldInfo(this);
        b.SetAngle(b.GetAngle() - C3$jscomp$171.toRadians(a));
        b.SetBboxChanged()
    }
}
function RotateTowardAngle(a, b) {
    const c = GetWorldInfo(this),
        d = c.GetAngle();
    a = C3$jscomp$171.angleRotate(d, C3$jscomp$171.toRadians(b), C3$jscomp$171.toRadians(a));
    isNaN(a) || d === a || (c.SetAngle(a), c.SetBboxChanged())
}
function RotateTowardPosition(a, b, c) {
    const d = GetWorldInfo(this),
        e = d.GetAngle();
    b -= d.GetX();
    c -= d.GetY();
    a = C3$jscomp$171.angleRotate(e, Math.atan2(c, b), C3$jscomp$171.toRadians(a));
    isNaN(a) || e === a || (d.SetAngle(a), d.SetBboxChanged())
}
function SetTowardPosition(a, b) {
    const c = GetWorldInfo(this),
        d = c.GetAngle();
    a -= c.GetX();
    b -= c.GetY();
    b = Math.atan2(b, a);
    isNaN(b) || d === b || (c.SetAngle(b), c.SetBboxChanged())
}
function GetAngle() {
    return C3$jscomp$171.toDegrees(GetWorldInfo(this).GetAngle())
}
function CompareOpacity(a, b) {
    return C3$jscomp$171.compare(C3$jscomp$171.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6), a, b)
}
function IsVisible() {
    return GetWorldInfo(this).IsVisible()
}
function SetVisible(a) {
    const b = GetInst(this),
        c = b.GetWorldInfo();
    a = 2 === a ? !c.IsVisible() : 0 !== a;
    c.IsVisible() !== a && (c.SetVisible(a), b.GetRuntime().UpdateRender())
}
function SetOpacity(a) {
    a = C3$jscomp$171.clamp(a / 100, 0, 1);
    const b = GetInst(this),
        c = b.GetWorldInfo();
    if (c.GetTransformWithParentOpacity()) {
        if (c._GetSceneGraphInfo().GetOwnOpacity() === a)
            return
    } else if (c.GetOpacity() === a)
        return;
    c.SetOpacity(a);
    b.GetRuntime().UpdateRender()
}
function SetDefaultColor(a) {
    tempColor$jscomp$5.setFromRgbValue(a);
    a = GetInst(this);
    const b = a.GetWorldInfo();
    b.GetUnpremultipliedColor().equalsIgnoringAlpha(tempColor$jscomp$5) || (b.SetUnpremultipliedColor(tempColor$jscomp$5), a.GetRuntime().UpdateRender())
}
function GetColor() {
    const a = GetWorldInfo(this).GetUnpremultipliedColor();
    return C3$jscomp$171.PackRGBAEx(a.getR(), a.getG(), a.getB(), a.getA())
}
function GetOpacity() {
    return C3$jscomp$171.roundToDp(100 * GetWorldInfo(this).GetOpacity(), 6)
}
function IsOnLayer(a) {
    return a ? GetWorldInfo(this).GetLayer() === a : !1
}
function PickTopBottom(a) {
    const b = this.GetCurrentSol(),
        c = b.GetInstances();
    if (!c.length)
        return !1;
    let d = c[0];
    for (let e = 1, f = c.length; e < f; ++e) {
        const g = c[e],
            h = g.GetWorldInfo(),
            k = d.GetWorldInfo(),
            l = h.GetLayer().GetIndex(),
            m = k.GetLayer().GetIndex();
        if (0 === a) {
            if (l > m || l === m && h.GetZIndex() > k.GetZIndex())
                d = g
        } else if (l < m || l === m && h.GetZIndex() < k.GetZIndex())
            d = g
    }
    b.PickOne(d);
    return !0
}
function CompareZElevation(a, b, c) {
    const d = GetWorldInfo(this);
    a = 0 === a ? d.GetZElevation() : d.GetTotalZElevation();
    return C3$jscomp$171.compare(a, b, c)
}
function MoveToTop() {
    GetWorldInfo(this).ZOrderMoveToTop()
}
function MoveToBottom() {
    GetWorldInfo(this).ZOrderMoveToBottom()
}
function MoveToLayer(a) {
    a && GetWorldInfo(this).ZOrderMoveToLayer(a)
}
function ZMoveToObject(a, b) {
    a = 0 === a;
    if (b) {
        var c = GetInst(this);
        (b = b.GetFirstPicked(c)) && c.GetWorldInfo().ZOrderMoveAdjacentToInstance(b, a)
    }
}
function SetZElevation(a) {
    const b = GetInst(this),
        c = b.GetWorldInfo();
    c.GetZElevation() !== a && (c.SetZElevation(a), b.GetRuntime().UpdateRender())
}
function LayerNumber() {
    return GetWorldInfo(this).GetLayer().GetIndex()
}
function LayerName() {
    return GetWorldInfo(this).GetLayer().GetName()
}
function ZIndex() {
    return GetWorldInfo(this).GetZIndex()
}
function ZElevation() {
    return GetWorldInfo(this).GetZElevation()
}
function TotalZElevation() {
    return GetWorldInfo(this).GetTotalZElevation()
}
function IsEffectEnabled(a) {
    const b = GetInst(this);
    if (a = b.GetObjectClass().GetEffectList().GetEffectTypeByName(a))
        return a = a.GetIndex(), b.GetWorldInfo().GetInstanceEffectList().IsEffectIndexActive(a)
}
function SetEffectEnabled(a, b) {
    const c = GetInst(this);
    if (b = c.GetObjectClass().GetEffectList().GetEffectTypeByName(b)) {
        b = b.GetIndex();
        a = 1 === a;
        var d = c.GetWorldInfo().GetInstanceEffectList();
        d.IsEffectIndexActive(b) !== a && (d.SetEffectIndexActive(b, a), d.UpdateActiveEffects(), c.GetRuntime().UpdateRender())
    }
}
function SetEffectParam(a, b, c) {
    const d = GetInst(this);
    if (a = d.GetObjectClass().GetEffectList().GetEffectTypeByName(a)) {
        b = Math.floor(b);
        var e = a.GetShaderProgram().GetParameterType(b);
        e && ("color" === e ? (tempColor$jscomp$5.setFromRgbValue(c), c = tempColor$jscomp$5) : "percent" === e && (c /= 100), a = a.GetIndex(), e = d.GetWorldInfo().GetInstanceEffectList(), e.SetEffectParameter(a, b, c) && e.IsEffectIndexActive(a) && d.GetRuntime().UpdateRender())
    }
}
const tempRect$jscomp$5 = C3$jscomp$171.New(C3$jscomp$171.Rect),
    tempCandidates1 = [],
    tempCandidates2 = [];
let needsCollisionFinish = !1,
    rPickType = null,
    rPickFromElseInstances = !1;
const rToPick = new Set;
function CollMemory_Add(a, b, c, d) {
    const e = b.GetUID(),
        f = c.GetUID();
    e < f ? a.Set(b, c, d) : a.Set(c, b, d)
}
function CollMemory_Remove(a, b, c) {
    const d = b.GetUID(),
        e = c.GetUID();
    d < e ? a.Delete(b, c) : a.Delete(c, b)
}
function CollMemory_RemoveInstance(a, b) {
    a.DeleteEither(b)
}
function CollMemory_Get(a, b, c) {
    const d = b.GetUID(),
        e = c.GetUID();
    return d < e ? a.Get(b, c) : a.Get(c, b)
}
function DoOverlapCondition(a, b, c, d) {
    if (!b)
        return !1;
    const e = 0 !== c || 0 !== d,
        f = a.GetWorldInfo(),
        g = a.GetRuntime(),
        h = g.GetCollisionEngine();
    var k = g.GetCurrentCondition();
    const l = k.GetEventBlock().IsOrBlock();
    var m = k.GetObjectClass();
    k = k.IsInverted();
    const n = b.GetCurrentSol();
    m = m !== b;
    rPickType = b;
    needsCollisionFinish = m && !k;
    rPickFromElseInstances = !1;
    let p = 0,
        q = 0,
        r = !1;
    n.IsSelectAll() ? (tempRect$jscomp$5.copy(f.GetBoundingBox()), tempRect$jscomp$5.offset(c, d), h.GetCollisionCandidates(f.GetLayer(), b, tempRect$jscomp$5,
    tempCandidates2), b = tempCandidates2) : l ? g.IsCurrentConditionFirst() && !n._GetOwnElseInstances().length && n._GetOwnInstances().length ? b = n._GetOwnInstances() : (b = n._GetOwnElseInstances(), rPickFromElseInstances = !0) : b = n._GetOwnInstances();
    e && (p = f.GetX(), q = f.GetY(), f.OffsetXY(c, d), f.SetBboxChanged());
    for (const t of b)
        if (h.TestOverlap(a, t)) {
            r = !0;
            if (k)
                break;
            m && rToPick.add(t)
        }
    e && (f.SetXY(p, q), f.SetBboxChanged());
    C3$jscomp$171.clearArray(tempCandidates2);
    return r
}
function FinishCollisionConditionPicking(a) {
    a = a.GetRuntime().GetCurrentEvent().IsOrBlock();
    const b = rPickType.GetCurrentSol(),
        c = b._GetOwnInstances(),
        d = b._GetOwnElseInstances();
    b.IsSelectAll() ? (b.SetSetPicked(rToPick), a && (C3$jscomp$171.clearArray(d), b.AddElseInstances(rToPick, rPickType.GetInstances()))) : a ? rPickFromElseInstances ? b.TransferElseInstancesToOwn(rToPick) : (b.AddElseInstances(rToPick, c), b.SetSetPicked(rToPick)) : b.SetSetPicked(rToPick);
    rPickType.ApplySolToContainer()
}
function FinishCollisionCondition(a, b) {
    needsCollisionFinish && (b && FinishCollisionConditionPicking(a), rToPick.clear(), rPickType = null, needsCollisionFinish = !1)
}
function OnCollision(a) {
    if (this._runtime.IsDebugging())
        return DebugOnCollision.call(this, a);
    if (!a)
        return !1;
    var b = this._runtime;
    const c = b.GetCollisionEngine(),
        d = b.GetEventSheetManager(),
        e = d.GetEventStack();
    var f = d.GetCurrentCondition();
    const g = f.GetObjectClass();
    var h = f.GetSavedDataMap(),
        k = f.GetUnsavedDataMap();
    f = e.GetCurrentStackFrame();
    const l = b.GetTickCount(),
        m = l - 1,
        n = f.GetCurrentEvent(),
        p = e.Push(n);
    let q = h.get("collmemory");
    q || (q = C3$jscomp$171.New(C3$jscomp$171.PairMap), h.set("collmemory", q));
    k.get("collisionCreatedDestroyCallback") ||
    (k.set("collisionCreatedDestroyCallback", !0), b.Dispatcher().addEventListener("instancedestroy", v => CollMemory_RemoveInstance(q, v.instance)));
    h = g.GetCurrentSol();
    b = a.GetCurrentSol();
    h = h.GetInstances();
    k = null;
    for (let v = 0; v < h.length; ++v) {
        const w = h[v];
        b.IsSelectAll() ? (c.GetCollisionCandidates(w.GetWorldInfo().GetLayer(), a, w.GetWorldInfo().GetBoundingBox(), tempCandidates1), k = tempCandidates1, c.AddRegisteredCollisionCandidates(w, a, k)) : k = b.GetInstances();
        for (let x = 0; x < k.length; ++x) {
            const y = k[x];
            if (c.TestOverlap(w,
            y) || c.CheckRegisteredCollision(w, y)) {
                var r = CollMemory_Get(q, w, y),
                    t = !1,
                    u = -2;
                "number" === typeof r && (t = !0, u = r);
                r = !t || u < m;
                CollMemory_Add(q, w, y, l);
                r && (r = n.GetSolModifiers(), d.PushCopySol(r), u = g.GetCurrentSol(), t = a.GetCurrentSol(), u._SetSelectAll(!1), t._SetSelectAll(!1), g === a ? (t = u._GetOwnInstances(), C3$jscomp$171.clearArray(t), t.push(w), t.push(y), g.ApplySolToContainer()) : (u = u._GetOwnInstances(), t = t._GetOwnInstances(), C3$jscomp$171.clearArray(u), C3$jscomp$171.clearArray(t), u.push(w), t.push(y), g.ApplySolToContainer(),
                a.ApplySolToContainer()), n.Retrigger(f, p), d.PopSol(r))
            } else
                CollMemory_Remove(q, w, y)
        }
        C3$jscomp$171.clearArray(tempCandidates1)
    }
    e.Pop();
    return !1
}
function* DebugOnCollision(a) {
    if (!a)
        return !1;
    var b = this._runtime;
    const c = b.GetCollisionEngine(),
        d = b.GetEventSheetManager(),
        e = d.GetEventStack();
    var f = d.GetCurrentCondition();
    const g = f.GetObjectClass();
    var h = f.GetSavedDataMap(),
        k = f.GetUnsavedDataMap();
    f = e.GetCurrentStackFrame();
    const l = b.GetTickCount(),
        m = l - 1,
        n = f.GetCurrentEvent(),
        p = e.Push(n);
    let q = h.get("collmemory");
    q || (q = C3$jscomp$171.New(C3$jscomp$171.PairMap), h.set("collmemory", q));
    k.get("collisionCreatedDestroyCallback") || (k.set("collisionCreatedDestroyCallback",
    !0), b.Dispatcher().addEventListener("instancedestroy", v => CollMemory_RemoveInstance(q, v.instance)));
    h = g.GetCurrentSol();
    b = a.GetCurrentSol();
    h = h.GetInstances();
    k = null;
    for (let v = 0; v < h.length; ++v) {
        const w = h[v];
        b.IsSelectAll() ? (c.GetCollisionCandidates(w.GetWorldInfo().GetLayer(), a, w.GetWorldInfo().GetBoundingBox(), tempCandidates1), k = tempCandidates1, c.AddRegisteredCollisionCandidates(w, a, k)) : k = b.GetInstances();
        for (let x = 0; x < k.length; ++x) {
            const y = k[x];
            if (c.TestOverlap(w, y) || c.CheckRegisteredCollision(w,
            y)) {
                var r = CollMemory_Get(q, w, y),
                    t = !1,
                    u = -2;
                "number" === typeof r && (t = !0, u = r);
                r = !t || u < m;
                CollMemory_Add(q, w, y, l);
                r && (r = n.GetSolModifiers(), d.PushCopySol(r), u = g.GetCurrentSol(), t = a.GetCurrentSol(), u._SetSelectAll(!1), t._SetSelectAll(!1), g === a ? (t = u._GetOwnInstances(), C3$jscomp$171.clearArray(t), t.push(w), t.push(y), g.ApplySolToContainer()) : (u = u._GetOwnInstances(), t = t._GetOwnInstances(), C3$jscomp$171.clearArray(u), C3$jscomp$171.clearArray(t), u.push(w), t.push(y), g.ApplySolToContainer(), a.ApplySolToContainer()),
                yield *n.DebugRetrigger(f, p), d.PopSol(r))
            } else
                CollMemory_Remove(q, w, y)
        }
        C3$jscomp$171.clearArray(tempCandidates1)
    }
    e.Pop();
    return !1
}
function IsOverlapping(a) {
    return DoOverlapCondition(GetInst(this), a, 0, 0)
}
function IsOverlappingOffset(a, b, c) {
    return DoOverlapCondition(GetInst(this), a, b, c)
}
function HasParent() {
    return GetWorldInfo(this).HasParent()
}
function HasChildren() {
    return GetWorldInfo(this).HasChildren()
}
function PickParent(a, b) {
    const c = this.GetCurrentSol().GetInstances();
    if (0 === c.length)
        return !1;
    const d = a.GetCurrentSol();
    var e = d.GetInstances();
    if (d.IsSelectAll()) {
        var f = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < f.length && (e = e.concat(f))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    f = new Set;
    for (let h = 0, k = c.length; h < k; ++h) {
        var g = c[h];
        if (1 === b)
            for (const l of g.parents())
                l.BelongsToObjectClass(a) && e.has(l) && f.add(l);
        else {
            if (0 === b) {
                if (g = g.GetParent(), null === g)
                    continue
            } else
                g = g.GetTopParent();
            g.BelongsToObjectClass(a) && e.has(g) && f.add(g)
        }
    }
    if (0 === f.size)
        return !1;
    d.SetSetPicked(f);
    a.ApplySolToContainer();
    return !0
}
function PickChildren(a, b) {
    const c = this.GetCurrentSol().GetInstances();
    if (0 === c.length)
        return !1;
    const d = a.GetCurrentSol();
    var e = d.GetInstances();
    if (d.IsSelectAll()) {
        var f = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < f.length && (e = e.concat(f))
    }
    if (0 === e.length)
        return !1;
    e = new Set(e);
    f = new Set;
    for (let g = 0, h = c.length; g < h; ++g) {
        const k = c[g];
        2 === b && !k.HasChildren() && k.BelongsToObjectClass(a) && e.has(k) && f.add(k);
        for (const l of 0 === b ? k.children() : k.allChildren())
            2 === b && l.HasChildren() || l.BelongsToObjectClass(a) &&
            e.has(l) && f.add(l)
    }
    if (0 === f.size)
        return !1;
    d.SetSetPicked(f);
    a.ApplySolToContainer();
    return !0
}
function PickNthChild(a, b, c) {
    const d = this.GetCurrentSol().GetInstances();
    if (0 === d.length)
        return !1;
    const e = a.GetCurrentSol();
    var f = e.GetInstances();
    if (e.IsSelectAll()) {
        var g = [...this._runtime.instancesPendingCreateForObjectClass(a)];
        0 < g.length && (f = f.concat(g))
    }
    if (0 === f.length)
        return !1;
    f = new Set(f);
    g = [];
    for (let k = 0, l = d.length; k < l; ++k) {
        var h = d[k];
        if (0 === b)
            h = h.GetChildAt(c),
            null !== h && h.BelongsToObjectClass(a) && f.has(h) && g.push(h);
        else if (1 === b)
            for (const m of h.children())
                if (m.BelongsToObjectClass(a))
                    if (0 ===
                    c) {
                        f.has(m) && g.push(m);
                        break
                    } else
                        --c
    }
    if (0 === g.length)
        return !1;
    e.SetArrayPicked(g);
    a.ApplySolToContainer();
    return !0
}
function CompareChildCount(a, b, c) {
    const d = GetInst(this);
    switch (a) {
    default:
        return C3$jscomp$171.compare(d.GetChildCount(), b, c);
    case 1:
        return C3$jscomp$171.compare(d.GetAllChildCount(), b, c)
    }
}
function AddChild(a, b, c, d, e, f, g, h, k, l) {
    const m = GetInst(this),
        n = m.GetRuntime().GetCurrentAction().GetObjectClass();
    for (const p of a.allCorrespondingInstances(m, n)) {
        if (!p.GetPlugin().SupportsSceneGraph())
            break;
        m.AddChild(p, {
            transformX: b,
            transformY: c,
            transformWidth: d,
            transformHeight: e,
            transformAngle: f,
            transformOpacity: g,
            transformZElevation: h,
            transformVisibility: k,
            destroyWithParent: l
        })
    }
}
function RemoveChild(a) {
    const b = GetInst(this),
        c = b.GetRuntime().GetCurrentAction().GetObjectClass();
    for (const d of a.allCorrespondingInstances(b, c))
        b.RemoveChild(d)
}
function RemoveFromParent() {
    const a = GetInst(this);
    a.HasParent() && a.GetParent().RemoveChild(a)
}
function ChildCount() {
    return GetInst(this).GetChildCount()
}
function AllChildCount() {
    return GetInst(this).GetAllChildCount()
}
function SetMeshSize(a, b) {
    a = Math.floor(a);
    b = Math.floor(b);
    const c = GetWorldInfo(this);
    2 > a || 2 > b || !isFinite(a) || !isFinite(b) ? (c.ReleaseMesh(), c.SetBboxChanged()) : c.CreateMesh(a, b)
}
function SetMeshPoint(a, b, c, d, e, f, g, h) {
    const k = GetWorldInfo(this);
    k.SetMeshPoint(a, b, {
        mode: 0 === c ? "absolute" : "relative",
        x: d,
        y: e,
        zElevation: f,
        u: g,
        v: h
    }) && k.SetBboxChanged()
}
function MeshColumns() {
    const a = GetWorldInfo(this);
    return a.HasMesh() ? a.GetSourceMesh().GetHSize() : 0
}
function MeshRows() {
    const a = GetWorldInfo(this);
    return a.HasMesh() ? a.GetSourceMesh().GetVSize() : 0
}
function SetElementVisible(a) {
    const b = GetWorldInfo(this);
    a = 2 === a ? !b.IsVisible() : 0 !== a;
    b.IsVisible() !== a && b.SetVisible(a)
}
function SetElementCSSStyle(a, b) {
    this instanceof self.IInstance ? this.setElementCSSStyle(a, b) : this.SetElementCSSStyle(a, b)
}
function SetElementAttribute(a, b) {
    this instanceof self.IInstance ? this.setElementAttribute(a, "" + b) : this.SetElementAttribute(a, "" + b)
}
function RemoveElementAttribute(a) {
    this instanceof self.IInstance ? this.removeElementAttribute(a) : this.RemoveElementAttribute(a)
}
function SetElementFocus() {
    this instanceof self.IInstance ? this.focusElement() : this.FocusElement()
}
function SetElementBlur() {
    this instanceof self.IInstance ? this.blurElement() : this.BlurElement()
}
function IsElementFocused() {
    return this instanceof self.IInstance ? this.isElementFocused() : this.IsElementFocused()
}
function SetElementEnabled(a) {
    this instanceof self.IInstance ? this._setEnabled(0 !== a) : this._SetEnabled(0 !== a)
}
function IsElementEnabled() {
    return this instanceof self.IInstance ? this._isEnabled() : this._IsEnabled()
}
function CompareInstanceVar(a, b, c) {
    return C3$jscomp$171.compare(GetInst(this).GetInstanceVariableValue(a), b, c)
}
function IsBoolInstanceVarSet(a) {
    return !!GetInst(this).GetInstanceVariableValue(a)
}
function PickInstVarHiLow(a, b) {
    const c = this.GetCurrentSol(),
        d = c.GetInstances();
    if (!d.length)
        return !1;
    const e = this.IsFamily();
    let f = null,
        g = 0;
    for (let k = 0, l = d.length; k < l; ++k) {
        const m = d[k];
        var h = e ? m.GetObjectClass().GetFamilyInstanceVariableOffset(this.GetFamilyIndex()) : 0;
        h = m.GetInstanceVariableValue(h + b);
        if (null === f || 0 === a && h < g || 1 === a && h > g)
            g = h,
            f = m
    }
    c.PickOne(f);
    return !0
}
function PickByUID(a) {
    return this._runtime.GetCurrentCondition().IsInverted() ? PickByUID_Inverted(this, a) : PickByUID_Normal(this, a)
}
function PickByUID_Normal(a, b) {
    b = a.GetRuntime().GetInstanceByUID(b);
    if (!b)
        return !1;
    const c = a.GetCurrentSol();
    if (!c.IsSelectAll() && !c._GetOwnInstances().includes(b))
        return !1;
    if (a.IsFamily()) {
        if (b.GetObjectClass().BelongsToFamily(a))
            return c.PickOne(b), a.ApplySolToContainer(), !0
    } else if (b.GetObjectClass() === a)
        return c.PickOne(b), a.ApplySolToContainer(), !0;
    return !1
}
function PickByUID_Inverted(a, b) {
    const c = a.GetCurrentSol();
    if (c.IsSelectAll()) {
        c._SetSelectAll(!1);
        c.ClearArrays();
        var d = a.GetInstances();
        for (let f = 0, g = d.length; f < g; ++f) {
            var e = d[f];
            e.GetUID() === b ? c._PushElseInstance(e) : c._PushInstance(e)
        }
        a.ApplySolToContainer();
        return !!c._GetOwnInstances().length
    }
    d = c._GetOwnInstances();
    e = 0;
    for (let f = 0, g = d.length; f < g; ++f) {
        const h = d[f];
        d[e] = h;
        h.GetUID() === b ? c._PushElseInstance(h) : ++e
    }
    C3$jscomp$171.truncateArray(d, e);
    a.ApplySolToContainer();
    return !!d.length
}
function HasTags(a) {
    a = new Set(C3$jscomp$171.splitStringAndNormalize(a));
    const b = GetInst(this).GetTagsSet();
    return a.isSubsetOf(b)
}
function Tags() {
    return GetInst(this).GetTagsString()
}
function TagsCount() {
    return GetInst(this).GetTagsSet().size
}
function TagAt(a) {
    return GetInst(this).GetTagAt(a)
}
function ChangeTags(a, b) {
    b = C3$jscomp$171.splitStringAndNormalize(b);
    if (0 !== b.length) {
        var c = GetInst(this),
            d = new Set(c.GetTagsSet());
        if (0 === a)
            for (const e of b)
                d.add(e);
        else if (1 === a)
            for (const e of b)
                d.delete(e);
        c.SetTagsSet(d)
    }
}
function Destroy() {
    const a = GetInst(this);
    a.GetRuntime().DestroyInstance(a)
}
function OnCreated() {
    return !0
}
function OnDestroyed() {
    return !0
}
function SetInstanceVar(a, b) {
    GetInst(this).SetInstanceVariableValue(a, b)
}
function AddInstanceVar(a, b) {
    const c = GetInst(this),
        d = c.GetInstanceVariableValue(a);
    "number" === typeof d && "number" !== typeof b ? b = parseFloat(b) : "string" === typeof d && "string" !== typeof b && (b = b.toString());
    c.SetInstanceVariableValue(a, d + b)
}
function SubInstanceVar(a, b) {
    const c = GetInst(this),
        d = c.GetInstanceVariableValue(a);
    "number" === typeof d && ("number" !== typeof b && (b = parseFloat(b)), c.SetInstanceVariableValue(a, d - b))
}
function SetBoolInstanceVar(a, b) {
    GetInst(this).SetInstanceVariableValue(a, b ? 1 : 0)
}
function ToggleBoolInstanceVar(a) {
    const b = GetInst(this);
    b.SetInstanceVariableValue(a, 0 === b.GetInstanceVariableValue(a) ? 1 : 0)
}
function LoadFromJsonString(a) {
    let b;
    try {
        b = JSON.parse(a)
    } catch (c) {
        console.error("Failed to load from JSON string: ", c);
        return
    }
    a = GetInst(this);
    a.GetRuntime().ClearIntancesNeedingAfterLoad();
    a._OnBeforeLoad("state");
    a.LoadFromJson(b, "state");
    a.GetRuntime().DoAfterLoad("state", {
        setFromJson: !0
    })
}
function AsJSON() {
    return JSON.stringify(GetInst(this).SaveToJson("state"))
}
function ObjectTypeName() {
    return GetInst(this).GetObjectClass().GetName()
}
function Count() {
    const a = GetInst(this).GetRuntime(),
        b = a.GetCurrentEventStackFrame().GetExpressionObjectClass();
    let c = b.GetInstanceCount();
    for (const d of a.instancesPendingCreateForObjectClass(b))
        ++c;
    return c
}
function PickedCount() {
    return GetInst(this).GetRuntime().GetCurrentEventStackFrame().GetExpressionObjectClass().GetCurrentSol().GetInstances().length
}
function GetIID() {
    return GetInst(this).GetIID()
}
function GetUID() {
    return GetInst(this).GetUID()
}
function OnInstanceSignal(a) {
    const b = GetInst(this);
    return a.toLowerCase() === b.GetRuntime().GetEventSheetManager().GetCurrentInstanceSignalTag(b)
}
function InstanceSignal(a) {
    const b = GetInst(this);
    b.GetRuntime().GetEventSheetManager().InstanceSignal(b, a)
}
function InstanceWaitForSignal(a) {
    this.GetRuntime().GetEventSheetManager().AddScheduledWait().InitInstanceSignals(this.GetCurrentSol().GetInstances(), a);
    return !0
}
function TemplateName() {
    return GetInst(this).GetTemplateName()
}
C3$jscomp$171.AddCommonACEs = function(a, b) {
    const c = a[1],
        d = a[4],
        e = a[5],
        f = a[6],
        g = a[7],
        h = a[8],
        k = a[10],
        l = a[11],
        m = a[12],
        n = a[13],
        p = a[14],
        q = a[15],
        r = a[16],
        t = b.Cnds,
        u = b.Acts,
        v = b.Exps;
    a[3] && (t.CompareX = CompareX, t.CompareY = CompareY, t.IsOnScreen = IsOnScreen, t.IsOutsideLayout = IsOutsideLayout, t.PickDistance = PickDistance, u.SetX = SetX, u.SetY = SetY, u.SetPos = SetPos, u.SetPosToObject = SetPosToObject, u.MoveForward = MoveForward, u.MoveAtAngle = MoveAtAngle, v.X = GetX, v.Y = GetY, v.dt = GetDt);
    d && (t.CompareWidth = CompareWidth, t.CompareHeight =
    CompareHeight, u.SetWidth = SetWidth, u.SetHeight = SetHeight, u.SetSize = SetSize, v.Width = GetWidth, v.Height = GetHeight, v.BBoxLeft = GetBboxLeft, v.BBoxTop = GetBboxTop, v.BBoxRight = GetBboxRight, v.BBoxBottom = GetBboxBottom, v.BBoxMidX = GetBboxMidX, v.BBoxMidY = GetBboxMidY);
    e && (t.AngleWithin = IsAngleWithin, t.IsClockwiseFrom = IsAngleClockwiseFrom, t.IsBetweenAngles = IsBetweenAngles, u.SetAngle = SetAngle, u.RotateClockwise = RotateClockwise, u.RotateCounterclockwise = RotateCounterclockwise, u.RotateTowardAngle = RotateTowardAngle, u.RotateTowardPosition =
    RotateTowardPosition, u.SetTowardPosition = SetTowardPosition, v.Angle = GetAngle);
    f && (t.IsVisible = IsVisible, t.CompareOpacity = CompareOpacity, u.SetVisible = SetVisible, u.SetOpacity = SetOpacity, u.SetDefaultColor = SetDefaultColor, v.Opacity = GetOpacity, v.ColorValue = GetColor);
    g && (t.IsOnLayer = IsOnLayer, t.PickTopBottom = PickTopBottom, t.CompareZElevation = CompareZElevation, u.MoveToTop = MoveToTop, u.MoveToBottom = MoveToBottom, u.MoveToLayer = MoveToLayer, u.ZMoveToObject = ZMoveToObject, u.SetZElevation = SetZElevation, v.LayerNumber =
    LayerNumber, v.LayerName = LayerName, v.ZIndex = ZIndex, v.ZElevation = ZElevation, v.TotalZElevation = TotalZElevation);
    h && (t.IsEffectEnabled = IsEffectEnabled, u.SetEffectEnabled = SetEffectEnabled, u.SetEffectParam = SetEffectParam);
    n && (t.HasParent = HasParent, t.HasChildren = HasChildren, t.PickParent = PickParent, t.PickChildren = PickChildren, t.PickNthChild = PickNthChild, t.CompareChildCount = CompareChildCount, u.AddChild = AddChild, u.RemoveChild = RemoveChild, u.RemoveFromParent = RemoveFromParent, v.ChildCount = ChildCount, v.AllChildCount =
    AllChildCount);
    p && (u.SetMeshSize = SetMeshSize, u.SetMeshPoint = SetMeshPoint, v.MeshColumns = MeshColumns, v.MeshRows = MeshRows);
    k && (t.IsVisible = IsVisible, u.SetVisible = SetElementVisible, u.SetCSSStyle = SetElementCSSStyle, u.SetElemAttribute = SetElementAttribute, u.RemoveElemAttribute = RemoveElementAttribute);
    l && (t.IsFocused = IsElementFocused, u.SetFocus = SetElementFocus, u.SetBlur = SetElementBlur);
    m && (t.IsEnabled = IsElementEnabled, u.SetEnabled = SetElementEnabled);
    q && (t.OnCollision = OnCollision, t.IsOverlapping = IsOverlapping,
    t.IsOverlappingOffset = IsOverlappingOffset, b.FinishCollisionCondition = FinishCollisionCondition);
    c || (t.CompareInstanceVar = CompareInstanceVar, t.IsBoolInstanceVarSet = IsBoolInstanceVarSet, t.PickInstVarHiLow = PickInstVarHiLow, t.PickByUID = PickByUID, t.HasTags = HasTags, u.SetInstanceVar = SetInstanceVar, u.AddInstanceVar = AddInstanceVar, u.SubInstanceVar = SubInstanceVar, u.SetBoolInstanceVar = SetBoolInstanceVar, u.ToggleBoolInstanceVar = ToggleBoolInstanceVar, u.ChangeTags = ChangeTags, t.OnCreated = OnCreated, t.OnDestroyed =
    OnDestroyed, u.Destroy = Destroy, u.LoadFromJsonString || (u.LoadFromJsonString = LoadFromJsonString), v.AsJSON || (v.AsJSON = AsJSON), v.Count = Count, v.PickedCount = PickedCount, v.IID = GetIID, v.UID = GetUID, v.ObjectTypeName = ObjectTypeName, v.Tags = Tags, v.TagsCount = TagsCount, v.TagAt = TagAt, t.OnInstanceSignal = OnInstanceSignal, u.InstanceSignal = InstanceSignal, u.InstanceWaitForSignal = InstanceWaitForSignal);
    r && (v.TemplateName = TemplateName)
};
"use strict";
const C3$jscomp$172 = self.C3;
C3$jscomp$172.ScheduledWait = class  extends C3$jscomp$172.DefendedBase{
    constructor(a)
    {
        super();
        this._eventSheetManager = a;
        this._type = "";
        this._time = -1;
        this._signalTag = "";
        this._isSignalled = !1;
        this._event = null;
        this._actIndex = 0;
        this._solModifiers = [];
        this._dynamicSolModifiers = null;
        this._sols = new Map;
        this._callingFunctionBlock = this._pendingInstances = null;
        this._asyncId = -1;
        this._functionInnerLocalVars = this._functionParameters = null;
        this._shouldRelease = !1
    }
    Release()
    {
        this._type = "";
        this._time = -1;
        this._signalTag = "";
        this._functionInnerLocalVars = this._functionParameters = this._callingFunctionBlock = this._event = null;
        this._asyncId = -1;
        C3$jscomp$172.clearArray(this._solModifiers);
        this._dynamicSolModifiers && (this._dynamicSolModifiers.clear(), this._dynamicSolModifiers = null);
        for (const a of this._sols.values())
            a.Release();
        this._sols.clear();
        this._pendingInstances = null
    }
    _Init()
    {
        var a = this._eventSheetManager,
            b = a.GetRuntime().GetAllObjectClasses(),
            c = a.GetCurrentEventStackFrame();
        this._event = c.GetCurrentEvent();
        this._actIndex =
        c.GetActionIndex() + 1;
        if (c = a.FindFirstFunctionBlockParent(this._event))
            this._callingFunctionBlock = c,
            this._functionParameters = c.CaptureFunctionParameters(),
            this._functionInnerLocalVars = c._GetAllInnerLocalVariables().map(d => d.GetValue()),
            c.IsAsync() && (this._asyncId = c.PauseCurrentAsyncFunction());
        for (const d of b)
            if (b = d.GetCurrentSol(), !b.IsSelectAll() || this._event.HasSolModifier(d))
                this._solModifiers.push(d),
                this._sols.set(d, C3$jscomp$172.New(C3$jscomp$172.SolState, b));
        a = a.GetDynamicSolModifiersSet();
        this._dynamicSolModifiers = 0 < a.size ? a : null
    }
    InitTimer(a)
    {
        this._type = "timer";
        this._Init();
        this._time = this._eventSheetManager.GetRuntime().GetGameTime() + a
    }
    InitSignal(a)
    {
        this._type = "signal";
        this._Init();
        this._signalTag = a.toLowerCase()
    }
    InitInstanceSignals(a, b)
    {
        this._type = "instance-signals";
        this._Init();
        this._signalTag = b.toLowerCase();
        this._pendingInstances = new Set(a)
    }
    InitPromise(a)
    {
        this._type = "promise";
        this._Init();
        a.then(() => this.SetSignalled()).catch(b => {
            console.warn("[C3 runtime] Promise rejected in 'Wait for previous actions to complete': ",
            b);
            this.SetSignalled()
        })
    }
    IsTimer()
    {
        return "timer" === this._type
    }
    IsSignal()
    {
        return "signal" === this._type
    }
    IsInstanceSignals()
    {
        return "instance-signals" === this._type
    }
    IsPromise()
    {
        return "promise" === this._type
    }
    GetSignalTag()
    {
        return this._signalTag
    }
    IsSignalled()
    {
        return this._isSignalled
    }
    SetSignalled()
    {
        this._isSignalled = !0
    }
    SetInstanceSignalled(a)
    {
        this._pendingInstances.delete(a);
        0 === this._pendingInstances.size && this.SetSignalled()
    }
    _ShouldRun()
    {
        return this.IsTimer() ? this._time <= this._eventSheetManager.GetRuntime().GetGameTime() :
        this.IsSignalled()
    }
    _RestoreState(a)
    {
        a._Restore(this._event, this._actIndex);
        for (const [b, c] of this._sols.entries()) {
            const d = b.GetCurrentSol();
            c._Restore(d)
        }
        this._dynamicSolModifiers && a.SetDynamicSolModifiers([...this._dynamicSolModifiers]);
        if (a = this._callingFunctionBlock)
            a.SetFunctionParameters(this._functionParameters),
            a._GetAllInnerLocalVariables().map((b, c) => b.SetValue(this._functionInnerLocalVars[c])),
            a.IsAsync() && a.ResumeAsyncFunction(this._asyncId)
    }
    _Run(a)
    {
        this._RestoreState(a);
        this._event._ResumeActionsAndSubEvents(a);
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
        this._eventSheetManager.ClearSol(this._solModifiers);
        this._shouldRelease = !0
    }
    async _DebugRun(a)
    {
        this._RestoreState(a);
        for (const b of this._event._DebugResumeActionsAndSubEvents(a))
            await this._eventSheetManager.GetRuntime().DebugBreak(b);
        this._callingFunctionBlock && this._callingFunctionBlock.IsAsync() && this._callingFunctionBlock.MaybeFinishAsyncFunctionCall(this._asyncId);
        this._eventSheetManager.ClearSol(this._solModifiers);
        this._shouldRelease = !0
    }
    ShouldRelease()
    {
        return this._shouldRelease
    }
    RemoveInstances(a)
    {
        for (const b of this._sols.values())
            b.RemoveInstances(a);
        if ("instance-signals" === this._type) {
            for (const b of a)
                this._pendingInstances.delete(b);
            0 === this._pendingInstances.size && this.SetSignalled()
        }
    }
    _SaveToJson()
    {
        const a = {},
            b = {
                wt: this._type,
                t: this._time,
                st: this._signalTag,
                s: this._isSignalled,
                ev: this._event.GetSID(),
                sm: this._solModifiers.map(c => c.GetSID()),
                dsm: this._dynamicSolModifiers ?
                [...this._dynamicSolModifiers].map(c => c.GetSID()) : null,
                sols: a
            };
        this._event._HasActionIndex(this._actIndex) && (b.act = this._event.GetActionAt(this._actIndex).GetSID());
        for (const [c, d] of this._sols)
            a[c.GetSID().toString()] = d._SaveToJson();
        "instance-signals" === this._type && (b.pi = [...this._pendingInstances].map(c => c.GetUID()));
        return b
    }
    static _CreateFromJson(a, b)
    {
        const c = a.GetRuntime();
        var d = a.GetEventBlockBySID(b.ev);
        if (!d)
            return null;
        let e = 0;
        if (b.hasOwnProperty("act")) {
            var f = a.GetActionBySID(b.act);
            if (!f)
                return null;
            e = f.GetIndex()
        }
        f = C3$jscomp$172.New(C3$jscomp$172.ScheduledWait, a);
        f._time = b.t;
        b.hasOwnProperty("wt") ? f._type = b.wt : f._type = -1 === f._time ? "signal" : "timer";
        f._signalTag = b.st;
        f._isSignalled = b.s;
        f._event = d;
        f._actIndex = e;
        for (var g of b.sm)
            (d = c.GetObjectClassBySID(g)) && f._solModifiers.push(d);
        if (Array.isArray(b.dsm))
            for (var h of b.dsm)
                if (g = c.GetObjectClassBySID(h))
                    f._dynamicSolModifiers || (f._dynamicSolModifiers = new Set),
                    f._dynamicSolModifiers.add(g);
        for (const [k, l] of Object.entries(b.sols))
            if (h = parseInt(k,
            10), h = c.GetObjectClassBySID(h))
                g = C3$jscomp$172.New(C3$jscomp$172.SolState, null),
                g._LoadFromJson(a, l),
                f._sols.set(h, g);
        if ("instance-signals" === f._type) {
            f._pendingInstances = new Set;
            for (const k of b.pi)
                (a = c.GetInstanceByUID(k)) && f._pendingInstances.add(a)
        }
        return f
    }
}
;
"use strict";
const C3$jscomp$173 = self.C3;
C3$jscomp$173.SolState = class  extends C3$jscomp$173.DefendedBase{
    constructor(a)
    {
        super();
        this._objectClass = null;
        this._isSelectAll = !0;
        this._instances = [];
        a && (this._objectClass = a.GetObjectClass(), this._isSelectAll = a.IsSelectAll(), C3$jscomp$173.shallowAssignArray(this._instances, a._GetOwnInstances()))
    }
    Release()
    {
        this._objectClass = null;
        C3$jscomp$173.clearArray(this._instances)
    }
    _Restore(a)
    {
        a._SetSelectAll(this._isSelectAll);
        C3$jscomp$173.shallowAssignArray(a._GetOwnInstances(), this._instances)
    }
    RemoveInstances(a)
    {
        C3$jscomp$173.arrayRemoveAllInSet(this._instances,
        a)
    }
    _SaveToJson()
    {
        return {
            sa: this._isSelectAll,
            insts: this._instances.map(a => a.GetUID())
        }
    }
    _LoadFromJson(a, b)
    {
        a = a.GetRuntime();
        this._isSelectAll = !!b.sa;
        C3$jscomp$173.clearArray(this._instances);
        for (const c of b.insts)
            (b = a.GetInstanceByUID(c)) && this._instances.push(b)
    }
}
;
"use strict";
const C3$jscomp$174 = self.C3;
function GetNextParamMap(a, b) {
    let c = a.get(b);
    c || (c = new Map, a.set(b, c));
    return c
}
C3$jscomp$174.SDKPluginBase = class  extends C3$jscomp$174.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a.runtime;
        this._isSingleGlobal = !!a.isSingleGlobal;
        this._isWorldType = !!a.isWorld;
        this._isRotatable = !!a.isRotatable;
        this._mustPredraw = !!a.mustPredraw;
        this._hasEffects = !!a.hasEffects;
        this._supportsSceneGraph = !!a.supportsSceneGraph;
        this._supportsMesh = !!a.supportsMesh;
        this._isHTMLElementType = !!a.isHTMLElementType;
        this._is3d = !!a.is3d;
        this._sdkVersion = a.sdkVersion;
        this._singleGlobalObjectClass = null;
        this._boundACEMethodCache = new Map;
        this._boundACEMethodCache_1param = new Map;
        this._boundACEMethodCache_2params = new Map;
        this._boundACEMethodCache_3params = new Map;
        this._scriptInterfaceClass = a.scriptInterfaceClass;
        this._iPlugin = null
    }
    Release()
    {
        this._runtime = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    OnCreate() {}
    GetConstructor()
    {
        return 2 <= this.GetSdkVersion() ? this._iPlugin.constructor : this.constructor
    }
    GetSdkVersion()
    {
        return this._sdkVersion
    }
    GetScriptInterfaceClass(a=!1)
    {
        let b = this._scriptInterfaceClass;
        a && "function" !==
        typeof b && 2 <= this.GetSdkVersion() && (b = globalThis.ISDKPluginBase);
        return b
    }
    IsSingleGlobal()
    {
        return this._isSingleGlobal
    }
    IsWorldType()
    {
        return this._isWorldType
    }
    IsHTMLElementType()
    {
        return this._isHTMLElementType
    }
    Is3D()
    {
        return this._is3d
    }
    IsRotatable()
    {
        return this._isRotatable
    }
    MustPreDraw()
    {
        return this._mustPredraw
    }
    HasEffects()
    {
        return this._hasEffects
    }
    SupportsSceneGraph()
    {
        return this._supportsSceneGraph
    }
    SupportsMesh()
    {
        return this._supportsMesh
    }
    _GetBoundACEMethod(a, b)
    {
        if (!b)
            throw Error("missing 'this' binding");
        let c = this._boundACEMethodCache.get(a);
        if (c)
            return c;
        c = a.bind(b);
        this._boundACEMethodCache.set(a, c);
        return c
    }
    _GetBoundACEMethod_1param(a, b, c)
    {
        if (!b)
            throw Error("missing 'this' binding");
        const d = GetNextParamMap(this._boundACEMethodCache_1param, a);
        let e = d.get(c);
        if (e)
            return e;
        e = a.bind(b, c);
        d.set(c, e);
        return e
    }
    _GetBoundACEMethod_2params(a, b, c, d)
    {
        if (!b)
            throw Error("missing 'this' binding");
        var e = GetNextParamMap(this._boundACEMethodCache_2params, a);
        e = GetNextParamMap(e, c);
        let f = e.get(d);
        if (f)
            return f;
        f =
        a.bind(b, c, d);
        e.set(d, f);
        return f
    }
    _GetBoundACEMethod_3params(a, b, c, d, e)
    {
        if (!b)
            throw Error("missing 'this' binding");
        var f = GetNextParamMap(this._boundACEMethodCache_3params, a);
        f = GetNextParamMap(f, c);
        f = GetNextParamMap(f, d);
        let g = f.get(e);
        if (g)
            return g;
        g = a.bind(b, c, d, e);
        f.set(e, g);
        return g
    }
    _SetSingleGlobalObjectClass(a)
    {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        this._singleGlobalObjectClass = a
    }
    GetSingleGlobalObjectClass()
    {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        return this._singleGlobalObjectClass
    }
    GetSingleGlobalInstance()
    {
        if (!this.IsSingleGlobal())
            throw Error("must be single-global plugin");
        return this._singleGlobalObjectClass.GetSingleGlobalInstance()
    }
    _InitScriptInterface()
    {
        const a = this.GetSdkVersion();
        C3$jscomp$174.AddonManager._PushInitObject(this, a);
        const b = this.GetScriptInterfaceClass(!0);
        if (b) {
            if (this._iPlugin = new b, !(this._iPlugin instanceof self.IPlugin))
                throw new TypeError("plugin class must derive from IPlugin");
        } else
            this._iPlugin = new self.IPlugin;
        C3$jscomp$174.AddonManager._PopInitObject(a)
    }
    GetIPlugin()
    {
        return this._iPlugin
    }
}
;
"use strict";
const C3$jscomp$175 = self.C3;
C3$jscomp$175.SDKDOMPluginBase = class  extends C3$jscomp$175.SDKPluginBase{
    constructor(a, b)
    {
        super(a);
        this._domComponentId = b;
        this._nextElementId = 0;
        this._instMap = new Map;
        this.AddElementMessageHandler("elem-focused", c => c._OnElemFocused());
        this.AddElementMessageHandler("elem-blurred", c => {
            c && c._OnElemBlurred()
        })
    }
    Release()
    {
        super.Release()
    }
    _AddElement(a)
    {
        const b = this._nextElementId++;
        this._instMap.set(b, a);
        return b
    }
    _RemoveElement(a)
    {
        this._instMap.delete(a)
    }
    AddElementMessageHandler(a, b)
    {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
        a, c => {
            const d = this._instMap.get(c.elementId);
            b(d, c)
        })
    }
}
;
"use strict";
const C3$jscomp$176 = self.C3;
C3$jscomp$176.SDKTypeBase = class  extends C3$jscomp$176.DefendedBase{
    constructor(a)
    {
        super();
        this._objectClass = a;
        this._runtime = a.GetRuntime();
        this._plugin = a.GetPlugin()
    }
    Release()
    {
        this._plugin = this._runtime = this._objectClass = null
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetPlugin()
    {
        return this._plugin
    }
    GetImageInfo()
    {
        return this._objectClass.GetImageInfo()
    }
    OnCreate() {}
    FinishCondition(a) {}
    BeforeRunAction(a) {}
    AfterRunAction(a) {}
    LoadTextures(a) {}
    ReleaseTextures() {}
    OnDynamicTextureLoadComplete() {}
    PreloadTexturesWithInstances(a) {}
    LoadTilemapData() {}
    GetScriptInterfaceClass()
    {
        return null
    }
    DispatchScriptEvent(a, b,
    c)
    {
        a = C3$jscomp$176.New(C3$jscomp$176.Event, a, b);
        a.objectClass = this;
        c && Object.assign(a, c);
        this.GetObjectClass().DispatchUserScriptEvent(a)
    }
}
;
"use strict";
const C3$jscomp$177 = self.C3;
C3$jscomp$177.SDKInstanceBase = class  extends C3$jscomp$177.DefendedBase{
    constructor(a, b)
    {
        super();
        this._inst = a;
        this._domComponentId = b;
        this._wrapperComponentId = null;
        this._runtime = a.GetRuntime();
        this._objectClass = this._inst.GetObjectClass();
        this._sdkType = this._objectClass.GetSdkType();
        this._tick2Func = this._tickFunc = null;
        this._isTicking2 = this._isTicking = !1;
        this._disposables = null;
        this._wasReleased = !1
    }
    Release()
    {
        this._wasReleased = !0;
        this._StopTicking();
        this._StopTicking2();
        this._tick2Func = this._tickFunc =
        null;
        this._disposables && (this._disposables.Release(), this._disposables = null);
        this._sdkType = this._objectClass = this._runtime = this._inst = null
    }
    WasReleased()
    {
        return this._wasReleased
    }
    GetInstance()
    {
        return this._inst
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetPlugin()
    {
        return this._sdkType.GetPlugin()
    }
    GetSdkType()
    {
        return this._sdkType
    }
    GetScriptInterface()
    {
        return this._inst.GetInterfaceClass()
    }
    Trigger(a)
    {
        return this._runtime.Trigger(a, this._inst, null)
    }
    DebugTrigger(a)
    {
        return this._runtime.DebugTrigger(a,
        this._inst, null)
    }
    TriggerAsync(a)
    {
        return this._runtime.TriggerAsync(a, this._inst, null)
    }
    FastTrigger(a, b)
    {
        return this._runtime.FastTrigger(a, this._inst, b)
    }
    DebugFastTrigger(a, b)
    {
        return this._runtime.DebugFastTrigger(a, this._inst, b)
    }
    ScheduleTriggers(a)
    {
        return this._runtime.ScheduleTriggers(a)
    }
    AddDOMMessageHandler(a, b)
    {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId, a, b)
    }
    AddDOMMessageHandlers(a)
    {
        for (const [b, c] of a)
            this.AddDOMMessageHandler(b, c)
    }
    PostToDOM(a, b)
    {
        this._runtime.PostComponentMessageToDOM(this._domComponentId,
        a, b)
    }
    PostToDOMAsync(a, b)
    {
        return this._runtime.PostComponentMessageToDOMAsync(this._domComponentId, a, b)
    }
    _PostToDOMMaybeSync(a, b)
    {
        if (this._runtime.IsInWorker())
            this.PostToDOM(a, b);
        else
            return window.c3_runtimeInterface._OnMessageFromRuntime({
                type: "event",
                component: this._domComponentId,
                handler: a,
                data: b,
                responseId: null
            })
    }
    SetWrapperExtensionComponentId(a)
    {
        if (!a)
            throw Error("cannot set empty component id");
        this._wrapperComponentId = a
    }
    IsWrapperExtensionAvailable()
    {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        return this._runtime.HasWrapperComponentId(this._wrapperComponentId)
    }
    AddWrapperExtensionMessageHandler(a, b)
    {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        this._runtime.AddWrapperExtensionMessageHandler(this._wrapperComponentId, a, b)
    }
    AddWrapperExtensionMessageHandlers(a)
    {
        for (const [b, c] of a)
            this.AddWrapperExtensionMessageHandler(b, c)
    }
    SendWrapperExtensionMessage(a, b)
    {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        this._runtime.SendWrapperExtensionMessage(this._wrapperComponentId,
        a, b)
    }
    SendWrapperExtensionMessageAsync(a, b)
    {
        if (!this._wrapperComponentId)
            throw Error("wrapper extension component id not set");
        return this._runtime.SendWrapperExtensionMessageAsync(this._wrapperComponentId, a, b)
    }
    Tick() {}
    Tick2() {}
    _StartTicking()
    {
        this._isTicking || (this._tickFunc || (this._tickFunc = () => this.Tick()), this._runtime.Dispatcher().addEventListener("tick", this._tickFunc), this._isTicking = !0)
    }
    _StopTicking()
    {
        this._isTicking && (this._runtime.Dispatcher().removeEventListener("tick", this._tickFunc), this._isTicking =
        !1)
    }
    IsTicking()
    {
        return this._isTicking
    }
    _StartTicking2()
    {
        this._isTicking2 || (this._tick2Func || (this._tick2Func = () => this.Tick2()), this._runtime.Dispatcher().addEventListener("tick2", this._tick2Func), this._isTicking2 = !0)
    }
    _StopTicking2()
    {
        this._isTicking2 && (this._runtime.Dispatcher().removeEventListener("tick2", this._tick2Func), this._isTicking2 = !1)
    }
    IsTicking2()
    {
        return this._isTicking2
    }
    GetDebuggerProperties()
    {
        return []
    }
    SaveToJson()
    {
        return null
    }
    LoadFromJson(a) {}
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a,
    b) {}
    OffsetPropertyValueByIndex(a, b, c)
    {
        if (0 !== b) {
            var d = this.GetPropertyValueByIndex(a);
            if ("number" !== typeof d)
                throw Error("expected number");
            this.SetPropertyValueByIndex(a, d + b, c)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, c, d) {}
    CallAction(a, ...b)
    {
        a.call(this, ...b)
    }
    CallExpression(a, ...b)
    {
        return a.call(this, ...b)
    }
    GetScriptInterfaceClass()
    {
        return null
    }
    DispatchScriptEvent(a, b, c)
    {
        if (this._inst.HasScriptInterface()) {
            var d = this.GetScriptInterface();
            a = C3$jscomp$177.New(C3$jscomp$177.Event, a, b);
            a.instance = d;
            c &&
            Object.assign(a, c);
            d.dispatchEvent(a)
        }
    }
    MustPreDraw()
    {
        return !1
    }
}
;
"use strict";
const C3$jscomp$178 = self.C3;
C3$jscomp$178.SDKWorldInstanceBase = class  extends C3$jscomp$178.SDKInstanceBase{
    constructor(a, b)
    {
        super(a, b);
        this._worldInfo = a.GetWorldInfo();
        this._renderercontextrestored_handler = this._renderercontextlost_handler = null
    }
    Release()
    {
        if (this._renderercontextlost_handler) {
            const a = this._runtime.Dispatcher();
            a.removeEventListener("renderercontextlost", this._renderercontextlost_handler);
            a.removeEventListener("renderercontextrestored", this._renderercontextrestored_handler);
            this._renderercontextrestored_handler =
            this._renderercontextlost_handler = null
        }
        this._worldInfo = null;
        super.Release()
    }
    HandleWebGLContextLoss()
    {
        this.HandleRendererContextLoss()
    }
    OnWebGLContextLost() {}
    OnWebGLContextRestored() {}
    HandleRendererContextLoss()
    {
        if (!this._renderercontextlost_handler) {
            this._renderercontextlost_handler = () => this.OnRendererContextLost();
            this._renderercontextrestored_handler = () => this.OnRendererContextRestored();
            var a = this._runtime.Dispatcher();
            a.addEventListener("renderercontextlost", this._renderercontextlost_handler);
            a.addEventListener("renderercontextrestored",
            this._renderercontextrestored_handler)
        }
    }
    OnRendererContextLost()
    {
        this.OnWebGLContextLost()
    }
    OnRendererContextRestored()
    {
        this.OnWebGLContextRestored()
    }
    GetWorldInfo()
    {
        return this._worldInfo
    }
    IsOriginalSizeKnown()
    {
        return !1
    }
    GetOriginalWidth()
    {
        if (!this.IsOriginalSizeKnown())
            throw Error("original size not known");
        const a = this.GetCurrentImageInfo();
        if (a)
            return a.GetWidth()
    }
    GetOriginalHeight()
    {
        if (!this.IsOriginalSizeKnown())
            throw Error("original size not known");
        const a = this.GetCurrentImageInfo();
        if (a)
            return a.GetHeight()
    }
    GetCurrentImageInfo()
    {
        return null
    }
    GetCurrentSurfaceSize()
    {
        var a =
        this.GetCurrentImageInfo();
        return a && (a = a.GetTexture()) ? [a.GetWidth(), a.GetHeight()] : [100, 100]
    }
    GetCurrentTexRect()
    {
        const a = this.GetCurrentImageInfo();
        return a ? a.GetTexRect() : null
    }
    GetCurrentTexQuad()
    {
        const a = this.GetCurrentImageInfo();
        return a ? a.GetTexQuad() : null
    }
    IsCurrentTexRotated()
    {
        const a = this.GetCurrentImageInfo();
        return a ? a.IsRotated() : !1
    }
    GetImagePoint(a)
    {
        a = this._inst.GetWorldInfo();
        return [a.GetX(), a.GetY(), a.GetTotalZElevation()]
    }
    LoadTilemapData(a, b, c) {}
    TestPointOverlapTile(a, b) {}
    RendersToOwnZPlane()
    {
        return !0
    }
}
;
"use strict";
const C3$jscomp$179 = self.C3,
    tempRect$jscomp$6 = C3$jscomp$179.New(C3$jscomp$179.Rect);
C3$jscomp$179.SDKDOMInstanceBase = class  extends C3$jscomp$179.SDKWorldInstanceBase{
    constructor(a, b)
    {
        super(a, b);
        this._elementId = this.GetPlugin()._AddElement(this);
        this._isElementShowing = !0;
        this._autoFontSize = this._elemHasFocus = !1;
        this._autoFontSizeOffset = -.2;
        this._lastRect = C3$jscomp$179.New(C3$jscomp$179.Rect, 0, 0, -1, -1);
        a = this._runtime.GetCanvasManager();
        this._lastWindowWidth = a.GetLastWidth();
        this._lastWindowHeight = a.GetLastHeight();
        this._lastHTMLZIndex = this._lastHTMLIndex = -1;
        this._isPendingUpdateState =
        !1;
        this._StartTicking()
    }
    Release()
    {
        this.GetPlugin()._RemoveElement(this._elementId);
        this.PostToDOMElement("destroy");
        this._elementId = -1;
        super.Release()
    }
    _GetElementInDOMMode()
    {
        if (this._runtime.IsInWorker())
            throw Error("not valid in worker mode");
        return this._PostToDOMElementMaybeSync("get-element")
    }
    PostToDOMElement(a, b)
    {
        b || (b = {});
        b.elementId = this._elementId;
        this.PostToDOM(a, b)
    }
    _PostToDOMElementMaybeSync(a, b)
    {
        b || (b = {});
        b.elementId = this._elementId;
        return this._PostToDOMMaybeSync(a, b)
    }
    PostToDOMElementAsync(a,
    b)
    {
        b || (b = {});
        b.elementId = this._elementId;
        return this.PostToDOMAsync(a, b)
    }
    CreateElement(a)
    {
        a || (a = {});
        const b = this.GetWorldInfo();
        a.elementId = this._elementId;
        a.isVisible = b.IsVisible();
        a.htmlIndex = b.GetLayer().GetHTMLIndex();
        a.htmlZIndex = b.GetHTMLZIndex();
        Object.assign(a, this.GetElementState());
        this._isElementShowing = !!a.isVisible;
        this._PostToDOMMaybeSync("create", a);
        this._UpdatePosition(!0)
    }
    SetElementVisible(a)
    {
        a = !!a;
        this._isElementShowing !== a && (this._isElementShowing = a, this.PostToDOMElement("set-visible",
        {
            isVisible: a
        }))
    }
    Tick()
    {
        this._UpdatePosition(!1)
    }
    _ShouldPreserveElement()
    {
        const a = this._runtime.GetCanvasManager().GetFullscreenMode();
        return "Android" === C3$jscomp$179.Platform.OS && ("scale-inner" === a || "scale-outer" === a || "crop" === a)
    }
    _UpdatePosition(a)
    {
        if (!this.GetInstance().IsDestroyed()) {
            var b = this.GetWorldInfo(),
                c = b.GetLayer(),
                d = b.GetBoundingBox(),
                [e, f] = c.LayerToCanvasCss(d.getLeft(), d.getTop()),
                [g, h] = c.LayerToCanvasCss(d.getRight(), d.getBottom()),
                k = this._runtime.GetCanvasManager();
            d = k.GetCssWidth();
            var l = k.GetCssHeight();
            b.IsVisible() && c.IsVisible() ? !this._ShouldPreserveElement() && (0 >= g || 0 >= h || e >= d || f >= l) ? this.SetElementVisible(!1) : (tempRect$jscomp$6.set(e, f, g, h), d = k.GetLastWidth(), l = k.GetLastHeight(), k = c.GetHTMLIndex(), b = b.GetHTMLZIndex(), !a && tempRect$jscomp$6.equals(this._lastRect) && this._lastWindowWidth === d && this._lastWindowHeight === l && this._lastHTMLIndex === k && this._lastHTMLZIndex === b ? this.SetElementVisible(!0) : (this._lastRect.copy(tempRect$jscomp$6), this._lastWindowWidth = d, this._lastWindowHeight =
            l, this._lastHTMLIndex = k, this._lastHTMLZIndex = b, this.SetElementVisible(!0), a = null, this._autoFontSize && (a = c.GetDisplayScale() + this._autoFontSizeOffset), this.PostToDOMElement("update-position", {
                left: Math.round(this._lastRect.getLeft()),
                top: Math.round(this._lastRect.getTop()),
                width: Math.round(this._lastRect.width()),
                height: Math.round(this._lastRect.height()),
                htmlIndex: k,
                htmlZIndex: b,
                fontSize: a
            }))) : this.SetElementVisible(!1)
        }
    }
    FocusElement()
    {
        this._PostToDOMElementMaybeSync("focus", {
            focus: !0
        })
    }
    BlurElement()
    {
        this._PostToDOMElementMaybeSync("focus",
        {
            focus: !1
        })
    }
    _OnElemFocused()
    {
        this._elemHasFocus = !0
    }
    _OnElemBlurred()
    {
        this._elemHasFocus = !1
    }
    IsElementFocused()
    {
        return this._elemHasFocus
    }
    SetElementCSSStyle(a, b)
    {
        this.PostToDOMElement("set-css-style", {
            prop: C3$jscomp$179.CSSToCamelCase(a),
            val: b
        })
    }
    SetElementAttribute(a, b)
    {
        this.PostToDOMElement("set-attribute", {
            name: a,
            val: b
        })
    }
    RemoveElementAttribute(a)
    {
        this.PostToDOMElement("remove-attribute", {
            name: a
        })
    }
    UpdateElementState()
    {
        this._isPendingUpdateState || (this._isPendingUpdateState = !0, Promise.resolve().then(() =>
        {
            this._isPendingUpdateState = !1;
            this.PostToDOMElement("update-state", this.GetElementState())
        }))
    }
    GetElementState() {}
    GetElementId()
    {
        return this._elementId
    }
}
;
"use strict";
const C3$jscomp$180 = self.C3,
    IBehavior$jscomp$1 = self.IBehavior;
C3$jscomp$180.SDKBehaviorBase = class  extends C3$jscomp$180.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a.runtime;
        this._myObjectClasses = C3$jscomp$180.New(C3$jscomp$180.ArraySet);
        this._myInstances = C3$jscomp$180.New(C3$jscomp$180.ArraySet);
        this._sdkVersion = a.sdkVersion;
        this._scriptInterfaceClass = a.scriptInterfaceClass;
        this._iBehavior = null
    }
    Release()
    {
        this._myInstances.Release();
        this._myObjectClasses.Release();
        this._runtime = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    OnCreate() {}
    GetSdkVersion()
    {
        return this._sdkVersion
    }
    GetScriptInterfaceClass(a=
    !1)
    {
        let b = this._scriptInterfaceClass;
        a && "function" !== typeof b && 2 <= this.GetSdkVersion() && (b = globalThis.ISDKBehaviorBase);
        return b
    }
    _AddObjectClass(a)
    {
        this._myObjectClasses.Add(a)
    }
    GetObjectClasses()
    {
        return this._myObjectClasses.GetArray()
    }
    _AddInstance(a)
    {
        this._myInstances.Add(a)
    }
    _RemoveInstance(a)
    {
        this._myInstances.Delete(a)
    }
    GetInstances()
    {
        return this._myInstances.GetArray()
    }
    _InitScriptInterface()
    {
        const a = this.GetSdkVersion();
        C3$jscomp$180.AddonManager._PushInitObject(this, a);
        const b = this.GetScriptInterfaceClass(!0);
        if (b) {
            if (this._iBehavior = new b, !(this._iBehavior instanceof IBehavior$jscomp$1))
                throw new TypeError("behavior class must derive from IBehavior");
        } else
            this._iBehavior = new IBehavior$jscomp$1;
        C3$jscomp$180.AddonManager._PopInitObject(a)
    }
    GetIBehavior()
    {
        return this._iBehavior
    }
}
;
"use strict";
const C3$jscomp$181 = self.C3;
C3$jscomp$181.SDKBehaviorTypeBase = class  extends C3$jscomp$181.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a.GetRuntime();
        this._behaviorType = a;
        this._objectClass = a.GetObjectClass();
        this._behavior = a.GetBehavior();
        this._behavior._AddObjectClass(this._objectClass)
    }
    Release()
    {
        this._behavior = this._objectClass = this._behaviorType = this._runtime = null
    }
    OnCreate() {}
    GetBehaviorType()
    {
        return this._behaviorType
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetBehavior()
    {
        return this._behavior
    }
}
;
"use strict";
const C3$jscomp$182 = self.C3;
C3$jscomp$182.SDKBehaviorInstanceBase = class  extends C3$jscomp$182.DefendedBase{
    constructor(a, b)
    {
        super();
        this._behInst = a;
        this._domComponentId = b;
        this._inst = a.GetObjectInstance();
        this._runtime = a.GetRuntime();
        this._behaviorType = a.GetBehaviorType();
        this._sdkType = this._behaviorType.GetSdkType();
        this._isPostTicking = this._isTicking2 = this._isTicking = !1;
        this._disposables = null
    }
    Release()
    {
        this._StopTicking();
        this._StopTicking2();
        this._StopPostTicking();
        this._disposables && (this._disposables.Release(), this._disposables =
        null);
        this._sdkType = this._behaviorType = this._runtime = this._inst = this._behInst = null
    }
    GetBehavior()
    {
        return this._behaviorType.GetBehavior()
    }
    GetBehaviorInstance()
    {
        return this._behInst
    }
    GetObjectInstance()
    {
        return this._inst
    }
    GetObjectClass()
    {
        return this._inst.GetObjectClass()
    }
    GetWorldInfo()
    {
        return this._inst.GetWorldInfo()
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetBehaviorType()
    {
        return this._behaviorType
    }
    GetSdkType()
    {
        return this._sdkType
    }
    GetScriptInterface()
    {
        return this._behInst.GetScriptInterface()
    }
    Trigger(a)
    {
        return this._runtime.Trigger(a,
        this._inst, this._behaviorType)
    }
    DebugTrigger(a)
    {
        return this._runtime.DebugTrigger(a, this._inst, this._behaviorType)
    }
    TriggerAsync(a)
    {
        return this._runtime.TriggerAsync(a, this._inst, this._behaviorType)
    }
    PostCreate() {}
    Tick() {}
    Tick2() {}
    PostTick() {}
    _StartTicking()
    {
        this._isTicking || (this._runtime._AddBehInstToTick(this), this._isTicking = !0)
    }
    _StopTicking()
    {
        this._isTicking && (this._runtime._RemoveBehInstToTick(this), this._isTicking = !1)
    }
    IsTicking()
    {
        return this._isTicking
    }
    _StartTicking2()
    {
        this._isTicking2 || (this._runtime._AddBehInstToTick2(this),
        this._isTicking2 = !0)
    }
    _StopTicking2()
    {
        this._isTicking2 && (this._runtime._RemoveBehInstToTick2(this), this._isTicking2 = !1)
    }
    IsTicking2()
    {
        return this._isTicking2
    }
    _StartPostTicking()
    {
        this._isPostTicking || (this._runtime._AddBehInstToPostTick(this), this._isPostTicking = !0)
    }
    _StopPostTicking()
    {
        this._isPostTicking && (this._runtime._RemoveBehInstToPostTick(this), this._isPostTicking = !1)
    }
    IsPostTicking()
    {
        return this._isPostTicking
    }
    GetDebuggerProperties()
    {
        return []
    }
    AddDOMMessageHandler(a, b)
    {
        this._runtime.AddDOMComponentMessageHandler(this._domComponentId,
        a, b)
    }
    OnSpriteFrameChanged(a, b) {}
    SaveToJson()
    {
        return null
    }
    LoadFromJson(a) {}
    GetPropertyValueByIndex(a) {}
    SetPropertyValueByIndex(a, b) {}
    OffsetPropertyValueByIndex(a, b)
    {
        if (0 !== b) {
            var c = this.GetPropertyValueByIndex(a);
            if ("number" !== typeof c)
                throw Error("expected number");
            this.SetPropertyValueByIndex(a, c + b)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, c, d) {}
    CallAction(a, ...b)
    {
        a.call(this, ...b)
    }
    CallExpression(a, ...b)
    {
        return a.call(this, ...b)
    }
    GetScriptInterfaceClass()
    {
        return null
    }
    DispatchScriptEvent(a, b, c)
    {
        if (this._behInst.HasScriptInterface()) {
            var d =
            this.GetScriptInterface();
            a = C3$jscomp$182.New(C3$jscomp$182.Event, a, b);
            a.behaviorInstance = d;
            a.instance = d.instance;
            c && Object.assign(a, c);
            d.dispatchEvent(a)
        }
    }
}
;
"use strict";
const C3$jscomp$183 = self.C3;
C3$jscomp$183.Plugins = {};
C3$jscomp$183.Behaviors = {};
const internalApiToken$jscomp$14 = C3$jscomp$183._GetInternalAPIToken();
function ValidateInternalAPIToken(a) {
    if (a !== internalApiToken$jscomp$14)
        throw Error("invalid internal API token");
}
let initObjectStack = [],
    initObjectStack2 = [],
    initPropertiesStack = [],
    originalPushInitObject = null,
    originalPopInitObject = null,
    originalGetInitObject = null,
    originalGetInitObject2 = null;
const pluginsByCtor = new Map,
    behaviorsByCtor = new Map;
C3$jscomp$183.AddonManager = class  extends C3$jscomp$183.DefendedBase{
    constructor(a, b)
    {
        super();
        this._runtime = a;
        this._allPlugins = [];
        this._systemPlugin = null;
        this._allBehaviors = [];
        this._delayCreateBehaviors = new Map;
        this._jumpthruBehavior = this._solidBehavior = null;
        this._wrapperComponentIds = new Set(b)
    }
    CreatePlugin(a)
    {
        const b = a[19],
            c = this._runtime.GetObjectReference(a[0]);
        if (!c)
            throw Error("missing plugin");
        C3$jscomp$183.AddCommonACEs(a, c);
        a = C3$jscomp$183.New(2 <= b ? C3$jscomp$183.SDKPluginBase : c, {
            runtime: this._runtime,
            isSingleGlobal: a[1],
            isWorld: a[2],
            isRotatable: a[5],
            hasEffects: a[8],
            mustPredraw: a[9],
            supportsSceneGraph: a[13],
            supportsMesh: a[14],
            isHTMLElementType: a[17],
            is3d: a[18],
            sdkVersion: b,
            scriptInterfaceClass: 2 <= b ? c : null
        });
        a.OnCreate();
        this._allPlugins.push(a);
        pluginsByCtor.set(c, a)
    }
    CreateSystemPlugin()
    {
        this._systemPlugin = C3$jscomp$183.New(C3$jscomp$183.Plugins.System, {
            runtime: this._runtime,
            isSingleGlobal: !0
        });
        this._systemPlugin.OnCreate()
    }
    CreateBehavior(a)
    {
        const b = a[1],
            c = this._runtime.GetObjectReference(a[0]);
        if (!c)
            throw Error("missing behavior");
        this._delayCreateBehaviors.set(c, () => {
            const d = C3$jscomp$183.New(2 <= b ? C3$jscomp$183.SDKBehaviorBase : c, {
                runtime: this._runtime,
                sdkVersion: b,
                scriptInterfaceClass: 2 <= b ? c : null
            });
            d.OnCreate();
            this._allBehaviors.push(d);
            behaviorsByCtor.set(c, d);
            !this._solidBehavior && C3$jscomp$183.Behaviors.solid && d instanceof C3$jscomp$183.Behaviors.solid ? this._solidBehavior = d : !this._jumpthruBehavior && C3$jscomp$183.Behaviors.jumpthru && d instanceof C3$jscomp$183.Behaviors.jumpthru && (this._jumpthruBehavior =
            d);
            d._InitScriptInterface()
        })
    }
    _DelayCreateBehavior(a)
    {
        const b = this._delayCreateBehaviors.get(a);
        b && (b(), this._delayCreateBehaviors.delete(a))
    }
    static _PushInitObject(a, b=1)
    {
        if (C3$jscomp$183.AddonManager._PushInitObject !== originalPushInitObject)
            throw Error("invalid method");
        1 === b && initObjectStack.push(a);
        initObjectStack2.push(a)
    }
    static _PopInitObject(a=1)
    {
        if (C3$jscomp$183.AddonManager._PopInitObject !== originalPopInitObject)
            throw Error("invalid method");
        1 === a && initObjectStack.pop();
        initObjectStack2.pop()
    }
    static _GetInitObject()
    {
        if (C3$jscomp$183.AddonManager._GetInitObject !==
        originalGetInitObject)
            throw Error("invalid method");
        if (0 === initObjectStack.length)
            throw Error("no init object set");
        return initObjectStack.at(-1)
    }
    static _GetInitObject2(a)
    {
        if (C3$jscomp$183.AddonManager._GetInitObject2 !== originalGetInitObject2)
            throw Error("invalid method");
        ValidateInternalAPIToken(a);
        if (0 === initObjectStack2.length)
            throw Error("no init object set");
        return initObjectStack2.at(-1)
    }
    static _PushInitProperties(a)
    {
        initPropertiesStack.push(a)
    }
    static _PopInitProperties()
    {
        initPropertiesStack.pop()
    }
    static _GetInitProperties()
    {
        if (0 ===
        initPropertiesStack.length)
            throw Error("no init properties set");
        return initPropertiesStack.at(-1)
    }
    _InitAddonScriptInterfaces()
    {
        for (const a of this._allPlugins)
            a._InitScriptInterface()
    }
    static GetPluginByConstructorFunction(a)
    {
        return pluginsByCtor.get(a) || null
    }
    static GetBehaviorByConstructorFunction(a)
    {
        return behaviorsByCtor.get(a) || null
    }
    GetSystemPlugin()
    {
        return this._systemPlugin
    }
    GetSolidBehavior()
    {
        return this._solidBehavior
    }
    GetJumpthruBehavior()
    {
        return this._jumpthruBehavior
    }
    HasWrapperComponentId(a)
    {
        return this._wrapperComponentIds.has(a)
    }
}
;
originalPushInitObject = C3$jscomp$183.AddonManager._PushInitObject;
originalPopInitObject = C3$jscomp$183.AddonManager._PopInitObject;
originalGetInitObject = C3$jscomp$183.AddonManager._GetInitObject;
originalGetInitObject2 = C3$jscomp$183.AddonManager._GetInitObject2;
"use strict";
const C3$jscomp$184 = self.C3,
    allImageInfos = new Set;
C3$jscomp$184.ImageInfo = class  extends C3$jscomp$184.DefendedBase{
    constructor()
    {
        super();
        this._generation = 0;
        this._url = "";
        this._height = this._width = this._offsetY = this._offsetX = this._size = 0;
        this._hasMetaData = this._isRotated = !1;
        this._imageAsset = null;
        this._textureState = "";
        this._rcTex = C3$jscomp$184.New(C3$jscomp$184.Rect);
        this._quadTex = C3$jscomp$184.New(C3$jscomp$184.Quad);
        this._blobUrl = "";
        this._iImageInfo = new self.IImageInfo(this);
        allImageInfos.add(this)
    }
    Release()
    {
        this.ReleaseTexture();
        this._imageAsset &&
        0 === this._imageAsset.GetRefCount() && this._imageAsset.Release();
        this._imageAsset = null;
        allImageInfos.delete(this);
        this.ReleaseBlobURL()
    }
    static OnRendererContextLost()
    {
        for (const a of allImageInfos)
            a._textureState = "",
            a._rcTex.set(0, 0, 0, 0),
            a._quadTex.setFromRect(a._rcTex)
    }
    LoadData(a)
    {
        this._url = a[0];
        this._size = a[1];
        this._offsetX = a[2];
        this._offsetY = a[3];
        this._width = a[4];
        this._height = a[5];
        this._isRotated = a[6];
        this._hasMetaData = !0
    }
    LoadDynamicAsset(a, b)
    {
        if (this._imageAsset)
            throw Error("already loaded asset");
        this._url = b;
        const c = {};
        C3$jscomp$184.IsAbsoluteURL(b) && (c.loadPolicy = "remote");
        this.LoadAsset(a, c);
        return this._imageAsset.Load()
    }
    LoadDynamicBlobAsset(a, b)
    {
        if (this._imageAsset)
            throw Error("already loaded asset");
        this._url = "";
        this._size = b.size;
        this._imageAsset = C3$jscomp$184.New(C3$jscomp$184.ImageAsset, a.GetAssetManager(), {
            blob: b,
            size: this._size,
            loadPolicy: "local"
        })
    }
    ReplaceWith(a)
    {
        if (a === this)
            throw Error("cannot replace with self");
        this._generation++;
        this.ReleaseTexture();
        this._url = a._url;
        this._size =
        a._size;
        this._offsetX = a._offsetX;
        this._offsetY = a._offsetY;
        this._width = a._width;
        this._height = a._height;
        this._isRotated = a._isRotated;
        this._hasMetaData = a._hasMetaData;
        this._imageAsset = a._imageAsset;
        this._textureState = a._textureState;
        this._rcTex = a._rcTex;
        this._quadTex = a._quadTex;
        this.ReleaseBlobURL()
    }
    GetURL()
    {
        return this._url
    }
    GetSize()
    {
        return this._size
    }
    GetOffsetX()
    {
        return this._offsetX
    }
    GetOffsetY()
    {
        return this._offsetY
    }
    IsRotated()
    {
        return this._isRotated
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    GetSheetWidth()
    {
        return this._imageAsset.GetWidth()
    }
    GetSheetHeight()
    {
        return this._imageAsset.GetHeight()
    }
    LoadAsset(a,
    b)
    {
        if (this._imageAsset)
            throw Error("already got asset");
        b = Object.assign({}, b, {
            url: this.GetURL(),
            size: this.GetSize()
        });
        this._imageAsset = a.LoadImage(b)
    }
    IsLoaded()
    {
        return this._imageAsset && this._imageAsset.IsLoaded()
    }
    async LoadStaticTexture(a, b)
    {
        if (!this._imageAsset)
            throw Error("no asset");
        if (this._textureState)
            throw Error("already loaded texture");
        const c = this._generation;
        this._textureState = "loading";
        a = await this._imageAsset.LoadStaticTexture(a, b);
        if (this._generation !== c)
            return null;
        if (!a)
            return this._textureState =
            "", null;
        this._textureState = "loaded";
        this._hasMetaData || (this._width = a.GetWidth(), this._height = a.GetHeight(), this._hasMetaData = !0);
        this._rcTex.set(this._offsetX, this._offsetY, this._offsetX + (this._isRotated ? this._height : this._width), this._offsetY + (this._isRotated ? this._width : this._height));
        this._rcTex.divide(a.GetWidth(), a.GetHeight());
        this._quadTex.setFromRect(this._rcTex);
        this._isRotated && this._quadTex.rotatePointsAnticlockwise();
        return a
    }
    ReleaseTexture()
    {
        this._textureState && (this._imageAsset && this._imageAsset.ReleaseTexture(),
        this._textureState = "", this._rcTex.set(0, 0, 0, 0), this._quadTex.setFromRect(this._rcTex))
    }
    GetTexture()
    {
        return this._imageAsset && "loaded" === this._textureState ? this._imageAsset.GetTexture() : null
    }
    GetTexRect()
    {
        return this._rcTex
    }
    GetTexQuad()
    {
        return this._quadTex
    }
    GetIImageInfo()
    {
        return this._iImageInfo
    }
    GetImageAsset()
    {
        return this._imageAsset
    }
    async ExtractImageToCanvas(a)
    {
        a || (a = await this._imageAsset.LoadToDrawable());
        const b = C3$jscomp$184.CreateCanvas(this._width, this._height),
            c = b.getContext("2d");
        this._isRotated ?
        (c.rotate(Math.PI / -2), c.translate(-this._height, 0), c.drawImage(a, this._offsetX, this._offsetY, this._height, this._width, 0, 0, this._height, this._width)) : c.drawImage(a, this._offsetX, this._offsetY, this._width, this._height, 0, 0, this._width, this._height);
        return b
    }
    async ExtractImageToBlobURL(a)
    {
        if (this._blobUrl)
            return this._blobUrl;
        a = await this.ExtractImageToCanvas(a);
        a = await C3$jscomp$184.CanvasToBlob(a);
        return this._blobUrl = URL.createObjectURL(a)
    }
    ReleaseBlobURL()
    {
        this._blobUrl && (URL.revokeObjectURL(this._blobUrl),
        this._blobUrl = "")
    }
}
;
"use strict";
const C3$jscomp$185 = self.C3;
C3$jscomp$185.AnimationInfo = class  extends C3$jscomp$185.DefendedBase{
    constructor(a)
    {
        super();
        this._name = a[0];
        this._speed = a[1];
        this._isLooping = !!a[2];
        this._repeatCount = a[3];
        this._repeatTo = a[4];
        this._isPingPong = !!a[5];
        this._sid = a[6];
        this._frames = a[7].map(b => C3$jscomp$185.New(C3$jscomp$185.AnimationFrameInfo, b));
        this._iAnimation = new self.IAnimation(this)
    }
    static CreateDynamic(a, b)
    {
        b = C3$jscomp$185.New(C3$jscomp$185.AnimationInfo, [b, 0, !1, 0, 0, !1, Math.floor(1E15 * Math.random()), []]);
        b._frames.push(C3$jscomp$185.AnimationFrameInfo.CreateDynamic(a));
        return b
    }
    Release()
    {
        for (const a of this._frames)
            a.Release();
        C3$jscomp$185.clearArray(this._frames)
    }
    LoadAllAssets(a)
    {
        for (const b of this._frames)
            b.GetImageInfo().LoadAsset(a)
    }
    LoadAllTextures(a, b)
    {
        return Promise.all(this._frames.map(c => c.GetImageInfo().LoadStaticTexture(a, b)))
    }
    ReleaseAllTextures()
    {
        for (const a of this._frames)
            a.GetImageInfo().ReleaseTexture()
    }
    GetName()
    {
        return this._name
    }
    GetSID()
    {
        return this._sid
    }
    GetFrameCount()
    {
        return this._frames.length
    }
    GetFrames()
    {
        return this._frames
    }
    GetFrameAt(a)
    {
        a =
        Math.floor(a);
        if (0 > a || a >= this._frames.length)
            throw new RangeError("invalid frame");
        return this._frames[a]
    }
    InsertFrameAt(a, b)
    {
        b = Math.floor(b);
        0 > b ? this._frames.unshift(a) : b >= this._frames.length ? this._frames.push(a) : this._frames.splice(b, 0, a)
    }
    RemoveFrameAt(a)
    {
        a = Math.floor(a);
        if (0 > a || a >= this._frames.length)
            throw new RangeError("invalid frame");
        this._frames[a].Release();
        this._frames.splice(a, 1)
    }
    GetFrameIndexByTag(a)
    {
        for (let b = 0, c = this._frames.length; b < c; ++b)
            if (C3$jscomp$185.equalsNoCase(this._frames[b].GetTag(),
            a))
                return b;
        return -1
    }
    FrameTagOrIndexToIndex(a)
    {
        if ("string" === typeof a) {
            const b = this.GetFrameIndexByTag(a);
            if (-1 === b)
                throw Error(`cannot find animation frame with tag ${a}`);
            return b
        }
        return a
    }
    GetSpeed()
    {
        return this._speed
    }
    IsLooping()
    {
        return this._isLooping
    }
    GetRepeatCount()
    {
        return this._repeatCount
    }
    GetRepeatTo()
    {
        return this._repeatTo
    }
    IsPingPong()
    {
        return this._isPingPong
    }
    GetIAnimation()
    {
        return this._iAnimation
    }
}
;
"use strict";
const C3$jscomp$186 = self.C3,
    EMPTY_IMAGE_BLOB = (() => {
        const a = atob("iVBORw0KGgoAAAANSUhEUgAAAGQAAABkAQMAAABKLAcXAAAAAXNSR0IArs4c6QAAAANQTFRFAAAAp3o92gAAAAF0Uk5TAEDm2GYAAAATSURBVBgZYxgFo2AUjIJRQFcAAAV4AAHcRQIbAAAAAElFTkSuQmCC"),
            b = new Uint8Array(a.length);
        for (let c = 0, d = a.length; c < d; ++c)
            b[c] = a.charCodeAt(c);
        return new Blob([b], {
            type: "image/png"
        })
    })();
C3$jscomp$186.AnimationFrameInfo = class  extends C3$jscomp$186.DefendedBase{
    constructor(a)
    {
        super();
        this._imageInfo = C3$jscomp$186.New(C3$jscomp$186.ImageInfo);
        this._imageInfo.LoadData(a);
        this._duration = a[7];
        this._origin = C3$jscomp$186.New(C3$jscomp$186.Vector2, a[8], a[9]);
        this._imagePoints = a[10].map(c => C3$jscomp$186.New(C3$jscomp$186.ImagePoint, this, c));
        this._imagePointsByName = new Map;
        for (var b of this._imagePoints)
            this._imagePointsByName.set(b.GetName().toLowerCase(), b);
        this._collisionPoly = null;
        b = a[11];
        6 <= b.length && (this._collisionPoly = C3$jscomp$186.New(C3$jscomp$186.CollisionPoly, b));
        this._tag = a[12] ? a[12] : "";
        this._iAnimationFrame = new self.IAnimationFrame(this)
    }
    static CreateDynamic(a)
    {
        const b = C3$jscomp$186.New(C3$jscomp$186.AnimationFrameInfo, ["", 0, 0, 0, 100, 100, !1, 1, 0, 0, [], [], ""]);
        b._imageInfo.LoadDynamicBlobAsset(a, EMPTY_IMAGE_BLOB);
        return b
    }
    Release()
    {
        this._collisionPoly && (this._collisionPoly.Release(), this._collisionPoly = null);
        this._imageInfo.Release();
        this._imageInfo = null
    }
    GetImageInfo()
    {
        return this._imageInfo
    }
    GetDuration()
    {
        return this._duration
    }
    GetOriginX()
    {
        return this._origin.getX()
    }
    GetOriginY()
    {
        return this._origin.getY()
    }
    GetCollisionPoly()
    {
        return this._collisionPoly
    }
    GetImagePointByName(a)
    {
        return this._imagePointsByName.get(a.toLowerCase()) ||
            null
    }
    GetImagePointByIndex(a)
    {
        a = Math.floor(a);
        return 0 > a || a >= this._imagePoints.length ? null : this._imagePoints[a]
    }
    GetImagePointCount()
    {
        return this._imagePoints.length
    }
    GetTag()
    {
        return this._tag
    }
    GetIAnimationFrame()
    {
        return this._iAnimationFrame
    }
}
;
"use strict";
const C3$jscomp$187 = self.C3;
C3$jscomp$187.ImagePoint = class  extends C3$jscomp$187.DefendedBase{
    constructor(a, b)
    {
        super();
        this._afi = a;
        this._name = b[0];
        this._pos = C3$jscomp$187.New(C3$jscomp$187.Vector2, b[1], b[2])
    }
    Release() {}
    GetName()
    {
        return this._name
    }
    GetX()
    {
        return this._pos.getX()
    }
    GetY()
    {
        return this._pos.getY()
    }
    GetVec2()
    {
        return this._pos
    }
}
;
"use strict";
const C3$jscomp$188 = self.C3,
    C3Debugger$jscomp$1 = self.C3Debugger,
    IObjectClass$jscomp$1 = self.IObjectClass;
C3$jscomp$188.ObjectClass = class  extends C3$jscomp$188.DefendedBase{
    constructor(a, b, c)
    {
        super();
        var d = a.GetObjectReference(c[1]);
        this._runtime = a;
        this._plugin = C3$jscomp$188.AddonManager.GetPluginByConstructorFunction(d);
        this._sdkType = null;
        this._instSdkCtor = d.Instance;
        this._index = b;
        this._sid = c[11];
        this._name = c[0];
        this._jsPropName = this._runtime.GetJsPropName(c[14]);
        this._isGlobal = !!c[9];
        this._isFamily = !!c[2];
        this._isOnLoaderLayout = !!c[10];
        this._instVars = c[3].map(g => ({
            sid: g[0],
            type: g[1],
            name: g[2],
            jsPropName: a.GetJsPropName(g[3])
        }));
        this._behaviorsCount = c[4];
        this._effectsCount = c[5];
        this._isWorldType = this._plugin.IsWorldType();
        this._dispatcher = C3$jscomp$188.New(C3$jscomp$188.Event.Dispatcher);
        this._effectList = null;
        const [e, f] = a.GetCollisionEngine().GetCollisionCellSize();
        this._collisionGrid = C3$jscomp$188.New(C3$jscomp$188.SparseGrid, e, f);
        this._anyCollisionCellChanged = !0;
        this._familyMembersSet = this._familyMembers = null;
        this._familyIndex = -1;
        this._familyEffectMap = this._familyBehaviorMap = this._familyInstVarMap = this._familiesSet = this._families =
        null;
        this._isInContainer = !1;
        this._container = null;
        this._behaviorTypes = c[8].map(g => C3$jscomp$188.BehaviorType.Create(this, g));
        this._behaviorTypesIncludingInherited = [];
        this._behaviorsByName = new Map;
        this._behaviorNameToIndex = new Map;
        this._usedBehaviorCtors = new Set;
        this._customActionMap = new Map;
        this._solStack = C3$jscomp$188.New(C3$jscomp$188.SolStack, this);
        this._defaultInstanceData = null;
        this._defaultLayerIndex = 0;
        this._isContained = !1;
        this._animationsBySid = this._animationsByName = this._animations = this._imageInfo =
        this._container = null;
        this._textureRefCount = 0;
        this._savedData = new Map;
        this._unsavedData = new Map;
        this._instances = [];
        this._worldInfosByLayer = new Map;
        this._iidsStale = !0;
        this._plugin.HasEffects() && (this._effectList = C3$jscomp$188.New(C3$jscomp$188.EffectList, this, c[12]));
        c[6] && (this._imageInfo = C3$jscomp$188.New(C3$jscomp$188.ImageInfo), this._imageInfo.LoadData(c[6]));
        if (c[7]) {
            this._animations = c[7].map(g => C3$jscomp$188.New(C3$jscomp$188.AnimationInfo, g));
            this._animationsByName = new Map;
            this._animationsBySid =
            new Map;
            for (const g of this._animations)
                this._animationsByName.set(g.GetName().toLowerCase(), g),
                this._animationsBySid.set(g.GetSID(), g)
        }
        this._isFamily ? (this._familyMembers = [], this._familyMembersSet = new Set, this._familyIndex = this._runtime._GetNextFamilyIndex()) : (this._families = [], this._familiesSet = new Set, this._familyInstVarMap = [], this._familyBehaviorMap = [], this._familyEffectMap = []);
        b = this._plugin.GetSdkVersion();
        if (2 > b && (this._sdkType = C3$jscomp$188.New(d.Type, this, c[15]), !(this._sdkType instanceof
        C3$jscomp$188.SDKTypeBase)))
            throw Error("v1 sdk type must derive from SDKTypeBase");
        this._instanceUserScriptClass = this._iObjectClass = null;
        this._userScriptDispatcher = C3$jscomp$188.New(C3$jscomp$188.Event.Dispatcher);
        C3$jscomp$188.AddonManager._PushInitObject(this, b);
        2 <= b ? (d = d.Type, d || (d = globalThis.ISDKObjectTypeBase)) : d = this._sdkType.GetScriptInterfaceClass();
        if (d) {
            this._iObjectClass = new d(2 > b ? this : null);
            if (2 > b && !(this._iObjectClass instanceof IObjectClass$jscomp$1))
                throw new TypeError("script interface class must derive from IObjectClass");
            if (2 <= b && !(this._iObjectClass instanceof globalThis.ISDKObjectTypeBase))
                throw new TypeError("script interface class must derive from ISDKObjectTypeBase");
        } else
            this._iObjectClass = new IObjectClass$jscomp$1;
        C3$jscomp$188.AddonManager._PopInitObject(b);
        c[13] && (d = c[13]) && this._sdkType.LoadTilemapData(d[0], d[1], d[2]);
        this._runtime.UsesLoaderLayout() && !this._isFamily && !this._isOnLoaderLayout && this._isWorldType || this.OnCreate();
        this._plugin.IsSingleGlobal() && (this._plugin._SetSingleGlobalObjectClass(this),
        this._CreateSingleGlobalInstance(c));
        this._loadInstancesJson = null
    }
    static Create(a, b, c)
    {
        return C3$jscomp$188.New(C3$jscomp$188.ObjectClass, a, b, c)
    }
    Release()
    {
        this._dispatcher.Release();
        this._dispatcher = null;
        this._imageInfo && (this._imageInfo.Release(), this._imageInfo = null);
        if (this._animations) {
            for (const a of this._animations)
                a.Release();
            C3$jscomp$188.clearArray(this._animations);
            this._animationsByName.clear();
            this._animationsBySid.clear()
        }
        this._loadInstancesJson = null;
        this._solStack.Release();
        this._solStack =
        null;
        this._savedData.clear();
        this._unsavedData.clear();
        this._runtime = this._container = null
    }
    _LoadFamily(a)
    {
        for (let b = 1, c = a.length; b < c; ++b) {
            const d = this._runtime.GetObjectClassByIndex(a[b]);
            this._familyMembers.push(d);
            this._familyMembersSet.add(d);
            d._families.push(this);
            d._familiesSet.add(this)
        }
    }
    _SetContainer(a)
    {
        this._isInContainer = !0;
        this._container = a
    }
    IsInContainer()
    {
        return this._isInContainer
    }
    GetContainer()
    {
        return this._container
    }
    _OnAfterCreate()
    {
        var a = 0;
        if (!this._isFamily)
            for (var b of this._families)
                for (var c of b.GetBehaviorTypes()) {
                    const f =
                    c.GetName().toLowerCase();
                    this._behaviorsByName.set(f, c);
                    this._behaviorNameToIndex.set(f, a);
                    this._behaviorTypesIncludingInherited.push(c);
                    ++a
                }
        for (var d of this.GetBehaviorTypes())
            b = d.GetName().toLowerCase(),
            this._behaviorsByName.set(b, d),
            this._behaviorNameToIndex.set(b, a),
            this._behaviorTypesIncludingInherited.push(d),
            ++a;
        for (var e of this._behaviorTypesIncludingInherited)
            this._usedBehaviorCtors.add(e.GetBehavior().constructor);
        if (!this._isFamily && this._families.length) {
            a = this._runtime.GetFamilyCount();
            C3$jscomp$188.extendArray(this._familyInstVarMap, a, 0);
            C3$jscomp$188.extendArray(this._familyBehaviorMap, a, 0);
            C3$jscomp$188.extendArray(this._familyEffectMap, a, 0);
            a = [];
            b = e = d = 0;
            for (const f of this._families)
                if (c = f.GetFamilyIndex(), this._familyInstVarMap[c] = d, d += f.GetInstanceVariablesCount(), this._familyBehaviorMap[c] = e, e += f.GetBehaviorTypesCount(), this._familyEffectMap[c] = b, b += f.GetEffectTypesCount(), (c = f.GetEffectList()) && this._effectList)
                    for (const g of c.GetAllEffectTypes())
                        a.push(g.Clone(this._effectList));
            this._effectList && this._effectList.PrependEffectTypes(a)
        }
    }
    _CreateSingleGlobalInstance(a)
    {
        const b = this._runtime._GetNewUID(),
            c = C3$jscomp$188.New(C3$jscomp$188.Instance, {
                runtime: this._runtime,
                objectType: this,
                uid: b
            });
        c._CreateSdkInstance(a[16], []);
        this._runtime._MapInstanceByUID(b, c);
        this._instances.push(c)
    }
    GetSdkType()
    {
        return this._sdkType
    }
    IsOnLoaderLayout()
    {
        return this._isOnLoaderLayout
    }
    Dispatcher()
    {
        return this._dispatcher
    }
    OnCreate()
    {
        this._isFamily || (this._sdkType ? this._sdkType.OnCreate() : this._iObjectClass._onCreate())
    }
    HasLoadedTextures()
    {
        return 0 <
        this._textureRefCount
    }
    async LoadTextures(a)
    {
        this._isFamily || (this._textureRefCount++, 1 === this._textureRefCount && (this._sdkType ? await this._sdkType.LoadTextures(a) : await this._iObjectClass._loadTextures(this._runtime.GetCanvasManager().GetIRenderer())))
    }
    ReleaseTextures()
    {
        if (!this._isFamily) {
            this._textureRefCount--;
            if (0 > this._textureRefCount)
                throw Error("released textures too many times");
            0 === this._textureRefCount && (this._sdkType ? this._sdkType.ReleaseTextures() : this._iObjectClass._releaseTextures(this._runtime.GetCanvasManager().GetIRenderer()))
        }
    }
    OnDynamicTextureLoadComplete()
    {
        if (this._isFamily)
            throw Error("not applicable to family");
        this._sdkType ? this._sdkType.OnDynamicTextureLoadComplete() : this._iObjectClass._onDynamicTextureLoadComplete()
    }
    async PreloadTexturesWithInstances(a)
    {
        this._isFamily || (this._sdkType ? await this._sdkType.PreloadTexturesWithInstances(a) : await this._iObjectClass._preloadTexturesWithInstances(this._runtime.GetCanvasManager().GetIRenderer()))
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetPlugin()
    {
        return this._plugin
    }
    GetInstanceSdkCtor()
    {
        return this._instSdkCtor
    }
    GetName()
    {
        return this._name
    }
    GetJsPropName()
    {
        return this._jsPropName
    }
    GetIndex()
    {
        return this._index
    }
    GetSID()
    {
        return this._sid
    }
    IsFamily()
    {
        return this._isFamily
    }
    IsGlobal()
    {
        return this._isGlobal
    }
    IsWorldType()
    {
        return this._isWorldType
    }
    GetFamilyIndex()
    {
        return this._familyIndex
    }
    GetBehaviorTypes()
    {
        return this._behaviorTypes
    }
    GetBehaviorTypesCount()
    {
        return this._behaviorsCount
    }
    UsesBehaviorByCtor(a)
    {
        return a &&
            this._usedBehaviorCtors.has(a)
    }
    GetInstanceVariablesCount()
    {
        return this._instVars.length
    }
    GetInstanceVariableSIDs()
    {
        return this._instVars.map(a => a.sid)
    }
    GetInstanceVariableIndexBySID(a)
    {
        return this._instVars.findIndex(b => b.sid === a)
    }
    GetInstanceVariableIndexByName(a)
    {
        return this._instVars.findIndex(b => b.name === a)
    }
    _GetAllInstanceVariableNames()
    {
        return this._instVars.map(a => a.name)
    }
    _GetAllInstanceVariableJsPropNames()
    {
        return this._instVars.map(a => a.jsPropName)
    }
    GetInstanceVariableType(a)
    {
        a = Math.floor(a);
        if (0 > a || a >= this._instVars.length)
            throw new RangeError("invalid instance variable index");
        return this._instVars[a].type
    }
    GetInstanceVariableName(a)
    {
        a = Math.floor(a);
        if (0 > a || a >= this._instVars.length)
            throw new RangeError("invalid instance variable index");
        return this._instVars[a].name
    }
    GetEffectTypesCount()
    {
        return this._effectsCount
    }
    GetBehaviorTypesIncludingInherited()
    {
        return this._behaviorTypesIncludingInherited
    }
    GetBehaviorTypeByName(a)
    {
        return this._behaviorsByName.get(a.toLowerCase()) || null
    }
    GetBehaviorIndexByName(a)
    {
        a =
        this._behaviorNameToIndex.get(a.toLowerCase());
        return "undefined" === typeof a ? -1 : a
    }
    GetEffectList()
    {
        return this._effectList
    }
    HasEffects()
    {
        return this._plugin.HasEffects()
    }
    UsesEffects()
    {
        return this._effectList && this._effectList.HasAnyEffectType()
    }
    GetSolStack()
    {
        return this._solStack
    }
    GetCurrentSol()
    {
        return this._solStack.GetCurrentSol()
    }
    GetImageInfo()
    {
        return this._imageInfo
    }
    SetDefaultInstanceData(a)
    {
        this._defaultInstanceData = a
    }
    GetDefaultInstanceData()
    {
        return this._defaultInstanceData
    }
    _SetDefaultLayerIndex(a)
    {
        this._defaultLayerIndex =
        a
    }
    GetDefaultLayerIndex()
    {
        return this._defaultLayerIndex
    }
    GetAnimations()
    {
        return this._animations
    }
    GetAnimationCount()
    {
        return this._animations.length
    }
    GetFamilies()
    {
        return this._families
    }
    BelongsToFamily(a)
    {
        return this._familiesSet.has(a)
    }
    GetFamilyMembers()
    {
        return this._familyMembers
    }
    FamilyHasMember(a)
    {
        return this._familyMembersSet.has(a)
    }
    GetFamilyBehaviorOffset(a)
    {
        return this._familyBehaviorMap[a]
    }
    GetFamilyInstanceVariableOffset(a)
    {
        return this._familyInstVarMap[a]
    }
    AddCustomAction(a)
    {
        this._customActionMap.set(a.GetACEName().toLowerCase(),
        a)
    }
    HasOwnCustomActionByName(a)
    {
        return !!this.GetOwnCustomActionByName(a)
    }
    GetOwnCustomActionByName(a)
    {
        return (a = this._customActionMap.get(a.toLowerCase())) && a.IsEnabled() ? a : null
    }
    GetAllAnimations()
    {
        return this._animations
    }
    GetAnimationByName(a)
    {
        if (!this._animations)
            throw Error("no animations");
        return this._animationsByName.get(a.toLowerCase()) || null
    }
    GetAnimationBySID(a)
    {
        if (!this._animations)
            throw Error("no animations");
        return this._animationsBySid.get(a) || null
    }
    AddAnimation(a)
    {
        if (this.GetAnimationByName(a))
            throw Error(`animation name '${a}' already exists`);
        a = C3$jscomp$188.AnimationInfo.CreateDynamic(this.GetRuntime(), a);
        this._animations.push(a);
        this._animationsByName.set(a.GetName().toLowerCase(), a);
        this._animationsBySid.set(a.GetSID(), a);
        return a
    }
    RemoveAnimation(a)
    {
        const b = this.GetAnimationByName(a);
        if (!b)
            throw Error(`animation name '${a}' does not exist`);
        if (1 === this._animations.length)
            throw Error("cannot remove last animation");
        a = this._animations.indexOf(b);
        this._animations.splice(a, 1);
        this._animationsByName.delete(b.GetName().toLowerCase());
        this._animationsBySid.delete(b.GetSID());
        b.Release()
    }
    GetFirstAnimation()
    {
        if (!this._animations)
            throw Error("no animations");
        return this._animations[0]
    }
    GetFirstAnimationFrame()
    {
        return this.GetFirstAnimation().GetFrameAt(0)
    }
    GetDefaultInstanceSize()
    {
        if (this._animations) {
            const a = this.GetFirstAnimationFrame().GetImageInfo();
            return [a.GetWidth(), a.GetHeight()]
        }
        return this._imageInfo ? [this._imageInfo.GetWidth(), this._imageInfo.GetHeight()] : [100, 100]
    }
    GetSingleGlobalInstance()
    {
        if (!this._plugin.IsSingleGlobal())
            throw Error("not a single-global plugin");
        return this._instances[0]
    }
    GetInstances()
    {
        return this._instances
    }
    *instances()
    {
        yield *this._instances
    }
    *instancesIncludingPendingCreate()
    {
        yield *this._instances;
        yield *this._runtime.instancesPendingCreateForObjectClass(this)
    }
    GetInstanceCount()
    {
        return this._instances.length
    }
    _AddInstance(a)
    {
        this._instances.push(a)
    }
    _SetIIDsStale()
    {
        this._iidsStale = !0
    }
    _UpdateIIDs()
    {
        if (this._iidsStale && !this._isFamily) {
            var a = this._instances,
                b = 0;
            for (let c = a.length; b < c; ++b)
                a[b]._SetIID(b);
            a = this._runtime._GetInstancesPendingCreate();
            for (const c of a)
                c.GetObjectClass() === this && c._SetIID(b++);
            this._iidsStale = !1
        }
    }
    GetInstanceByIID(a)
    {
        var b = this._instances;
        if (a < b.length)
            return b[a];
        a -= b.length;
        b = this._runtime._GetInstancesPendingCreate();
        for (const c of b)
            if (c.GetObjectClass() === this) {
                if (0 === a)
                    return c;
                --a
            }
        return null
    }
    GetFirstPicked(a)
    {
        if (a && a.IsInContainer() && a.GetObjectClass() !== this)
            for (const b of a.siblings())
                if (b.GetObjectClass() === this)
                    return b;
        a = this.GetCurrentSol().GetInstances();
        return a.length ? a[0] : null
    }
    GetPairedInstance(a)
    {
        const b =
        this.GetCurrentSol().GetInstances();
        return 0 < b.length ? b[a.GetIID() % b.length] : null
    }
    *allCorrespondingInstances(a, b)
    {
        const c = this.GetCurrentSol().GetInstances();
        var d = c.length;
        const e = b.GetCurrentSol(),
            f = b.GetCurrentSol().GetInstances(),
            g = f.length;
        var h = a.GetIID();
        if (b.IsFamily() || !e.IsSelectAll())
            h = f.indexOf(a);
        a = Math.ceil(d / g);
        d %= g;
        0 === d || h < d ? (h *= a, d = a) : (h = d * a + (h - d) * (a - 1), d = a - 1);
        for (let k = h, l = h + d; k < l; ++k)
            yield c[k]
    }
    FinishCondition(a)
    {
        this._sdkType?.FinishCondition(a)
    }
    ApplySolToContainer()
    {
        if (this._isInContainer &&
        !this._isFamily) {
            this._UpdateIIDs();
            var a = this.GetCurrentSol(),
                b = a._GetOwnInstances(),
                c = a.IsSelectAll(),
                d = this._runtime.GetCurrentEventStackFrame();
            d = d && d.GetCurrentEvent() && d.GetCurrentEvent().IsOrBlock();
            for (const g of this._container.objectTypes())
                if (g !== this) {
                    g._UpdateIIDs();
                    var e = g.GetCurrentSol();
                    e._SetSelectAll(c);
                    if (!c) {
                        var f = e._GetOwnInstances();
                        C3$jscomp$188.clearArray(f);
                        for (const h of b)
                            f.push(g.GetInstanceByIID(h.GetIID()));
                        if (d) {
                            f = a._GetOwnElseInstances();
                            e = e._GetOwnElseInstances();
                            C3$jscomp$188.clearArray(e);
                            for (const h of f)
                                e.push(g.GetInstanceByIID(h.GetIID()))
                        }
                    }
                }
        }
    }
    _TruncateContainerSols(a, b)
    {
        for (const c of this.GetContainer().objectTypes()) {
            const d = c.GetCurrentSol();
            a ? C3$jscomp$188.truncateArray(d._GetOwnElseInstances(), b) : C3$jscomp$188.truncateArray(d._GetOwnInstances(), b)
        }
    }
    _GetCollisionCellGrid()
    {
        return this._collisionGrid
    }
    _SetAnyCollisionCellChanged(a)
    {
        this._anyCollisionCellChanged = !!a
    }
    _UpdateAllCollisionCells()
    {
        if (this._anyCollisionCellChanged && this._isWorldType) {
            for (const a of this._instances)
                a.GetWorldInfo()._UpdateCollisionCell();
            for (const a of this._runtime._GetInstancesPendingCreate())
                a.GetObjectClass() === this && a.GetWorldInfo()._UpdateCollisionCell();
            this._anyCollisionCellChanged = !1
        }
    }
    _OnWorldInstanceLayerChanged(a, b, c)
    {
        if (b) {
            const d = this._worldInfosByLayer.get(b);
            d && (d.delete(a), 0 === d.size && this._worldInfosByLayer.delete(b))
        }
        c && (b = this._worldInfosByLayer.get(c), b || (b = new Set, this._worldInfosByLayer.set(c, b)), b.add(a))
    }
    layersHasInstancesOn()
    {
        if (this.IsFamily()) {
            const a = new Set;
            for (const b of this._familyMembers)
                for (const c of b.layersHasInstancesOn())
                    a.add(c);
            return a.values()
        }
        return this._worldInfosByLayer.keys()
    }
    GetSavedDataMap()
    {
        this._savedData || (this._savedData = new Map);
        return this._savedData
    }
    GetUnsavedDataMap()
    {
        this._unsavedData || (this._unsavedData = new Map);
        return this._unsavedData
    }
    HasSolidBehavior()
    {
        return this.UsesBehaviorByCtor(C3$jscomp$188.Behaviors.solid)
    }
    HasJumpthruBehavior()
    {
        return this.UsesBehaviorByCtor(C3$jscomp$188.Behaviors.jumpthru)
    }
    HasNoSaveBehavior()
    {
        return this.UsesBehaviorByCtor(C3$jscomp$188.Behaviors.NoSave)
    }
    HasPersistBehavior()
    {
        return this.UsesBehaviorByCtor(C3$jscomp$188.Behaviors.Persist)
    }
    _SaveToJson()
    {
        const a =
        {
            instances: this._instances.map(b => b.SaveToJson())
        };
        this._savedData && this._savedData.size && (a.ex = C3$jscomp$188.ToSuperJSON(this._savedData));
        return a
    }
    _LoadFromJson(a, b)
    {
        this._savedData && (this._savedData.clear(), this._savedData = null);
        var c = a.ex;
        c && (this._savedData = C3$jscomp$188.FromSuperJSON(c));
        c = this._instances;
        a = a.instances;
        for (let e = 0, f = Math.min(c.length, a.length); e < f; ++e)
            c[e].LoadFromJson(a[e]);
        for (let e = a.length, f = c.length; e < f; ++e)
            this._runtime.DestroyInstance(c[e]);
        for (let e = c.length, f = a.length; e <
        f; ++e) {
            c = a[e];
            var d = null;
            if (this.IsWorldType() && (d = this._runtime.GetMainRunningLayout().GetLayerBySID(c.w.l), !d))
                continue;
            d = this._runtime.CreateInstanceFromData(this._defaultInstanceData || this, d, !1, 0, 0, !0);
            d.LoadFromJson(c);
            b && b.add(d)
        }
        this._loadInstancesJson = a;
        this._SetIIDsStale()
    }
    _GetLoadInstancesJson()
    {
        return this._loadInstancesJson
    }
    _ClearLoadInstancesJson()
    {
        this._loadInstancesJson = null
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout()
    {
        for (let a = 0, b = this._instances; a < b; ++a)
            this._instances[a]._SetupSceneGraphConnectionsOnChangeOfLayout()
    }
    GetIObjectClass()
    {
        return this._iObjectClass
    }
    UserScriptDispatcher()
    {
        return this._userScriptDispatcher
    }
    _GetUserScriptInstanceClass()
    {
        return this._instanceUserScriptClass
    }
    _SetUserScriptInstanceClass(a)
    {
        this._instanceUserScriptClass =
        a
    }
    DispatchUserScriptEvent(a)
    {
        var b = this._runtime;
        (b = b.IsDebug() && !b.GetEventSheetManager().IsInEventEngine()) && C3Debugger$jscomp$1.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger$jscomp$1.AddScriptTime()
    }
}
;
"use strict";
const C3$jscomp$189 = self.C3;
C3$jscomp$189.Container = class  extends C3$jscomp$189.DefendedBase{
    constructor(a, b)
    {
        super();
        this._runtime = a;
        this._objectTypes = b;
        for (const c of this._objectTypes)
            c._SetContainer(this)
    }
    Release()
    {
        this._runtime = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetObjectTypes()
    {
        return this._objectTypes
    }
    objectTypes()
    {
        return this._objectTypes
    }
    HasAnyWorldType()
    {
        return this._objectTypes.some(a => a.IsWorldType())
    }
}
;
"use strict";
const C3$jscomp$190 = self.C3,
    C3Debugger$jscomp$2 = self.C3Debugger,
    originalAddonManager = C3$jscomp$190.AddonManager,
    EMPTY_ARRAY$jscomp$1 = [];
let nextPuid = 0;
const savedDataMaps = new WeakMap,
    unsavedDataMaps = new WeakMap,
    FLAG_DESTROYED = 1,
    FLAG_TILEMAP = 2,
    FLAG_MUST_PREDRAW = 4,
    FLAG_SOLID_ENABLED = 8,
    FLAG_JUMPTHRU_ENABLED = 16,
    FLAG_MUST_MITIGATE_Z_FIGHTING = 32,
    FLAG_IS_DRAWING_WITH_EFFECTS = 64;
C3$jscomp$190.Instance = class  extends C3$jscomp$190.DefendedBase{
    constructor(a)
    {
        if (C3$jscomp$190.AddonManager !== originalAddonManager)
            throw Error("invalid addon manager");
        super();
        this._runtime = a.runtime;
        this._objectType = a.objectType;
        this._iScriptInterface = this._sdkInst = this._worldInfo = null;
        this._iid = 0;
        this._uid = a.uid;
        this._puid = nextPuid++;
        this._flags = 0;
        this._tagsSet = null;
        var b = C3$jscomp$190.splitStringAndNormalize(a.tags);
        0 < b.length && (this._tagsSet = new Set(b));
        this._behaviorInstances = this._instVarValues =
        EMPTY_ARRAY$jscomp$1;
        b = this._objectType.GetBehaviorTypesIncludingInherited();
        0 < b.length && (this._behaviorInstances = b.map((c, d) => C3$jscomp$190.New(C3$jscomp$190.BehaviorInstance, {
            runtime: this._runtime,
            behaviorType: c,
            instance: this,
            index: d
        })));
        this._siblings = this._objectType.IsInContainer() ? [] : null;
        this._timeScale = -1;
        this._dispatcher = null;
        b = this.GetPlugin();
        b.MustPreDraw() && (this._flags |= FLAG_MUST_PREDRAW);
        if (b.IsWorldType())
            if (this._worldInfo = C3$jscomp$190.New(C3$jscomp$190.WorldInfo, this, a.layer), a.worldData)
                this._worldInfo.Init(a.worldData);
            else {
                this._worldInfo.InitNoData();
                const [c, d] = this._objectType.GetDefaultInstanceSize();
                this._worldInfo.SetSize(c, d);
                this.GetObjectClass().UsesEffects() && this._worldInfo.GetInstanceEffectList().LoadDefaultEffectParameters()
            }
        a.instVarData ? this._LoadInstanceVariableData(a.instVarData) : this._LoadDefaultInstanceVariables()
    }
    Release()
    {
        this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null);
        if (0 < this._behaviorInstances.length) {
            for (var a of this._behaviorInstances)
                a.Release();
            C3$jscomp$190.clearArray(this._behaviorInstances)
        }
        this._sdkInst && (this._sdkInst.Release(), this._sdkInst = null);
        if (a = savedDataMaps.get(this))
            a.clear(),
            savedDataMaps.delete(this);
        if (a = unsavedDataMaps.get(this))
            a.clear(),
            unsavedDataMaps.delete(this);
        this._siblings && C3$jscomp$190.clearArray(this._siblings);
        this._dispatcher && (this._dispatcher.Release(), this._dispatcher = null);
        this._tagsSet && this._tagsSet.clear();
        this._objectType = this._runtime = this._tagsSet = null;
        0 < this._instVarValues.length && C3$jscomp$190.clearArray(this._instVarValues);
        this._worldInfo && (this._worldInfo.Release(), this._worldInfo = null)
    }
    _LoadInstanceVariableData(a)
    {
        0 < a.length && (this._instVarValues = [], C3$jscomp$190.shallowAssignArray(this._instVarValues, a))
    }
    _LoadDefaultInstanceVariables()
    {
        const a = this._objectType.GetInstanceVariablesCount();
        if (0 !== a) {
            this._instVarValues = [];
            var b = [0, 0, ""];
            for (let c = 0; c < a; ++c)
                this._instVarValues.push(b[this._objectType.GetInstanceVariableType(c)])
        }
    }
    _CreateSdkInstance(a, b)
    {
        if (this._sdkInst)
            throw Error("already got sdk instance");
        for (let c =
            0, d = this._behaviorInstances.length; c < d; ++c)
            this._behaviorInstances[c]._CreateSdkInstance(b ? b[c] : null);
        if (2 > this.GetPlugin().GetSdkVersion()) {
            this._sdkInst = C3$jscomp$190.New(this._objectType.GetInstanceSdkCtor(), this, a);
            if (!(this._sdkInst instanceof C3$jscomp$190.SDKInstanceBase))
                throw Error("sdk type must derive from SDKInstanceBase");
            !this.GetPlugin().IsWorldType() && this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass()
        } else
            b = this.GetPlugin().GetScriptInterfaceClass(),
            this._InitUserScriptInterface(b.Instance,
            a)
    }
    GetSdkInstance()
    {
        return this._sdkInst ?? this._iScriptInterface
    }
    GetWorldInfo()
    {
        return this._worldInfo
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetTimeScale()
    {
        return this._timeScale
    }
    GetActiveTimeScale()
    {
        const a = this._timeScale;
        return -1 === a ? this.GetRuntime().GetTimeScale() : a
    }
    SetTimeScale(a)
    {
        a = +a;
        if (0 > a || !isFinite(a))
            a = 0;
        this._timeScale = a;
        this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this, !0)
    }
    RestoreTimeScale()
    {
        this._timeScale = -1;
        this.GetObjectClass().UsesEffects() && this._runtime._SetTrackingInstanceTime(this,
        !1)
    }
    GetInstanceGameTime()
    {
        return this._runtime._GetInstanceGameTime(this)
    }
    Dispatcher()
    {
        this._dispatcher || (this._dispatcher = C3$jscomp$190.New(C3$jscomp$190.Event.Dispatcher));
        return this._dispatcher
    }
    Draw(a)
    {
        this._sdkInst ? this._sdkInst.Draw(a) : this._iScriptInterface._draw(this._runtime.GetCanvasManager().GetIRenderer())
    }
    OnCreate(a)
    {
        this._sdkInst.OnCreate(a)
    }
    _SetHasTilemap()
    {
        this._flags |= FLAG_TILEMAP
    }
    HasTilemap()
    {
        return 0 !== (this._flags & FLAG_TILEMAP)
    }
    _MarkDestroyed()
    {
        this._flags |= FLAG_DESTROYED
    }
    IsDestroyed()
    {
        return 0 !==
        (this._flags & FLAG_DESTROYED)
    }
    MustPreDraw()
    {
        return 0 !== (this._flags & FLAG_MUST_PREDRAW) || this._sdkInst.MustPreDraw()
    }
    SetMustMitigateZFighting()
    {
        this._flags |= FLAG_MUST_MITIGATE_Z_FIGHTING
    }
    MustMitigateZFighting()
    {
        return 0 !== (this._flags & FLAG_MUST_MITIGATE_Z_FIGHTING)
    }
    _IsSolidEnabled()
    {
        return 0 !== (this._flags & FLAG_SOLID_ENABLED)
    }
    _SetSolidEnabled(a)
    {
        this._flags = a ? this._flags | FLAG_SOLID_ENABLED : this._flags & ~FLAG_SOLID_ENABLED
    }
    _IsJumpthruEnabled()
    {
        return 0 !== (this._flags & FLAG_JUMPTHRU_ENABLED)
    }
    _SetJumpthruEnabled(a)
    {
        this._flags =
        a ? this._flags | FLAG_JUMPTHRU_ENABLED : this._flags & ~FLAG_JUMPTHRU_ENABLED
    }
    _IsDrawingWithEffects()
    {
        return 0 !== (this._flags & FLAG_IS_DRAWING_WITH_EFFECTS)
    }
    _SetIsDrawingWithEffects(a)
    {
        this._flags = a ? this._flags | FLAG_IS_DRAWING_WITH_EFFECTS : this._flags & ~FLAG_IS_DRAWING_WITH_EFFECTS
    }
    SetFlag(a, b)
    {
        a <<= 16;
        this._flags = b ? this._flags | a : this._flags & ~a
    }
    GetFlag(a)
    {
        return 0 !== (this._flags & a << 16)
    }
    GetCurrentImageInfo()
    {
        return this._sdkInst.GetCurrentImageInfo()
    }
    GetCurrentSurfaceSize()
    {
        return this._sdkInst.GetCurrentSurfaceSize()
    }
    GetCurrentTexRect()
    {
        return this._sdkInst.GetCurrentTexRect()
    }
    GetCurrentTexQuad()
    {
        return this._sdkInst.GetCurrentTexQuad()
    }
    IsCurrentTexRotated()
    {
        return this._sdkInst.IsCurrentTexRotated()
    }
    GetImagePoint(a)
    {
        return this._sdkInst.GetImagePoint(a)
    }
    GetObjectClass()
    {
        return this._objectType
    }
    RendersToOwnZPlane()
    {
        return this._sdkInst.RendersToOwnZPlane()
    }
    BelongsToObjectClass(a)
    {
        return a.IsFamily() ?
        a.FamilyHasMember(this.GetObjectClass()) : this.GetObjectClass() === a
    }
    CollectInstancesToPick(a, b, c)
    {
        const d = (e, f) => {
            f = f || e.GetObjectClass();
            const g = a.get(f);
            g ? g.add(e) : a.set(f, new Set([e]))
        };
        d(this, b);
        if (this.IsInContainer())
            for (const e of this.siblings())
                d(e);
        if (c)
            for (const e of this.allChildren())
                d(e)
    }
    VerifySupportsSceneGraph()
    {
        if (!this.GetPlugin().SupportsSceneGraph())
            throw Error("object does not support scene graph");
    }
    HasParent()
    {
        return null !== this.GetParent()
    }
    GetParent()
    {
        var a = this.GetWorldInfo();
        return a ? (a = a.GetParent()) ? a.GetInstance() : null : null
    }
    GetTopParent()
    {
        var a = this.GetWorldInfo();
        return a ? (a = a.GetTopParent()) ? a.GetInstance() : null : null
    }
    *parents()
    {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.parents())
                yield b.GetInstance()
    }
    HasChild(a)
    {
        if (!a)
            return !1;
        for (const b of this.children())
            if (b === a)
                return !0;
        return !1
    }
    HasChildren()
    {
        const a = this.GetWorldInfo();
        return a ? a.HasChildren() : !1
    }
    GetChildrenOfObjectClass(a)
    {
        const b = this.GetWorldInfo();
        if (!b)
            return [];
        const c = a.GetName();
        return b.GetChildren().map(d =>
        d.GetInstance()).filter(d => d.GetObjectClass().GetName() === c)
    }
    GetChildren()
    {
        const a = this.GetWorldInfo();
        return a ? a.GetChildren().map(b => b.GetInstance()) : []
    }
    *children()
    {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.children())
                yield b.GetInstance()
    }
    *allChildren()
    {
        const a = this.GetWorldInfo();
        if (a)
            for (const b of a.allChildren())
                yield b.GetInstance()
    }
    GetChildCount()
    {
        const a = this.GetWorldInfo();
        return a ? a.GetChildCount() : 0
    }
    GetParentCount()
    {
        return [...this.parents()].length
    }
    GetAllChildCount()
    {
        const a =
        this.GetWorldInfo();
        return a ? a.GetAllChildCount() : 0
    }
    GetChildAt(a)
    {
        const b = this.GetWorldInfo();
        return b ? (a = b.GetChildAt(a)) ? a.GetInstance() : null : null
    }
    GetIndexInParent()
    {
        const a = this.GetWorldInfo();
        if (!a)
            return NaN;
        const b = a.GetParent();
        return b ? b.GetChildIndex(a) : NaN
    }
    HasChildWithUID(a)
    {
        for (const b of this.GetWorldInfo().GetChildren())
            if (b.GetInstance().GetUID() === a)
                return !0;
        return !1
    }
    AddChild(a, b)
    {
        this.VerifySupportsSceneGraph();
        a.VerifySupportsSceneGraph();
        this.GetWorldInfo().AddChild(a.GetWorldInfo(),
        b || {})
    }
    RemoveChild(a)
    {
        const b = this.GetWorldInfo();
        b && b.RemoveChild(a.GetWorldInfo())
    }
    GetDestroyWithParent()
    {
        const a = this.GetWorldInfo();
        return a ? a.GetDestroyWithParent() : !1
    }
    SetupInitialSceneGraphConnections()
    {
        var a = this.GetWorldInfo();
        if (a && (a = a.GetSceneGraphChildrenExportData()))
            for (const b of a)
                if (a = this._runtime.GetInstanceByUID(b[2])) {
                    const c = b[3];
                    this.AddChild(a, {
                        transformX: !!(c >> 0 & 1),
                        transformY: !!(c >> 1 & 1),
                        transformWidth: !!(c >> 2 & 1),
                        transformHeight: !!(c >> 3 & 1),
                        transformAngle: !!(c >> 4 & 1),
                        destroyWithParent: !!(c >>
                        5 & 1),
                        transformZElevation: !!(c >> 6 & 1),
                        transformOpacity: !!(c >> 7 & 1),
                        transformVisibility: !!(c >> 8 & 1)
                    })
                }
    }
    SetupPersistedSceneGraphConnections(a, b)
    {
        if (a = a.get(this))
            for (const c of a.sceneGraphJson.children) {
                a = b.get(c.index);
                if (!a)
                    continue;
                const d = c.flags;
                this.AddChild(a, {
                    transformX: !!(d >> 0 & 1),
                    transformY: !!(d >> 1 & 1),
                    transformWidth: !!(d >> 2 & 1),
                    transformHeight: !!(d >> 3 & 1),
                    transformAngle: !!(d >> 4 & 1),
                    destroyWithParent: !!(d >> 5 & 1),
                    transformZElevation: !!(d >> 6 & 1),
                    transformOpacity: !!(d >> 7 & 1),
                    transformVisibility: !!(d >> 8 &
                    1)
                })
            }
    }
    GetTemplateName()
    {
        const a = this._runtime.GetTemplateManager();
        return a ? a.GetInstanceTemplateName(this) : ""
    }
    IsInContainer()
    {
        return null !== this._siblings
    }
    _AddSibling(a)
    {
        this._siblings.push(a)
    }
    GetSiblings()
    {
        return this._siblings
    }
    HasSibling(a)
    {
        return !!this.GetSibling(a)
    }
    GetSibling(a)
    {
        const b = this.siblings();
        if (null === b || 0 === b.length)
            return !1;
        for (const c of b)
            if (c.GetObjectClass() === a)
                return c;
        return null
    }
    siblings()
    {
        return this._siblings
    }
    SetSiblingsSinglePicked()
    {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol().SetSinglePicked(a)
    }
    _PushSiblingsToSolInstances()
    {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol()._PushInstance(a)
    }
    _SetSiblingsToSolInstancesIndex(a)
    {
        for (const b of this.siblings())
            b.GetObjectClass().GetCurrentSol()._GetOwnInstances()[a] =
            b
    }
    _PushSiblingsToSolElseInstances()
    {
        for (const a of this.siblings())
            a.GetObjectClass().GetCurrentSol()._PushElseInstance(a)
    }
    _SetSiblingsToSolElseInstancesIndex(a)
    {
        for (const b of this.siblings())
            b.GetObjectClass().GetCurrentSol()._GetOwnElseInstances()[a] = b
    }
    GetPlugin()
    {
        return this._objectType.GetPlugin()
    }
    _SetIID(a)
    {
        this._iid = a
    }
    GetIID()
    {
        this._objectType._UpdateIIDs();
        return this._iid
    }
    GetUID()
    {
        return this._uid
    }
    GetPUID()
    {
        return this._puid
    }
    _SetTagsSetFromJson(a)
    {
        a ? this.SetTagsSet(new Set(a)) : this._tagsSet =
        null
    }
    SetTagsSet(a)
    {
        if (0 === a.size)
            this._tagsSet = null;
        else {
            this._tagsSet ? this._tagsSet.clear() : this._tagsSet = new Set;
            for (const b of a)
                this._tagsSet.add(b)
        }
    }
    GetTagsSet()
    {
        return this._tagsSet ?? new Set
    }
    GetTagsString()
    {
        return Array.from(this.GetTagsSet()).join(" ")
    }
    GetTagAt(a)
    {
        a = Math.floor(a);
        for (const b of this.GetTagsSet()) {
            if (0 === a)
                return b;
            --a
        }
        return ""
    }
    GetBehaviorInstances()
    {
        return this._behaviorInstances
    }
    GetBehaviorInstanceFromCtor(a)
    {
        if (!a)
            return null;
        for (const b of this._behaviorInstances)
            if (b.GetBehavior() instanceof
            a)
                return b;
        return null
    }
    GetBehaviorSdkInstanceFromCtor(a)
    {
        return a ? (a = this.GetBehaviorInstanceFromCtor(a)) ? a.GetSdkInstance() : null : null
    }
    GetBehaviorIndexBySID(a)
    {
        const b = this._behaviorInstances;
        for (let c = 0, d = b.length; c < d; ++c)
            if (b[c].GetBehaviorType().GetSID() === a)
                return c;
        return -1
    }
    GetAllInstanceVariableValues()
    {
        return this._instVarValues
    }
    _GetAllInstanceVariableNames()
    {
        return this._objectType._GetAllInstanceVariableNames()
    }
    GetInstanceVariableCount()
    {
        return this._instVarValues.length
    }
    GetInstanceVariableValue(a)
    {
        a |=
        0;
        const b = this._instVarValues;
        if (0 > a || a >= b.length)
            throw new RangeError("invalid instance variable");
        return b[a]
    }
    _GetInstanceVariableValueUnchecked(a)
    {
        return this._instVarValues[a]
    }
    _GetInstanceVariableTypedValue(a)
    {
        const b = this._instVarValues[a];
        return 0 === this._objectType.GetInstanceVariableType(a) ? !!b : b
    }
    SetInstanceVariableValue(a, b)
    {
        a |= 0;
        const c = this._instVarValues;
        if (0 > a || a >= c.length)
            throw new RangeError("invalid instance variable");
        switch (this._objectType.GetInstanceVariableType(a)) {
        case 0:
            c[a] =
            b ? 1 : 0;
            break;
        case 1:
            c[a] = "number" === typeof b ? b : parseFloat(b);
            break;
        case 2:
            c[a] = "string" === typeof b ? b : b.toString();
            break;
        default:
            throw Error("unknown instance variable type");
        }
    }
    SetInstanceVariableOffset(a, b)
    {
        if (0 !== b) {
            a |= 0;
            var c = this._instVarValues;
            if (0 > a || a >= c.length)
                throw new RangeError("invalid instance variable");
            var d = c[a];
            if ("number" === typeof d)
                c[a] = "number" === typeof b ? c[a] + b : c[a] + parseFloat(b);
            else {
                if ("boolean" === typeof d)
                    throw Error("can not set offset of boolean variable");
                if ("string" === typeof d)
                    throw Error("can not set offset of string variable");
                throw Error("unknown instance variable type");
            }
        }
    }
    GetSavedDataMap()
    {
        let a = savedDataMaps.get(this);
        if (a)
            return a;
        a = new Map;
        savedDataMaps.set(this, a);
        return a
    }
    GetUnsavedDataMap()
    {
        let a = unsavedDataMaps.get(this);
        if (a)
            return a;
        a = new Map;
        unsavedDataMaps.set(this, a);
        return a
    }
    _HasAnyCreateDestroyHandler(a)
    {
        const b = this.GetObjectClass();
        if (b.UserScriptDispatcher().HasAnyHandlerFor(a))
            return !0;
        for (const c of b.GetFamilies())
            if (c.UserScriptDispatcher().HasAnyHandlerFor(a))
                return !0;
        return this._runtime.UserScriptDispatcher().HasAnyHandlerFor(a) ?
        !0 : !1
    }
    _TriggerOnCreatedOnSelfAndRelated()
    {
        const a = new Set;
        a.add(this);
        const b = this.GetWorldInfo();
        if (b && b.HasChildren())
            for (const c of this.allChildren())
                if (a.add(c), c.IsInContainer())
                    for (const d of c.siblings())
                        a.add(d);
        if (this.IsInContainer())
            for (const c of this.siblings())
                a.add(c);
        for (const c of a.values())
            c._TriggerOnCreated()
    }
    _OnCreatedCommon()
    {
        this._objectType._GetUserScriptInstanceClass() && this.GetInterfaceClass();
        for (const a of this._behaviorInstances)
            a.PostCreate()
    }
    _OnCreatedForLoadingSavegame()
    {
        this._OnCreatedCommon()
    }
    _TriggerOnCreated()
    {
        this._OnCreatedCommon();
        if (this._HasAnyCreateDestroyHandler("instancecreate")) {
            const a = this.GetObjectClass(),
                b = new C3$jscomp$190.Event("instancecreate");
            b.instance = this.GetInterfaceClass();
            a.DispatchUserScriptEvent(b);
            for (const c of a.GetFamilies())
                c.DispatchUserScriptEvent(b);
            this._runtime.DispatchUserScriptEvent(b)
        }
        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnCreated, this, null)
    }
    _TriggerOnDestroyed()
    {
        this._runtime.Trigger(this.GetPlugin().GetConstructor().Cnds.OnDestroyed, this, null)
    }
    _FireDestroyedScriptEvents(a)
    {
        if (this._iScriptInterface) {
            var b =
            new C3$jscomp$190.Event("destroy");
            b.isEndingLayout = a;
            this.DispatchUserScriptEvent(b)
        }
        if (this._HasAnyCreateDestroyHandler("instancedestroy")) {
            b = this.GetObjectClass();
            var c = new C3$jscomp$190.Event("instancedestroy");
            c.instance = this.GetInterfaceClass();
            c.isEndingLayout = a;
            b.DispatchUserScriptEvent(c);
            for (const d of b.GetFamilies())
                d.DispatchUserScriptEvent(c);
            this._runtime.DispatchUserScriptEvent(c)
        }
    }
    _GetDebuggerProperties()
    {
        return this._sdkInst ? this._sdkInst.GetDebuggerProperties() : this._iScriptInterface._getDebuggerProperties()
    }
    SaveToJson(a=
    "full", b=null)
    {
        const c = {};
        "full" === a ? c.uid = this.GetUID() : c.c3 = !0;
        var d = this.GetTagsSet();
        0 < d.size && (c.tags = Array.from(d));
        if ("visual-state" !== a) {
            (d = savedDataMaps.get(this)) && d.size && (c.ex = C3$jscomp$190.ToSuperJSON(d));
            -1 !== this.GetTimeScale() && (c.mts = this.GetTimeScale());
            if (0 < this._objectType.GetInstanceVariablesCount()) {
                d = {};
                var e = this._objectType.GetInstanceVariableSIDs();
                for (let f = 0, g = this._instVarValues.length; f < g; ++f)
                    d[e[f].toString()] = this._instVarValues[f];
                c.ivs = d
            }
            if (this._behaviorInstances.length) {
                d =
                {};
                for (const f of this._behaviorInstances)
                    (e = f.SaveToJson(a)) && (d[f.GetBehaviorType().GetSID().toString()] = e);
                c.behs = d
            }
        }
        this._worldInfo && (c.w = this._worldInfo._SaveToJson(a, b));
        (a = this._sdkInst ? this._sdkInst.SaveToJson() : this._iScriptInterface._saveToJson()) && (c.data = a);
        return c
    }
    _OnBeforeLoad(a="full", b)
    {
        this._worldInfo && this._worldInfo._OnBeforeLoad(a)
    }
    _OnAfterLoad(a, b="full", c=null)
    {
        this._worldInfo && this._worldInfo._OnAfterLoad(a, b, c)
    }
    _OnAfterLoad2(a, b="full", c=null)
    {
        this._worldInfo && this._worldInfo._OnAfterLoad2(a,
        b, c)
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout()
    {
        this.GetPlugin().IsWorldType() && this._worldInfo._SetupSceneGraphConnectionsOnChangeOfLayout()
    }
    LoadFromJson(a, b="full", c)
    {
        if ("full" === b)
            this._uid = a.uid;
        else if (!a.c3)
            return;
        this._SetTagsSetFromJson(a.tags);
        if ("visual-state" !== b) {
            if (c = savedDataMaps.get(this))
                c.clear(),
                savedDataMaps.delete(this);
            if (c = a.ex)
                c = C3$jscomp$190.FromSuperJSON(c),
                savedDataMaps.set(this, c);
            this._timeScale = a.hasOwnProperty("mts") ? a.mts : -1;
            if (c = a.ivs)
                for (const [f, g] of Object.entries(c))
                    if (c =
                    parseInt(f, 10), c = this._objectType.GetInstanceVariableIndexBySID(c), !(0 > c || c >= this._instVarValues.length)) {
                        var d = g;
                        null === d && (d = NaN);
                        this._instVarValues[c] = d
                    }
        }
        if (this.GetPlugin().IsWorldType() && (c = a.w)) {
            var e = c.l;
            this._worldInfo.GetLayer().GetSID() !== e && (d = this._worldInfo.GetLayer(), (e = d.GetLayout().GetLayerBySID(e)) ? (this._worldInfo._SetLayer(e), d._RemoveInstance(this, !0), e._AddInstance(this, !0), e.SetZIndicesChanged(this), this._worldInfo.SetBboxChanged()) : "full" === b && this._runtime.DestroyInstance(this));
            this._worldInfo._LoadFromJson(c, b)
        }
        if ("visual-state" !== b && (c = a.behs))
            for (const [f, g] of Object.entries(c))
                c = parseInt(f, 10),
                c = this.GetBehaviorIndexBySID(c),
                0 > c || c >= this._behaviorInstances.length || this._behaviorInstances[c].LoadFromJson(g, b);
        (a = a.data) && (this._sdkInst ? this._sdkInst.LoadFromJson(a, b) : this._iScriptInterface._loadFromJson(a))
    }
    GetInterfaceClass()
    {
        return this._iScriptInterface || this._InitUserScriptInterface()
    }
    HasScriptInterface()
    {
        return !!this._iScriptInterface
    }
    _InitUserScriptInterface(a,
    b)
    {
        const c = this._worldInfo ? a ? self.ISDKWorldInstanceBase : self.IWorldInstance : a ? self.ISDKInstanceBase : self.IInstance;
        a = a || this._sdkInst.GetScriptInterfaceClass();
        const d = this._objectType._GetUserScriptInstanceClass(),
            e = d || a || c,
            f = this.GetPlugin().GetSdkVersion();
        C3$jscomp$190.AddonManager._PushInitObject(this, f);
        C3$jscomp$190.AddonManager._PushInitProperties(b);
        this._iScriptInterface = new e;
        C3$jscomp$190.AddonManager._PopInitProperties();
        C3$jscomp$190.AddonManager._PopInitObject(f);
        if (a && !(this._iScriptInterface instanceof
        c))
            throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${c.name}'`);
        if (d && !(this._iScriptInterface instanceof (a || c)))
            throw new TypeError(`setInstanceClass(): class '${d.name}' does not extend the right base class - check it extends the right class, e.g. globalThis.InstanceType.MyObjectName`);
        return this._iScriptInterface
    }
    _GetInstVarsScriptDescriptor(a)
    {
        if (0 !== this._instVarValues.length) {
            var b = {},
                c = this._objectType._GetAllInstanceVariableJsPropNames();
            for (let d =
                0, e = c.length; d < e; ++d)
                b[c[d]] = {
                    configurable: !1,
                    enumerable: !0,
                    get: C3$jscomp$190.Instance.prototype._GetInstanceVariableTypedValue.bind(this, d),
                    set: C3$jscomp$190.Instance.prototype.SetInstanceVariableValue.bind(this, d)
                };
            b = Object.create(Object.prototype, b);
            a.instVars = {
                value: b,
                writable: !1
            }
        }
    }
    _GetBehaviorsScriptDescriptor(a)
    {
        var b = this._behaviorInstances;
        if (0 !== b.length) {
            var c = {};
            for (const d of b)
                c[d.GetBehaviorType().GetJsPropName()] = {
                    value: d.GetScriptInterface(),
                    writable: !1
                };
            b = Object.create(Object.prototype,
            c);
            a.behaviors = {
                value: b,
                writable: !1
            }
        }
    }
    DispatchUserScriptEvent(a)
    {
        if (this.HasScriptInterface()) {
            var b = this.GetInterfaceClass();
            a.instance = b;
            var c = this._runtime;
            (c = c.IsDebug() && !c.GetEventSheetManager().IsInEventEngine()) && C3Debugger$jscomp$2.StartMeasuringScriptTime();
            b.dispatchEvent(a);
            c && C3Debugger$jscomp$2.AddScriptTime()
        }
    }
}
;
"use strict";
const C3$jscomp$191 = self.C3;
C3$jscomp$191.SceneGraphInfo = class  extends C3$jscomp$191.DefendedBase{
    constructor(a)
    {
        super();
        this._owner = a;
        this._parent = null;
        this._children = [];
        this._startWidth = a.GetWidth();
        this._startHeight = a.GetHeight();
        this._startScaleY = this._startScaleX = 1;
        this._parentStartAngle = 0;
        this._ownOpacity = 1;
        this._startOpacity = a.GetOpacity();
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = null;
        this._indexInParent = NaN
    }
    Release()
    {
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = this._parent = null;
        this._indexInParent = NaN;
        C3$jscomp$191.clearArray(this._children)
    }
    SetParent(a)
    {
        this._startOpacity = this._ownOpacity = this._owner.GetOpacity();
        this._parentStartAngle = (this._parent = a) ? a.GetAngle() : 0
    }
    GetParent()
    {
        return this._parent
    }
    HasChildren()
    {
        return 0 < this._children.length
    }
    GetChildren()
    {
        return this._children
    }
    _MaybeSortChildren()
    {
        this.HasChildren() && 1 !== this._children.length && (this._tmpSceneGraphChildrenIndexes ? this._children.sort((a, b) => {
            a = this._tmpSceneGraphChildrenIndexes.get(a.GetInstance());
            b = this._tmpSceneGraphChildrenIndexes.get(b.GetInstance());
            return C3$jscomp$191.IsFiniteNumber(a) && C3$jscomp$191.IsFiniteNumber(b) ? a - b : 0
        }) : this._children.sort((a, b) => {
            a = a._GetSceneGraphInfo()._GetIndexInParent();
            b = b._GetSceneGraphInfo()._GetIndexInParent();
            return C3$jscomp$191.IsFiniteNumber(a) && C3$jscomp$191.IsFiniteNumber(b) ? a - b : 0
        }))
    }
    _GetIndexInParent()
    {
        return this._indexInParent
    }
    GetStartScaleX()
    {
        return this._startScaleX
    }
    SetStartScaleX(a)
    {
        this._startScaleX = a
    }
    GetStartScaleY()
    {
        return this._startScaleY
    }
    SetStartScaleY(a)
    {
        this._startScaleY = a
    }
    GetStartOpacity()
    {
        return this._startOpacity
    }
    GetOwnOpacity()
    {
        return this._ownOpacity
    }
    SetOwnOpacity(a)
    {
        this._ownOpacity =
        a
    }
    _GetStartWidth()
    {
        return 0 === this._startWidth ? Number.EPSILON : this._startWidth
    }
    _GetStartHeight()
    {
        return 0 === this._startHeight ? Number.EPSILON : this._startHeight
    }
    GetParentScaleX()
    {
        if (this._owner.GetTransformWithParentWidth()) {
            var a = this._parent;
            let b = a.GetWidth(),
                c = a._GetSceneGraphInfo()._GetStartWidth();
            0 === b && (b = Number.EPSILON);
            return c === Number.EPSILON && b === Number.EPSILON ? 1 : c === Number.EPSILON && b !== Number.EPSILON && (a = a.GetInstance().GetSdkInstance(), a.IsOriginalSizeKnown()) ? 1 + b / a.GetOriginalWidth() :
            b / c
        }
        return 1
    }
    GetParentScaleY()
    {
        if (this._owner.GetTransformWithParentHeight()) {
            var a = this._parent;
            let b = a.GetHeight(),
                c = a._GetSceneGraphInfo()._GetStartHeight();
            0 === b && (b = Number.EPSILON);
            return c === Number.EPSILON && b === Number.EPSILON ? 1 : c === Number.EPSILON && b !== Number.EPSILON && (a = a.GetInstance().GetSdkInstance(), a.IsOriginalSizeKnown()) ? 1 + b / a.GetOriginalHeight() : b / c
        }
        return 1
    }
    GetParentStartAngle()
    {
        return this._parentStartAngle
    }
    _SaveToJsonProperties()
    {
        return {
            sw: this._startWidth,
            sh: this._startHeight,
            sx: this._startScaleX,
            sy: this._startScaleY,
            psa: this._parentStartAngle,
            oo: this._ownOpacity,
            so: this._startOpacity,
            pi: this._owner.GetInstance().GetIndexInParent()
        }
    }
    _SaveToJson(a, b=null)
    {
        const c = this._SaveToJsonProperties();
        return b && b.selfOnly ? Object.assign(c, {
            p: null,
            c: []
        }) : Object.assign(c, {
            p: this._GetParentJson(a),
            c: this._GetChildrenJson(a)
        })
    }
    _GetFlagsString(a)
    {
        let b = "";
        a.GetTransformWithParentX() && (b += "x");
        a.GetTransformWithParentY() && (b += "y");
        a.GetTransformWithParentWidth() && (b += "w");
        a.GetTransformWithParentHeight() &&
        (b += "h");
        a.GetTransformWithParentAngle() && (b += "a");
        a.GetTransformWithParentZElevation() && (b += "z");
        a.GetDestroyWithParent() && (b += "d");
        a.GetTransformWithParentOpacity() && (b += "o");
        a.GetTransformWithParentVisibility() && (b += "v");
        return b
    }
    _GetParentJson(a)
    {
        return this._parent && this._parent.GetInstance() && !this._parent.GetInstance().IsDestroyed() ? this._GetInstanceJson(this._parent, this._owner, a) : null
    }
    _GetChildrenJson(a)
    {
        return this._children.map(b => this._GetInstanceJson(b, b, a)).filter(b => b)
    }
    _GetInstanceJson(a,
    b, c)
    {
        if ((a = a.GetInstance()) && a.IsDestroyed())
            return null;
        const d = {};
        d.uid = a.GetUID();
        d.f = this._GetFlagsString(b);
        d.offsets = b._SaveSceneGraphPropertiesToJson();
        d.data = C3$jscomp$191.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(a);
        d.oci = a.GetObjectClass().GetIndex();
        "state" === c ? (d.inst = a.SaveToJson("full", {
            selfOnly: !0
        }), d.instIndex = NaN) : (d.instIndex = a.GetObjectClass().GetInstances().indexOf(a), d.inst = null);
        return d
    }
    _LoadFromJson(a)
    {
        this._startWidth = a.sw;
        this._startHeight = a.sh;
        this._startScaleX =
        a.sx;
        this._startScaleY = a.sy;
        this._parentStartAngle = a.psa;
        this._ownOpacity = a.oo;
        this._startOpacity = a.so;
        this._indexInParent = C3$jscomp$191.IsFiniteNumber(a.pi) ? a.pi : NaN
    }
    _SetTmpSceneGraphChildren(a, b)
    {
        if (!a && !b && this._tmpSceneGraphChildren)
            for (const c of this._tmpSceneGraphChildren)
                c.IsDestroyed() || c.HasParent() || c.GetRuntime().DestroyInstance(c);
        this._tmpSceneGraphChildren = a;
        this._tmpSceneGraphChildrenIndexes = b
    }
    _OnAfterLoad(a, b)
    {
        const c = this._owner,
            d = c.GetRuntime(),
            e = new Set;
        if (a.p && !this._parent) {
            var f =
            d.GetInstanceByUID(a.p.uid);
            if (f) {
                var g = f.GetWorldInfo();
                f.HasChild(c.GetInstance()) ? this._parent = g : (f.HasChildWithUID(c.GetInstance().GetUID()) ? d.DestroyInstance(c.GetInstance()) : f.AddChild(c.GetInstance(), this._GetFlagsObj(a.p.f)), e.has(c) || (c._LoadSceneGraphPropertiesFromJson(a.p.offsets), this._LoadInstancePropertiesFromJson(f, a.p, b)), e.add(c), f.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren())
            } else
                C3$jscomp$191.IsFiniteNumber(a.p.oci) && (f = d.GetObjectClassByIndex(a.p.oci), d.GetSystemPlugin(),
                f = d.CreateInstance(f, c.GetLayer(), 0, 0, !0)) && (g = this._GetInstanceData(a.p, d), f.LoadFromJson(g), f.GetWorldInfo().GetLayer().SortAndAddInstancesByZIndex(f), f.AddChild(c.GetInstance(), this._GetFlagsObj(a.p.f)), f.GetWorldInfo()._GetSceneGraphInfo()._MaybeSortChildren())
        }
        f = [];
        for (var h of a.c)
            (g = d.GetInstanceByUID(h.uid)) && f.push(g);
        h = 0;
        for (const m of a.c) {
            if (g = d.GetInstanceByUID(m.uid)) {
                if (this._tmpSceneGraphChildren)
                    if (this._tmpSceneGraphChildren.includes(g)) {
                        var k = g;
                        if (k.GetObjectClass() !== g.GetObjectClass()) {
                            h++;
                            continue
                        }
                        if (k.IsDestroyed()) {
                            h++;
                            continue
                        }
                        g = a.c[h];
                        if (!b?.setFromJson && this._HasAllChildrenOfType(k, f, c)) {
                            this._UpdateInstance(h, g, c, e, b);
                            h++;
                            continue
                        }
                        if (k.HasParent() && k.GetParent() !== c.GetInstance()) {
                            k = this._CreateNewChildInstance(g, b);
                            this._AddAndSetChildInstance(k, g, e, b);
                            h++;
                            continue
                        }
                        this._AddAndSetChildInstance(k.GetWorldInfo(), g, e, b, !0);
                        h++;
                        continue
                    } else if (this._tmpSceneGraphChildren[h]) {
                        k = this._tmpSceneGraphChildren[h];
                        if (k.GetObjectClass() !== g.GetObjectClass()) {
                            h++;
                            continue
                        }
                        if (k.IsDestroyed()) {
                            h++;
                            continue
                        }
                        g = a.c[h];
                        if (!b?.setFromJson && this._HasAllChildrenOfType(k, f, c)) {
                            this._UpdateInstance(h, g, c, e, b);
                            h++;
                            continue
                        }
                        if (k.HasParent() && k.GetParent() !== c.GetInstance()) {
                            k = this._CreateNewChildInstance(g, b);
                            this._AddAndSetChildInstance(k, g, e, b);
                            h++;
                            continue
                        }
                        this._AddAndSetChildInstance(k.GetWorldInfo(), g, e, b, !0);
                        h++;
                        continue
                    }
                var l = g.GetObjectClass();
                k = this._GetInstancesOfObjectClassCount(f, l);
                l = c.GetInstance().GetChildrenOfObjectClass(l).length;
                if (k === l) {
                    if (g = c.GetInstance().GetChildAt(h))
                        if (k = g.GetWorldInfo())
                            e.has(k) ||
                            (k._LoadSceneGraphPropertiesFromJson(m.offsets), this._LoadInstancePropertiesFromJson(g, m, b)),
                            e.add(k);
                    h++;
                    continue
                }
                if (g.HasParent() && g.GetParent() !== c.GetInstance()) {
                    g = this._CreateNewChildInstance(m, b);
                    this._AddAndSetChildInstance(g, m, e, b);
                    h++;
                    continue
                }
                this._AddAndSetChildInstance(g.GetWorldInfo(), m, e, b)
            } else if (this._tmpSceneGraphChildren && this._tmpSceneGraphChildren[h]) {
                g = this._tmpSceneGraphChildren[h];
                k = d.GetObjectClassByIndex(this._GetObjectClassIndex(m));
                if (g.GetObjectClass() !== k) {
                    h++;
                    continue
                }
                if (g.IsDestroyed()) {
                    h++;
                    continue
                }
                k = a.c[h];
                if (!b?.setFromJson && this._HasAllChildrenOfType(g, f, c)) {
                    this._UpdateInstance(h, k, c, e, b);
                    h++;
                    continue
                }
                if (g.HasParent() && g.GetParent() !== c.GetInstance()) {
                    g = this._CreateNewChildInstance(k, b);
                    this._AddAndSetChildInstance(g, k, e, b);
                    h++;
                    continue
                }
                this._AddAndSetChildInstance(g.GetWorldInfo(), k, e, b)
            } else
                g = this._CreateNewChildInstance(m, b),
                this._AddAndSetChildInstance(g, m, e, b);
            h++
        }
    }
    _HasAllChildrenOfType(a, b, c)
    {
        a = a.GetObjectClass();
        b = this._GetInstancesOfObjectClassCount(b, a);
        c = c.GetInstance().GetChildrenOfObjectClass(a).length;
        return b === c
    }
    _UpdateInstance(a, b, c, d, e)
    {
        if (a = c.GetInstance().GetChildAt(a, b))
            if (c = a.GetWorldInfo())
                d.has(c) || (c._LoadSceneGraphPropertiesFromJson(b.offsets), this._LoadInstancePropertiesFromJson(a, b, e)),
                d.add(c)
    }
    _GetFlagsObj(a)
    {
        const b = {};
        b.transformX = a.includes("x");
        b.transformY = a.includes("y");
        b.transformWidth = a.includes("w");
        b.transformHeight = a.includes("h");
        b.transformAngle = a.includes("a");
        b.transformZElevation = a.includes("z");
        b.destroyWithParent = a.includes("d");
        b.transformOpacity = a.includes("o");
        b.transformVisibility = a.includes("v");
        return b
    }
    _GetObjectClassIndex(a)
    {
        return C3$jscomp$191.IsFiniteNumber(a.oci) ? a.oci : a[1]
    }
    _CreateNewChildInstance(a, b)
    {
        if (C3$jscomp$191.IsFiniteNumber(a.oci)) {
            var c = this._owner;
            b = c.GetRuntime();
            if (a.data)
                c = b.CreateInstanceFromData(a.data, c.GetLayer(), !1, 0, 0, !1, !0);
            else {
                const d = b.GetObjectClassByIndex(a.oci);
                c = b.CreateInstance(d, c.GetLayer(), 0, 0, !0)
            }
            if (c)
                return a = this._GetInstanceData(a, b), c.LoadFromJson(a), a = c.GetWorldInfo(), a.GetLayer().SortAndAddInstancesByZIndex(c,
                !0), a
        }
    }
    _AddAndSetChildInstance(a, b, c, d, e=!0)
    {
        this._owner.AddChild(a, this._GetFlagsObj(b.f)) && e && (c.has(a) || (a._LoadSceneGraphPropertiesFromJson(b.offsets), this._LoadInstancePropertiesFromJson(a.GetInstance(), b, d)), c.add(a));
        this._MaybeSortChildren()
    }
    _LoadInstancePropertiesFromJson(a, b, c)
    {
        if (b = this._GetInstanceData(b, this._owner.GetRuntime()))
            b = JSON.parse(JSON.stringify(b)),
            b.w = null,
            a.LoadFromJson(b)
    }
    _GetInstancesOfObjectClassCount(a, b)
    {
        return a.filter(c => c.GetObjectClass().GetName() === b.GetName()).length
    }
    _GetInstanceData(a,
    b)
    {
        if (C3$jscomp$191.IsFiniteNumber(a.instIndex))
            return b.GetObjectClassByIndex(a.oci)._GetLoadInstancesJson()[a.instIndex];
        if (C3$jscomp$191.IsString(a.inst))
            return JSON.parse(a.inst);
        if (a.inst)
            return a.inst
    }
    static GetSceneGraphInstanceDataFromInstance(a)
    {
        let b = a.GetWorldInfo().GetLayer().GetInitialInstanceData(a.GetUID());
        if (!b)
            return null;
        b = JSON.parse(JSON.stringify(b));
        const c = [];
        for (const d of [...a.GetChildren()]) {
            const e = d.GetWorldInfo();
            c.push([e.GetLayout().GetSID(), e.GetLayer().GetIndex(),
            d.GetUID(), C3$jscomp$191.SceneGraphInfo._GetFlagsNumber(e), d.GetObjectClass().IsInContainer() ? 1 : 0, e.GetZIndex(), C3$jscomp$191.SceneGraphInfo.GetSceneGraphInstanceDataFromInstance(d)])
        }
        C3$jscomp$191.IsArray(b[0][14]) ? b[0][14][1] = c : (b[0][14] = [], b[0][14][0] = C3$jscomp$191.SceneGraphInfo._GetDefaultFlagsNumber(), b[0][14][1] = c, b[0][14][2] = a.GetWorldInfo().GetZIndex());
        return b
    }
    static _GetFlagsNumber(a)
    {
        let b;
        b = 0 | Number(a.GetTransformWithParentVisibility()) << 8;
        b |= Number(a.GetTransformWithParentOpacity()) <<
        7;
        b |= Number(a.GetTransformWithParentZElevation()) << 6;
        b |= Number(a.GetDestroyWithParent()) << 5;
        b |= Number(a.GetTransformWithParentAngle()) << 4;
        b |= Number(a.GetTransformWithParentHeight()) << 3;
        b |= Number(a.GetTransformWithParentWidth()) << 2;
        b |= Number(a.GetTransformWithParentY()) << 1;
        return b |= Number(a.GetTransformWithParentX()) << 0
    }
    static _GetDefaultFlagsNumber(a)
    {
        return 511
    }
}
;
"use strict";
const C3$jscomp$192 = self.C3,
    tempRect$jscomp$7 = C3$jscomp$192.New(C3$jscomp$192.Rect),
    tempQuad$jscomp$3 = C3$jscomp$192.New(C3$jscomp$192.Quad),
    bboxChangeEvent = C3$jscomp$192.New(C3$jscomp$192.Event, "bboxchange", !1),
    tempColor$jscomp$6 = C3$jscomp$192.New(C3$jscomp$192.Color, 0, 0, 0, 0),
    tempCollisionPoly = C3$jscomp$192.New(C3$jscomp$192.CollisionPoly),
    DEFAULT_COLOR = C3$jscomp$192.New(C3$jscomp$192.Color, 1, 1, 1, 1),
    DEFAULT_RENDER_CELLS = C3$jscomp$192.New(C3$jscomp$192.Rect, 0, 0, -1, -1),
    DEFAULT_COLLISION_CELLS = C3$jscomp$192.New(C3$jscomp$192.Rect,
    0, 0, -1, -1),
    VALID_SET_MESH_POINT_MODES = new Set(["absolute", "relative"]),
    EMPTY_ARRAY$jscomp$2 = [];
let enableUpdateRendererStateGroup = !0;
const FLAG_IS_VISIBLE = 1,
    FLAG_BBOX_CHANGED = 2,
    FLAG_ENABLE_BBOX_CHANGED_EVENT = 4,
    FLAG_COLLISION_ENABLED = 8,
    FLAG_COLLISION_CELL_CHANGED = 16,
    FLAG_SOLID_FILTER_INCLUSIVE = 32,
    FLAG_HAS_ANY_ACTIVE_EFFECT = 64,
    FLAG_IS_ROTATABLE = 128,
    FLAG_DESTROYED$jscomp$1 = 256,
    FLAG_DESTROY_WITH_PARENT = 512,
    FLAG_TRANSFORM_WITH_PARENT_X = 1024,
    FLAG_TRANSFORM_WITH_PARENT_Y = 2048,
    FLAG_TRANSFORM_WITH_PARENT_W = 4096,
    FLAG_TRANSFORM_WITH_PARENT_H = 8192,
    FLAG_TRANSFORM_WITH_PARENT_A = 16384,
    FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION = 32768,
    FLAG_TRANSFORM_WITH_PARENT_OPACITY =
    4194304,
    FLAG_TRANSFORM_WITH_PARENT_VISIBILITY = 8388608,
    MASK_ALL_SCENE_GRAPH_FLAGS = FLAG_DESTROY_WITH_PARENT | FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y | FLAG_TRANSFORM_WITH_PARENT_W | FLAG_TRANSFORM_WITH_PARENT_H | FLAG_TRANSFORM_WITH_PARENT_A | FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION | FLAG_TRANSFORM_WITH_PARENT_OPACITY | FLAG_TRANSFORM_WITH_PARENT_VISIBILITY,
    FLAG_MESH_CHANGED = 65536,
    FLAG_PHYSICS_BODY_CHANGED = 131072,
    FLAG_SIN_COS_ANGLE_CHANGED = 262144,
    FLAG_USE_POINTS_SHADER_PROGRAM = 524288,
    FLAG_DRAW_BACK_FACE_ONLY =
    1048576,
    FLAG_DRAW_NON_BACK_FACES_ONLY = 2097152,
    FLAG_BLEND_MODE_MASK = 2080374784,
    sceneGraphExportDataMap = new WeakMap,
    sceneGraphZIndexMap = new WeakMap;
C3$jscomp$192.WorldInfo = class  extends C3$jscomp$192.DefendedBase{
    constructor(a, b)
    {
        super();
        this._inst = a;
        this._objectClass = a.GetObjectClass();
        this._runtime = a.GetRuntime();
        this._layer = b;
        this._objectClass._OnWorldInstanceLayerChanged(this, null, b);
        this._htmlZIndex = this._zIndex = -1;
        this._flags = FLAG_IS_VISIBLE | FLAG_BBOX_CHANGED | FLAG_COLLISION_ENABLED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED | FLAG_PHYSICS_BODY_CHANGED;
        this._objectClass.GetPlugin().IsRotatable() && (this._flags |= FLAG_IS_ROTATABLE);
        this._oy =
        this._ox = this._cosA = this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = NaN;
        this._boundingBox = C3$jscomp$192.New(C3$jscomp$192.Rect);
        this._boundingQuad = C3$jscomp$192.New(C3$jscomp$192.Quad);
        this._collisionCells = DEFAULT_COLLISION_CELLS;
        this._renderCells = DEFAULT_RENDER_CELLS;
        this._solidFilterTags = this._transformedPolyInfo = this._sourceCollisionPoly = null;
        this._colorPremultiplied = this._color = DEFAULT_COLOR;
        this._instanceEffectList = this._stateGroup = null;
        this._inst.GetObjectClass().UsesEffects() &&
        (this._instanceEffectList = C3$jscomp$192.New(C3$jscomp$192.InstanceEffectList, this._inst, this));
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = this._sceneGraphInfo = null;
        this._tmpHierarchyPosition = -1;
        this._meshInfo = null
    }
    _MarkDestroyed()
    {
        this._flags |= FLAG_DESTROYED$jscomp$1
    }
    Release()
    {
        this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, null);
        this._stateGroup && (this._runtime.GetRenderer().ReleaseStateGroup(this._stateGroup), this._stateGroup = null);
        this._sourceCollisionPoly = null;
        this._transformedPolyInfo && (this._transformedPolyInfo.poly.Release(), this._transformedPolyInfo = null);
        this._solidFilterTags && (this._solidFilterTags.clear(), this._solidFilterTags = null);
        this.ReleaseMesh();
        this._instanceEffectList && this._instanceEffectList.Release();
        this.HasParent() && this.GetParent().RemoveChild(this);
        if (this.HasChildren()) {
            const a = [...this.GetChildren()];
            for (const b of a)
                this.RemoveChild(b)
        }
        this._ReleaseSceneGraphInfo();
        this._ReleaseTmpSceneGraphInfo();
        sceneGraphExportDataMap.delete(this);
        sceneGraphZIndexMap.delete(this);
        this._layer = this._runtime = this._objectClass = this._inst = null
    }
    Init(a)
    {
        enableUpdateRendererStateGroup = !1;
        this.SetXY(a[0], a[1]);
        this.SetZElevation(a[2]);
        this.SetSize(a[3], a[4]);
        this._depth = 0;
        this.IsRotatable() ? this.SetAngle(a[6]) : this._a = 0;
        tempColor$jscomp$6.setFromJSON(a[7]);
        this._SetColor(tempColor$jscomp$6);
        this.SetOriginX(a[8]);
        this.SetOriginY(a[9]);
        this.SetBlendMode(a[10]);
        this._instanceEffectList && this._instanceEffectList._LoadEffectParameters(a[12]);
        a[14] && sceneGraphExportDataMap.set(this,
        {
            childrenData: a[14][1],
            zIndexData: a[14][2]
        });
        if (a[15]) {
            var b = a[15];
            this.CreateMesh(b[0], b[1]);
            var c = this.GetSourceMesh();
            b = b[2];
            for (let f = 0, g = b.length; f < g; ++f) {
                var d = b[f];
                for (let h = 0, k = d.length; h < k; ++h) {
                    var e = d[h];
                    const l = c.GetMeshPointAt(h, f);
                    l.SetX(e[0]);
                    l.SetY(e[1]);
                    l.SetZElevation(e[2]);
                    l.SetU(e[3]);
                    l.SetV(e[4])
                }
            }
        }
        a[16] && (c = a[16][0], a = a[16][1], b = !!a, d = !b, e = this._runtime.GetTemplateManager(), b && e && e.MapInstanceToTemplateName(this.GetInstance(), a), d && e && e.MapInstanceToTemplateName(this.GetInstance(),
        c));
        enableUpdateRendererStateGroup = !0;
        this._UpdateRendererStateGroup()
    }
    InitNoData()
    {
        this._sinA = this._a = this._depth = this._h = this._w = this._zElevation = this._y = this._x = 0;
        this._cosA = 1;
        this._oy = this._ox = 0;
        this._UpdateRendererStateGroup()
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetInstance()
    {
        return this._inst
    }
    _GetParentOffsetAngle()
    {
        return this.GetTransformWithParentAngle() ? this._MaybeReflectAngleForMirrorFlip(this.GetParent()._GetAngleNoReflect() - this._sceneGraphInfo.GetParentStartAngle()) :
        0
    }
    SetX(a)
    {
        a = +a;
        if (this.GetTransformWithParentX()) {
            const b = this._sceneGraphInfo;
            a -= this.GetX();
            const c = -this._GetParentOffsetAngle();
            0 === c ? this._x += a / b.GetParentScaleX() : (this._x += Math.cos(c) * a / b.GetParentScaleX(), this.GetTransformWithParentY() && (this._y += Math.sin(c) * a / b.GetParentScaleY()))
        } else
            this._x = a
    }
    OffsetX(a, b=!1)
    {
        a = +a;
        b ? this._x += a : this.GetTransformWithParentX() ? this.SetX(this.GetX() + a) : this._x += a
    }
    GetX()
    {
        if (this.GetTransformWithParentX()) {
            let a = this._x;
            const b = this._sceneGraphInfo,
                c = this.GetParent(),
                d = this._GetParentOffsetAngle();
            0 === d ? a *= b.GetParentScaleX() : (a = a * b.GetParentScaleX() * Math.cos(d), this.GetTransformWithParentY() && (a -= this._y * b.GetParentScaleY() * Math.sin(d)));
            return c.GetX() + a
        }
        return this._x
    }
    SetY(a)
    {
        a = +a;
        if (this.GetTransformWithParentY()) {
            const b = this._sceneGraphInfo;
            a -= this.GetY();
            const c = -this._GetParentOffsetAngle();
            0 === c ? this._y += a / b.GetParentScaleY() : (this.GetTransformWithParentX() && (this._x -= Math.sin(c) * a / b.GetParentScaleX()), this._y += Math.cos(c) * a / b.GetParentScaleY())
        } else
            this._y =
            a
    }
    OffsetY(a, b=!1)
    {
        a = +a;
        b ? this._y += a : this.GetTransformWithParentY() ? this.SetY(this.GetY() + a) : this._y += a
    }
    GetY()
    {
        if (this.GetTransformWithParentY()) {
            let a = this._y;
            const b = this._sceneGraphInfo,
                c = this.GetParent(),
                d = this._GetParentOffsetAngle();
            0 === d ? a *= b.GetParentScaleY() : (a = a * b.GetParentScaleY() * Math.cos(d), this.GetTransformWithParentX() && (a += this._x * b.GetParentScaleX() * Math.sin(d)));
            return c.GetY() + a
        }
        return this._y
    }
    SetXY(a, b)
    {
        a = +a;
        b = +b;
        if (this.GetTransformWithParentXOrY()) {
            const d = this.GetTransformWithParentX(),
                e = this.GetTransformWithParentY(),
                f = this._sceneGraphInfo,
                g = a - this.GetX(),
                h = b - this.GetY();
            var c = -this._GetParentOffsetAngle();
            if (0 === c)
                this._x = d ? this._x + g / f.GetParentScaleX() : a,
                this._y = e ? this._y + h / f.GetParentScaleY() : b;
            else {
                const k = Math.sin(c);
                c = Math.cos(c);
                this._x = d ? e ? this._x + (c * g - k * h) / f.GetParentScaleX() : this._x + c * g / f.GetParentScaleX() : a;
                this._y = e ? d ? this._y + (k * g + c * h) / f.GetParentScaleY() : this._y + c * h / f.GetParentScaleY() : b
            }
        } else
            this._x = a,
            this._y = b
    }
    GetXY()
    {
        return [this.GetX(), this.GetY()]
    }
    OffsetXY(a,
    b)
    {
        a = +a;
        b = +b;
        this.GetTransformWithParentXOrY() ? this.SetXY(this.GetX() + a, this.GetY() + b) : (this._x += a, this._y += b)
    }
    EqualsXY(a, b)
    {
        return this.GetX() === a && this.GetY() === b
    }
    SetZElevation(a)
    {
        a = +a;
        this.GetTransformWithParentZElevation() && (a -= this.GetParent().GetZElevation());
        this._zElevation !== a && (this._zElevation = a, this._UpdateZElevation(), a = this.GetLayer(), 0 !== this._zElevation && a._SetAnyInstanceZElevated(), a.SetZIndicesChanged(this))
    }
    _UpdateZElevation()
    {
        this._UpdateRendererStateGroup();
        if (this.HasChildren()) {
            const a =
            this.GetChildren();
            for (let b = 0, c = a.length; b < c; b++) {
                const d = a[b];
                d.GetTransformWithParentZElevation() && d._UpdateZElevation()
            }
        }
    }
    OffsetZElevation(a)
    {
        this.SetZElevation(this.GetZElevation() + a)
    }
    GetZElevation()
    {
        return this.GetTransformWithParentZElevation() ? this.GetParent().GetZElevation() + this._zElevation : this._zElevation
    }
    GetTotalZElevation()
    {
        return this.GetLayer().GetZElevation() + this.GetZElevation()
    }
    SetWidth(a)
    {
        a = +a;
        if (this.GetTransformWithParentWidth()) {
            const b = this.GetWidth();
            this._w = 0 === b ? Number.EPSILON :
            a / b * this._w
        } else
            this._w = a;
        this._MarkSinCosAngleChanged()
    }
    OffsetWidth(a, b)
    {
        a = +a;
        b ? this._w += a : this.GetTransformWithParentWidth() ? this.SetWidth(this.GetWidth() + a) : this._w += a;
        this._MarkSinCosAngleChanged()
    }
    GetWidth()
    {
        if (this.GetTransformWithParentWidth()) {
            const a = this.GetParent(),
                b = a.GetWidth();
            return a._GetSceneGraphInfo()._GetStartWidth() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartWidth() + b) * this._w : b * this._w
        }
        return this._w
    }
    SetHeight(a)
    {
        a = +a;
        if (this.GetTransformWithParentHeight()) {
            const b =
            this.GetHeight();
            this._h = 0 === b ? Number.EPSILON : a / b * this._h
        } else
            this._h = a;
        this._MarkSinCosAngleChanged()
    }
    OffsetHeight(a, b)
    {
        a = +a;
        b ? this._h += a : this.GetTransformWithParentHeight() ? this.SetHeight(this.GetHeight() + a) : this._h += a;
        this._MarkSinCosAngleChanged()
    }
    GetHeight()
    {
        if (this.GetTransformWithParentHeight()) {
            const a = this.GetParent(),
                b = a.GetHeight();
            return a._GetSceneGraphInfo()._GetStartHeight() === Number.EPSILON ? (this._GetSceneGraphInfo()._GetStartHeight() + b) * this._h : b * this._h
        }
        return this._h
    }
    SetSize(a,
    b)
    {
        a = +a;
        b = +b;
        if (this.GetTransformWithParentWidth()) {
            const c = this.GetWidth();
            this._w = 0 === c ? Number.EPSILON : a / c * this._w
        } else
            this._w = a;
        this.GetTransformWithParentHeight() ? (a = this.GetHeight(), this._h = 0 === a ? Number.EPSILON : b / a * this._h) : this._h = b;
        this._MarkSinCosAngleChanged()
    }
    GetSize()
    {
        return [this.GetWidth(), this.GetHeight()]
    }
    GetDepth()
    {
        return this._depth
    }
    SetDepth(a)
    {
        if (0 > a)
            throw new RangeError("invalid depth");
        this._depth = a
    }
    GetSceneGraphScale()
    {
        if (this.HasParent()) {
            const a = this._sceneGraphInfo;
            return Math.min(a.GetParentScaleX(),
            a.GetParentScaleY())
        }
        return 1
    }
    IsRotatable()
    {
        return 0 !== (this._flags & FLAG_IS_ROTATABLE)
    }
    SetAngle(a)
    {
        a = +a;
        this.IsRotatable() && (this.GetTransformWithParentAngle() && (a -= this.GetParent().GetAngle()), a = C3$jscomp$192.clampAngle(a), this._a !== a && (this._a = a, this._MarkSinCosAngleChanged()))
    }
    OffsetAngle(a)
    {
        a = +a;
        0 !== a && this.IsRotatable() && (this._a = C3$jscomp$192.clampAngle(this._a + a), this._MarkSinCosAngleChanged())
    }
    _MarkSinCosAngleChanged()
    {
        this._flags |= FLAG_SIN_COS_ANGLE_CHANGED;
        if (this.HasChildren()) {
            const a =
            this.GetChildren();
            for (let b = 0, c = a.length; b < c; b++)
                a[b]._MarkSinCosAngleChanged()
        }
    }
    GetAngle()
    {
        return this.GetTransformWithParentAngle() && this.IsRotatable() ? this._MaybeReflectAngleForMirrorFlip(C3$jscomp$192.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a)) : this._a
    }
    _GetAngleNoReflect()
    {
        return this.GetTransformWithParentAngle() && this.IsRotatable() ? C3$jscomp$192.clampAngle(this.GetParent()._GetAngleNoReflect() + this._a) : this._a
    }
    _MaybeReflectAngleForMirrorFlip(a)
    {
        this.GetTransformWithParentWidth() &&
        0 > this.GetTopParent().GetWidth() && (a = C3$jscomp$192.clampAngle(C3$jscomp$192.angleReflect(a, this.GetTopParent().GetAngle() + Math.PI)));
        this.GetTransformWithParentHeight() && 0 > this.GetTopParent().GetHeight() && (a = C3$jscomp$192.angleReflect(a, this.GetTopParent().GetAngle()));
        return a
    }
    _NeedsReflectAngleForMirrorOrFlip()
    {
        const a = this.GetParent();
        return this.GetTransformWithParentWidth() && 0 > a.GetWidth() || this.GetTransformWithParentHeight() && 0 > a.GetHeight() ? !0 : !1
    }
    _NeedsReflectAngleForMirrorAndFlip()
    {
        const a =
        this.GetParent();
        return this.GetTransformWithParentWidth() && 0 > a.GetWidth() && this.GetTransformWithParentHeight() && 0 > a.GetHeight() ? !0 : !1
    }
    _MaybeUpdateSinCosAngle()
    {
        const a = this._flags;
        if (0 !== (a & FLAG_SIN_COS_ANGLE_CHANGED)) {
            var b = this.GetAngle();
            this._sinA = Math.sin(b);
            this._cosA = Math.cos(b);
            this._flags = a & ~FLAG_SIN_COS_ANGLE_CHANGED
        }
    }
    GetSinAngle()
    {
        this._MaybeUpdateSinCosAngle();
        return this._sinA
    }
    GetCosAngle()
    {
        this._MaybeUpdateSinCosAngle();
        return this._cosA
    }
    SetOriginX(a)
    {
        this._ox = +a
    }
    OffsetOriginX(a)
    {
        this._ox +=
        +a
    }
    GetOriginX()
    {
        return this._ox
    }
    SetOriginY(a)
    {
        this._oy = +a
    }
    OffsetOriginY(a)
    {
        this._oy += +a
    }
    GetOriginY()
    {
        return this._oy
    }
    _SetColor(a)
    {
        this._color.equals(a) || (this._color === DEFAULT_COLOR ? (this._color = C3$jscomp$192.New(C3$jscomp$192.Color, a), this._colorPremultiplied = C3$jscomp$192.New(C3$jscomp$192.Color, a), this._colorPremultiplied.premultiply()) : a.equalsRgba(1, 1, 1, 1) ? this._colorPremultiplied = this._color = DEFAULT_COLOR : (this._color.set(a), this._colorPremultiplied.set(a), this._colorPremultiplied.premultiply()),
        this._UpdateRendererStateGroup())
    }
    SetOpacity(a)
    {
        a = C3$jscomp$192.clamp(+a, 0, 1);
        if (this.GetTransformWithParentOpacity()) {
            if (this._GetSceneGraphInfo().GetOwnOpacity() === a)
                return;
            this._GetSceneGraphInfo().SetOwnOpacity(a);
            a = this.GetOpacity()
        } else if (this._color.a === a)
            return;
        this._SetColorWithOpacity(a)
    }
    _SetOpacityOfChildren()
    {
        if (this.HasChildren()) {
            var a = this.GetChildren();
            for (let b = 0, c = a.length; b < c; b++) {
                const d = a[b];
                d._SetColorWithOpacity(d.GetOpacity())
            }
        }
    }
    _SetColorWithOpacity(a)
    {
        tempColor$jscomp$6.copyRgb(this._color);
        tempColor$jscomp$6.a = a;
        this._SetColor(tempColor$jscomp$6);
        this._SetOpacityOfChildren()
    }
    OffsetOpacity(a)
    {
        this.GetTransformWithParentOpacity() ? this.SetOpacity(this._GetSceneGraphInfo().GetOwnOpacity() + a) : this.SetOpacity(this.GetOpacity() + a)
    }
    GetOpacity()
    {
        return this.GetTransformWithParentOpacity() ? this.GetParent().GetOpacity() * this._GetSceneGraphInfo().GetOwnOpacity() : this._color.a
    }
    SetUnpremultipliedColor(a)
    {
        this._color.equalsIgnoringAlpha(a) || (tempColor$jscomp$6.copyRgb(a), tempColor$jscomp$6.a = this.GetOpacity(),
        this._SetColor(tempColor$jscomp$6))
    }
    SetUnpremultipliedColorRGB(a, b, c)
    {
        tempColor$jscomp$6.setRgb(a, b, c);
        this.SetUnpremultipliedColor(tempColor$jscomp$6)
    }
    OffsetUnpremultipliedColorRGB(a, b, c)
    {
        if (0 !== a || 0 !== b || 0 !== c)
            tempColor$jscomp$6.copyRgb(this._color),
            tempColor$jscomp$6.r += a,
            tempColor$jscomp$6.g += b,
            tempColor$jscomp$6.b += c,
            this.SetUnpremultipliedColor(tempColor$jscomp$6)
    }
    GetUnpremultipliedColor()
    {
        return this._color
    }
    GetPremultipliedColor()
    {
        return this._colorPremultiplied
    }
    GetDestroyWithParent()
    {
        return 0 !==
        (this._flags & FLAG_DESTROY_WITH_PARENT)
    }
    SetDestroyWithParent(a)
    {
        this._SetFlag(FLAG_DESTROY_WITH_PARENT, a)
    }
    GetTransformWithParentX()
    {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_X)
    }
    SetTransformWithParentX(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_X, a)
    }
    GetTransformWithParentY()
    {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_Y)
    }
    GetTransformWithParentXOrY()
    {
        return 0 !== (this._flags & (FLAG_TRANSFORM_WITH_PARENT_X | FLAG_TRANSFORM_WITH_PARENT_Y))
    }
    SetTransformWithParentY(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Y,
        a)
    }
    GetTransformWithParentWidth()
    {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_W)
    }
    SetTransformWithParentWidth(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_W, a)
    }
    GetTransformWithParentHeight()
    {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_H)
    }
    SetTransformWithParentHeight(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_H, a)
    }
    GetTransformWithParentAngle()
    {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_A)
    }
    SetTransformWithParentAngle(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_A, a)
    }
    GetTransformWithParentZElevation()
    {
        return 0 !==
        (this._flags & FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION)
    }
    SetTransformWithParentZElevation(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_Z_ELEVATION, a)
    }
    GetTransformWithParentOpacity()
    {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_OPACITY)
    }
    SetTransformWithParentOpacity(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_OPACITY, a)
    }
    GetTransformWithParentVisibility()
    {
        return 0 !== (this._flags & FLAG_TRANSFORM_WITH_PARENT_VISIBILITY)
    }
    SetTransformWithParentVisibility(a)
    {
        this._SetFlag(FLAG_TRANSFORM_WITH_PARENT_VISIBILITY,
        a)
    }
    _ClearAllSceneGraphFlags()
    {
        this._flags &= ~MASK_ALL_SCENE_GRAPH_FLAGS
    }
    AddChild(a, b)
    {
        if (a === this || a.HasParent() || this._HasChildRecursive(a) || this._HasAnyParent(a))
            return !1;
        var c = a.GetX(),
            d = a.GetY(),
            e = a.GetWidth();
        const f = a.GetHeight(),
            g = a.GetAngle(),
            h = a.GetZElevation(),
            k = a.GetOpacity();
        a._SetParent(this);
        a.SetTransformWithParentX(b.transformX);
        a.SetTransformWithParentY(b.transformY);
        a.SetTransformWithParentWidth(b.transformWidth);
        a.SetTransformWithParentHeight(b.transformHeight);
        a.SetTransformWithParentAngle(b.transformAngle);
        a.SetTransformWithParentZElevation(b.transformZElevation);
        a.SetTransformWithParentOpacity(b.transformOpacity);
        a.SetTransformWithParentVisibility(b.transformVisibility);
        a.SetDestroyWithParent(b.destroyWithParent);
        b.transformX && (a._x = c - this.GetX(), b.transformWidth && (c = this.GetWidth() / this._sceneGraphInfo._GetStartWidth(), 0 !== c && (a._x /= c)));
        b.transformY && (a._y = d - this.GetY(), b.transformHeight && (d = this.GetHeight() / this._sceneGraphInfo._GetStartHeight(), 0 !== d && (a._y /= d)));
        b.transformWidth && (d = this.GetWidth(),
        0 === d || d === Number.EPSILON ? (a._w = 1, a._sceneGraphInfo.SetStartScaleX(1)) : (a._w = e / this.GetWidth(), a._sceneGraphInfo.SetStartScaleX(a._w)));
        b.transformHeight && (e = this.GetHeight(), 0 === e || e === Number.EPSILON ? (a._h = 1, a._sceneGraphInfo.SetStartScaleY(1)) : (a._h = f / this.GetHeight(), a._sceneGraphInfo.SetStartScaleY(a._h)));
        b.transformAngle && (a._a = g - this.GetAngle());
        b.transformZElevation && (a._zElevation = h - this.GetZElevation());
        b.transformOpacity && a._sceneGraphInfo.SetOwnOpacity(k);
        b.transformVisibility && a.SetVisible(this.IsVisible());
        this._AddChildToSceneGraphInfo(a);
        this.SetBboxChanged();
        this._SetOpacityOfChildren();
        return !0
    }
    RemoveChild(a)
    {
        if (a.GetParent() === this) {
            var b = a.GetX(),
                c = a.GetY(),
                d = a.GetWidth(),
                e = a.GetHeight(),
                f = a.GetAngle(),
                g = a.GetZElevation(),
                h = a.GetOpacity();
            a._SetParent(null);
            a._ClearAllSceneGraphFlags();
            a.SetXY(b, c);
            a.SetSize(d, e);
            a.SetAngle(f);
            a.SetZElevation(g);
            a.SetOpacity(h);
            this._RemoveChildFromSceneGraphInfo(a);
            this.SetBboxChanged()
        }
    }
    GetTmpHierarchyPosition()
    {
        return this._tmpHierarchyPosition
    }
    _ResetAllSceneGraphState()
    {
        this._BuildTmpSceneGraphData();
        var a = [...this.children()];
        for (const b of a)
            this.RemoveChild(b);
        (a = this.GetParent()) && a.RemoveChild(this);
        this._ClearAllSceneGraphFlags()
    }
    _BuildTmpSceneGraphData()
    {
        this._SetTmpHierarchyPosition();
        if (!this._tmpSceneGraphChildren) {
            var a = [...this.children()];
            a.length && (this._tmpSceneGraphChildren = [], this._tmpSceneGraphChildrenIndexes = new WeakMap);
            var b = 0;
            for (const c of a)
                a = c.GetInstance(),
                this._tmpSceneGraphChildren.push(a),
                this._tmpSceneGraphChildrenIndexes.set(a, b),
                b++
        }
        (b = this.GetParent()) && b._BuildTmpSceneGraphData()
    }
    _SetTmpHierarchyPosition()
    {
        if (-1 ===
        this._tmpHierarchyPosition) {
            var a = [...this.parents()];
            this._tmpHierarchyPosition = a.length;
            for (const b of a)
                b._SetTmpHierarchyPosition();
            a = [...this.children()];
            for (const b of a)
                b._SetTmpHierarchyPosition()
        }
    }
    _ReleaseTmpSceneGraphInfo()
    {
        this._tmpSceneGraphChildren && (this._tmpSceneGraphChildren.length = 0);
        this._tmpSceneGraphChildrenIndexes = this._tmpSceneGraphChildren = null;
        const a = this.GetParent();
        a && a._ReleaseTmpSceneGraphInfo();
        this._tmpHierarchyPosition = -1
    }
    HasParent()
    {
        return null !== this.GetParent()
    }
    GetParent()
    {
        const a =
        this._sceneGraphInfo;
        return null !== a ? a.GetParent() : null
    }
    GetTopParent()
    {
        let a = this;
        for (; a.HasParent();)
            a = a.GetParent();
        return a
    }
    *parents()
    {
        let a = this.GetParent();
        for (; a;)
            yield a,
            a = a.GetParent()
    }
    HasChild(a)
    {
        return this.GetChildren().includes(a)
    }
    HasChildren()
    {
        const a = this._sceneGraphInfo;
        return null !== a ? a.HasChildren() : !1
    }
    GetChildren()
    {
        const a = this._sceneGraphInfo;
        return null !== a ? a.GetChildren() : EMPTY_ARRAY$jscomp$2
    }
    children()
    {
        return this.GetChildren()
    }
    *allChildren()
    {
        for (const a of this.children())
            yield a,
            yield *a.allChildren()
    }
    GetChildCount()
    {
        return this.GetChildren().length
    }
    GetAllChildCount()
    {
        return [...this.allChildren()].length
    }
    GetChildAt(a)
    {
        const b = this.GetChildren();
        a = Math.floor(+a);
        return 0 > a || a >= b.length ? null : b[a]
    }
    GetChildIndex(a)
    {
        if (!a)
            return NaN;
        const b = this.GetChildren();
        if (!b)
            return NaN;
        for (let c = 0; c < b.length; c++)
            if (a === b[c])
                return c;
        return NaN
    }
    _CreateSceneGraphInfo(a)
    {
        this._sceneGraphInfo || (this._sceneGraphInfo = C3$jscomp$192.New(C3$jscomp$192.SceneGraphInfo, this));
        a && this._sceneGraphInfo.SetParent(a)
    }
    _GetSceneGraphInfo()
    {
        return this._sceneGraphInfo
    }
    _ReleaseSceneGraphInfo()
    {
        this._sceneGraphInfo &&
        (this._sceneGraphInfo.Release(), this._sceneGraphInfo = null)
    }
    _SetParent(a)
    {
        a ? (a._CreateSceneGraphInfo(null), this._CreateSceneGraphInfo(a)) : (this._sceneGraphInfo && this._sceneGraphInfo.SetParent(null), this.HasChildren() || this._ReleaseSceneGraphInfo())
    }
    _HasAnyParent(a)
    {
        if (!this.HasParent())
            return !1;
        const b = this.GetParent();
        return b === a ? !0 : b._HasAnyParent(a)
    }
    _HasChildRecursive(a)
    {
        if (this.HasChild(a))
            return !0;
        for (const b of this.GetChildren())
            if (b._HasChildRecursive(a))
                return !0;
        return !1
    }
    _AddChildToSceneGraphInfo(a)
    {
        this._sceneGraphInfo.GetChildren().push(a)
    }
    _RemoveChildFromSceneGraphInfo(a)
    {
        const b =
            this._sceneGraphInfo.GetChildren(),
            c = b.indexOf(a);
        -1 !== c && b.splice(c, 1);
        0 !== b.length || this.HasParent() || this._ReleaseSceneGraphInfo();
        a.HasChildren() || a._ReleaseSceneGraphInfo()
    }
    GetSceneGraphChildrenExportData()
    {
        const a = sceneGraphExportDataMap.get(this);
        return a ? a.childrenData : null
    }
    GetSceneGraphZIndexExportData()
    {
        const a = sceneGraphExportDataMap.get(this);
        return a ? a.zIndexData : NaN
    }
    GetSceneGraphZIndex()
    {
        const a = sceneGraphZIndexMap.get(this);
        return C3$jscomp$192.IsFiniteNumber(a) ? a : NaN
    }
    SetSceneGraphZIndex(a)
    {
        sceneGraphZIndexMap.set(this,
        a)
    }
    SetUsePointsShaderProgram()
    {
        this._SetFlag(FLAG_USE_POINTS_SHADER_PROGRAM, !0);
        this._UpdateRendererStateGroup()
    }
    _UpdateRendererStateGroup()
    {
        if (enableUpdateRendererStateGroup) {
            var a = this._runtime.GetRenderer();
            this._stateGroup && a.ReleaseStateGroup(this._stateGroup);
            var b = 0 !== (this._flags & FLAG_USE_POINTS_SHADER_PROGRAM) ? a.GetPointsRenderingProgram() || "<point>" : a.GetTextureFillShaderProgram() || "<default>";
            this._stateGroup = a.AcquireStateGroup(b, this.GetBlendMode(), this._colorPremultiplied, this.GetZElevation())
        }
    }
    GetRendererStateGroup()
    {
        return this._stateGroup
    }
    HasDefaultColor()
    {
        return this._color ===
        DEFAULT_COLOR
    }
    SetBlendMode(a)
    {
        a |= 0;
        if (0 > a || 31 < a)
            throw new RangeError("invalid blend mode");
        this.GetBlendMode() !== a && (this._flags = this._flags & ~FLAG_BLEND_MODE_MASK | a << 26, this._UpdateRendererStateGroup())
    }
    GetBlendMode()
    {
        return (this._flags & FLAG_BLEND_MODE_MASK) >> 26
    }
    _SetLayer(a, b)
    {
        (b = b && this._layer !== a) && this._RemoveFromRenderCells();
        this._objectClass._OnWorldInstanceLayerChanged(this, this._layer, a);
        this._layer = a;
        b && this._UpdateRenderCell();
        0 !== this.GetZElevation() && this._layer._SetAnyInstanceZElevated()
    }
    GetLayer()
    {
        return this._layer
    }
    GetLayout()
    {
        return this.GetLayer().GetLayout()
    }
    _SetZIndex(a)
    {
        this._zIndex =
        a | 0
    }
    GetZIndex()
    {
        this._layer._UpdateZIndices();
        return this._zIndex
    }
    _SetHTMLZIndex(a)
    {
        this._htmlZIndex = a | 0
    }
    GetHTMLZIndex()
    {
        this._layer._UpdateHTMLZIndices();
        return this._htmlZIndex
    }
    _GetLastCachedZIndex()
    {
        return this._zIndex
    }
    _SetFlag(a, b)
    {
        this._flags = b ? this._flags | a : this._flags & ~a
    }
    IsVisible()
    {
        return 0 !== (this._flags & FLAG_IS_VISIBLE)
    }
    SetVisible(a)
    {
        this._SetFlag(FLAG_IS_VISIBLE, a);
        if (this.HasChildren())
            for (const b of this.GetChildren())
                b.GetTransformWithParentVisibility() && b.SetVisible(a)
    }
    IsCollisionEnabled()
    {
        return 0 !==
        (this._flags & FLAG_COLLISION_ENABLED)
    }
    SetCollisionEnabled(a)
    {
        a = !!a;
        this.IsCollisionEnabled() !== a && (this._SetFlag(FLAG_COLLISION_ENABLED, a), a ? this.SetBboxChanged() : this._RemoveFromCollisionCells())
    }
    SetSolidCollisionFilter(a, b)
    {
        this._SetFlag(FLAG_SOLID_FILTER_INCLUSIVE, a);
        this._solidFilterTags && this._solidFilterTags.clear();
        if (b.trim()) {
            this._solidFilterTags || (this._solidFilterTags = new Set);
            for (const c of b.split(" "))
                c && this._solidFilterTags.add(c.toLowerCase())
        } else
            this._solidFilterTags = null
    }
    IsSolidCollisionAllowed(a)
    {
        const b =
            0 !== (this._flags & FLAG_SOLID_FILTER_INCLUSIVE),
            c = this._solidFilterTags;
        if (!a || !c)
            return !b;
        for (const d of c)
            if (a.has(d))
                return b;
        return !b
    }
    SetBboxChanged()
    {
        this._flags = this._flags | FLAG_BBOX_CHANGED | FLAG_COLLISION_CELL_CHANGED | FLAG_MESH_CHANGED;
        this._objectClass._SetAnyCollisionCellChanged(!0);
        this._runtime.UpdateRender();
        this._layer.UsesRenderCells() && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags &= ~FLAG_BBOX_CHANGED, this._UpdateRenderCell());
        0 !== (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT) &&
        this._inst.Dispatcher().dispatchEvent(bboxChangeEvent);
        if (null !== this._sceneGraphInfo) {
            const a = this._sceneGraphInfo.GetChildren();
            for (let b = 0, c = a.length; b < c; ++b)
                a[b].SetBboxChanged()
        }
    }
    CalculateBbox(a, b, c)
    {
        const d = this.GetX(),
            e = this.GetY(),
            f = this.GetWidth(),
            g = this.GetHeight(),
            h = this.GetAngle();
        a.setWH(d - this._ox * f, e - this._oy * g, f, g);
        c && this.HasMesh() && this._ExpandBboxForMesh(a);
        0 === h ? b.setFromRect(a) : (a.offset(-d, -e), b.setFromRotatedRectPrecalc(a, this.GetSinAngle(), this.GetCosAngle()), b.offset(d, e),
        b.getBoundingBox(a));
        a.normalize()
    }
    _UpdateBbox()
    {
        const a = this._flags;
        0 !== (a & FLAG_BBOX_CHANGED) && (this.CalculateBbox(this._boundingBox, this._boundingQuad, !0), this._flags = a & ~FLAG_BBOX_CHANGED)
    }
    GetBoundingBox()
    {
        this._UpdateBbox();
        return this._boundingBox
    }
    GetBoundingQuad()
    {
        this._UpdateBbox();
        return this._boundingQuad
    }
    PixelRoundQuad(a)
    {
        var b = this.GetX(),
            c = this.GetY();
        b = Math.round(b) - b;
        c = Math.round(c) - c;
        if (0 === b && 0 === c)
            return a;
        tempQuad$jscomp$3.copy(a);
        tempQuad$jscomp$3.offset(b, c);
        return tempQuad$jscomp$3
    }
    OverwriteBoundingBox(a)
    {
        this._boundingBox.copy(a);
        this._boundingQuad.setFromRect(this._boundingBox);
        this._flags &= ~FLAG_BBOX_CHANGED;
        this._UpdateCollisionCell();
        this._UpdateRenderCell()
    }
    SetBboxChangeEventEnabled(a)
    {
        this._SetFlag(FLAG_ENABLE_BBOX_CHANGED_EVENT, a)
    }
    IsBboxChangeEventEnabled()
    {
        return 0 !== (this._flags & FLAG_ENABLE_BBOX_CHANGED_EVENT)
    }
    IsInViewport(a, b, c)
    {
        return b && 0 !== this.GetDepth() ? this.IsInViewport3D(this.GetLayer()._GetViewFrustum()) : 0 === this.GetZElevation() || c ? a.intersectsRect(this.GetBoundingBox()) : this._IsInViewport_ZElevated()
    }
    _IsInViewport_ZElevated()
    {
        const a =
            this.GetLayer(),
            b = this.GetTotalZElevation();
        if (b >= a.Get2DCameraZ())
            return !1;
        a.GetViewportForZ(b, tempRect$jscomp$7);
        return tempRect$jscomp$7.intersectsRect(this.GetBoundingBox())
    }
    IsInViewport3D(a)
    {
        var b = this.GetBoundingBox();
        const c = b.getLeft(),
            d = b.getRight(),
            e = b.getTop();
        b = b.getBottom();
        const f = this.GetTotalZElevation(),
            g = f + this.GetDepth();
        return a.ContainsAABB(c, e, f, d, b, g)
    }
    IsInViewport2()
    {
        const a = this.GetLayer();
        if (a.Has3DCamera())
            return this.IsInViewport3D(a._GetViewFrustum());
        const b = a.GetLayout();
        return this.IsInViewport(a.GetViewport(), b.HasVanishingPointOutsideViewport(), b.IsOrthographicProjection())
    }
    _SetDrawBackFaceOnly(a)
    {
        this._SetFlag(FLAG_DRAW_BACK_FACE_ONLY, a)
    }
    _SetDrawNonBackFacesOnly(a)
    {
        this._SetFlag(FLAG_DRAW_NON_BACK_FACES_ONLY, a)
    }
    IsDrawBackFaceOnly()
    {
        return 0 !== (this._flags & FLAG_DRAW_BACK_FACE_ONLY)
    }
    IsDrawNonBackFacesOnly()
    {
        return 0 !== (this._flags & FLAG_DRAW_NON_BACK_FACES_ONLY)
    }
    SetSourceCollisionPoly(a)
    {
        this._sourceCollisionPoly = a;
        this._DiscardTransformedCollisionPoly();
        this.HasMesh() &&
        (this._meshInfo.meshPoly = null)
    }
    GetSourceCollisionPoly()
    {
        return this._sourceCollisionPoly
    }
    HasOwnCollisionPoly()
    {
        return null !== this._sourceCollisionPoly || this.HasMesh()
    }
    GetTransformedCollisionPoly()
    {
        return this._GetCustomTransformedCollisionPolyPrecalc(this.GetWidth(), this.GetHeight(), this.GetAngle(), this.GetSinAngle(), this.GetCosAngle())
    }
    GetCustomTransformedCollisionPoly(a, b, c)
    {
        let d = 0,
            e = 1;
        0 !== c && (d = Math.sin(c), e = Math.cos(c));
        return this._GetCustomTransformedCollisionPolyPrecalc(a, b, c, d, e)
    }
    _GetCustomTransformedCollisionPolyPrecalc(a,
    b, c, d, e)
    {
        let f = this._transformedPolyInfo;
        null === f && (this._transformedPolyInfo = f = {
            poly: C3$jscomp$192.New(C3$jscomp$192.CollisionPoly),
            width: NaN,
            height: NaN,
            angle: NaN
        });
        const g = f.poly;
        if (f.width === a && f.height === b && f.angle === c)
            return g;
        const h = this._sourceCollisionPoly;
        if (this.HasMesh()) {
            const k = this.GetOriginX(),
                l = this.GetOriginY(),
                m = this.GetSourceMesh();
            let n = this._meshInfo.meshPoly;
            n || (h ? (tempCollisionPoly.copy(h), tempCollisionPoly.offset(k, l)) : tempCollisionPoly.setDefaultPoints(), n = m.InsertPolyMeshVertices(tempCollisionPoly),
            this._meshInfo.meshPoly = n);
            m.TransformCollisionPoly(n, g);
            g.offset(-k, -l);
            g.transformPrecalc(a, b, d, e)
        } else
            h ? (g.copy(h), g.transformPrecalc(a, b, d, e)) : g.setFromQuad(this.GetBoundingQuad(), -this.GetX(), -this.GetY());
        f.width = a;
        f.height = b;
        f.angle = c;
        return g
    }
    _DiscardTransformedCollisionPoly()
    {
        this.SetPhysicsBodyChanged(!0);
        const a = this._transformedPolyInfo;
        null !== a && (a.width = NaN)
    }
    CreateMesh(a, b)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        if (!this.GetInstance().GetPlugin().SupportsMesh())
            throw Error("object does not support mesh");
        this.ReleaseMesh();
        this._meshInfo = {
            sourceMesh: C3$jscomp$192.New(C3$jscomp$192.Gfx.Mesh, a, b),
            transformedMesh: C3$jscomp$192.New(C3$jscomp$192.Gfx.Mesh, a, b),
            meshPoly: null
        }
    }
    HasMesh()
    {
        return null !== this._meshInfo
    }
    GetSourceMesh()
    {
        if (!this.HasMesh())
            throw Error("no mesh");
        return this._meshInfo.sourceMesh
    }
    GetTransformedMesh()
    {
        if (!this.HasMesh())
            throw Error("no mesh");
        return this._meshInfo.transformedMesh
    }
    SetMeshChanged(a)
    {
        this._SetFlag(FLAG_MESH_CHANGED, a)
    }
    IsMeshChanged()
    {
        return 0 !== (this._flags & FLAG_MESH_CHANGED)
    }
    SetPhysicsBodyChanged(a)
    {
        this._SetFlag(FLAG_PHYSICS_BODY_CHANGED,
        a)
    }
    IsPhysicsBodyChanged()
    {
        return 0 !== (this._flags & FLAG_PHYSICS_BODY_CHANGED)
    }
    _ExpandBboxForMesh(a)
    {
        const b = this._meshInfo.sourceMesh,
            c = Math.min(b.GetMinX(), 0),
            d = Math.min(b.GetMinY(), 0),
            e = Math.max(b.GetMaxX(), 1),
            f = Math.max(b.GetMaxY(), 1),
            g = a.width(),
            h = a.height();
        a.offsetLeft(c * g);
        a.offsetTop(d * h);
        a.offsetRight((e - 1) * g);
        a.offsetBottom((f - 1) * h);
        this._depth = b.GetMaxZ()
    }
    ReleaseMesh()
    {
        this._meshInfo && (this._meshInfo.sourceMesh.Release(), this._meshInfo.transformedMesh.Release(), this._meshInfo = null, this._DiscardTransformedCollisionPoly())
    }
    SetMeshPoint(a,
    b, c)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        var d = c.mode || "absolute";
        if (!VALID_SET_MESH_POINT_MODES.has(d))
            throw Error("invalid mode");
        d = "relative" === d;
        let e = c.x,
            f = c.y;
        const g = c.zElevation;
        let h = "number" === typeof c.u ? c.u : d ? 0 : -1;
        c = "number" === typeof c.v ? c.v : d ? 0 : -1;
        if (!this.HasMesh())
            return !1;
        const k = this.GetSourceMesh(),
            l = k.GetMeshPointAt(a, b);
        if (null === l)
            return !1;
        let m = !1;
        "number" === typeof g && l.GetZElevation() !== g && (l.SetZElevation(g), m = !0);
        d && (e += a / (k.GetHSize() - 1), f += b / (k.GetVSize() - 1));
        -1 !== h || d ? (d && (h +=
        a / (k.GetHSize() - 1)), h = C3$jscomp$192.clamp(h, 0, 1)) : h = l.GetU();
        -1 !== c || d ? (d && (c += b / (k.GetVSize() - 1)), c = C3$jscomp$192.clamp(c, 0, 1)) : c = l.GetV();
        if (l.GetX() === e && l.GetY() === f && l.GetU() === h && l.GetV() === c)
            return m;
        l.SetX(e);
        l.SetY(f);
        l.SetU(h);
        l.SetV(c);
        this._DiscardTransformedCollisionPoly();
        return !0
    }
    HasTilemap()
    {
        return this._inst.HasTilemap()
    }
    ContainsPoint(a, b)
    {
        return this.GetBoundingBox().containsPoint(a, b) && this.GetBoundingQuad().containsPoint(a, b) ? this.HasTilemap() ? this._inst.GetSdkInstance().TestPointOverlapTile(a,
        b) : this.HasOwnCollisionPoly() ? this.GetTransformedCollisionPoly().containsPoint(a - this.GetX(), b - this.GetY()) : !0 : !1
    }
    _IsCollisionCellChanged()
    {
        return 0 !== (this._flags & FLAG_COLLISION_CELL_CHANGED)
    }
    _UpdateCollisionCell()
    {
        if (this._IsCollisionCellChanged() && this.IsCollisionEnabled() && 0 === (this._flags & FLAG_DESTROYED$jscomp$1)) {
            var a = this.GetBoundingBox(),
                b = this._objectClass._GetCollisionCellGrid(),
                c = this._collisionCells;
            tempRect$jscomp$7.set(b.XToCell(a.getLeft()), b.YToCell(a.getTop()), b.XToCell(a.getRight()),
            b.YToCell(a.getBottom()));
            c.equals(tempRect$jscomp$7) || (a = this._inst, c === DEFAULT_COLLISION_CELLS ? (b.Update(a, null, tempRect$jscomp$7), this._collisionCells = C3$jscomp$192.New(C3$jscomp$192.Rect, tempRect$jscomp$7)) : (b.Update(a, c, tempRect$jscomp$7), c.copy(tempRect$jscomp$7)), this._flags &= ~FLAG_COLLISION_CELL_CHANGED)
        }
    }
    _SetCollisionCellChanged()
    {
        this._flags |= FLAG_COLLISION_CELL_CHANGED
    }
    _RemoveFromCollisionCells()
    {
        const a = this._collisionCells;
        a !== DEFAULT_COLLISION_CELLS && (this._objectClass._GetCollisionCellGrid().Update(this._inst,
        a, null), this._collisionCells = DEFAULT_COLLISION_CELLS)
    }
    _UpdateRenderCell()
    {
        const a = this.GetLayer();
        if (a.UsesRenderCells() && 0 === (this._flags & FLAG_DESTROYED$jscomp$1)) {
            var b = a.GetRenderGrid(),
                c = this.GetBoundingBox(),
                d = this._renderCells;
            tempRect$jscomp$7.set(b.XToCell(c.getLeft()), b.YToCell(c.getTop()), b.XToCell(c.getRight()), b.YToCell(c.getBottom()));
            d.equals(tempRect$jscomp$7) || (c = this._inst, d === DEFAULT_RENDER_CELLS ? (b.Update(c, null, tempRect$jscomp$7), this._renderCells = C3$jscomp$192.New(C3$jscomp$192.Rect,
            tempRect$jscomp$7)) : (b.Update(c, d, tempRect$jscomp$7), d.copy(tempRect$jscomp$7)), a.SetRenderListStale())
        }
    }
    _RemoveFromRenderCells()
    {
        const a = this._renderCells;
        a !== DEFAULT_RENDER_CELLS && (this.GetLayer().GetRenderGrid().Update(this._inst, a, null), this._renderCells = DEFAULT_RENDER_CELLS)
    }
    GetRenderCellRange()
    {
        return this._renderCells
    }
    ZOrderMoveToTop()
    {
        const a = this._inst,
            b = this._layer,
            c = b._GetInstances();
        c.length && c.at(-1) === a || (b._RemoveInstance(a, !1), b._AddInstance(a, !1), this._runtime.UpdateRender())
    }
    ZOrderMoveToBottom()
    {
        const a =
            this._inst,
            b = this._layer,
            c = b._GetInstances();
        c.length && c[0] === a || (b._RemoveInstance(a, !1), b._PrependInstance(a, !1), this._runtime.UpdateRender())
    }
    ZOrderMoveToLayer(a)
    {
        const b = this._inst,
            c = this._layer;
        if (c.GetLayout() !== a.GetLayout())
            throw Error("layer from different layout");
        a !== c && (c._RemoveInstance(b, !0), this._SetLayer(a), a._AddInstance(b, !0), this._runtime.UpdateRender())
    }
    ZOrderMoveAdjacentToInstance(a, b)
    {
        const c = this._inst;
        let d = !1;
        const e = this._layer;
        if (a.GetUID() !== c.GetUID()) {
            var f = a.GetWorldInfo();
            if (!f)
                throw Error("expected world instance");
            f = f.GetLayer();
            e.GetIndex() !== f.GetIndex() && (e._RemoveInstance(c, !0), this._SetLayer(f), f._AddInstance(c, !0), d = !0);
            a = f.MoveInstanceAdjacent(c, a, !!b);
            (d || a) && this._runtime.UpdateRender()
        }
    }
    GetInstanceEffectList()
    {
        return this._instanceEffectList
    }
    _SetHasAnyActiveEffect(a)
    {
        this._SetFlag(FLAG_HAS_ANY_ACTIVE_EFFECT, a)
    }
    HasAnyActiveEffect()
    {
        return 0 !== (this._flags & FLAG_HAS_ANY_ACTIVE_EFFECT)
    }
    _SaveToJson(a, b=null)
    {
        const c = {
            x: this.GetX(),
            y: this.GetY(),
            w: this.GetWidth(),
            h: this.GetHeight(),
            l: this.GetLayer().GetSID(),
            zi: this.GetZIndex()
        };
        0 !== this.GetZElevation() && (c.ze = this.GetZElevation());
        0 !== this.GetAngle() && (c.a = this._GetAngleNoReflect());
        this.HasDefaultColor() || (c.c = this._color.toJSON());
        .5 !== this.GetOriginX() && (c.oX = this.GetOriginX());
        .5 !== this.GetOriginY() && (c.oY = this.GetOriginY());
        0 !== this.GetBlendMode() && (c.bm = this.GetBlendMode());
        this.IsVisible() || (c.v = this.IsVisible());
        this.IsCollisionEnabled() || (c.ce = this.IsCollisionEnabled());
        this.IsBboxChangeEventEnabled() &&
        (c.be = this.IsBboxChangeEventEnabled());
        this._instanceEffectList && (c.fx = this._instanceEffectList._SaveToJson());
        const d = 0 !== (this._flags & FLAG_SOLID_FILTER_INCLUSIVE);
        d && (c.sfi = d);
        this._solidFilterTags && (c.sft = [...this._solidFilterTags].join(" "));
        this._sceneGraphInfo && "visual-state" !== a && (c.sgi = this._sceneGraphInfo._SaveToJson(a, b), sceneGraphExportDataMap.has(this) && (c.sgcd = sceneGraphExportDataMap.get(this).childrenData, c.sgzid = sceneGraphExportDataMap.get(this).zIndexData));
        this.HasMesh() && (c.mesh =
        this.GetSourceMesh().SaveToJson());
        return c
    }
    _SaveSceneGraphPropertiesToJson()
    {
        return {
            x: this._x,
            y: this._y,
            z: this._zElevation,
            w: this._w,
            h: this._h,
            a: this._a,
            sgi: this._GetSceneGraphInfo() ? this._GetSceneGraphInfo()._SaveToJsonProperties() : null
        }
    }
    _LoadSceneGraphPropertiesFromJson(a)
    {
        a && (this._x = a.x, this._y = a.y, this._zElevation = a.z, this._w = a.w, this._h = a.h, this._a = a.a, a.sgi && this._GetSceneGraphInfo() && this._GetSceneGraphInfo()._LoadFromJson(a.sgi), this._MarkSinCosAngleChanged(), this.SetBboxChanged())
    }
    _SetupSceneGraphConnectionsOnChangeOfLayout()
    {
        this._ReleaseTmpSceneGraphInfo();
        this._ResetAllSceneGraphState();
        this._CreateSceneGraphInfo(null);
        this._sceneGraphInfo && this._sceneGraphInfo._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes)
    }
    _OnBeforeLoad(a)
    {
        "visual-state" !== a && this._ResetAllSceneGraphState()
    }
    _OnAfterLoad(a, b="full", c=null)
    {
        a.hasOwnProperty("sgi") && "visual-state" !== b && 0 === (this._flags & FLAG_DESTROYED$jscomp$1) && this._sceneGraphInfo._OnAfterLoad(a.sgi, c)
    }
    _OnAfterLoad2(a, b="full", c)
    {
        a.hasOwnProperty("sgi") && "visual-state" !== b &&
        0 === (this._flags & FLAG_DESTROYED$jscomp$1) && (this._sceneGraphInfo._SetTmpSceneGraphChildren(null, null), this._ReleaseTmpSceneGraphInfo(), this.SetBboxChanged())
    }
    _LoadFromJson(a, b)
    {
        enableUpdateRendererStateGroup = !1;
        this.SetX(a.x);
        this.SetY(a.y);
        this.SetWidth(a.w);
        this.SetHeight(a.h);
        this._SetZIndex(a.zi);
        this.SetZElevation(a.hasOwnProperty("ze") ? a.ze : 0);
        this.SetAngle(a.hasOwnProperty("a") ? a.a : 0);
        a.hasOwnProperty("c") ? tempColor$jscomp$6.setFromJSON(a.c) : a.hasOwnProperty("o") ? (tempColor$jscomp$6.copyRgb(this._color),
        tempColor$jscomp$6.a = a.o) : tempColor$jscomp$6.setRgba(1, 1, 1, 1);
        this._SetColor(tempColor$jscomp$6);
        this.SetOriginX(a.hasOwnProperty("oX") ? a.oX : .5);
        this.SetOriginY(a.hasOwnProperty("oY") ? a.oY : .5);
        this.SetBlendMode(a.hasOwnProperty("bm") ? a.bm : 0);
        this.SetVisible(a.hasOwnProperty("v") ? a.v : !0);
        this.SetCollisionEnabled(a.hasOwnProperty("ce") ? a.ce : !0);
        this.SetBboxChangeEventEnabled(a.hasOwnProperty("be") ? a.be : !1);
        this.SetSolidCollisionFilter(a.hasOwnProperty("sfi") ? a.sfi : !1, a.hasOwnProperty("sft") ? a.sft : "");
        this._instanceEffectList && a.hasOwnProperty("fx") && this._instanceEffectList._LoadFromJson(a.fx);
        if (!a.hasOwnProperty("sgi") && "visual-state" !== b && this._tmpSceneGraphChildren)
            for (var c of this._tmpSceneGraphChildren)
                c.IsDestroyed() || this._runtime.DestroyInstance(c);
        a.hasOwnProperty("sgi") && "visual-state" !== b && (this._CreateSceneGraphInfo(null), c = this._sceneGraphInfo, c._LoadFromJson(a.sgi), c._SetTmpSceneGraphChildren(this._tmpSceneGraphChildren, this._tmpSceneGraphChildrenIndexes), a.sgcd && C3$jscomp$192.IsFiniteNumber(a.sgzid) &&
        sceneGraphExportDataMap.set(this, {
            childrenData: a.sgcd,
            zIndexData: a.sgzid
        }));
        a.hasOwnProperty("mesh") ? (c = a.mesh, this.CreateMesh(c.cols, c.rows), this.GetSourceMesh().LoadFromJson(c)) : this.ReleaseMesh();
        this.SetBboxChanged();
        enableUpdateRendererStateGroup = !0;
        this._UpdateRendererStateGroup();
        "visual-state" !== b && this._runtime.AddInstanceNeedingAfterLoad(this.GetInstance(), a)
    }
}
;
"use strict";
const C3$jscomp$193 = self.C3;
C3$jscomp$193.BehaviorType = class  extends C3$jscomp$193.DefendedBase{
    constructor(a, b)
    {
        super();
        const c = a.GetRuntime(),
            d = c.GetObjectReference(b[1]);
        c.GetAddonManager()._DelayCreateBehavior(d);
        this._runtime = c;
        this._objectClass = a;
        this._behavior = C3$jscomp$193.AddonManager.GetBehaviorByConstructorFunction(d);
        this._iBehaviorType = this._sdkType = null;
        this._instSdkCtor = d.Instance;
        this._sid = b[2];
        this._name = b[0];
        this._jsPropName = this._runtime.GetJsPropName(b[3]);
        a = this._behavior.GetSdkVersion();
        if (2 > a && (this._sdkType =
        C3$jscomp$193.New(d.Type, this), !(this._sdkType instanceof C3$jscomp$193.SDKBehaviorTypeBase)))
            throw Error("v1 sdk type must derive from SDKBehaviorBase");
        C3$jscomp$193.AddonManager._PushInitObject(this, a);
        if (2 <= a) {
            if (this._iBehaviorType = new (d.Type ?? globalThis.ISDKBehaviorTypeBase), !(this._iBehaviorType instanceof globalThis.ISDKBehaviorTypeBase))
                throw Error("script interface class must derive from ISDKBehaviorTypeBase");
        } else
            this._iBehaviorType = new globalThis.IBehaviorType;
        C3$jscomp$193.AddonManager._PopInitObject(a);
        this.OnCreate()
    }
    static Create(a, b)
    {
        return C3$jscomp$193.New(C3$jscomp$193.BehaviorType, a, b)
    }
    Release()
    {
        this._behavior = this._runtime = null;
        this._sdkType && (this._sdkType.Release(), this._sdkType = null);
        this._instSdkCtor = null
    }
    GetSdkType()
    {
        return this._sdkType
    }
    OnCreate()
    {
        this._sdkType ? this._sdkType.OnCreate() : this._iBehaviorType && this._iBehaviorType._onCreate()
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetObjectClass()
    {
        return this._objectClass
    }
    GetBehavior()
    {
        return this._behavior
    }
    GetInstanceSdkCtor()
    {
        return this._instSdkCtor
    }
    GetName()
    {
        return this._name
    }
    GetSID()
    {
        return this._sid
    }
    GetIBehaviorType()
    {
        return this._iBehaviorType
    }
    GetJsPropName()
    {
        return this._jsPropName
    }
}
;
"use strict";
const C3$jscomp$194 = self.C3,
    IBehaviorInstance$jscomp$1 = self.IBehaviorInstance;
C3$jscomp$194.BehaviorInstance = class  extends C3$jscomp$194.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a.runtime;
        this._behaviorType = a.behaviorType;
        this._behavior = this._behaviorType.GetBehavior();
        this._inst = a.instance;
        this._index = a.index;
        this._iScriptInterface = this._sdkInst = null;
        this._behavior._AddInstance(this._inst)
    }
    Release()
    {
        this._iScriptInterface && (this._iScriptInterface._release(), this._iScriptInterface = null);
        this._behavior._RemoveInstance(this._inst);
        this._sdkInst && (this._sdkInst.Release(),
        this._sdkInst = null);
        this._inst = this._behavior = this._behaviorType = this._runtime = null
    }
    _CreateSdkInstance(a)
    {
        if (this._sdkInst)
            throw Error("already got sdk instance");
        if (2 > this.GetBehavior().GetSdkVersion()) {
            if (this._sdkInst = C3$jscomp$194.New(this._behaviorType.GetInstanceSdkCtor(), this, a), !(this._sdkInst instanceof C3$jscomp$194.SDKBehaviorInstanceBase))
                throw Error("v1 sdk type must derive from SDKBehaviorInstanceBase");
        } else {
            const b = this.GetBehavior().GetScriptInterfaceClass();
            this._InitScriptInterface(b.Instance,
            a)
        }
    }
    GetSdkInstance()
    {
        return this._sdkInst ?? this._iScriptInterface
    }
    GetObjectInstance()
    {
        return this._inst
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetBehaviorType()
    {
        return this._behaviorType
    }
    GetBehavior()
    {
        return this._behavior
    }
    _GetIndex()
    {
        return this._index
    }
    PostCreate()
    {
        this._sdkInst ? this._sdkInst.PostCreate() : this._iScriptInterface._postCreate()
    }
    OnSpriteFrameChanged(a, b)
    {
        this._sdkInst && this._sdkInst.OnSpriteFrameChanged(a, b)
    }
    _GetDebuggerProperties()
    {
        return this._sdkInst ? this._sdkInst.GetDebuggerProperties() :
        this._iScriptInterface._getDebuggerProperties()
    }
    SaveToJson(a="full")
    {
        return this._sdkInst ? this._sdkInst.SaveToJson(a) : this._iScriptInterface._saveToJson(a)
    }
    LoadFromJson(a, b="full")
    {
        if (this._sdkInst)
            return this._sdkInst.LoadFromJson(a, b);
        this._iScriptInterface._loadFromJson(a, b)
    }
    static SortByTickSequence(a, b, c)
    {
        var d = globalThis.ISDKBehaviorInstanceBase;
        b = b instanceof d ? a._UnwrapScriptInterface(b) : b.GetBehaviorInstance();
        a = c instanceof d ? a._UnwrapScriptInterface(c) : c.GetBehaviorInstance();
        d = b.GetObjectInstance();
        c = a.GetObjectInstance();
        const e = d.GetObjectClass().GetIndex(),
            f = c.GetObjectClass().GetIndex();
        if (e !== f)
            return e - f;
        d = d.GetPUID();
        c = c.GetPUID();
        return d !== c ? d - c : b._GetIndex() - a._GetIndex()
    }
    _InitScriptInterface(a, b)
    {
        const c = (a = a ?? this._sdkInst.GetScriptInterfaceClass()) || IBehaviorInstance$jscomp$1,
            d = this.GetBehavior().GetSdkVersion();
        C3$jscomp$194.AddonManager._PushInitObject(this, d);
        C3$jscomp$194.AddonManager._PushInitProperties(b);
        this._iScriptInterface = new c;
        C3$jscomp$194.AddonManager._PopInitProperties();
        C3$jscomp$194.AddonManager._PopInitObject(d);
        if (a && !(this._iScriptInterface instanceof IBehaviorInstance$jscomp$1))
            throw new TypeError(`script interface class '${a.name}' does not extend the right base class '${IBehaviorInstance$jscomp$1.name}'`);
        return this._iScriptInterface
    }
    GetScriptInterface()
    {
        return this._iScriptInterface || this._InitScriptInterface()
    }
    HasScriptInterface()
    {
        return !!this._iScriptInterface
    }
}
;
"use strict";
const C3$jscomp$195 = self.C3;
C3$jscomp$195.EffectList = class  extends C3$jscomp$195.DefendedBase{
    constructor(a, b)
    {
        super();
        this._owner = a;
        this._allEffectTypes = [];
        this._activeEffectTypes = [];
        this._effectTypesByName = new Map;
        this._effectParams = [];
        this._effectParamBuffers = [];
        this._allInstanceEffectLists = new Set;
        this._preservesOpaqueness = !0;
        for (const c of b)
            a = C3$jscomp$195.New(C3$jscomp$195.EffectType, this, c, this._allEffectTypes.length),
            this._allEffectTypes.push(a),
            this._effectTypesByName.set(a.GetName().toLowerCase(), a),
            3 <= c.length &&
            this._effectParams.push(this._LoadSingleEffectParameters(a, c[2]));
        this.GetRuntime()._AddEffectList(this)
    }
    Release()
    {
        this.GetRuntime()._RemoveEffectList(this);
        for (const a of this._effectParamBuffers)
            a.Release();
        C3$jscomp$195.clearArray(this._effectParamBuffers);
        C3$jscomp$195.clearArray(this._allEffectTypes);
        C3$jscomp$195.clearArray(this._activeEffectTypes);
        this._effectTypesByName.clear();
        C3$jscomp$195.clearArray(this._effectParams);
        this._owner = null
    }
    _AddInstanceEffectList(a)
    {
        this._allInstanceEffectLists.add(a)
    }
    _RemoveInstanceEffectList(a)
    {
        this._allInstanceEffectLists.delete(a)
    }
    _InitRenderer(a)
    {
        a.IsWebGPU() &&
        (this._effectParamBuffers = this._allEffectTypes.map(b => {
            b = b.GetShaderProgram();
            return 0 < b.GetCustomParametersByteSize() ? C3$jscomp$195.New(C3$jscomp$195.Gfx.WebGPUEffectCustomParamsBuffer, b) : null
        }), this._UpdateAllEffectParamBuffers());
        for (const b of this._allInstanceEffectLists)
            b._InitRenderer(a)
    }
    PrependEffectTypes(a)
    {
        if (a.length) {
            this._allEffectTypes = a.concat(this._allEffectTypes);
            for (const b of a)
                this._effectTypesByName.set(b.GetName().toLowerCase(), b);
            for (let b = 0, c = this._allEffectTypes.length; b <
            c; ++b)
                this._allEffectTypes[b]._SetIndex(b)
        }
    }
    _LoadSingleEffectParameters(a, b)
    {
        a.SetActive(b[0]);
        a = b.slice(1);
        for (let c = 0, d = a.length; c < d; ++c)
            if (b = a[c], Array.isArray(b)) {
                const e = C3$jscomp$195.New(C3$jscomp$195.Color);
                e.setFromJSON(b);
                a[c] = e
            }
        return a
    }
    GetOwner()
    {
        return this._owner
    }
    GetRuntime()
    {
        return this._owner.GetRuntime()
    }
    UpdateActiveEffects()
    {
        C3$jscomp$195.clearArray(this._activeEffectTypes);
        let a = !0;
        for (const b of this._allEffectTypes)
            b.IsActive() && (this._activeEffectTypes.push(b), b.GetShaderProgram().PreservesOpaqueness() ||
            (a = !1));
        this._preservesOpaqueness = a
    }
    GetAllEffectTypes()
    {
        return this._allEffectTypes
    }
    HasAnyEffectType()
    {
        return 0 < this._allEffectTypes.length
    }
    GetEffectTypeByName(a)
    {
        return this._effectTypesByName.get(a.toLowerCase()) || null
    }
    GetEffectTypeByIndex(a)
    {
        a = Math.floor(+a);
        if (0 > a || a >= this._allEffectTypes.length)
            throw new RangeError("invalid effect type index");
        return this._allEffectTypes[a]
    }
    IsEffectIndexActive(a)
    {
        return this.GetEffectTypeByIndex(a).IsActive()
    }
    SetEffectIndexActive(a, b)
    {
        this.GetEffectTypeByIndex(a).SetActive(b)
    }
    GetActiveEffectTypes()
    {
        return this._activeEffectTypes
    }
    HasAnyActiveEffect()
    {
        return 0 <
        this._activeEffectTypes.length
    }
    PreservesOpaqueness()
    {
        return this._preservesOpaqueness
    }
    GetEffectParametersForIndex(a)
    {
        return this._effectParams[a]
    }
    _GetEffectChainShaderParametersForIndex(a)
    {
        return a < this._effectParamBuffers.length ? this._effectParamBuffers[a] : this._effectParams[a]
    }
    GetEffectParameter(a, b)
    {
        if (0 > a || a >= this._effectParams.length)
            return null;
        a = this._effectParams[a];
        return 0 > b || b >= a.length ? null : a[b]
    }
    SetEffectParameter(a, b, c)
    {
        if (0 > a || a >= this._effectParams.length)
            return !1;
        const d = this._effectParams[a];
        if (0 > b || b >= d.length)
            return !1;
        const e = d[b];
        if (e instanceof C3$jscomp$195.Color) {
            if (e.equalsIgnoringAlpha(c))
                return !1;
            e.copyRgb(c)
        } else {
            if (e === c)
                return !1;
            d[b] = c
        }
        a < this._effectParamBuffers.length && this._effectParamBuffers[a].SetParameterValue(b, c);
        return !0
    }
    _UpdateAllEffectParamBuffers()
    {
        const a = this._effectParams,
            b = this._effectParamBuffers;
        for (let c = 0, d = Math.min(a.length, b.length); c < d; ++c) {
            const e = b[c],
                f = a[c];
            for (let g = 0, h = f.length; g < h; ++g)
                e.SetParameterValue(g, f[g])
        }
    }
    static SaveFxParamToJson(a)
    {
        return a &&
        a instanceof C3$jscomp$195.Color ? {
            t: "color",
            v: a.toJSON()
        } : a
    }
    static LoadFxParamFromJson(a)
    {
        if (null === a)
            return NaN;
        if ("object" === typeof a) {
            if ("color" === a.t) {
                const b = C3$jscomp$195.New(C3$jscomp$195.Color);
                b.setFromJSON(a.v);
                return b
            }
            throw Error("invalid effect parameter type");
        }
        return a
    }
    static SaveFxParamsToJson(a)
    {
        return a.map(C3$jscomp$195.EffectList.SaveFxParamToJson)
    }
    static LoadFxParamsFromJson(a)
    {
        return a.map(C3$jscomp$195.EffectList.LoadFxParamFromJson)
    }
    SaveToJson()
    {
        return this._allEffectTypes.map(a =>
        ({
            name: a.GetName(),
            active: a.IsActive(),
            params: C3$jscomp$195.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
        }))
    }
    LoadFromJson(a)
    {
        for (const b of a)
            if (a = this.GetEffectTypeByName(b.name))
                a.SetActive(b.active),
                this._effectParams[a.GetIndex()] = C3$jscomp$195.EffectList.LoadFxParamsFromJson(b.params);
        this.UpdateActiveEffects();
        this._UpdateAllEffectParamBuffers()
    }
}
;
"use strict";
const C3$jscomp$196 = self.C3;
C3$jscomp$196.EffectType = class  extends C3$jscomp$196.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._effectList = a;
        this._id = b[0];
        this._name = b[1];
        this._index = c;
        this._shaderProgram = null;
        this._isActive = !0
    }
    Release()
    {
        this._shaderProgram = this._effectList = null
    }
    Clone(a)
    {
        a = C3$jscomp$196.New(C3$jscomp$196.EffectType, a, [this._id, this._name], -1);
        a._shaderProgram = this._shaderProgram;
        a._isActive = this._isActive;
        return a
    }
    _InitRenderer(a)
    {
        a = a.GetShaderProgramByName(this._id);
        if (!a)
            throw Error("failed to find shader program '" +
            this._id + "'");
        this._shaderProgram = a
    }
    GetEffectList()
    {
        return this._effectList
    }
    GetName()
    {
        return this._name
    }
    _SetIndex(a)
    {
        this._index = a
    }
    GetIndex()
    {
        return this._index
    }
    GetOwner()
    {
        return this._effectList.GetOwner()
    }
    GetRuntime()
    {
        return this._effectList.GetRuntime()
    }
    SetActive(a)
    {
        this._isActive = !!a
    }
    IsActive()
    {
        return this._isActive
    }
    GetShaderProgram()
    {
        return this._shaderProgram
    }
    GetDefaultParameterValues()
    {
        const a = [];
        for (let b = 0, c = this._shaderProgram.GetParameterCount(); b < c; ++b) {
            const d = this._shaderProgram.GetParameterType(b);
            if ("float" === d || "percent" === d)
                a.push(0);
            else if ("color" === d)
                a.push(C3$jscomp$196.New(C3$jscomp$196.Color, 1, 1, 1, 1));
            else
                throw new TypeError("unknown effect parameter type");
        }
        return a
    }
}
;
"use strict";
const C3$jscomp$197 = self.C3;
C3$jscomp$197.InstanceEffectList = class  extends C3$jscomp$197.DefendedBase{
    constructor(a, b)
    {
        super();
        this._inst = a;
        this._wi = b;
        this._effectList = a.GetObjectClass().GetEffectList();
        this._wasDefaultColor = this._needsRebuildSteps = !0;
        this._wasMustPreDraw = this._wasTexRotated = this._wasRotatedOrNegativeSize = this._was3D = !1;
        this._effectChain = C3$jscomp$197.New(C3$jscomp$197.Gfx.EffectChain, a.GetRuntime().GetCanvasManager().GetEffectChainManager(), {
            drawContent: (c, d) => {
                d = d.GetContentObject();
                const e = d.GetWorldInfo();
                c.SetColor(e.GetPremultipliedColor());
                c.SetCurrentZ(e.GetTotalZElevation());
                d.Draw(c);
                c.SetCurrentZ(0)
            },
            getSourceTextureInfo: c => {
                const d = c.GetCurrentTexRect(),
                    [e, f] = c.GetCurrentSurfaceSize();
                return {
                    srcTexRect: d,
                    srcWidth: e,
                    srcHeight: f
                }
            },
            getShaderParameters: c => this._GetEffectChainShaderParametersForIndex(c)
        });
        this._activeEffectFlags = [];
        this._activeEffectTypes = [];
        this._preservesOpaqueness = !0;
        this._effectParams = [];
        this._effectParamBuffers = [];
        this._InitRenderer(a.GetRuntime().GetRenderer());
        for (let c =
            0, d = this._effectList.GetAllEffectTypes().length; c < d; ++c)
            this._activeEffectFlags.push(!0);
        this.UpdateActiveEffects();
        this._effectList._AddInstanceEffectList(this)
    }
    Release()
    {
        this._effectList._RemoveInstanceEffectList(this);
        for (const a of this._effectParamBuffers)
            a && a.Release();
        C3$jscomp$197.clearArray(this._effectParamBuffers);
        this._effectChain.Release();
        this._effectChain = null;
        C3$jscomp$197.clearArray(this._activeEffectFlags);
        C3$jscomp$197.clearArray(this._activeEffectTypes);
        C3$jscomp$197.clearArray(this._effectParams);
        this._effectList = this._inst = null
    }
    _InitRenderer(a)
    {
        a.IsWebGPU() && (this._effectParamBuffers = this._effectList.GetAllEffectTypes().map(b => {
            b = b.GetShaderProgram();
            return 0 < b.GetCustomParametersByteSize() ? C3$jscomp$197.New(C3$jscomp$197.Gfx.WebGPUEffectCustomParamsBuffer, b) : null
        }))
    }
    _LoadEffectParameters(a)
    {
        let b = 0;
        for (const c of a)
            this._effectParams.push(this._LoadSingleEffectParameters(b, c)),
            ++b;
        this._UpdateAllEffectParamBuffers();
        this.UpdateActiveEffects()
    }
    _LoadSingleEffectParameters(a, b)
    {
        this._activeEffectFlags[a] =
        b[0];
        a = b.slice(1);
        for (let c = 0, d = a.length; c < d; ++c)
            if (b = a[c], Array.isArray(b)) {
                const e = C3$jscomp$197.New(C3$jscomp$197.Color);
                e.setFromJSON(b);
                a[c] = e
            }
        return a
    }
    LoadDefaultEffectParameters()
    {
        for (const a of this._effectList.GetAllEffectTypes())
            this._effectParams.push(a.GetDefaultParameterValues());
        this._UpdateAllEffectParamBuffers()
    }
    GetOwner()
    {
        return this._owner
    }
    GetEffectList()
    {
        return this._effectList
    }
    GetEffectChain()
    {
        this._MaybeRebuildEffectChainSteps();
        return this._effectChain
    }
    GetRuntime()
    {
        return this._inst.GetRuntime()
    }
    UpdateActiveEffects()
    {
        C3$jscomp$197.clearArray(this._activeEffectTypes);
        const a = this._wi,
            b = this._effectList.GetAllEffectTypes(),
            c = this._activeEffectTypes,
            d = this._activeEffectFlags;
        let e = !0;
        for (let f = 0, g = b.length; f < g; ++f)
            if (d[f]) {
                const h = b[f];
                c.push(h);
                h.GetShaderProgram().PreservesOpaqueness() || (e = !1)
            }
        this._preservesOpaqueness = e;
        a._SetHasAnyActiveEffect(!!c.length);
        this._needsRebuildSteps = !0
    }
    _MaybeRebuildEffectChainSteps()
    {
        var a = this._inst,
            b = this._wi;
        const c = b.HasDefaultColor(),
            d = a.GetPlugin().Is3D();
        b = 0 !== b.GetAngle() || 0 !== b.GetLayer().GetAngle() || 0 > b.GetWidth() || 0 >
        b.GetHeight();
        const e = a.IsCurrentTexRotated();
        a = a.MustPreDraw();
        if (this._needsRebuildSteps || c !== this._wasDefaultColor || d !== this._was3D || b !== this._wasRotatedOrNegativeSize || e !== this._wasTexRotated || a !== this._wasMustPreDraw || this._effectChain.NeedsRebuild())
            this._effectChain.BuildSteps(this._activeEffectTypes.map(f => f.GetShaderProgram()), {
                indexMap: this._activeEffectTypes.map(f => f.GetIndex()),
                forcePreDraw: !c || a,
                is3D: d,
                isSourceTextureRotated: e,
                isRotatedOrNegativeSizeInstance: b
            }),
            this._needsRebuildSteps =
            !1,
            this._wasDefaultColor = c,
            this._was3D = d,
            this._wasRotatedOrNegativeSize = b,
            this._wasTexRotated = e,
            this._wasMustPreDraw = a
    }
    GetActiveEffectTypes()
    {
        return this._activeEffectTypes
    }
    GetEffectParametersForIndex(a)
    {
        return this._effectParams[a]
    }
    _GetEffectChainShaderParametersForIndex(a)
    {
        return a < this._effectParamBuffers.length ? this._effectParamBuffers[a] : this._effectParams[a]
    }
    GetEffectParameter(a, b)
    {
        if (0 > a || a >= this._effectParams.length)
            return null;
        a = this._effectParams[a];
        return 0 > b || b >= a.length ? null : a[b]
    }
    SetEffectParameter(a,
    b, c)
    {
        if (0 > a || a >= this._effectParams.length)
            return !1;
        const d = this._effectParams[a];
        if (0 > b || b >= d.length)
            return !1;
        const e = d[b];
        if (e instanceof C3$jscomp$197.Color) {
            if (e.equalsIgnoringAlpha(c))
                return !1;
            e.copyRgb(c)
        } else {
            if (e === c)
                return !1;
            d[b] = c
        }
        a < this._effectParamBuffers.length && this._effectParamBuffers[a].SetParameterValue(b, c);
        return !0
    }
    _UpdateAllEffectParamBuffers()
    {
        const a = this._effectParams,
            b = this._effectParamBuffers;
        for (let c = 0, d = b.length; c < d; ++c) {
            const e = b[c],
                f = a[c];
            for (let g = 0, h = f.length; g < h; ++g)
                e.SetParameterValue(g,
                f[g])
        }
    }
    PreservesOpaqueness()
    {
        return this._preservesOpaqueness
    }
    HasAnyActiveBackgroundBlendingEffect()
    {
        return this._activeEffectTypes.some(a => a.GetShaderProgram().BlendsBackground())
    }
    IsEffectIndexActive(a)
    {
        return this._activeEffectFlags[a]
    }
    SetEffectIndexActive(a, b)
    {
        this._activeEffectFlags[a] = !!b
    }
    GetAllEffectTypes()
    {
        return this._effectList.GetAllEffectTypes()
    }
    _SaveToJson()
    {
        return this._effectList.GetAllEffectTypes().map(a => ({
            name: a.GetName(),
            active: this._activeEffectFlags[a.GetIndex()],
            params: C3$jscomp$197.EffectList.SaveFxParamsToJson(this._effectParams[a.GetIndex()])
        }))
    }
    _LoadFromJson(a)
    {
        for (const b of a)
            if (a =
            this._effectList.GetEffectTypeByName(b.name))
                this._activeEffectFlags[a.GetIndex()] = b.active,
                this._effectParams[a.GetIndex()] = C3$jscomp$197.EffectList.LoadFxParamsFromJson(b.params);
        this.UpdateActiveEffects();
        this._UpdateAllEffectParamBuffers()
    }
}
;
"use strict";
const C3$jscomp$198 = self.C3,
    tempCandidates = [],
    tileCollRectCandidates = [],
    tempJumpthruRet = [],
    tempPolyA = C3$jscomp$198.New(C3$jscomp$198.CollisionPoly),
    tempPolyB = C3$jscomp$198.New(C3$jscomp$198.CollisionPoly),
    tempQuad$jscomp$4 = C3$jscomp$198.New(C3$jscomp$198.Quad),
    tempRect$jscomp$8 = C3$jscomp$198.New(C3$jscomp$198.Rect),
    tempRect2$jscomp$1 = C3$jscomp$198.New(C3$jscomp$198.Rect);
let tempPolyC = null,
    tempRect3$jscomp$1 = null,
    tempQuadB = null;
C3$jscomp$198.CollisionEngine = class  extends C3$jscomp$198.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a;
        this._collisionCellHeight = this._collisionCellWidth = 0;
        this._registeredCollisions = [];
        this._polyCheckSec = this._polyCheckCount = this._collisionCheckSec = this._collisionCheckCount = 0;
        this._iCollisionEngine = new self.ICollisionEngine(this)
    }
    Release()
    {
        this._runtime = null
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetICollisionEngine()
    {
        return this._iCollisionEngine
    }
    _Update1sStats()
    {
        this._collisionCheckSec = this._collisionCheckCount;
        this._collisionCheckCount = 0;
        this._polyCheckSec = this._polyCheckCount;
        this._polyCheckCount = 0
    }
    Get1secCollisionChecks()
    {
        return this._collisionCheckSec
    }
    Get1secPolyChecks()
    {
        return this._polyCheckSec
    }
    RegisterCollision(a, b)
    {
        const c = a.GetWorldInfo(),
            d = b.GetWorldInfo();
        c && d && c.IsCollisionEnabled() && d.IsCollisionEnabled() && this._registeredCollisions.push([a, b])
    }
    AddRegisteredCollisionCandidates(a, b, c)
    {
        for (const [d, e] of this._registeredCollisions) {
            let f;
            if (a === d)
                f = e;
            else if (a === e)
                f = d;
            else
                continue;
            f.BelongsToObjectClass(b) &&
            (c.includes(f) || c.push(f))
        }
    }
    CheckRegisteredCollision(a, b)
    {
        if (!this._registeredCollisions.length)
            return !1;
        for (const [c, d] of this._registeredCollisions)
            if (a === c && b === d || a === d && b === c)
                return !0;
        return !1
    }
    ClearRegisteredCollisions()
    {
        C3$jscomp$198.clearArray(this._registeredCollisions)
    }
    TestOverlap(a, b)
    {
        if (!a || !b || a === b)
            return !1;
        a = a.GetWorldInfo();
        b = b.GetWorldInfo();
        if (!a.IsCollisionEnabled() || !b.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        const c = a.GetLayer(),
            d = b.GetLayer();
        return c.IsTransformCompatibleWith(d) ?
        this._TestOverlap_SameLayers(a, b) : this._TestOverlap_DifferentLayers(a, b)
    }
    _TestOverlap_SameLayers(a, b)
    {
        if (!a.GetBoundingBox().intersectsRect(b.GetBoundingBox()))
            return !1;
        this._polyCheckCount++;
        if (!a.GetBoundingQuad().intersectsQuad(b.GetBoundingQuad()) || a.HasTilemap() && b.HasTilemap())
            return !1;
        if (a.HasTilemap())
            return this.TestTilemapOverlap(a, b);
        if (b.HasTilemap())
            return this.TestTilemapOverlap(b, a);
        if (!a.HasOwnCollisionPoly() && !b.HasOwnCollisionPoly())
            return !0;
        const c = a.GetTransformedCollisionPoly(),
            d = b.GetTransformedCollisionPoly();
        return c.intersectsPoly(d, b.GetX() - a.GetX(), b.GetY() - a.GetY())
    }
    _TestOverlap_DifferentLayers(a, b)
    {
        var c = a.HasTilemap(),
            d = b.HasTilemap();
        if (c && !d)
            return this.TestTilemapOverlapDifferentLayers(a, b);
        if (d && !c)
            return this.TestTilemapOverlapDifferentLayers(b, a);
        if (d || c)
            return !1;
        d = a.GetLayer();
        c = b.GetLayer();
        tempPolyA.copy(a.GetTransformedCollisionPoly());
        tempPolyB.copy(b.GetTransformedCollisionPoly());
        var e = tempPolyA.pointsArr();
        for (let f = 0, g = e.length; f < g; f += 2) {
            const h =
                f + 1,
                k = e[h],
                [l, m] = d.LayerToCanvasCss(e[f] + a.GetX(), k + a.GetY());
            e[f] = l;
            e[h] = m
        }
        a = tempPolyB.pointsArr();
        for (let f = 0, g = a.length; f < g; f += 2) {
            d = f + 1;
            e = a[d];
            const [h, k] = c.LayerToCanvasCss(a[f] + b.GetX(), e + b.GetY());
            a[f] = h;
            a[d] = k
        }
        tempPolyA.setBboxChanged();
        tempPolyB.setBboxChanged();
        this._polyCheckCount++;
        return tempPolyA.intersectsPoly(tempPolyB, 0, 0)
    }
    TestTilemapOverlapDifferentLayers(a, b)
    {
        var c = a.GetLayer(),
            d = b.GetLayer();
        tempPolyC || (tempPolyC = C3$jscomp$198.New(C3$jscomp$198.CollisionPoly));
        tempRect3$jscomp$1 ||
        (tempRect3$jscomp$1 = C3$jscomp$198.New(C3$jscomp$198.Rect));
        tempQuadB || (tempQuadB = C3$jscomp$198.New(C3$jscomp$198.Quad));
        var e = b.GetX(),
            f = b.GetY();
        const [g, h] = d.LayerToCanvasCss(e, f),
            [k, l] = c.CanvasCssToLayer(g, h);
        c = k - e;
        f = l - f;
        tempRect3$jscomp$1.copy(b.GetBoundingBox());
        tempRect3$jscomp$1.offset(c, f);
        if (!a.GetBoundingBox().intersectsRect(tempRect3$jscomp$1))
            return !1;
        tempQuadB.copy(b.GetBoundingQuad());
        tempQuadB.offset(c, f);
        this._polyCheckCount++;
        if (!a.GetBoundingQuad().intersectsQuad(tempQuadB))
            return !1;
        tempPolyC.copy(b.GetTransformedCollisionPoly());
        d = tempPolyC.pointsArr();
        for (let m = 0, n = d.length; m < n; m += 2)
            e = m + 1,
            d[m] += c,
            d[e] += f;
        tempPolyC.setBboxChanged();
        return this.TestTilemapOverlap(a, b, k, l, tempPolyC, tempRect3$jscomp$1, tempQuadB)
    }
    TestTilemapOverlap(a, b, c, d, e, f, g)
    {
        f = void 0 !== f ? f : b.GetBoundingBox();
        const h = a.GetX(),
            k = a.GetY();
        var l = a.GetInstance().GetSdkInstance();
        c = void 0 !== c ? c : b.GetX();
        d = void 0 !== d ? d : b.GetY();
        a = b.HasOwnCollisionPoly();
        g = void 0 !== g ? g : b.GetBoundingQuad();
        l.GetCollisionRectCandidates(f,
        tileCollRectCandidates);
        for (let p = 0, q = tileCollRectCandidates.length; p < q; ++p) {
            var m = tileCollRectCandidates[p];
            l = m.GetRect();
            this._collisionCheckCount++;
            if (f.intersectsRectOffset(l, h, k) && (tempQuad$jscomp$4.setFromRect(l), tempQuad$jscomp$4.offset(h, k), tempQuad$jscomp$4.intersectsQuad(g)))
                if (a) {
                    var n = void 0 !== e ? e : b.GetTransformedCollisionPoly();
                    let r = c,
                        t = d;
                    void 0 !== e && (r = b.GetX(), t = b.GetY());
                    if (m = m.GetPoly()) {
                        if (this._polyCheckCount++, m.intersectsPoly(n, r - (h + l.getLeft()), t - (k + l.getTop())))
                            return C3$jscomp$198.clearArray(tileCollRectCandidates),
                            !0
                    } else if (tempPolyA.setFromQuad(tempQuad$jscomp$4, 0, 0), tempPolyA.intersectsPoly(n, r, t))
                        return C3$jscomp$198.clearArray(tileCollRectCandidates), !0
                } else if (n = m.GetPoly()) {
                    if (tempPolyA.setFromQuad(g, 0, 0), n.intersectsPoly(tempPolyA, -(h + l.getLeft()), -(k + l.getTop())))
                        return C3$jscomp$198.clearArray(tileCollRectCandidates), !0
                } else
                    return C3$jscomp$198.clearArray(tileCollRectCandidates), !0
        }
        C3$jscomp$198.clearArray(tileCollRectCandidates);
        return !1
    }
    TestAndSelectCanvasPointOverlap(a, b, c)
    {
        const d = a.GetCurrentSol();
        var e = this._runtime.GetCurrentEvent();
        if (!e)
            throw Error("cannot call outside event");
        const f = e.IsOrBlock(),
            g = new Map,
            h = l => {
                let m = g.get(l);
                "undefined" === typeof m && (m = l.IsSelfAndParentsInteractive(), g.set(l, m));
                return m
            };
        if (d.IsSelectAll()) {
            c || (d._SetSelectAll(!1), C3$jscomp$198.clearArray(d._GetOwnInstances()));
            f && C3$jscomp$198.clearArray(d._GetOwnElseInstances());
            for (var k of a.GetInstances()) {
                const l = k.GetWorldInfo(),
                    m = l.GetLayer();
                e = !1;
                h(m) && l.IsInViewport2() && (e = b.some(([n, p]) => {
                    const [q, r] = m.CanvasCssToLayer(n,
                    p, l.GetTotalZElevation());
                    return l.ContainsPoint(q, r)
                }));
                if (e) {
                    if (c)
                        return !1;
                    d._PushInstance(k)
                } else
                    f && d._PushElseInstance(k)
            }
        } else {
            k = !1;
            f && !e.IsFirstConditionOfType(this._runtime.GetCurrentCondition()) ? this._runtime.IsCurrentConditionFirst() && !d._GetOwnElseInstances().length && d._GetOwnInstances().length ? e = d._GetOwnInstances() : (e = d._GetOwnElseInstances(), k = !0) : e = d._GetOwnInstances();
            let l = 0;
            for (let m = 0, n = e.length; m < n; ++m) {
                const p = e[m],
                    q = p.GetWorldInfo(),
                    r = q.GetLayer();
                let t = !1;
                h(r) && q.IsInViewport2() &&
                (t = b.some(([u, v]) => {
                    const [w, x] = r.CanvasCssToLayer(u, v, q.GetTotalZElevation());
                    return q.ContainsPoint(w, x)
                }));
                if (t) {
                    if (c)
                        return !1;
                    k ? d._PushInstance(p) : e[l++] = p
                } else
                    k ? e[l++] = p : f && d._PushElseInstance(p)
            }
            c || (e.length = l)
        }
        a.ApplySolToContainer();
        g.clear();
        return c ? !0 : d.HasAnyInstances()
    }
    _ObjectClassCanUseCollisionCells(a, b)
    {
        if (!a)
            return !0;
        for (const c of b.layersHasInstancesOn())
            if (!a.IsTransformCompatibleWith(c))
                return !1;
        return !0
    }
    GetCollisionCandidates(a, b, c, d)
    {
        if (b.IsFamily())
            for (const e of b.GetFamilyMembers())
                this._ObjectClassCanUseCollisionCells(a,
                e) ? (e._UpdateAllCollisionCells(), e._GetCollisionCellGrid().QueryRange(c, d)) : C3$jscomp$198.appendArray(d, e.GetInstances());
        else
            this._ObjectClassCanUseCollisionCells(a, b) ? (b._UpdateAllCollisionCells(), b._GetCollisionCellGrid().QueryRange(c, d)) : C3$jscomp$198.appendArray(d, b.GetInstances())
    }
    GetObjectClassesCollisionCandidates(a, b, c, d)
    {
        for (const e of b)
            this.GetCollisionCandidates(a, e, c, d)
    }
    GetSolidCollisionCandidates(a, b, c)
    {
        const d = this._runtime.GetSolidBehavior();
        d && this.GetObjectClassesCollisionCandidates(a,
        d.GetObjectClasses(), b, c)
    }
    GetJumpthruCollisionCandidates(a, b, c)
    {
        const d = this._runtime.GetJumpthruBehavior();
        d && this.GetObjectClassesCollisionCandidates(a, d.GetObjectClasses(), b, c)
    }
    IsSolidCollisionAllowed(a, b)
    {
        return a._IsSolidEnabled() && (!b || b.GetWorldInfo().IsSolidCollisionAllowed(a.GetSavedDataMap().get("solidTags")))
    }
    TestOverlapSolid(a)
    {
        const b = a.GetWorldInfo();
        this.GetSolidCollisionCandidates(b.GetLayer(), b.GetBoundingBox(), tempCandidates);
        for (const c of tempCandidates)
            if (this.IsSolidCollisionAllowed(c,
            a) && this.TestOverlap(a, c))
                return C3$jscomp$198.clearArray(tempCandidates), c;
        C3$jscomp$198.clearArray(tempCandidates);
        return null
    }
    TestRectOverlapSolid(a, b)
    {
        this.GetSolidCollisionCandidates(null, a, tempCandidates);
        for (const c of tempCandidates)
            if (this.IsSolidCollisionAllowed(c, b) && this.TestRectOverlap(a, c))
                return C3$jscomp$198.clearArray(tempCandidates), c;
        C3$jscomp$198.clearArray(tempCandidates);
        return null
    }
    TestOverlapJumpthru(a, b)
    {
        let c = null;
        b && (c = tempJumpthruRet, C3$jscomp$198.clearArray(c));
        const d =
        a.GetWorldInfo();
        this.GetJumpthruCollisionCandidates(d.GetLayer(), d.GetBoundingBox(), tempCandidates);
        for (const e of tempCandidates)
            if (e._IsJumpthruEnabled() && this.TestOverlap(a, e))
                if (b)
                    c.push(e);
                else
                    return C3$jscomp$198.clearArray(tempCandidates), e;
        C3$jscomp$198.clearArray(tempCandidates);
        return c
    }
    PushOut(a, b, c, d, e)
    {
        d = d || 50;
        const f = a.GetWorldInfo(),
            g = f.GetX(),
            h = f.GetY();
        for (let k = 0; k < d; ++k)
            if (f.SetXY(g + b * k, h + c * k), f.SetBboxChanged(), !this.TestOverlap(a, e))
                return !0;
        f.SetXY(g, h);
        f.SetBboxChanged();
        return !1
    }
    PushOutSolid(a, b, c, d, e, f)
    {
        d = d || 50;
        const g = a.GetWorldInfo(),
            h = g.GetX(),
            k = g.GetY();
        let l = null,
            m = null;
        for (let n = 0; n < d; ++n)
            if (g.SetXY(h + b * n, k + c * n), g.SetBboxChanged(), !this.TestOverlap(a, l))
                if (l = this.TestOverlapSolid(a))
                    m = l;
                else if (e && (l = f ? this.TestOverlap(a, f) ? f : null : this.TestOverlapJumpthru(a)) && (m = l), !l)
                    return m && this.PushInFractional(a, b, c, m, 16, !0), !0;
        g.SetXY(h, k);
        g.SetBboxChanged();
        return !1
    }
    PushOutSolidAxis(a, b, c, d)
    {
        d = d || 50;
        const e = a.GetWorldInfo(),
            f = e.GetX(),
            g = e.GetY();
        let h = null,
            k = null;
        for (let l = 0; l < d; ++l)
            for (let m = 0; 2 > m; ++m) {
                const n = 2 * m - 1;
                e.SetXY(f + b * l * n, g + c * l * n);
                e.SetBboxChanged();
                if (!this.TestOverlap(a, h))
                    if (h = this.TestOverlapSolid(a))
                        k = h;
                    else
                        return k && this.PushInFractional(a, b * n, c * n, k, 16, !0), !0
            }
        e.SetXY(f, g);
        e.SetBboxChanged();
        return !1
    }
    PushInFractional(a, b, c, d, e, f)
    {
        let g = 2,
            h = !1;
        var k = !1;
        const l = a.GetWorldInfo();
        let m = l.GetX(),
            n = l.GetY();
        for (; g <= e;)
            k = 1 / g,
            g *= 2,
            l.OffsetXY(b * k * (h ? 1 : -1), c * k * (h ? 1 : -1)),
            l.SetBboxChanged(),
            this.TestOverlap(a, d) || f && this.TestOverlapSolid(a) ? k = h = !0 : (k =
            h = !1, m = l.GetX(), n = l.GetY());
        k && (l.SetXY(m, n), l.SetBboxChanged())
    }
    PushOutSolidNearest(a, b=100)
    {
        let c = 0;
        const d = a.GetWorldInfo(),
            e = d.GetX(),
            f = d.GetY();
        let g = 0,
            h = this.TestOverlapSolid(a);
        if (!h)
            return !0;
        for (; c <= b;) {
            let k = 0,
                l = 0;
            switch (g) {
            case 0:
                k = 0;
                l = -1;
                c++;
                break;
            case 1:
                k = 1;
                l = -1;
                break;
            case 2:
                k = 1;
                l = 0;
                break;
            case 3:
                l = k = 1;
                break;
            case 4:
                k = 0;
                l = 1;
                break;
            case 5:
                k = -1;
                l = 1;
                break;
            case 6:
                k = -1;
                l = 0;
                break;
            case 7:
                l = k = -1
            }
            g = (g + 1) % 8;
            d.SetXY(Math.floor(e + k * c), Math.floor(f + l * c));
            d.SetBboxChanged();
            if (!this.TestOverlap(a, h) &&
            (h = this.TestOverlapSolid(a), !h))
                return !0
        }
        d.SetXY(e, f);
        d.SetBboxChanged();
        return !1
    }
    CalculateBounceAngle(a, b, c, d)
    {
        const e = a.GetWorldInfo(),
            f = e.GetX(),
            g = e.GetY(),
            h = Math.max(10, C3$jscomp$198.distanceTo(b, c, f, g));
        var k = C3$jscomp$198.angleTo(b, c, f, g),
            l = d || this.TestOverlapSolid(a);
        if (!l)
            return C3$jscomp$198.clampAngle(k + Math.PI);
        let m = l;
        var n = 0,
            p = 0;
        const q = C3$jscomp$198.toRadians(5);
        let r;
        for (r = 1; 36 > r; ++r) {
            const t = k - r * q;
            e.SetXY(b + Math.cos(t) * h, c + Math.sin(t) * h);
            e.SetBboxChanged();
            if (!this.TestOverlap(a, m) &&
            (m = d ? null : this.TestOverlapSolid(a), !m)) {
                n = t;
                break
            }
        }
        36 === r && (n = C3$jscomp$198.clampAngle(k + Math.PI));
        m = l;
        for (r = 1; 36 > r; ++r)
            if (l = k + r * q, e.SetXY(b + Math.cos(l) * h, c + Math.sin(l) * h), e.SetBboxChanged(), !this.TestOverlap(a, m) && (m = d ? null : this.TestOverlapSolid(a), !m)) {
                p = l;
                break
            }
        36 === r && (p = C3$jscomp$198.clampAngle(k + Math.PI));
        e.SetXY(f, g);
        e.SetBboxChanged();
        if (p === n)
            return p;
        a = C3$jscomp$198.angleDiff(p, n) / 2;
        a = C3$jscomp$198.angleClockwise(p, n) ? C3$jscomp$198.clampAngle(n + a + Math.PI) : C3$jscomp$198.clampAngle(p + a);
        n =
        Math.cos(k);
        k = Math.sin(k);
        p = Math.cos(a);
        a = Math.sin(a);
        b = n * p + k * a;
        return C3$jscomp$198.angleTo(0, 0, n - 2 * b * p, k - 2 * b * a)
    }
    TestSegmentOverlap(a, b, c, d, e)
    {
        if (!e)
            return !1;
        const f = e.GetWorldInfo();
        if (!f.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        tempRect$jscomp$8.set(Math.min(a, c), Math.min(b, d), Math.max(a, c), Math.max(b, d));
        if (!f.GetBoundingBox().intersectsRect(tempRect$jscomp$8))
            return !1;
        if (e.HasTilemap())
            return this._TestSegmentOverlapTilemap(a, b, c, d, e, f);
        this._polyCheckCount++;
        return f.GetBoundingQuad().intersectsSegment(a,
        b, c, d) ? f.HasOwnCollisionPoly() ? f.GetTransformedCollisionPoly().intersectsSegment(f.GetX(), f.GetY(), a, b, c, d) : !0 : !1
    }
    _TestSegmentOverlapTilemap(a, b, c, d, e, f)
    {
        const g = f.GetX();
        f = f.GetY();
        e = e.GetSdkInstance();
        tempRect2$jscomp$1.set(a, b, c, d);
        tempRect2$jscomp$1.normalize();
        e.GetCollisionRectCandidates(tempRect2$jscomp$1, tileCollRectCandidates);
        for (let k = 0, l = tileCollRectCandidates.length; k < l; ++k) {
            var h = tileCollRectCandidates[k];
            e = h.GetRect();
            this._collisionCheckCount++;
            if (tempRect$jscomp$8.intersectsRectOffset(e,
            g, f) && (tempQuad$jscomp$4.setFromRect(e), tempQuad$jscomp$4.offset(g, f), tempQuad$jscomp$4.intersectsSegment(a, b, c, d)))
                if (h = h.GetPoly()) {
                    if (this._polyCheckCount++, h.intersectsSegment(g + e.getLeft(), f + e.getTop(), a, b, c, d))
                        return C3$jscomp$198.clearArray(tileCollRectCandidates), !0
                } else
                    return C3$jscomp$198.clearArray(tileCollRectCandidates), !0
        }
        C3$jscomp$198.clearArray(tileCollRectCandidates);
        return !1
    }
    TestRectOverlap(a, b)
    {
        if (!b)
            return !1;
        const c = b.GetWorldInfo();
        if (!c.IsCollisionEnabled())
            return !1;
        this._collisionCheckCount++;
        if (!c.GetBoundingBox().intersectsRect(a))
            return !1;
        if (b.HasTilemap())
            return this._TestRectOverlapTilemap(a, b, c);
        this._polyCheckCount++;
        tempQuad$jscomp$4.setFromRect(a);
        if (!c.GetBoundingQuad().intersectsQuad(tempQuad$jscomp$4))
            return !1;
        if (!c.HasOwnCollisionPoly())
            return !0;
        tempPolyA.setFromRect(a, c.GetX(), c.GetY());
        a = c.GetTransformedCollisionPoly();
        return tempPolyA.intersectsPoly(a, 0, 0)
    }
    _TestRectOverlapTilemap(a, b, c)
    {
        const d = c.GetX();
        c = c.GetY();
        b.GetSdkInstance().GetCollisionRectCandidates(a, tileCollRectCandidates);
        for (let f = 0, g = tileCollRectCandidates.length; f < g; ++f) {
            var e = tileCollRectCandidates[f];
            b = e.GetRect();
            this._collisionCheckCount++;
            if (a.intersectsRectOffset(b, d, c))
                if (e = e.GetPoly()) {
                    if (this._polyCheckCount++, tempPolyA.setFromRect(a, 0, 0), e.intersectsPoly(tempPolyA, -(d + b.getLeft()), -(c + b.getTop())))
                        return C3$jscomp$198.clearArray(tileCollRectCandidates), !0
                } else
                    return C3$jscomp$198.clearArray(tileCollRectCandidates), !0
        }
        C3$jscomp$198.clearArray(tileCollRectCandidates);
        return !1
    }
    TestRayIntersectsInstance(a,
    b)
    {
        if (a) {
            var c = a.GetWorldInfo();
            c.IsCollisionEnabled() && (this._collisionCheckCount++, c.GetBoundingBox().intersectsRect(b.rect) && (a.HasTilemap() ? this._TestRayIntersectsTilemap(a, c, b) : (this._polyCheckCount++, c.HasOwnCollisionPoly() ? b.TestInstancePoly(a, c.GetX(), c.GetY(), c.GetTransformedCollisionPoly()) : b.TestInstanceQuad(a, c.GetBoundingQuad()))))
        }
    }
    _TestRayIntersectsTilemap(a, b, c)
    {
        const d = b.GetX(),
            e = b.GetY();
        a.GetSdkInstance().GetCollisionRectCandidates(c.rect, tileCollRectCandidates);
        for (let g = 0, h = tileCollRectCandidates.length; g <
        h; g++) {
            var f = tileCollRectCandidates[g];
            const k = f.GetRect();
            this._collisionCheckCount++;
            c.rect.intersectsRectOffset(k, d, e) && (f = f.GetPoly(), this._polyCheckCount++, f ? c.TestInstancePoly(a, d + k.getLeft(), e + k.getTop(), f) : c.TestInstanceRect(a, b.GetX(), b.GetY(), k))
        }
        C3$jscomp$198.clearArray(tileCollRectCandidates)
    }
    SetCollisionCellSize(a, b)
    {
        if (a !== this._collisionCellWidth || b !== this._collisionCellHeight) {
            this._collisionCellWidth = a;
            this._collisionCellHeight = b;
            var c = this._runtime.GetAllObjectClasses();
            for (const d of c)
                if (d.IsWorldType()) {
                    for (const e of d.instancesIncludingPendingCreate())
                        e.GetWorldInfo()._RemoveFromCollisionCells();
                    d._GetCollisionCellGrid().SetCellSize(a, b);
                    d._SetAnyCollisionCellChanged();
                    for (const e of d.instancesIncludingPendingCreate())
                        c = e.GetWorldInfo(),
                        c._SetCollisionCellChanged(),
                        c._UpdateCollisionCell()
                }
        }
    }
    GetCollisionCellSize()
    {
        return [this._collisionCellWidth, this._collisionCellHeight]
    }
    _InitCollisionCellSize(a, b)
    {
        this._collisionCellWidth = a;
        this._collisionCellHeight = b
    }
}
;
"use strict";
const C3$jscomp$199 = self.C3;
C3$jscomp$199.SparseGrid = class  extends C3$jscomp$199.DefendedBase{
    constructor(a, b)
    {
        super();
        this._cellWidth = a;
        this._cellHeight = b;
        this._cells = C3$jscomp$199.New(C3$jscomp$199.PairMap)
    }
    Release()
    {
        this._cells.Release();
        this._cells = null
    }
    SetCellSize(a, b)
    {
        if (!this._cells.IsEmpty())
            throw Error("grid not empty");
        this._cellWidth = a;
        this._cellHeight = b
    }
    GetCell(a, b, c)
    {
        let d = this._cells.Get(a, b);
        return d ? d : c ? (d = C3$jscomp$199.New(C3$jscomp$199.GridCell, this, a, b), this._cells.Set(a, b, d), d) : null
    }
    XToCell(a)
    {
        a = Math.floor(a /
        this._cellWidth);
        return isFinite(a) ? a : 0
    }
    YToCell(a)
    {
        a = Math.floor(a / this._cellHeight);
        return isFinite(a) ? a : 0
    }
    Update(a, b, c)
    {
        if (b)
            for (let d = b.getLeft(), e = b.getRight(); d <= e; ++d)
                for (let f = b.getTop(), g = b.getBottom(); f <= g; ++f) {
                    if (c && c.containsPoint(d, f))
                        continue;
                    const h = this.GetCell(d, f, !1);
                    h && (h.Remove(a), h.IsEmpty() && this._cells.Delete(d, f))
                }
        if (c)
            for (let d = c.getLeft(), e = c.getRight(); d <= e; ++d)
                for (let f = c.getTop(), g = c.getBottom(); f <= g; ++f)
                    b && b.containsPoint(d, f) || this.GetCell(d, f, !0).Insert(a)
    }
    QueryRange(a,
    b)
    {
        let c = this.XToCell(a.getLeft());
        const d = this.YToCell(a.getTop()),
            e = this.XToCell(a.getRight());
        a = this.YToCell(a.getBottom());
        if (isFinite(e) && isFinite(a))
            for (; c <= e; ++c)
                for (let f = d; f <= a; ++f) {
                    const g = this.GetCell(c, f, !1);
                    g && g.Dump(b)
                }
    }
}
;
"use strict";
const C3$jscomp$200 = self.C3;
C3$jscomp$200.GridCell = class  extends C3$jscomp$200.DefendedBase{
    constructor(a, b, c)
    {
        super();
        this._grid = a;
        this._x = b;
        this._y = c;
        this._instances = C3$jscomp$200.New(C3$jscomp$200.ArraySet)
    }
    Release()
    {
        this._instances.Release();
        this._grid = this._instances = null
    }
    IsEmpty()
    {
        return this._instances.IsEmpty()
    }
    Insert(a)
    {
        this._instances.Add(a)
    }
    Remove(a)
    {
        this._instances.Delete(a)
    }
    Dump(a)
    {
        C3$jscomp$200.appendArray(a, this._instances.GetArray())
    }
}
;
"use strict";
const C3$jscomp$201 = self.C3;
C3$jscomp$201.Ray = class {
    constructor()
    {
        this.dy = this.dx = this.y2 = this.x2 = this.y1 = this.x1 = 0;
        this.rect = new C3$jscomp$201.Rect;
        this.hitFraction = 2;
        this.hitUid = null;
        this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
        this.normalX = 1;
        this.normalY = 0;
        this.reflectionX = 1;
        this.reflectionY = 0
    }
    DidCollide()
    {
        return 1.000001 > this.hitFraction
    }
    Reset()
    {
        this.hitFraction = 2
    }
    Set(a, b, c, d)
    {
        this.x1 = a;
        this.y1 = b;
        this.x2 = c;
        this.y2 = d;
        this.dx = c - a;
        this.dy = d - b;
        this.rect.set(a, b, c, d);
        this.rect.normalize();
        this.hitFraction = 2;
        this.hitUid = null;
        this.distance = this.hitY = this.hitX = this.hitNormalDy = this.hitNormalDx = this.hitNormal = 0;
        this.normalX = 1;
        this.normalY = 0;
        this.reflectionX = 1;
        this.reflectionY = 0;
        return this
    }
    Complete()
    {
        if (!1 !== this.DidCollide()) {
            var a = this.dx * this.hitFraction,
                b = this.dy * this.hitFraction,
                c = Math.hypot(a, b);
            a /= c;
            b /= c;
            this.distance = c - 1E-6;
            this.hitX = this.x1 + a * this.distance;
            this.hitY = this.y1 + b * this.distance;
            this.hitNormal = Math.atan2(this.hitNormalDy, this.hitNormalDx) + Math.PI / 2;
            this.normalX = Math.cos(this.hitNormal);
            this.normalY = Math.sin(this.hitNormal);
            c = a * this.normalX + b * this.normalY;
            this.reflectionX = a - 2 * this.normalX * c;
            this.reflectionY = b - 2 * this.normalY * c;
            0 < c && (this.hitNormal = C3$jscomp$201.clampAngle(this.hitNormal + Math.PI), this.normalX = -this.normalX, this.normalY = -this.normalY)
        }
    }
    TestInstanceSegment(a, b, c, d, e)
    {
        const f = C3$jscomp$201.rayIntersect(this.x1, this.y1, this.x2, this.y2, b, c, d, e);
        0 <= f && f < this.hitFraction && (this.hitFraction = f, this.hitUid = a.GetUID(), this.hitNormalDx = b - d, this.hitNormalDy = c - e)
    }
    TestInstanceRect(a,
    b, c, d)
    {
        const e = b + d.getLeft();
        b += d.getRight();
        const f = c + d.getTop();
        c += d.getBottom();
        this.TestInstanceSegment(a, e, f, b, f);
        this.TestInstanceSegment(a, b, f, b, c);
        this.TestInstanceSegment(a, b, c, e, c);
        this.TestInstanceSegment(a, e, c, e, f)
    }
    TestInstanceQuad(a, b)
    {
        const c = b.getTlx(),
            d = b.getTly(),
            e = b.getTrx(),
            f = b.getTry(),
            g = b.getBrx(),
            h = b.getBry(),
            k = b.getBlx();
        b = b.getBly();
        this.TestInstanceSegment(a, c, d, e, f);
        this.TestInstanceSegment(a, e, f, g, h);
        this.TestInstanceSegment(a, g, h, k, b);
        this.TestInstanceSegment(a, k, b, c, d)
    }
    TestInstancePoly(a,
    b, c, d)
    {
        d = d.pointsArr();
        for (let e = 0, f = d.length; e < f; e += 2) {
            const g = (e + 2) % f;
            this.TestInstanceSegment(a, d[e] + b, d[e + 1] + c, d[g] + b, d[g + 1] + c)
        }
    }
}
;
"use strict";
const C3$jscomp$202 = self.C3,
    VALID_FULLSCREEN_MODES = new Set("off crop scale-inner scale-outer letterbox-scale letterbox-integer-scale".split(" ")),
    VALID_FULLSCREEN_SCALING_QUALITIES = new Set(["high", "low"]),
    glMatrix$jscomp$11 = self.glMatrix,
    mat4$jscomp$9 = glMatrix$jscomp$11.mat4,
    tempProjection = mat4$jscomp$9.create(),
    tempQuad$jscomp$5 = C3$jscomp$202.New(C3$jscomp$202.Quad),
    tempRect$jscomp$9 = C3$jscomp$202.New(C3$jscomp$202.Rect);
C3$jscomp$202.CanvasManager = class  extends C3$jscomp$202.DefendedBase{
    constructor(a)
    {
        super();
        this._runtime = a;
        this._canvasLayers = [];
        this._isWebGPUEnabled = !1;
        this._iRenderer = this._webgpuRenderer = this._webglRenderer = null;
        this._gpuPreference = "high-performance";
        this._isLimitedToWebGL1 = !1;
        this._windowInnerHeight = this._windowInnerWidth = 0;
        this._cssDisplayMode = "";
        this._canvasCssOffsetY = this._canvasCssOffsetX = this._canvasDeviceHeight = this._canvasDeviceWidth = this._canvasCssHeight = this._canvasCssWidth = 0;
        this._zAxisScale =
        "normalized";
        this._initFieldOfView = 0;
        this._zNear = 1;
        this._zFar = 1E4;
        this._enableMipmaps = !0;
        this._drawHeight = this._drawWidth = this._textureAnisotropy = 0;
        this._documentFullscreenMode = this._fullscreenMode = "letterbox-scale";
        this._deviceTransformOffY = this._deviceTransformOffX = 0;
        this._defaultProjectionMatrix = mat4$jscomp$9.create();
        this._fullscreenScalingQuality = this._wantFullscreenScalingQuality = "high";
        this._isDocumentFullscreen = !1;
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets =
        new Set;
        this._shaderData = self.C3_Shaders;
        this._effectChainManager = C3$jscomp$202.New(C3$jscomp$202.Gfx.EffectChainManager, {
            getDrawSize: () => [this.GetDrawWidth(), this.GetDrawHeight()],
            getRenderTarget: () => this.GetEffectCompositorRenderTarget(),
            releaseRenderTarget: b => this.ReleaseEffectCompositorRenderTarget(b),
            getTime: () => this.GetRuntime().GetGameTime(),
            redraw: () => this.GetRuntime().UpdateRender()
        });
        this._gpuTimeEndFrame = this._gpuTimeStartFrame = 0;
        this._gpuLastUtilisation = NaN;
        this._gpuFrameTimingsBuffer =
        null;
        this._layersGpuProfile = new Map;
        this._gpuCurUtilisation = NaN;
        this._webgpuFrameTimings = new Map;
        this._snapshotFormat = "";
        this._snapshotQuality = 1;
        this._snapshotArea = C3$jscomp$202.New(C3$jscomp$202.Rect);
        this._snapshotUrl = "";
        this._snapshotResolve = this._snapshotPromise = null;
        this._loaderStartTime = this._isPastingToDrawingCanvas = 0;
        this._rafId = -1;
        this._loadingProgress = 0;
        this._loadingprogress_handler = b => this._loadingProgress = b.progress;
        this._percentText = null;
        this._splashTextures = {
            logo: null,
            powered: null,
            website: null
        };
        this._splashFadeOutStartTime = this._splashFadeInFinishTime = this._splashFrameNumber = 0;
        this._splashState = "fade-in";
        this._splashDoneResolve = null;
        this._splashDonePromise = new Promise(b => this._splashDoneResolve = b)
    }
    _SetGPUPowerPreference(a)
    {
        this._gpuPreference = a
    }
    _SetWebGPUEnabled(a)
    {
        this._isWebGPUEnabled = !!a
    }
    _SetZAxisScale(a)
    {
        this._zAxisScale = a
    }
    GetZAxisScale()
    {
        return this._zAxisScale
    }
    _SetInitFieldOfView(a)
    {
        this._initFieldOfView = a
    }
    _SetZDistances(a, b)
    {
        this._zNear = a;
        this._zFar = b
    }
    _SetLimitedToWebGL1(a)
    {
        this._isLimitedToWebGL1 =
        !!a
    }
    async CreateCanvas(a)
    {
        var b = a.canvas;
        this._canvasLayers.push({
            canvas: b,
            ctx: null
        });
        this._runtime.AddDOMComponentMessageHandler("runtime", "window-resize", d => this._OnWindowResize(d));
        this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenchange", d => this._OnFullscreenChange(d));
        this._runtime.AddDOMComponentMessageHandler("runtime", "fullscreenerror", d => this._OnFullscreenError(d));
        b.addEventListener("webglcontextlost", d => this._OnWebGLContextLost(d));
        b.addEventListener("webglcontextrestored",
        d => this._OnWebGLContextRestored(d));
        this._isDocumentFullscreen = !!a.isFullscreen;
        this._cssDisplayMode = a.cssDisplayMode;
        var c = navigator.gpu && this._isWebGPUEnabled;
        b = !1;
        if (c)
            try {
                await this._InitWebGPUContext(!0)
            } catch (d) {
                this._MaybeLogRendererError("WebGPU", d),
                this._webgpuRenderer = null
            }
        if (!this.GetRenderer())
            try {
                await this._InitWebGLContext(!0)
            } catch (d) {
                this._MaybeLogRendererError("WebGL", d),
                this._webglRenderer = null
            }
        this.GetRenderer() || (b = !0);
        if (!this.GetRenderer() && c)
            try {
                await this._InitWebGPUContext(!1)
            } catch (d) {
                this._MaybeLogRendererError("WebGPU",
                d),
                this._webgpuRenderer = null
            }
        if (!this.GetRenderer())
            try {
                await this._InitWebGLContext(!1)
            } catch (d) {
                this._MaybeLogRendererError("WebGL", d),
                this._webglRenderer = null
            }
        c = this.GetRenderer();
        if (!c)
            throw Error("failed to acquire a renderer - check WebGL or WebGPU is supported");
        c.SetHasMajorPerformanceCaveat(b);
        this._webgpuRenderer && (this._webgpuRenderer.ondevicelost = () => this._OnWebGPUDeviceLost(), this._webgpuRenderer.ondevicerestored = () => this._OnWebGPUDeviceRestored());
        "normalized" === this._zAxisScale ? c.SetZAxisScaleNormalized() :
        (c.SetZAxisScaleRegular(), c.SetFovY(this._initFieldOfView));
        this.SetSize(a.windowInnerWidth, a.windowInnerHeight, !0);
        await this._InitRenderer()
    }
    _MaybeLogRendererError(a, b)
    {
        b && "string" === typeof b.message && b.message.startsWith("renderer-unavailable") || console.error(`Error creating ${a} renderer: `, b)
    }
    async _InitWebGPUContext(a)
    {
        const b = {
            nearZ: this._zNear,
            farZ: this._zFar
        };
        a = {
            powerPreference: this._gpuPreference,
            depth: this._runtime.Uses3DFeatures(),
            failIfMajorPerformanceCaveat: a,
            usesBackgroundBlending: this._runtime.UsesAnyBackgroundBlending(),
            canSampleBackbuffer: this._runtime.UsesAnyCrossSampling(),
            canSampleDepth: this._runtime.UsesAnyDepthSampling()
        };
        this._webgpuRenderer = C3$jscomp$202.New(C3$jscomp$202.Gfx.WebGPURenderer, b);
        await this._webgpuRenderer.Create(this._canvasLayers[0].canvas, a)
    }
    async _InitWebGLContext(a)
    {
        a = {
            alpha: !0,
            powerPreference: this._gpuPreference,
            enableGpuProfiling: "xbox-uwp-webview2" !== this._runtime.GetExportType(),
            depth: this._runtime.Uses3DFeatures(),
            canSampleDepth: this._runtime.UsesAnyDepthSampling(),
            failIfMajorPerformanceCaveat: a,
            nearZ: this._zNear,
            farZ: this._zFar
        };
        this._isLimitedToWebGL1 && (a.maxWebGLVersion = 1);
        this._webglRenderer = C3$jscomp$202.New(C3$jscomp$202.Gfx.WebGLRenderer, this._canvasLayers[0].canvas, a);
        await this._webglRenderer.InitState()
    }
    async _InitWebGPU()
    {
        if (this._shaderData) {
            const a = [];
            for (const [b, c] of Object.entries(this._shaderData)) {
                c.src = c.wgsl;
                const d = C3$jscomp$202.Gfx.WebGPUShaderProgram.GetDefaultVertexShaderSource();
                a.push(this._webgpuRenderer.CreateShaderProgram(Object.assign({
                    vertexSrc: d,
                    name: b
                }, c)))
            }
            await Promise.all(a)
        }
    }
    async _InitWebGL()
    {
        if (this._shaderData) {
            const a =
            [];
            for (const [b, c] of Object.entries(this._shaderData)) {
                let d;
                if (c.glslWebGL2 && 2 <= this._webglRenderer.GetWebGLVersionNumber())
                    c.src = c.glslWebGL2,
                    d = C3$jscomp$202.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource_WebGL2();
                else {
                    if (!c.glsl)
                        throw Error(`shader '${b}' does not support WebGL 1`);
                    c.src = c.glsl;
                    d = C3$jscomp$202.Gfx.WebGLShaderProgram.GetDefaultVertexShaderSource()
                }
                a.push(this._webglRenderer.CreateShaderProgram(Object.assign({
                    vertexSrc: d,
                    name: b
                }, c)))
            }
            await Promise.all(a);
            this._webglRenderer.ResetLastProgram();
            this._webglRenderer.SetTextureFillMode()
        }
        this._webglRenderer.SupportsGPUProfiling() && (this._gpuFrameTimingsBuffer = C3$jscomp$202.New(C3$jscomp$202.Gfx.WebGLQueryResultBuffer, this._webglRenderer))
    }
    async _InitRenderer()
    {
        this._webgpuRenderer ? await this._InitWebGPU() : this._webglRenderer && await this._InitWebGL();
        const a = this.GetRenderer();
        a.SetMipmapsEnabled(this._enableMipmaps);
        a.SupportsGPUProfiling() && (this._gpuLastUtilisation = 0);
        for (const b of this._runtime._GetAllEffectLists()) {
            for (const c of b.GetAllEffectTypes())
                c._InitRenderer(a);
            b._InitRenderer(a);
            b.UpdateActiveEffects()
        }
        this._iRenderer = new self.IRenderer(this._runtime, a)
    }
    Release()
    {
        this._webglRenderer = this._runtime = null;
        this._canvasLayers.length = 0
    }
    IsInWorker()
    {
        return this._runtime.IsInWorker()
    }
    _OnWindowResize(a)
    {
        const b = this._runtime;
        if (!b.IsExportToVideo()) {
            var c = a.devicePixelRatio;
            this.IsInWorker() && (self.devicePixelRatio = c);
            b._SetDevicePixelRatio(c);
            this._isDocumentFullscreen = !!a.isFullscreen;
            this._cssDisplayMode = a.cssDisplayMode;
            this.SetSize(a.innerWidth, a.innerHeight);
            b.UpdateRender();
            c = new C3$jscomp$202.Event("window-resize");
            c.data = a;
            b.Dispatcher().dispatchEventAndWaitAsyncSequential(c);
            a = new C3$jscomp$202.Event("resize");
            a.cssWidth = this.GetCssWidth();
            a.cssHeight = this.GetCssHeight();
            a.deviceWidth = this.GetDeviceWidth();
            a.deviceHeight = this.GetDeviceHeight();
            b.DispatchUserScriptEvent(a);
            b.IsDebug() && (b.HitBreakpoint() || self.C3Debugger.IsDebuggerPaused()) && b.Render()
        }
    }
    _OnFullscreenChange(a)
    {
        this._isDocumentFullscreen = !!a.isFullscreen;
        this.SetSize(a.innerWidth, a.innerHeight,
        !0);
        this._runtime.UpdateRender()
    }
    _OnFullscreenError(a)
    {
        this._isDocumentFullscreen = !!a.isFullscreen;
        this.SetSize(a.innerWidth, a.innerHeight, !0);
        this._runtime.UpdateRender()
    }
    SetSize(a, b, c=!1)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        if (0 >= a || 0 >= b)
            throw Error("invalid size");
        if (this._windowInnerWidth !== a || this._windowInnerHeight !== b || c) {
            this._windowInnerWidth = a;
            this._windowInnerHeight = b;
            c = this.GetCurrentFullscreenMode();
            "letterbox-scale" === c ? this._CalculateLetterboxScale(a, b) : "letterbox-integer-scale" === c ? this._CalculateLetterboxIntegerScale(a,
            b) : "off" === c ? this._CalculateFixedSizeCanvas(a, b) : this._CalculateFullsizeCanvas(a, b);
            this._UpdateFullscreenScalingQuality(c);
            for (const {canvas: e} of this._canvasLayers)
                e.width = this._canvasDeviceWidth,
                e.height = this._canvasDeviceHeight;
            this._runtime.PostComponentMessageToDOM("canvas", "update-size", {
                marginLeft: this._canvasCssOffsetX,
                marginTop: this._canvasCssOffsetY,
                styleWidth: this._canvasCssWidth,
                styleHeight: this._canvasCssHeight,
                displayScale: this.GetDisplayScale()
            });
            a = this.GetRenderer();
            a.SetSize(this._canvasDeviceWidth,
            this._canvasDeviceHeight, !0);
            for (var d of this._availableAdditionalRenderTargets)
                a.DeleteRenderTarget(d);
            C3$jscomp$202.clearArray(this._availableAdditionalRenderTargets);
            this.UpdateDefaultProjectionMatrix();
            d = this._runtime.GetLayoutManager();
            d.SetAllLayerProjectionChanged();
            d.SetAllLayerMVChanged()
        }
    }
    UpdateDefaultProjectionMatrix()
    {
        this.GetRenderer().CalculatePerspectiveMatrix(this._defaultProjectionMatrix, this.GetDrawWidth() / this.GetDrawHeight())
    }
    GetDefaultProjectionMatrix()
    {
        return this._defaultProjectionMatrix
    }
    _CalculateLetterboxScale(a,
    b)
    {
        const c = this._runtime.GetDevicePixelRatio(),
            d = this._runtime.GetOriginalViewportWidth(),
            e = this._runtime.GetOriginalViewportHeight(),
            f = d / e;
        a / b > f ? (this._canvasCssWidth = Math.round(b * f), this._canvasCssHeight = b, this._canvasCssOffsetX = Math.floor((a - this._canvasCssWidth) / 2), this._canvasCssOffsetY = 0) : (this._canvasCssWidth = a, this._canvasCssHeight = Math.round(a / f), this._canvasCssOffsetX = 0, this._canvasCssOffsetY = Math.floor((b - this._canvasCssHeight) / 2));
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth *
        c);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * c);
        this._runtime.SetViewportSize(d, e)
    }
    _CalculateLetterboxIntegerScale(a, b)
    {
        const c = this._runtime.GetDevicePixelRatio();
        1 !== c && (a += 1, b += 1);
        const d = this._runtime.GetOriginalViewportWidth(),
            e = this._runtime.GetOriginalViewportHeight();
        var f = d / e;
        f = a / b > f ? b * f * c / d : a / f * c / e;
        1 < f ? f = Math.floor(f) : 1 > f && (f = 1 / Math.ceil(1 / f));
        this._canvasDeviceWidth = Math.round(d * f);
        this._canvasDeviceHeight = Math.round(e * f);
        this._canvasCssWidth = this._canvasDeviceWidth / c;
        this._canvasCssHeight =
        this._canvasDeviceHeight / c;
        this._canvasCssOffsetX = Math.max(Math.floor((a - this._canvasCssWidth) / 2), 0);
        this._canvasCssOffsetY = Math.max(Math.floor((b - this._canvasCssHeight) / 2), 0);
        this._runtime.SetViewportSize(d, e)
    }
    _CalculateFullsizeCanvas(a, b)
    {
        const c = this._runtime.GetDevicePixelRatio();
        this._canvasCssWidth = a;
        this._canvasCssHeight = b;
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * c);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * c);
        this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
        a =
        this.GetDisplayScale();
        this._runtime.SetViewportSize(this._canvasCssWidth / a, this._canvasCssHeight / a)
    }
    _CalculateFixedSizeCanvas(a, b)
    {
        const c = this._runtime.GetDevicePixelRatio();
        this._canvasCssWidth = this._runtime.GetViewportWidth();
        this._canvasCssHeight = this._runtime.GetViewportHeight();
        this._canvasDeviceWidth = Math.round(this._canvasCssWidth * c);
        this._canvasDeviceHeight = Math.round(this._canvasCssHeight * c);
        this.IsDocumentFullscreen() ? (this._canvasCssOffsetX = Math.floor((a - this._canvasCssWidth) / 2), this._canvasCssOffsetY =
        Math.floor((b - this._canvasCssHeight) / 2)) : this._canvasCssOffsetY = this._canvasCssOffsetX = 0;
        this._runtime.SetViewportSize(this._runtime.GetViewportWidth(), this._runtime.GetViewportHeight())
    }
    _UpdateFullscreenScalingQuality(a)
    {
        if ("high" === this._wantFullscreenScalingQuality)
            this._drawWidth = this._canvasDeviceWidth,
            this._drawHeight = this._canvasDeviceHeight,
            this._fullscreenScalingQuality = "high";
        else {
            let c;
            if ("off" === this.GetCurrentFullscreenMode()) {
                var b = this._runtime.GetViewportWidth();
                c = this._runtime.GetViewportHeight()
            } else
                b =
                this._runtime.GetOriginalViewportWidth(),
                c = this._runtime.GetOriginalViewportHeight();
            this._canvasDeviceWidth < b || this._canvasDeviceHeight < c ? (this._drawWidth = this._canvasDeviceWidth, this._drawHeight = this._canvasDeviceHeight, this._fullscreenScalingQuality = "high") : (this._drawWidth = b, this._drawHeight = c, this._fullscreenScalingQuality = "low", "scale-inner" === a ? (a = b / c, b = this._windowInnerWidth / this._windowInnerHeight, b < a ? this._drawWidth = this._drawHeight * b : b > a && (this._drawHeight = this._drawWidth / b)) : "scale-outer" ===
            a && (a = b / c, b = this._windowInnerWidth / this._windowInnerHeight, b > a ? this._drawWidth = this._drawHeight * b : b < a && (this._drawHeight = this._drawWidth / b)))
        }
    }
    GetRuntime()
    {
        return this._runtime
    }
    GetMainCanvas()
    {
        return this._canvasLayers[0].canvas
    }
    GetEffectChainManager()
    {
        return this._effectChainManager
    }
    IsDocumentFullscreen()
    {
        return this._isDocumentFullscreen
    }
    GetCssDisplayMode()
    {
        return this._cssDisplayMode
    }
    SetFullscreenMode(a)
    {
        if (!VALID_FULLSCREEN_MODES.has(a))
            throw Error("invalid fullscreen mode");
        this._fullscreenMode =
        a;
        a = this._runtime.GetLayoutManager();
        a.SetAllLayerProjectionChanged();
        a.SetAllLayerMVChanged()
    }
    GetFullscreenMode()
    {
        return this._fullscreenMode
    }
    SetDocumentFullscreenMode(a)
    {
        if (!VALID_FULLSCREEN_MODES.has(a))
            throw Error("invalid fullscreen mode");
        this._documentFullscreenMode = a;
        a = this._runtime.GetLayoutManager();
        a.SetAllLayerProjectionChanged();
        a.SetAllLayerMVChanged()
    }
    GetDocumentFullscreenMode()
    {
        return this._documentFullscreenMode
    }
    GetCurrentFullscreenMode()
    {
        return this.IsDocumentFullscreen() ? this.GetDocumentFullscreenMode() :
        this.GetFullscreenMode()
    }
    SetFullscreenScalingQuality(a)
    {
        if (!VALID_FULLSCREEN_SCALING_QUALITIES.has(a))
            throw Error("invalid fullscreen scaling quality");
        this._wantFullscreenScalingQuality = a;
        this._runtime.GetLayoutManager().SetAllLayerProjectionChanged()
    }
    GetSetFullscreenScalingQuality()
    {
        return this._wantFullscreenScalingQuality
    }
    GetCurrentFullscreenScalingQuality()
    {
        return this._fullscreenScalingQuality
    }
    static _FullscreenModeNumberToString(a)
    {
        switch (a) {
        case 0:
            return "off";
        case 1:
            return "crop";
        case 2:
            return "scale-inner";
        case 3:
            return "scale-outer";
        case 4:
            return "letterbox-scale";
        case 5:
            return "letterbox-integer-scale";
        default:
            throw Error("invalid fullscreen mode");
        }
    }
    GetLastWidth()
    {
        return this._windowInnerWidth
    }
    GetLastHeight()
    {
        return this._windowInnerHeight
    }
    GetDrawWidth()
    {
        return this._drawWidth
    }
    GetDrawHeight()
    {
        return this._drawHeight
    }
    SetMipmapsEnabled(a)
    {
        this._enableMipmaps = !!a
    }
    _SetTextureAnisotropy(a)
    {
        this._textureAnisotropy = a
    }
    GetTextureAnisotropy()
    {
        return this._textureAnisotropy
    }
    IsRendererContextLost()
    {
        return this.GetRenderer().IsContextLost()
    }
    _OnWebGLContextLost(a)
    {
        console.log("[Construct] WebGL context lost");
        a.preventDefault();
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets.clear();
        this._effectChainManager.OnContextLost();
        this._webglRenderer.OnContextLost();
        this._runtime._OnRendererContextLost()
    }
    _OnWebGPUDeviceLost()
    {
        console.log("[Construct] WebGPU device lost");
        this._availableAdditionalRenderTargets = [];
        this._usedAdditionalRenderTargets.clear();
        this._effectChainManager.OnContextLost();
        this._runtime._OnRendererContextLost()
    }
    async _OnWebGLContextRestored(a)
    {
        await this._webglRenderer.OnContextRestored();
        await this._InitRenderer();
        await this._runtime._OnRendererContextRestored();
        console.log("[Construct] WebGL context restored")
    }
    async _OnWebGPUDeviceRestored()
    {
        await this._InitRenderer();
        await this._runtime._OnRendererContextRestored();
        console.log("[Construct] WebGPU device restored")
    }
    GetWebGLRenderer()
    {
        return this._webglRenderer
    }
    GetWebGPURenderer()
    {
        return this._webgpuRenderer
    }
    GetRenderer()
    {
        return this._webgpuRenderer || this._webglRenderer
    }
    GetIRenderer()
    {
        return this._iRenderer
    }
    GetRenderScale()
    {
        return "low" ===
        this._fullscreenScalingQuality ? 1 / this._runtime.GetDevicePixelRatio() : this.GetDisplayScale()
    }
    GetDisplayScale()
    {
        const a = this.GetCurrentFullscreenMode();
        if ("off" === a || "crop" === a)
            return 1;
        const b = this._runtime.GetOriginalViewportWidth(),
            c = this._runtime.GetOriginalViewportHeight(),
            d = b / c,
            e = this._canvasDeviceWidth / this._canvasDeviceHeight;
        return "scale-inner" !== a && e > d || "scale-inner" === a && e < d ? this._canvasCssHeight / c : this._canvasCssWidth / b
    }
    GetEffectLayerScaleParam()
    {
        return "low" === this.GetCurrentFullscreenScalingQuality() ?
        1 : this.GetDisplayScale()
    }
    GetEffectDevicePixelRatioParam()
    {
        return "low" === this.GetCurrentFullscreenScalingQuality() ? 1 : this._runtime.GetDevicePixelRatio()
    }
    SetDeviceTransformOffset(a, b)
    {
        this._deviceTransformOffX = a;
        this._deviceTransformOffY = b
    }
    SetDeviceTransform(a, b, c, d=!0)
    {
        b = b || this._drawWidth;
        c = c || this._drawHeight;
        const e = b / 2 + this._deviceTransformOffX,
            f = c / 2 + this._deviceTransformOffY;
        if (d) {
            d = this.GetDefaultProjectionMatrix();
            if (b !== this._drawWidth || c !== this._drawHeight)
                a.CalculatePerspectiveMatrix(tempProjection,
                b / c),
                d = tempProjection;
            a.SetProjectionMatrix(d)
        }
        b = a.CalculateLookAtModelView2(e, f, a.GetDefaultCameraZ(c), e, f, 0, c);
        a.SetModelViewMatrix(b)
    }
    SetCssTransform(a, b=!0)
    {
        var c = this.GetCssWidth();
        const d = this.GetCssHeight();
        c /= 2;
        const e = d / 2;
        b && a.SetProjectionMatrix(this.GetDefaultProjectionMatrix());
        b = a.CalculateLookAtModelView2(c, e, a.GetDefaultCameraZ(d), c, e, 0, d);
        a.SetModelViewMatrix(b)
    }
    GetDeviceWidth()
    {
        return this._canvasDeviceWidth
    }
    GetDeviceHeight()
    {
        return this._canvasDeviceHeight
    }
    GetCssWidth()
    {
        return this._canvasCssWidth
    }
    GetCssHeight()
    {
        return this._canvasCssHeight
    }
    GetCanvasClientX()
    {
        return this._canvasCssOffsetX
    }
    GetCanvasClientY()
    {
        return this._canvasCssOffsetY
    }
    GetHTMLLayerCount()
    {
        return this._canvasLayers.length
    }
    _CanUseImageBitmapRenderingContext()
    {
        return "undefined" !==
            typeof OffscreenCanvas && this.GetMainCanvas() instanceof OffscreenCanvas && ("Chromium" !== C3$jscomp$202.Platform.BrowserEngine || 124 <= C3$jscomp$202.Platform.BrowserVersionNumber)
    }
    async SetHTMLLayerCount(a, b=!1)
    {
        if (1 > a)
            throw Error("invalid HTML layer count");
        if (this._canvasLayers.length !== a) {
            b = {
                count: a,
                immediate: b,
                marginLeft: this._canvasCssOffsetX,
                marginTop: this._canvasCssOffsetY,
                styleWidth: this._canvasCssWidth,
                styleHeight: this._canvasCssHeight
            };
            b = this.IsInWorker() ? await this._runtime.PostComponentMessageToDOMAsync("canvas",
            "set-html-layer-count", b) : self.c3_runtimeInterface._OnSetHTMLLayerCount(b);
            if (a < this._canvasLayers.length)
                this._canvasLayers.length = a;
            else
                for (const c of b.addedCanvases) {
                    c.width = this._canvasDeviceWidth;
                    c.height = this._canvasDeviceHeight;
                    a = this._CanUseImageBitmapRenderingContext() ? "bitmaprenderer" : "2d";
                    b = c.getContext(a);
                    if (!b)
                        throw Error(`failed to acquire '${a}' canvas context`);
                    this._canvasLayers.push({
                        canvas: c,
                        ctx: b
                    })
                }
            this._runtime.UpdateRender()
        }
    }
    BlitMainCanvasToHTMLLayerCanvas(a)
    {
        if (!(a >= this._canvasLayers.length)) {
            var b =
            this.GetMainCanvas();
            a = this._canvasLayers[a].ctx;
            this._CanUseImageBitmapRenderingContext() ? a.transferFromImageBitmap(b.transferToImageBitmap()) : (a.globalCompositeOperation = "copy", a.drawImage(b, 0, 0))
        }
    }
    GetAdditionalRenderTarget(a)
    {
        a.depth = this._runtime.Uses3DFeatures();
        const b = this._availableAdditionalRenderTargets,
            c = b.findIndex(e => e.IsCompatibleWithOptions(a));
        let d;
        -1 !== c ? (d = b[c], b.splice(c, 1)) : d = this.GetRenderer().CreateRenderTarget(a);
        this._usedAdditionalRenderTargets.add(d);
        return d
    }
    ReleaseAdditionalRenderTarget(a)
    {
        if (!this._usedAdditionalRenderTargets.has(a))
            throw Error("render target not in use");
        this._usedAdditionalRenderTargets.delete(a);
        this._availableAdditionalRenderTargets.push(a)
    }
    GetEffectCompositorRenderTarget()
    {
        const a = {
            sampling: this._runtime.GetSampling()
        };
        "low" === this.GetCurrentFullscreenScalingQuality() && (a.width = this.GetDrawWidth(), a.height = this.GetDrawHeight());
        return this.GetAdditionalRenderTarget(a)
    }
    ReleaseEffectCompositorRenderTarget(a)
    {
        this.ReleaseAdditionalRenderTarget(a)
    }
    *activeLayersGpuProfiles()
    {
        for (const a of this._runtime.GetLayoutManager().runningLayouts())
            for (const b of a.GetLayers()) {
                const c =
                this._layersGpuProfile.get(b);
                c && (yield c)
            }
    }
    GetLayerTimingsBuffer(a)
    {
        if (!this.GetRenderer().SupportsGPUProfiling())
            return null;
        let b = this._layersGpuProfile.get(a);
        b || (b = {
            layer: a,
            name: a.GetName(),
            timingsBuffer: C3$jscomp$202.New(C3$jscomp$202.Gfx.WebGLQueryResultBuffer, this._webglRenderer),
            curUtilisation: 0,
            lastTotalUtilisation: 0,
            lastSelfUtilisation: 0
        }, this._layersGpuProfile.set(a, b));
        return b.timingsBuffer
    }
    _Update1sFrameRange()
    {
        const a = this.GetRenderer();
        if (a.SupportsGPUProfiling() && 0 === this._gpuTimeEndFrame) {
            this._gpuTimeEndFrame =
            a.GetFrameNumber();
            this._gpuCurUtilisation = NaN;
            for (const b of this.activeLayersGpuProfiles())
                b.curUtilisation = NaN
        }
    }
    _UpdateTick()
    {
        this._webglRenderer && this._webglRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGL();
        this._webgpuRenderer && this._webgpuRenderer.SupportsGPUProfiling() && this._UpdateTick_WebGPU()
    }
    _UpdateTick_WebGL()
    {
        if (isNaN(this._gpuCurUtilisation) && (this._gpuCurUtilisation = this._gpuFrameTimingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), !isNaN(this._gpuCurUtilisation))) {
            if (this._runtime.IsDebug())
                for (var a of this.activeLayersGpuProfiles())
                    if (a.curUtilisation =
                    a.timingsBuffer.GetFrameRangeResultSum(this._gpuTimeStartFrame, this._gpuTimeEndFrame), isNaN(a.curUtilisation))
                        return;
            this._gpuFrameTimingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame);
            this._gpuLastUtilisation = Math.min(this._gpuCurUtilisation, 1);
            if (this._runtime.IsDebug()) {
                const c = new Map;
                for (const d of this.activeLayersGpuProfiles())
                    d.timingsBuffer.DeleteAllBeforeFrameNumber(this._gpuTimeEndFrame),
                    d.lastTotalUtilisation = Math.min(d.curUtilisation, 1),
                    c.set(d.layer, d.lastTotalUtilisation);
                for (var b of this.activeLayersGpuProfiles())
                    a = b.layer,
                    a = (c.get(a) || 0) - a.GetSubLayers().reduce((d, e) => d + (c.get(e) || 0), 0),
                    b.lastSelfUtilisation = C3$jscomp$202.clamp(a, 0, 1);
                b = this._runtime.GetMainRunningLayout();
                b = this._gpuLastUtilisation - b._GetRootLayers().reduce((d, e) => d + (c.get(e) || 0), 0);
                self.C3Debugger.UpdateGPUProfile(C3$jscomp$202.clamp(b, 0, 1), this._gpuLastUtilisation, [...this.activeLayersGpuProfiles()])
            }
            this._gpuTimeStartFrame = this._gpuTimeEndFrame;
            this._gpuTimeEndFrame = 0
        }
    }
    GetGPUFrameTimingsBuffer()
    {
        return this._gpuFrameTimingsBuffer
    }
    _UpdateTick_WebGPU()
    {
        if (0 !==
        this._gpuTimeEndFrame) {
            for (var a = this._gpuTimeStartFrame; a < this._gpuTimeEndFrame; ++a) {
                var b = this._webgpuFrameTimings.get(a);
                if (b && !b.HasResult())
                    return
            }
            a = this._runtime.GetMainRunningLayout();
            b = C3$jscomp$202.MakeFilledArray(a.GetLayerCount() + 1, 0);
            var c = 0;
            for (let e = this._gpuTimeStartFrame; e < this._gpuTimeEndFrame; ++e) {
                var d = this._webgpuFrameTimings.get(e);
                if (!d)
                    continue;
                d = d.GetResult();
                let f = BigInt(0),
                    g = BigInt(0);
                const h = BigInt(0);
                for (let k = 0, l = Math.min(b.length, d.length / 2); k < l; ++k) {
                    const m = d[2 * k],
                        n =
                        d[2 * k + 1];
                    m !== h && (f === h || m < f) && (f = m);
                    n > g && (g = n);
                    b[k] += Number(n - m) / 1E9
                }
                c += Number(g - f) / 1E9
            }
            this._gpuLastUtilisation = C3$jscomp$202.clamp(c, 0, 1);
            if (this._runtime.IsDebug()) {
                c = a.GetLayers();
                const e = new Map;
                for (let g = 0, h = Math.min(c.length, b.length - 1); g < h; ++g)
                    e.set(c[g], b[g + 1]);
                b = [];
                const f = new Map;
                for (const [g, h] of e)
                    c = [...g.selfAndAllSubLayers()].reduce((k, l) => k + (e.get(l) || 0), 0),
                    f.set(g, c),
                    b.push({
                        name: g.GetName(),
                        lastSelfUtilisation: C3$jscomp$202.clamp(h, 0, 1),
                        lastTotalUtilisation: C3$jscomp$202.clamp(c,
                        0, 1)
                    });
                a = this._gpuLastUtilisation - a._GetRootLayers().reduce((g, h) => g + (f.get(h) || 0), 0);
                self.C3Debugger.UpdateGPUProfile(C3$jscomp$202.clamp(a, 0, 1), this._gpuLastUtilisation, b)
            }
            for (a = this._gpuTimeStartFrame; a < this._gpuTimeEndFrame; ++a)
                this._webgpuFrameTimings.delete(a);
            this._gpuTimeStartFrame = this._gpuTimeEndFrame;
            this._gpuTimeEndFrame = 0
        }
    }
    _AddWebGPUFrameTiming(a)
    {
        this._webgpuFrameTimings.set(this._webgpuRenderer.GetFrameNumber(), a)
    }
    GetGPUUtilisation()
    {
        return this._gpuLastUtilisation
    }
    SnapshotCanvas(a,
    b, c, d, e, f)
    {
        this._snapshotFormat = a;
        this._snapshotQuality = b;
        this._snapshotArea.setWH(c, d, e, f);
        return this._snapshotPromise ? this._snapshotPromise : this._snapshotPromise = new Promise(g => {
            this._snapshotResolve = g
        })
    }
    _MaybeTakeSnapshot()
    {
        if (this._snapshotFormat) {
            var a = this.GetMainCanvas(),
                b = this._snapshotArea,
                c = C3$jscomp$202.clamp(Math.floor(b.getLeft()), 0, a.width),
                d = C3$jscomp$202.clamp(Math.floor(b.getTop()), 0, a.height),
                e = b.width();
            e = 0 === e ? a.width - c : C3$jscomp$202.clamp(Math.floor(e), 0, a.width - c);
            b = b.height();
            b = 0 === b ? a.height - d : C3$jscomp$202.clamp(Math.floor(b), 0, a.height - d);
            if ((0 !== c || 0 !== d || e !== a.width || b !== a.height) && 0 < e && 0 < b) {
                const f = C3$jscomp$202.CreateCanvas(e, b);
                f.getContext("2d").drawImage(a, c, d, e, b, 0, 0, e, b);
                a = f
            }
            C3$jscomp$202.CanvasToBlob(a, this._snapshotFormat, this._snapshotQuality).then(f => {
                this._snapshotUrl && URL.revokeObjectURL(this._snapshotUrl);
                this._snapshotUrl = URL.createObjectURL(f);
                this._snapshotPromise = null;
                this._snapshotResolve(this._snapshotUrl)
            });
            this._snapshotFormat = "";
            this._snapshotQuality =
            1
        }
    }
    GetCanvasSnapshotUrl()
    {
        return this._snapshotUrl
    }
    SetIsPastingToDrawingCanvas(a)
    {
        a ? this._isPastingToDrawingCanvas++ : this._isPastingToDrawingCanvas--
    }
    IsPastingToDrawingCanvas()
    {
        return 0 < this._isPastingToDrawingCanvas
    }
    InitLoadingScreen(a)
    {
        const b = this.GetRenderer();
        2 === a ? (this._percentText = C3$jscomp$202.New(C3$jscomp$202.Gfx.RendererText, this.GetRenderer()), this._percentText.SetFontName("Arial"), this._percentText.SetFontSize(16), this._percentText.SetHorizontalAlignment("center"), this._percentText.SetVerticalAlignment("center"),
        this._percentText.SetSize(300, 200)) : 0 === a ? (a = this._runtime.GetLoadingLogoAsset()) && a.LoadStaticTexture(b).catch(c => console.warn("[C3 runtime] Failed to create texture for loading logo: ", c)) : 4 === a && (this._LoadSvgSplashImage("splash-images/splash-logo.svg").then(c => {
            "done" === this._splashState ? b.DeleteTexture(c) : this._splashTextures.logo = c
        }).catch(c => console.warn("Failed to load splash image: ", c)), this._LoadBitmapSplashImage("splash-images/splash-poweredby-512.png").then(c => {
            "done" === this._splashState ?
            b.DeleteTexture(c) : this._splashTextures.powered = c
        }).catch(c => console.warn("Failed to load splash image: ", c)), this._LoadBitmapSplashImage("splash-images/splash-website-512.png").then(c => {
            "done" === this._splashState ? b.DeleteTexture(c) : this._splashTextures.website = c
        }).catch(c => console.warn("Failed to load splash image: ", c)))
    }
    async _LoadSvgSplashImage(a)
    {
        a = (new URL(a, this._runtime.GetRuntimeBaseURL())).toString();
        a = await C3$jscomp$202.FetchBlob(a);
        a = await this._runtime.RasterSvgImage(a, 2048, 2048);
        return await this.GetRenderer().CreateStaticTextureAsync(a,
        {
            mipMapQuality: "high"
        })
    }
    async _LoadBitmapSplashImage(a)
    {
        a = (new URL(a, this._runtime.GetRuntimeBaseURL())).toString();
        a = await C3$jscomp$202.FetchBlob(a);
        return await this.GetRenderer().CreateStaticTextureAsync(a, {
            mipMapQuality: "high"
        })
    }
    HideCordovaSplashScreen()
    {
        this._runtime.PostComponentMessageToDOM("runtime", "hide-cordova-splash")
    }
    StartLoadingScreen()
    {
        this._loaderStartTime = Date.now();
        this._runtime.Dispatcher().addEventListener("loadingprogress", this._loadingprogress_handler);
        this._rafId = requestAnimationFrame(() =>
        this._DrawLoadingScreen());
        3 !== this._runtime.GetLoaderStyle() && this.HideCordovaSplashScreen()
    }
    async EndLoadingScreen()
    {
        const a = this.GetRenderer();
        this._loadingProgress = 1;
        const b = this._runtime.GetLoaderStyle();
        4 === b && await this._splashDonePromise;
        this._splashDonePromise = this._splashDoneResolve = null;
        -1 !== this._rafId && (cancelAnimationFrame(this._rafId), this._rafId = -1);
        this._runtime.Dispatcher().removeEventListener("loadingprogress", this._loadingprogress_handler);
        this._loadingprogress_handler = null;
        this._percentText &&
        (this._percentText.Release(), this._percentText = null);
        this._runtime.ReleaseLoadingLogoAsset();
        a.Start();
        this._splashTextures.logo && (a.DeleteTexture(this._splashTextures.logo), this._splashTextures.logo = null);
        this._splashTextures.powered && (a.DeleteTexture(this._splashTextures.powered), this._splashTextures.powered = null);
        this._splashTextures.website && (a.DeleteTexture(this._splashTextures.website), this._splashTextures.website = null);
        a.ClearRgba(0, 0, 0, 0);
        a.Finish();
        this._splashState = "done";
        this._gpuTimeStartFrame =
        a.GetFrameNumber();
        3 === b && this.HideCordovaSplashScreen()
    }
    _DrawLoadingScreen()
    {
        if (-1 !== this._rafId) {
            var a = this.GetRenderer();
            a.Start();
            this._rafId = -1;
            var b = this._runtime.GetAssetManager().HasHadErrorLoading(),
                c = this._runtime.GetLoaderStyle();
            3 !== c && (this.SetCssTransform(a), a.ClearRgba(0, 0, 0, 0), a.ResetColor(), a.SetTextureFillMode(), a.SetTexture(null));
            if (0 === c)
                this._DrawProgressBarAndLogoLoadingScreen(b);
            else if (1 === c)
                this._DrawProgressBarLoadingScreen(b, 120, 0);
            else if (2 === c)
                this._DrawPercentTextLoadingScreen(b);
            else if (3 === c)
                C3$jscomp$202.noop();
            else if (4 === c)
                this._DrawSplashLoadingScreen(b);
            else
                throw Error("invalid loader style");
            a.Finish();
            this._rafId = requestAnimationFrame(() => this._DrawLoadingScreen())
        }
    }
    _DrawPercentTextLoadingScreen(a)
    {
        a ? this._percentText.SetColorRgb(1, 0, 0) : this._percentText.SetColorRgb(.6, .6, .6);
        this._percentText.SetText(Math.round(100 * this._loadingProgress) + "%");
        a = this._canvasCssWidth / 2;
        const b = this._canvasCssHeight / 2;
        tempQuad$jscomp$5.setRect(a - 150, b - 100, a + 150, b + 100);
        a = this.GetRenderer();
        a.SetTexture(this._percentText.GetTexture());
        a.Quad3(tempQuad$jscomp$5, this._percentText.GetTexRect())
    }
    _DrawProgressBarLoadingScreen(a, b, c)
    {
        const d = this.GetRenderer();
        d.SetColorFillMode();
        a ? d.SetColorRgba(1, 0, 0, 1) : d.SetColorRgba(.118, .565, 1, 1);
        a = this._canvasCssWidth / 2;
        const e = this._canvasCssHeight / 2,
            f = b / 2;
        tempRect$jscomp$9.setWH(a - f, e - 4 + c, Math.floor(b * this._loadingProgress), 8);
        d.Rect(tempRect$jscomp$9);
        tempRect$jscomp$9.setWH(a - f, e - 4 + c, b, 8);
        tempRect$jscomp$9.offset(-.5, -.5);
        tempRect$jscomp$9.inflate(.5,
        .5);
        d.SetColorRgba(0, 0, 0, 1);
        d.LineRect2(tempRect$jscomp$9);
        tempRect$jscomp$9.inflate(1, 1);
        d.SetColorRgba(1, 1, 1, 1);
        d.LineRect2(tempRect$jscomp$9)
    }
    _DrawProgressBarAndLogoLoadingScreen(a)
    {
        const b = this.GetRenderer();
        var c = this._runtime.GetLoadingLogoAsset();
        if (c)
            if (c = c.GetTexture()) {
                var d = c.GetWidth(),
                    e = c.GetHeight(),
                    f = this._canvasCssWidth / 2,
                    g = this._canvasCssHeight / 2,
                    h = d / 2;
                e /= 2;
                tempQuad$jscomp$5.setRect(f - h, g - e, f + h, g + e);
                b.SetTexture(c);
                b.Quad(tempQuad$jscomp$5);
                this._DrawProgressBarLoadingScreen(a, d,
                e + 16)
            } else
                this._DrawProgressBarLoadingScreen(a, 120, 0);
        else
            this._DrawProgressBarLoadingScreen(a, 120, 0)
    }
    _DrawSplashLoadingScreen(a)
    {
        const b = this.GetRenderer(),
            c = this._splashTextures.logo,
            d = this._splashTextures.powered,
            e = this._splashTextures.website,
            f = Date.now();
        0 === this._splashFrameNumber && (this._loaderStartTime = f);
        const g = this._runtime.IsPreview() || this._runtime.IsFBInstantAvailable() && !this._runtime.IsCordova(),
            h = g ? 0 : 200,
            k = g ? 0 : 3E3;
        let l = 1;
        "fade-in" === this._splashState ? l = Math.min((f - this._loaderStartTime) /
        300, 1) : "fade-out" === this._splashState && (l = Math.max(1 - (f - this._splashFadeOutStartTime) / 300, 0));
        b.SetColorFillMode();
        b.SetColorRgba(.231 * l, .251 * l, .271 * l, l);
        tempRect$jscomp$9.set(0, 0, this._canvasCssWidth, this._canvasCssHeight);
        b.Rect(tempRect$jscomp$9);
        const m = Math.ceil(this._canvasCssWidth),
            n = Math.ceil(this._canvasCssHeight);
        let p;
        256 < this._canvasCssHeight ? (b.SetColorRgba(.302 * l, .334 * l, .365 * l, l), p = Math.max(.005 * n, 2), tempRect$jscomp$9.setWH(0, .8 * n - p / 2, m, p), b.Rect(tempRect$jscomp$9), a ? b.SetColorRgba(l,
        0, 0, l) : b.SetColorRgba(.161 * l, .953 * l, .816 * l, l), a = m * this._loadingProgress, tempRect$jscomp$9.setWH(.5 * m - a / 2, .8 * n - p / 2, a, p), b.Rect(tempRect$jscomp$9), b.SetColorRgba(l, l, l, l), b.SetTextureFillMode(), d && (a = 1.5 * C3$jscomp$202.clamp(.22 * n, 105, .6 * m), p = a / 8, tempRect$jscomp$9.setWH(.5 * m - a / 2, .2 * n - p / 2, a, p), b.SetTexture(d), b.Rect(tempRect$jscomp$9)), c && (p = a = Math.min(.395 * n, .95 * m), tempRect$jscomp$9.setWH(.5 * m - a / 2, .485 * n - p / 2, a, p), b.SetTexture(c), b.Rect(tempRect$jscomp$9)), e && (a = 1.5 * C3$jscomp$202.clamp(.22 * n, 105, .6 * m),
        p = a / 8, tempRect$jscomp$9.setWH(.5 * m - a / 2, .868 * n - p / 2, a, p), b.SetTexture(e), b.Rect(tempRect$jscomp$9))) : (b.SetColorRgba(.302 * l, .334 * l, .365 * l, l), p = Math.max(.005 * n, 2), tempRect$jscomp$9.setWH(0, .85 * n - p / 2, m, p), b.Rect(tempRect$jscomp$9), a ? b.SetColorRgba(l, 0, 0, l) : b.SetColorRgba(.161 * l, .953 * l, .816 * l, l), a = m * this._loadingProgress, tempRect$jscomp$9.setWH(.5 * m - a / 2, .85 * n - p / 2, a, p), b.Rect(tempRect$jscomp$9), b.SetColorRgba(l, l, l, l), b.SetTextureFillMode(), c && (p = a = .55 * n, tempRect$jscomp$9.setWH(.5 * m - a / 2, .45 * n - p / 2, a, p),
        b.SetTexture(c), b.Rect(tempRect$jscomp$9)));
        this._splashFrameNumber++;
        "fade-in" === this._splashState && 300 <= f - this._loaderStartTime && 2 <= this._splashFrameNumber && (this._splashState = "wait", this._splashFadeInFinishTime = f);
        "wait" === this._splashState && f - this._splashFadeInFinishTime >= k && 1 <= this._loadingProgress && (this._splashState = "fade-out", this._splashFadeOutStartTime = f);
        ("fade-out" === this._splashState && f - this._splashFadeOutStartTime >= 300 + h || g && 1 <= this._loadingProgress && 500 > f - this._loaderStartTime) && this._splashDoneResolve()
    }
}
;
"use strict";
const C3$jscomp$203 = self.C3,
    C3Debugger$jscomp$3 = self.C3Debugger,
    DEFAULT_RUNTIME_OPTS = {
        messagePort: null,
        runtimeBaseUrl: "",
        headless: !1,
        hasDom: !0,
        isInWorker: !1,
        useAudio: !0,
        exportType: ""
    };
let ife = !0;
C3$jscomp$203.Runtime = class  extends C3$jscomp$203.DefendedBase{
    constructor(a)
    {
        a = Object.assign({}, DEFAULT_RUNTIME_OPTS, a);
        super();
        this._messagePort = a.messagePort;
        this._runtimeBaseUrl = a.runtimeBaseUrl;
        this._previewUrl = a.previewUrl;
        this._isHeadless = !!a.headless;
        this._hasDom = !!a.hasDom;
        this._isInWorker = !!a.isInWorker;
        ife = a.ife;
        this._useAudio = !!a.useAudio;
        this._exportType = a.exportType;
        this._isiOSCordova = !!a.isiOSCordova;
        this._isiOSWebView = !!a.isiOSWebView;
        this._isWindowsWebView2 = !!a.isWindowsWebView2;
        this._isAnyWebView2Wrapper = !!a.isAnyWebView2Wrapper;
        this._isFBInstantAvailable = !!a.isFBInstantAvailable;
        this._isDebugging = this._breakpointsEnabled = this._isDebug = !("preview" !== this._exportType || !a.isDebug);
        this._debuggingDisabled = 0;
        this._additionalLoadPromises = [];
        this._additionalCreatePromises = [];
        this._isUsingCreatePromises = !1;
        this._appId = this._projectUniqueId = this._projectVersion = this._projectName = "";
        this._originalViewportHeight = this._originalViewportWidth = 0;
        this._devicePixelRatio = self.devicePixelRatio;
        this._loaderStyle = this._viewportHeight = this._viewportWidth = this._parallaxYorigin = this._parallaxXorigin = 0;
        this._usesLoaderLayout = !1;
        this._isLoading = !0;
        this._usesAnyDepthSampling = this._usesAnyCrossSampling = this._usesAnyBackgroundBlending = !1;
        this._loadingLogoAsset = null;
        this._assetManager = C3$jscomp$203.New(C3$jscomp$203.AssetManager, this, a);
        this._layoutManager = C3$jscomp$203.New(C3$jscomp$203.LayoutManager, this);
        this._eventSheetManager = C3$jscomp$203.New(C3$jscomp$203.EventSheetManager, this);
        this._addonManager =
        C3$jscomp$203.New(C3$jscomp$203.AddonManager, this, a.wrapperComponentIds);
        this._collisionEngine = C3$jscomp$203.New(C3$jscomp$203.CollisionEngine, this);
        this._timelineManager = C3$jscomp$203.New(C3$jscomp$203.TimelineManager, this);
        this._transitionManager = C3$jscomp$203.New(C3$jscomp$203.TransitionManager, this);
        this._templateManager = C3$jscomp$203.New(C3$jscomp$203.TemplateManager, this);
        this._flowchartManager = C3$jscomp$203.New(C3$jscomp$203.FlowchartManager, this);
        this._textIconManager = C3$jscomp$203.New(C3$jscomp$203.TextIconManager,
        {
            getIconSetMeta: c => this._GetTextIconSetMeta(c),
            getIconSetContent: c => this._GetTextIconSetContent(c)
        });
        this._iconChangeHandlers = new Map;
        this._allObjectClasses = [];
        this._objectClassesByName = new Map;
        this._objectClassesBySid = new Map;
        this._familyCount = 0;
        this._allContainers = [];
        this._allEffectLists = new Set;
        this._currentLayoutStack = [];
        this._instancesPendingCreate = [];
        this._instancesPendingDestroy = new Map;
        this._isFlushingPendingInstances = this._hasPendingInstances = !1;
        this._nextUid = this._objectCount = 0;
        this._instancesByUid =
        new Map;
        this._instancesPendingRelease = new Set;
        this._instancesPendingReleaseAffectedObjectClasses = new Set;
        this._objectReferenceTable = [];
        this._jsPropNameTable = [];
        this._canvasManager = null;
        this._uses3dFeatures = !1;
        this._framerateMode = "vsync";
        this._sampling = "trilinear";
        this._isPixelRoundingEnabled = !1;
        this._needRender = !0;
        this._isPausedOnBlur = this._pauseOnBlur = !1;
        this._exportToVideo = null;
        this._tickCallbacks = {
            normal: c => {
                this._ruafId = this._rafId = -1;
                this.Tick(c)
            },
            tickOnly: c => {
                this._ruafId = -1;
                this.Tick(c, !1,
                "skip-render")
            },
            renderOnly: () => {
                this._rafId = -1;
                this.Render()
            }
        };
        this._ruafId = this._rafId = -1;
        this._tickCountNoSave = this._tickCount = 0;
        this._hasStartedTicking = this._isInTick = this._hasStarted = !1;
        this._isAutoSuspendEnabled = this._isLayoutFirstTick = !0;
        this._isPageVisibilitySuspended = !1;
        this._suspendCount = 0;
        this._scheduleTriggersThrottle = new C3$jscomp$203.PromiseThrottle(1);
        this._randomNumberCallback = () => Math.random();
        this._dt = this._dt1 = this._dtRaw = this._lastTickTime = this._startTime = 0;
        this._timeScale = 1;
        this._maxDt =
        1 / 30;
        this._minDt = 0;
        this._gameTime = C3$jscomp$203.New(C3$jscomp$203.KahanSum);
        this._gameTimeRaw = C3$jscomp$203.New(C3$jscomp$203.KahanSum);
        this._wallTime = C3$jscomp$203.New(C3$jscomp$203.KahanSum);
        this._instanceTimes = new Map;
        this._fpsFrameCount = -1;
        this._fps = this._fpsLastTime = 0;
        this._tpsTickCount = -1;
        this._mainThreadTime = this._mainThreadTimeCounter = this._tps = 0;
        this._isLoadingState = !1;
        this._loadFromSlotName = this._saveToSlotName = "";
        this._loadFromJson = null;
        this._lastSaveJson = "";
        this._savegamesStorage = this._projectStorage =
        null;
        this._dispatcher = C3$jscomp$203.New(C3$jscomp$203.Event.Dispatcher);
        this._domEventHandlers = new Map;
        this._pendingResponsePromises = new Map;
        this._nextDomResponseId = 0;
        this._isReadyToHandleEvents = this._didRequestDeviceMotionEvent = this._didRequestDeviceOrientationEvent = !1;
        this._waitingToHandleEvents = [];
        this._eventObjects = {
            pretick: C3$jscomp$203.New(C3$jscomp$203.Event, "pretick", !1),
            tick: C3$jscomp$203.New(C3$jscomp$203.Event, "tick", !1),
            tick2: C3$jscomp$203.New(C3$jscomp$203.Event, "tick2", !1),
            instancedestroy: C3$jscomp$203.New(C3$jscomp$203.Event,
            "instancedestroy", !1),
            beforelayoutchange: C3$jscomp$203.New(C3$jscomp$203.Event, "beforelayoutchange", !1),
            layoutchange: C3$jscomp$203.New(C3$jscomp$203.Event, "layoutchange", !1)
        };
        this._eventObjects.instancedestroy.instance = null;
        this._userScriptDispatcher = C3$jscomp$203.New(C3$jscomp$203.Event.Dispatcher);
        this._userScriptEventObjects = null;
        const b = (c, d) => C3$jscomp$203.BehaviorInstance.SortByTickSequence(this, c, d);
        this._behInstsToTick = C3$jscomp$203.New(C3$jscomp$203.RedBlackSet, b);
        this._behInstsToPostTick =
        C3$jscomp$203.New(C3$jscomp$203.RedBlackSet, b);
        this._behInstsToTick2 = C3$jscomp$203.New(C3$jscomp$203.RedBlackSet, b);
        this._jobScheduler = C3$jscomp$203.New(C3$jscomp$203.JobSchedulerRuntime, this, a.jobScheduler);
        a.canvas && (this._canvasManager = C3$jscomp$203.New(C3$jscomp$203.CanvasManager, this));
        this._messagePort.onmessage = c => this._OnMessageFromDOM(c.data);
        this.AddDOMComponentMessageHandler("runtime", "visibilitychange", c => this._OnVisibilityChange(c));
        this.AddDOMComponentMessageHandler("runtime", "wrapper-extension-message",
        c => this._OnWrapperExtensionMessage(c));
        this.AddDOMComponentMessageHandler("runtime", "opus-decode", c => this._WasmDecodeWebMOpus(c.arrayBuffer));
        this.AddDOMComponentMessageHandler("runtime", "get-remote-preview-status-info", () => this._GetRemotePreviewStatusInfo());
        this.AddDOMComponentMessageHandler("runtime", "js-invoke-function", c => this._InvokeFunctionFromJS(c));
        this.AddDOMComponentMessageHandler("runtime", "go-to-last-error-script", self.goToLastErrorScript);
        this.AddDOMComponentMessageHandler("runtime",
        "offline-audio-render-completed", c => this._OnOfflineAudioRenderCompleted(c));
        this._dispatcher.addEventListener("window-blur", c => this._OnWindowBlur(c));
        this._dispatcher.addEventListener("window-focus", () => this._OnWindowFocus());
        this._timelineManager.AddRuntimeListeners();
        this._templateManager.AddRuntimeListeners();
        this._iRuntime = null;
        this._interfaceMap = new WeakMap;
        this._commonScriptInterfaces = {
            keyboard: null,
            mouse: null,
            touch: null,
            timelineController: null,
            platformInfo: null
        };
        this._instancesNeedingAfterLoadMap =
        new WeakMap;
        this._instancesNeedingAfterLoadArray = []
    }
    static Create(a)
    {
        return C3$jscomp$203.New(C3$jscomp$203.Runtime, a)
    }
    Release()
    {
        C3$jscomp$203.clearArray(this._allObjectClasses);
        this._objectClassesByName.clear();
        this._objectClassesBySid.clear();
        this._layoutManager.Release();
        this._layoutManager = null;
        this._eventSheetManager.Release();
        this._eventSheetManager = null;
        this._addonManager.Release();
        this._addonManager = null;
        this._assetManager.Release();
        this._assetManager = null;
        this._collisionEngine.Release();
        this._collisionEngine = null;
        this._timelineManager.Release();
        this._timelineManager = null;
        this._transitionManager.Release();
        this._transitionManager = null;
        this._templateManager.Release();
        this._templateManager = null;
        this._flowchartManager.Release();
        this._flowchartManager = null;
        this._textIconManager.Release();
        this._textIconManager = null;
        this._canvasManager && (this._canvasManager.Release(), this._canvasManager = null);
        this._dispatcher.Release();
        this._tickEvent = this._dispatcher = null
    }
    _OnMessageFromDOM(a)
    {
        const b = a.type;
        if ("event" === b)
            this._OnEventFromDOM(a);
        else if ("result" === b)
            this._OnResultFromDOM(a);
        else
            throw Error(`unknown message '${b}'`);
    }
    _OnEventFromDOM(a)
    {
        if (this._isReadyToHandleEvents) {
            var b = a.component,
                c = a.handler,
                d = a.data,
                e = a.dispatchOpts,
                f = !(!e || !e.dispatchRuntimeEvent);
            e = !(!e || !e.dispatchUserScriptEvent);
            var g = a.responseId;
            if ("runtime" === b && (f && (a = new C3$jscomp$203.Event(c), a.data = d, this._dispatcher.dispatchEventAndWaitAsyncSequential(a)), e)) {
                a = new C3$jscomp$203.Event(c, !0);
                for (const [h, k] of Object.entries(d))
                    a[h] =
                    k;
                this.DispatchUserScriptEvent(a)
            }
            if (a = this._domEventHandlers.get(b))
                if (a = a.get(c)) {
                    f = null;
                    try {
                        f = a(d)
                    } catch (h) {
                        console.error(`Exception in '${b}' handler '${c}':`, h);
                        null !== g && this._PostResultToDOM(g, !1, "" + h);
                        return
                    }
                    null !== g && (f && f.then ? f.then(h => this._PostResultToDOM(g, !0, h)).catch(h => {
                        console.error(`Rejection from '${b}' handler '${c}':`, h);
                        this._PostResultToDOM(g, !1, "" + h)
                    }) : this._PostResultToDOM(g, !0, f))
                } else
                    f || e || console.warn(`[Runtime] No DOM handler '${c}' for component '${b}'`);
            else
                f || e ||
                console.warn(`[Runtime] No DOM event handlers for component '${b}'`)
        } else
            this._waitingToHandleEvents.push(a)
    }
    _PostResultToDOM(a, b, c)
    {
        this._messagePort.postMessage({
            type: "result",
            responseId: a,
            isOk: b,
            result: c
        })
    }
    _OnResultFromDOM(a)
    {
        const b = a.responseId,
            c = a.isOk;
        a = a.result;
        const d = this._pendingResponsePromises.get(b);
        c ? d.resolve(a) : d.reject(a);
        this._pendingResponsePromises.delete(b)
    }
    AddDOMComponentMessageHandler(a, b, c)
    {
        let d = this._domEventHandlers.get(a);
        d || (d = new Map, this._domEventHandlers.set(a, d));
        if (d.has(b))
            throw Error(`[Runtime] Component '${a}' already has handler '${b}'`);
        d.set(b, c)
    }
    PostComponentMessageToDOM(a, b, c, d)
    {
        this._messagePort.postMessage({
            type: "event",
            component: a,
            handler: b,
            data: c,
            responseId: null
        }, d)
    }
    PostComponentMessageToDOMAsync(a, b, c, d)
    {
        const e = this._nextDomResponseId++,
            f = new Promise((g, h) => {
                this._pendingResponsePromises.set(e, {
                    resolve: g,
                    reject: h
                })
            });
        this._messagePort.postMessage({
            type: "event",
            component: a,
            handler: b,
            data: c,
            responseId: e
        }, d);
        return f
    }
    SendWrapperExtensionMessage(a,
    b, c, d=-1)
    {
        this.PostComponentMessageToDOM("runtime", "send-wrapper-extension-message", {
            componentId: a,
            messageId: b,
            params: c,
            asyncId: d
        })
    }
    SendWrapperExtensionMessageAsync(a, b, c)
    {
        const d = this._nextDomResponseId++,
            e = new Promise((f, g) => {
                this._pendingResponsePromises.set(d, {
                    resolve: f,
                    reject: g
                })
            });
        this.SendWrapperExtensionMessage(a, b, c, d);
        return e
    }
    _OnWrapperExtensionMessage(a)
    {
        if (-1 !== a.asyncId) {
            const b = a.asyncId;
            this._pendingResponsePromises.get(b).resolve(a.params);
            this._pendingResponsePromises.delete(b)
        } else
            this._OnEventFromDOM({
                component: "wrapper-extension:" +
                a.componentId,
                handler: a.messageId,
                data: a.params,
                responseId: null
            })
    }
    AddWrapperExtensionMessageHandler(a, b, c)
    {
        this.AddDOMComponentMessageHandler("wrapper-extension:" + a, b, c)
    }
    HasWrapperComponentId(a)
    {
        return this._addonManager.HasWrapperComponentId(a)
    }
    PostToDebugger(a)
    {
        if (!this.IsDebug())
            throw Error("not in debug mode");
        this.PostComponentMessageToDOM("runtime", "post-to-debugger", a)
    }
    async Init(a)
    {
        C3$jscomp$203.CommonACES_SetRuntime(this);
        this.IsDebug() ? await C3Debugger$jscomp$3.Init(this) : self.C3Debugger &&
        self.C3Debugger.InitPreview(this);
        var [b] = await Promise.all([this._assetManager.FetchJson("data.json"), this._MaybeLoadOpusDecoder(), this._jobScheduler.Init()]);
        await this._LoadDataJson(b);
        await this._InitialiseCanvas(a);
        this.IsPreview() || console.info("%cMade with Construct, the game and animation creation tool. Visit: https://www.construct.net", "font-weight: bold");
        this.GetWebGLRenderer() ? (b = this.GetWebGLRenderer(), console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGL ${b.GetWebGLVersionNumber()} [${b.GetUnmaskedRenderer()}]`)) :
        this.GetWebGPURenderer() && console.info(`[C3 runtime] Hosted in ${this.IsInWorker() ? "worker" : "DOM"}, rendering with WebGPU [${this.GetWebGPURenderer().GetAdapterInfoString()}]`);
        this.GetRenderer().HasMajorPerformanceCaveat() && console.warn("[C3 runtime] The renderer indicates a major performance caveat. Software rendering may be in use. This can result in significantly degraded performance.");
        this._isReadyToHandleEvents = !0;
        for (const c of this._waitingToHandleEvents)
            this._OnEventFromDOM(c);
        C3$jscomp$203.clearArray(this._waitingToHandleEvents);
        this._canvasManager && this._canvasManager.StartLoadingScreen();
        for (const c of a.runOnStartupFunctions)
            this._additionalLoadPromises.push(this._RunOnStartupFunction(c));
        await Promise.all([this._assetManager.WaitForAllToLoad(), ...this._additionalLoadPromises]);
        C3$jscomp$203.clearArray(this._additionalLoadPromises);
        if (this._assetManager.HasHadErrorLoading())
            this._canvasManager && this._canvasManager.HideCordovaSplashScreen();
        else
            return this._canvasManager && await this._canvasManager.EndLoadingScreen(), await this._dispatcher.dispatchEventAndWaitAsync(new C3$jscomp$203.Event("beforeruntimestart")),
            await this.Start(), this._messagePort.postMessage({
                type: "runtime-ready"
            }), this
    }
    async _RunOnStartupFunction(a)
    {
        try {
            await a(this._iRuntime)
        } catch (b) {
            console.error("[C3 runtime] Error in runOnStartup function: ", b)
        }
    }
    async _LoadDataJson(a)
    {
        a = a.project;
        this._projectName = a[0];
        this._projectVersion = a[16];
        this._projectUniqueId = a[31];
        this._appId = a[38];
        var b = a[39] || "loading-logo.png";
        this._isPixelRoundingEnabled = !!a[9];
        this._originalViewportWidth = this._viewportWidth = a[10];
        this._originalViewportHeight = this._viewportHeight =
        a[11];
        this._collisionEngine._InitCollisionCellSize(this._originalViewportWidth, this._originalViewportHeight);
        this._parallaxXorigin = this._originalViewportWidth / 2;
        this._parallaxYorigin = this._originalViewportHeight / 2;
        this._framerateMode = a[37];
        this._uses3dFeatures = !!a[40];
        this._sampling = a[14];
        this._usesAnyBackgroundBlending = a[15];
        this._usesAnyCrossSampling = a[42];
        this._usesAnyDepthSampling = a[17];
        this._usesLoaderLayout = !!a[18];
        this._loaderStyle = a[19];
        this._nextUid = a[21];
        this._pauseOnBlur = a[22];
        const c =
        this._assetManager;
        c._SetFileStructure(a[45]);
        c._SetAudioFiles(a[7], a[25]);
        c._SetMediaSubfolder(a[8]);
        c._SetFontsSubfolder(a[32]);
        c._SetIconsSubfolder(a[28]);
        c._SetWebFonts(a[29]);
        if (0 === this._loaderStyle) {
            let h = "";
            if (h = "flat" === c.GetFileStructure() ? c.GetIconsSubfolder() + b : b)
                this._loadingLogoAsset = c.LoadImage({
                    url: h
                })
        }
        this._canvasManager && (this._canvasManager.SetFullscreenMode(C3$jscomp$203.CanvasManager._FullscreenModeNumberToString(a[12])), this._canvasManager.SetFullscreenScalingQuality(a[23] ? "high" :
        "low"), this._canvasManager.SetMipmapsEnabled(0 !== a[24]), this._canvasManager._SetGPUPowerPreference(a[34]), this._canvasManager._SetTextureAnisotropy(a[41]), this._canvasManager._SetWebGPUEnabled(a[13]), this._canvasManager._SetZAxisScale(a[30]), this._canvasManager._SetZDistances(a[46], a[47]), this._canvasManager._SetInitFieldOfView(a[26]), this._canvasManager._SetLimitedToWebGL1(a[48]));
        (b = a[43]) && await this._LoadExportToVideoData(b);
        this._InitScriptInterfaces();
        this._addonManager.CreateSystemPlugin();
        this._objectReferenceTable = self.C3_GetObjectRefTable();
        b = a[2];
        for (var d of b[1])
            this._addonManager.CreateBehavior(d);
        for (const h of b[0])
            this._addonManager.CreatePlugin(h);
        this._objectReferenceTable = self.C3_GetObjectRefTable();
        this._LoadJsPropNameTable();
        this._addonManager._InitAddonScriptInterfaces();
        for (var e of a[3])
            d = C3$jscomp$203.ObjectClass.Create(this, this._allObjectClasses.length, e),
            this._allObjectClasses.push(d),
            this._objectClassesByName.set(d.GetName().toLowerCase(), d),
            this._objectClassesBySid.set(d.GetSID(),
            d);
        for (const h of a[4])
            this._allObjectClasses[h[0]]._LoadFamily(h);
        for (var f of a[27])
            e = f.map(h => this._allObjectClasses[h]),
            this._allContainers.push(C3$jscomp$203.New(C3$jscomp$203.Container, this, e));
        this._InitObjectsScriptInterface();
        for (const h of this._allObjectClasses)
            h._OnAfterCreate();
        for (const h of a[5])
            this._layoutManager.Create(h);
        (f = a[1]) && (f = this._layoutManager.GetLayoutByName(f)) && this._layoutManager.SetFirstLayout(f);
        for (var g of a[35])
            this._transitionManager.Create(g);
        for (const h of a[33])
            this._timelineManager.Create(h);
        for (const h of a[44])
            this._templateManager.Create(h);
        this._templateManager.HasTemplates() || (this._templateManager.Release(), this._templateManager = null);
        for (const h of a[49])
            this._flowchartManager.Create(h);
        this._flowchartManager.HasFlowcharts() || (this._flowchartManager.Release(), this._flowchartManager = null);
        for (const h of a[6])
            this._eventSheetManager.Create(h);
        this._eventSheetManager._PostInit();
        this._InitGlobalVariableScriptInterface();
        C3$jscomp$203.clearArray(this._objectReferenceTable);
        this.FlushPendingInstances();
        g = "any";
        a = a[20];
        1 === a ? g = "portrait" : 2 === a && (g = "landscape");
        this.PostComponentMessageToDOM("runtime", "set-target-orientation", {
            targetOrientation: g
        })
    }
    async _LoadExportToVideoData(a)
    {
        const b = a.format;
        "image-sequence" === b ? this._exportToVideo = new self.C3ExportToImageSequence(this, a) : "image-sequence-gif" === b ? this._exportToVideo = new self.C3ExportToGIF(this, a) : "webm" === b ? this._exportToVideo = new self.C3ExportToWebMVideo(this, a) : "mp4" === b && (this._exportToVideo = new self.C3ExportToMP4Video(this, a));
        this._framerateMode =
        "unlimited-frame";
        this._canvasManager.SetFullscreenMode("off");
        this._devicePixelRatio = 1;
        self.devicePixelRatio = 1;
        await this.PostComponentMessageToDOMAsync("runtime", "set-exporting-to-video", {
            message: this._exportToVideo.GetExportingMessageForPercent(0),
            duration: this._exportToVideo.GetDuration()
        })
    }
    GetLoaderStyle()
    {
        return this._loaderStyle
    }
    IsExportToVideo()
    {
        return null !== this._exportToVideo
    }
    GetExportVideoDuration()
    {
        return this._exportToVideo.GetDuration()
    }
    GetExportVideoFramerate()
    {
        return this._exportToVideo.GetFramerate()
    }
    _InitExportToVideo()
    {
        return this._exportToVideo.Init({
            width: this._canvasManager.GetDeviceWidth(),
            height: this._canvasManager.GetDeviceHeight()
        })
    }
    _ExportToVideoAddFrame()
    {
        const a = this._tickCount / this.GetExportVideoFramerate();
        return this._exportToVideo.AddFrame(this._canvasManager.GetMainCanvas(), a)
    }
    _ExportToVideoAddKeyframe()
    {
        this._exportToVideo && this._exportToVideo.AddKeyframe()
    }
    _OnOfflineAudioRenderCompleted(a)
    {
        this._exportToVideo.OnOfflineAudioRenderCompleted(a)
    }
    _ExportToVideoFinish()
    {
        return this._exportToVideo.Finish()
    }
    IsFBInstantAvailable()
    {
        return this._isFBInstantAvailable
    }
    IsLoading()
    {
        return this._isLoading
    }
    AddLoadPromise(a)
    {
        this._additionalLoadPromises.push(a)
    }
    SetUsingCreatePromises(a)
    {
        this._isUsingCreatePromises =
        !!a
    }
    AddCreatePromise(a)
    {
        this._isUsingCreatePromises && this._additionalCreatePromises.push(a)
    }
    GetCreatePromises()
    {
        return this._additionalCreatePromises
    }
    _GetNextFamilyIndex()
    {
        return this._familyCount++
    }
    GetFamilyCount()
    {
        return this._familyCount
    }
    _AddEffectList(a)
    {
        this._allEffectLists.add(a)
    }
    _RemoveEffectList(a)
    {
        this._allEffectLists.delete(a)
    }
    _GetAllEffectLists()
    {
        return this._allEffectLists
    }
    async _InitialiseCanvas(a)
    {
        this._canvasManager && (await this._canvasManager.CreateCanvas(a), this._canvasManager.InitLoadingScreen(this._loaderStyle))
    }
    async _MaybeLoadOpusDecoder()
    {
        const a =
        this._assetManager;
        if (!a.IsAudioFormatSupported("audio/webm; codecs=opus")) {
            var b = null,
                c = a.GetScriptSubfolder(),
                d = c + "opus.wasm.js";
            c += "opus.wasm.wasm";
            try {
                b = this.IsiOSCordova() && a.IsFileProtocol() ? await a.CordovaFetchLocalFileAsArrayBuffer(c) : await a.FetchArrayBuffer(c)
            } catch (e) {
                console.info("Failed to fetch Opus decoder WASM; assuming project has no Opus audio.", e);
                return
            }
            this.AddJobWorkerBuffer(b, "opus-decoder-wasm");
            await this.AddJobWorkerScripts([d])
        }
    }
    async _WasmDecodeWebMOpus(a)
    {
        return await this.AddJob("OpusDecode",
        {
            arrayBuffer: a
        }, [a])
    }
    async Start()
    {
        this._hasStarted = !0;
        this._startTime = Date.now();
        let a = null;
        const b = new Promise(d => a = d);
        if (this._usesLoaderLayout) {
            for (var c of this._allObjectClasses)
                c.IsFamily() || c.IsOnLoaderLayout() || !c.IsWorldType() || c.OnCreate();
            (async () => {
                await this._assetManager.WaitForAllToLoad();
                await b;
                this._isLoading = !1;
                this._OnLoadFinished()
            })()
        } else
            this._isLoading = !1;
        this._assetManager.SetInitialLoadFinished();
        this.IsDebug() && C3Debugger$jscomp$3.RuntimeInit(ife);
        for (const d of this._layoutManager.GetAllLayouts())
            d._CreateGlobalNonWorlds();
        this.IsExportToVideo() && await this._InitExportToVideo();
        c = this._layoutManager.GetFirstLayout();
        await c._Load(null, this.GetRenderer());
        await c._StartRunning(!0);
        this._fpsLastTime = performance.now();
        a();
        this._usesLoaderLayout || this._OnLoadFinished();
        (await this.PostComponentMessageToDOMAsync("runtime", "before-start-ticking")).isSuspended && !this.IsExportToVideo() ? (this._suspendCount++, this._isPageVisibilitySuspended = !0) : this.Tick()
    }
    _OnLoadFinished()
    {
        this.Trigger(C3$jscomp$203.Plugins.System.Cnds.OnLoadFinished,
        null, null);
        this.PostComponentMessageToDOM("runtime", "register-sw")
    }
    GetObjectReference(a)
    {
        a = Math.floor(a);
        const b = this._objectReferenceTable;
        if (0 > a || a >= b.length)
            throw Error("invalid object reference");
        return b[a]
    }
    _LoadJsPropNameTable()
    {
        for (const a of self.C3_JsPropNameTable) {
            const b = C3$jscomp$203.first(Object.keys(a));
            this._jsPropNameTable.push(b)
        }
    }
    GetJsPropName(a)
    {
        a = Math.floor(a);
        const b = this._jsPropNameTable;
        if (0 > a || a >= b.length)
            throw Error("invalid prop reference");
        return b[a]
    }
    HasDOM()
    {
        return this._hasDom
    }
    IsHeadless()
    {
        return this._isHeadless
    }
    IsInWorker()
    {
        return this._isInWorker
    }
    GetRuntimeBaseURL()
    {
        return this._runtimeBaseUrl
    }
    GetPreviewURL()
    {
        return this._previewUrl
    }
    GetEventSheetManager()
    {
        return this._eventSheetManager
    }
    GetEventStack()
    {
        return this._eventSheetManager.GetEventStack()
    }
    GetCurrentEventStackFrame()
    {
        return this._eventSheetManager.GetCurrentEventStackFrame()
    }
    GetCurrentEvent()
    {
        return this._eventSheetManager.GetCurrentEvent()
    }
    GetCurrentCondition()
    {
        return this._eventSheetManager.GetCurrentCondition()
    }
    IsCurrentConditionFirst()
    {
        return 0 ===
        this.GetCurrentEventStackFrame().GetConditionIndex()
    }
    GetCurrentAction()
    {
        return this._eventSheetManager.GetCurrentAction()
    }
    GetAddonManager()
    {
        return this._addonManager
    }
    GetSystemPlugin()
    {
        return this._addonManager.GetSystemPlugin()
    }
    GetObjectClassByIndex(a)
    {
        a = Math.floor(a);
        if (0 > a || a >= this._allObjectClasses.length)
            throw new RangeError("invalid index");
        return this._allObjectClasses[a]
    }
    GetObjectClassByName(a)
    {
        return this._objectClassesByName.get(a.toLowerCase()) || null
    }
    GetObjectClassBySID(a)
    {
        return this._objectClassesBySid.get(a) ||
            null
    }
    GetSingleGlobalObjectClassByCtor(a)
    {
        return (a = C3$jscomp$203.AddonManager.GetPluginByConstructorFunction(a)) ? a.GetSingleGlobalObjectClass() : null
    }
    GetAllObjectClasses()
    {
        return this._allObjectClasses
    }
    *allInstances()
    {
        for (const a of this._allObjectClasses)
            a.IsFamily() || (yield *a.instances())
    }
    Dispatcher()
    {
        return this._dispatcher
    }
    UserScriptDispatcher()
    {
        return this._userScriptDispatcher
    }
    DispatchUserScriptEvent(a)
    {
        a.runtime = this.GetIRuntime();
        const b = this.IsDebug() && !this._eventSheetManager.IsInEventEngine();
        b && C3Debugger$jscomp$3.StartMeasuringScriptTime();
        this._userScriptDispatcher.dispatchEvent(a);
        b && C3Debugger$jscomp$3.AddScriptTime()
    }
    DispatchUserScriptEventAsyncWait(a)
    {
        a.runtime = this.GetIRuntime();
        return this._userScriptDispatcher.dispatchEventAndWaitAsync(a)
    }
    GetOriginalViewportWidth()
    {
        return this._originalViewportWidth
    }
    GetOriginalViewportHeight()
    {
        return this._originalViewportHeight
    }
    SetOriginalViewportSize(a, b)
    {
        if (this._originalViewportWidth !== a || this._originalViewportHeight !== b)
            this._originalViewportWidth =
            a,
            this._originalViewportHeight = b,
            a = this.GetLayoutManager(),
            a.SetAllLayerProjectionChanged(),
            a.SetAllLayerMVChanged()
    }
    GetViewportWidth()
    {
        return this._viewportWidth
    }
    GetViewportHeight()
    {
        return this._viewportHeight
    }
    SetViewportSize(a, b)
    {
        if (this._viewportWidth !== a || this._viewportHeight !== b)
            this._viewportWidth = a,
            this._viewportHeight = b,
            a = this.GetLayoutManager(),
            a.SetAllLayerProjectionChanged(),
            a.SetAllLayerMVChanged()
    }
    _SetDevicePixelRatio(a)
    {
        this.IsExportToVideo() || (this._devicePixelRatio = a)
    }
    GetDevicePixelRatio()
    {
        return this._devicePixelRatio
    }
    GetParallaxXOrigin()
    {
        return this._parallaxXorigin
    }
    GetParallaxYOrigin()
    {
        return this._parallaxYorigin
    }
    GetCanvasManager()
    {
        return this._canvasManager
    }
    GetDrawWidth()
    {
        return this._canvasManager ?
        this._canvasManager.GetDrawWidth() : this._viewportWidth
    }
    GetDrawHeight()
    {
        return this._canvasManager ? this._canvasManager.GetDrawHeight() : this._viewportHeight
    }
    GetRenderScale()
    {
        return this._canvasManager ? this._canvasManager.GetRenderScale() : 1
    }
    GetDisplayScale()
    {
        return this._canvasManager ? this._canvasManager.GetDisplayScale() : 1
    }
    GetEffectLayerScaleParam()
    {
        return this._canvasManager ? this._canvasManager.GetEffectLayerScaleParam() : 1
    }
    GetEffectDevicePixelRatioParam()
    {
        return this._canvasManager ? this._canvasManager.GetEffectDevicePixelRatioParam() :
        1
    }
    GetCanvasClientX()
    {
        return this._canvasManager ? this._canvasManager.GetCanvasClientX() : 0
    }
    GetCanvasClientY()
    {
        return this._canvasManager ? this._canvasManager.GetCanvasClientY() : 0
    }
    GetCanvasCssWidth()
    {
        return this._canvasManager ? this._canvasManager.GetCssWidth() : 0
    }
    GetCanvasCssHeight()
    {
        return this._canvasManager ? this._canvasManager.GetCssHeight() : 0
    }
    GetFullscreenMode()
    {
        return this._canvasManager ? this._canvasManager.GetFullscreenMode() : "off"
    }
    GetAdditionalRenderTarget(a)
    {
        return this._canvasManager ? this._canvasManager.GetAdditionalRenderTarget(a) :
        null
    }
    ReleaseAdditionalRenderTarget(a)
    {
        this._canvasManager && this._canvasManager.ReleaseAdditionalRenderTarget(a)
    }
    UsesAnyBackgroundBlending()
    {
        return this._usesAnyBackgroundBlending
    }
    UsesAnyCrossSampling()
    {
        return this._usesAnyCrossSampling
    }
    UsesAnyDepthSampling()
    {
        return this._usesAnyDepthSampling
    }
    GetGPUUtilisation()
    {
        return this._canvasManager ? this._canvasManager.GetGPUUtilisation() : NaN
    }
    IsLinearSampling()
    {
        return "nearest" !== this.GetSampling()
    }
    GetFramerateMode()
    {
        return this._framerateMode
    }
    _SetFramerateMode(a)
    {
        this._framerateMode !==
        a && (this._framerateMode = a, -1 !== this._rafId || -1 !== this._ruafId) && (this._CancelAnimationFrame(), this._RequestAnimationFrame())
    }
    GetSampling()
    {
        return this._sampling
    }
    UsesLoaderLayout()
    {
        return this._usesLoaderLayout
    }
    GetLoadingLogoAsset()
    {
        return this._loadingLogoAsset
    }
    ReleaseLoadingLogoAsset()
    {
        this._loadingLogoAsset && (this._loadingLogoAsset.ReleaseTexture(), this._loadingLogoAsset.Release(), this._loadingLogoAsset = null)
    }
    GetLayoutManager()
    {
        return this._layoutManager
    }
    GetMainRunningLayout()
    {
        return this._layoutManager.GetMainRunningLayout()
    }
    GetTimelineManager()
    {
        return this._timelineManager
    }
    GetTransitionManager()
    {
        return this._transitionManager
    }
    GetTemplateManager()
    {
        return this._templateManager
    }
    GetFlowchartManager()
    {
        return this._flowchartManager
    }
    GetAssetManager()
    {
        return this._assetManager
    }
    LoadImage(a)
    {
        return this._assetManager.LoadImage(a)
    }
    CreateInstance(a,
    b, c, d, e, f)
    {
        if (f && this._templateManager) {
            if (a instanceof C3$jscomp$203.ObjectClass && a.IsFamily()) {
                a = a.GetFamilyMembers();
                var g = Math.floor(this.Random() * a.length);
                return this.CreateInstance(a[g], b, c, d, e, f)
            }
            if (g = this._templateManager.GetTemplateData(a, f))
                return b = this.CreateInstanceFromData(g, b, !1, c, d, !1, e, void 0, e), this._templateManager.MapInstanceToTemplateName(b, f), b
        }
        return this.CreateInstanceFromData(a, b, !1, c, d, !1, e, void 0, e)
    }
    CreateInstanceFromData(a, b, c, d, e, f, g, h, k)
    {
        var l = null;
        let m = null;
        if (a instanceof
        C3$jscomp$203.ObjectClass) {
            m = a;
            if (m.IsFamily()) {
                a = m.GetFamilyMembers();
                var n = Math.floor(this.Random() * a.length);
                m = a[n]
            }
            l = m.GetDefaultInstanceData()
        } else
            l = a,
            m = this.GetObjectClassByIndex(l[1]);
        var p = m.GetPlugin().IsWorldType();
        if (this._isLoading && p && !m.IsOnLoaderLayout())
            return null;
        const q = b;
        p || (b = null);
        var r = c && !f && l && !this._instancesByUid.has(l[2]) ? l[2] : this._nextUid++;
        n = l ? l[0] : null;
        a = C3$jscomp$203.New(C3$jscomp$203.Instance, {
            runtime: this,
            objectType: m,
            layer: b,
            worldData: n,
            instVarData: l ? l[3] : null,
            uid: r,
            tags: l ? l[6] : null
        });
        this._instancesByUid.set(r, a);
        r = null;
        p && (r = a.GetWorldInfo(), "undefined" !== typeof d && "undefined" !== typeof e && (r.SetX(d), r.SetY(e)), m._SetAnyCollisionCellChanged(!0));
        b && (k || b._AddInstance(a, !0), b.GetLayout().MaybeLoadTexturesFor(m));
        this._objectCount++;
        var t = !0;
        if (h) {
            var u = h.GetObjectClass();
            u.IsInContainer() && m.IsInContainer() && (h = m.GetContainer(), u = u.GetContainer(), h === u && (t = !1))
        }
        if (m.IsInContainer() && !c && !f && t) {
            h = new Set;
            for (var v of m.GetContainer().objectTypes())
                v !== m &&
                ((t = this._MaybeGetChildInstanceForObjectTypeData(v, r, h)) ? (t = this.CreateInstanceFromData(t, q, !1, r ? r.GetX() : d, r ? r.GetY() : e, !0, !1, void 0, k), a._AddSibling(t)) : (t = this.CreateInstanceFromData(v, q, !1, r ? r.GetX() : d, r ? r.GetY() : e, !0, !1, void 0, k), a._AddSibling(t)));
            for (var w of a.siblings()) {
                w._AddSibling(a);
                for (const x of a.siblings())
                    w !== x && w._AddSibling(x)
            }
        }
        p && !c && g && this._CreateChildInstancesFromData(a, n, r, b, d, e, k);
        if (m.IsInContainer() && !c && !f && g)
            for (const x of a.siblings())
                if (c = x.GetWorldInfo())
                    v = x.GetPlugin(),
                    w = x.GetObjectClass().GetDefaultInstanceData()[0],
                    v.IsWorldType() ? this._CreateChildInstancesFromData(x, w, c, b, c.GetX(), c.GetY(), k) : this._CreateChildInstancesFromData(x, w, c, b, void 0, void 0, k);
        !f && g && ("undefined" === typeof d && (d = n[0]), "undefined" === typeof e && (e = n[1]), b = r.GetTopParent(), d = d - r.GetX() + b.GetX(), e = e - r.GetY() + b.GetY(), b.SetXY(d, e));
        m._SetIIDsStale();
        e = l ? C3$jscomp$203.cloneArray(l[5]) : null;
        l = l ? l[4].map(x => C3$jscomp$203.cloneArray(x)) : null;
        (p = p && n && n[13]) && a._SetHasTilemap();
        a._CreateSdkInstance(e,
        l);
        p && (n = n[13], a.GetSdkInstance().LoadTilemapData(n[2], n[0], n[1]));
        this._instancesPendingCreate.push(a);
        this._hasPendingInstances = !0;
        this.IsDebug() && C3Debugger$jscomp$3.InstanceCreated(a);
        return a
    }
    _GetInstanceData(a)
    {
        const b = a[1],
            c = a[2],
            d = a[6];
        return d ? d : this._layoutManager.GetLayoutBySID(a[0]).GetLayer(b).GetInitialInstanceData(c)
    }
    _MaybeGetChildInstanceForObjectTypeData(a, b, c)
    {
        b = b?.GetSceneGraphChildrenExportData() ?? [];
        for (const d of b) {
            b = this._GetInstanceData(d);
            const e = !!d[4],
                f = this.GetObjectClassByIndex(b[1]);
            if (!c.has(b) && a === f && e)
                return c.add(b), b
        }
    }
    _CreateChildInstancesFromData(a, b, c, d, e, f, g)
    {
        var h = c.GetSceneGraphZIndexExportData(),
            k = c.GetSceneGraphChildrenExportData();
        a.GetWorldInfo().SetSceneGraphZIndex(h);
        if (k) {
            "undefined" === typeof e && (e = b[0]);
            "undefined" === typeof f && (f = b[1]);
            h = new Set;
            c = b[0];
            b = b[1];
            for (const r of k) {
                var l = r[0],
                    m = r[1],
                    n = r[2];
                k = r[3];
                var p = !!r[4];
                const t = r[5];
                var q = r[6];
                m = q ? q : this._layoutManager.GetLayoutBySID(l).GetLayer(m).GetInitialInstanceData(n);
                l = this.GetObjectClassByIndex(m[1]);
                n = a.HasSibling(l);
                q = h.has(l);
                n && !q && p ? (p = a.GetSibling(l), p.GetWorldInfo().Init(m[0]), n = e + m[0][0] - c, m = f + m[0][1] - b, p.GetWorldInfo().SetXY(n, m), p.GetWorldInfo().SetSceneGraphZIndex(t), a.AddChild(p, {
                    transformX: !!(k >> 0 & 1),
                    transformY: !!(k >> 1 & 1),
                    transformWidth: !!(k >> 2 & 1),
                    transformHeight: !!(k >> 3 & 1),
                    transformAngle: !!(k >> 4 & 1),
                    destroyWithParent: !!(k >> 5 & 1),
                    transformZElevation: !!(k >> 6 & 1),
                    transformOpacity: !!(k >> 7 & 1),
                    transformVisibility: !!(k >> 8 & 1)
                }), h.add(l)) : (p = this.CreateInstanceFromData(m, d, !1, e + m[0][0] - c, f +
                m[0][1] - b, !1, !0, a, g), p.GetWorldInfo().SetSceneGraphZIndex(t), a.AddChild(p, {
                    transformX: !!(k >> 0 & 1),
                    transformY: !!(k >> 1 & 1),
                    transformWidth: !!(k >> 2 & 1),
                    transformHeight: !!(k >> 3 & 1),
                    transformAngle: !!(k >> 4 & 1),
                    destroyWithParent: !!(k >> 5 & 1),
                    transformZElevation: !!(k >> 6 & 1),
                    transformOpacity: !!(k >> 7 & 1),
                    transformVisibility: !!(k >> 8 & 1)
                }))
            }
        }
    }
    DestroyInstance(a)
    {
        if (!this._instancesPendingRelease.has(a)) {
            var b = a.GetObjectClass(),
                c = this._instancesPendingDestroy.get(b);
            if (c) {
                if (c.has(a))
                    return;
                c.add(a)
            } else
                c = new Set,
                c.add(a),
                this._instancesPendingDestroy.set(b, c);
            this.IsDebug() && C3Debugger$jscomp$3.InstanceDestroyed(a);
            a._MarkDestroyed();
            this._hasPendingInstances = !0;
            if (a.IsInContainer())
                for (const d of a.siblings())
                    this.DestroyInstance(d);
            for (const d of a.children())
                d.GetDestroyWithParent() && this.DestroyInstance(d);
            this._layoutManager.IsEndingLayout() || this._isLoadingState || (b = this.GetEventSheetManager(), b.BlockFlushingInstances(!0), a._TriggerOnDestroyed(), b.BlockFlushingInstances(!1));
            a._FireDestroyedScriptEvents(this._layoutManager.IsEndingLayout())
        }
    }
    FlushPendingInstances()
    {
        this._hasPendingInstances &&
        (this._isFlushingPendingInstances = !0, this._FlushInstancesPendingCreate(), this._FlushInstancesPendingDestroy(), this._hasPendingInstances = this._isFlushingPendingInstances = !1, this.UpdateRender())
    }
    _FlushInstancesPendingCreate()
    {
        for (const a of this._instancesPendingCreate) {
            const b = a.GetObjectClass();
            b._AddInstance(a);
            for (const c of b.GetFamilies())
                c._AddInstance(a),
                c._SetIIDsStale()
        }
        C3$jscomp$203.clearArray(this._instancesPendingCreate)
    }
    _FlushInstancesPendingDestroy()
    {
        this._dispatcher.SetDelayRemoveEventsEnabled(!0);
        for (const [a, b] of this._instancesPendingDestroy.entries())
            this._FlushInstancesPendingDestroyForObjectClass(a, b),
            b.clear();
        this._instancesPendingDestroy.clear();
        this._dispatcher.SetDelayRemoveEventsEnabled(!1)
    }
    _FlushInstancesPendingDestroyForObjectClass(a, b)
    {
        for (const d of b) {
            var c = this._eventObjects.instancedestroy;
            c.instance = d;
            this._dispatcher.dispatchEvent(c);
            this._instancesByUid.delete(d.GetUID());
            this._instanceTimes.delete(d);
            if (c = d.GetWorldInfo())
                c._RemoveFromCollisionCells(),
                c._RemoveFromRenderCells(),
                c._MarkDestroyed();
            this._instancesPendingRelease.add(d);
            this._objectCount--
        }
        C3$jscomp$203.arrayRemoveAllInSet(a.GetInstances(), b);
        a._SetIIDsStale();
        this._instancesPendingReleaseAffectedObjectClasses.add(a);
        for (const d of a.GetFamilies())
            C3$jscomp$203.arrayRemoveAllInSet(d.GetInstances(), b),
            d._SetIIDsStale(),
            this._instancesPendingReleaseAffectedObjectClasses.add(d);
        if (a.GetPlugin().IsWorldType()) {
            a = new Set([...b].map(d => d.GetWorldInfo().GetLayer()));
            for (const d of a)
                d._RemoveAllInstancesInSet(b)
        }
    }
    _GetInstancesPendingCreate()
    {
        return this._instancesPendingCreate
    }
    *instancesPendingCreateForObjectClass(a)
    {
        for (const b of this._GetInstancesPendingCreate())
            a.IsFamily() ?
            b.GetObjectClass().BelongsToFamily(a) && (yield b) : b.GetObjectClass() === a && (yield b)
    }
    _GetNewUID()
    {
        return this._nextUid++
    }
    _MapInstanceByUID(a, b)
    {
        this._instancesByUid.set(a, b)
    }
    _SetAutoSuspendEnabled(a)
    {
        a = !!a;
        this._isAutoSuspendEnabled !== a && (this._isAutoSuspendEnabled = !!a) && this._isPageVisibilitySuspended && (this.SetSuspended(!1), this._isPageVisibilitySuspended = !1)
    }
    _IsAutoSuspendEnabled()
    {
        return this._isAutoSuspendEnabled
    }
    _OnRendererContextLost()
    {
        this._dispatcher.dispatchEvent(C3$jscomp$203.New(C3$jscomp$203.Event,
        "renderercontextlost"));
        this.SetSuspended(!0);
        for (var a of this._allObjectClasses)
            !a.IsFamily() && a.HasLoadedTextures() && a.ReleaseTextures();
        (a = this.GetMainRunningLayout()) && a._OnRendererContextLost();
        C3$jscomp$203.ImageInfo.OnRendererContextLost();
        C3$jscomp$203.ImageAsset.OnRendererContextLost()
    }
    async _OnRendererContextRestored()
    {
        await this.GetMainRunningLayout()._Load(null, this.GetRenderer());
        this._dispatcher.dispatchEvent(C3$jscomp$203.New(C3$jscomp$203.Event, "renderercontextrestored"));
        this.SetSuspended(!1);
        this.UpdateRender()
    }
    _OnVisibilityChange(a)
    {
        this._isAutoSuspendEnabled && (a = a.hidden, this.SetSuspended(a), (this._isPageVisibilitySuspended = a) || this.UpdateRender())
    }
    _OnWindowBlur(a)
    {
        this.IsPreview() && this._pauseOnBlur && !C3$jscomp$203.Platform.IsMobile && !a.data.parentHasFocus && (this.SetSuspended(!0), this._isPausedOnBlur = !0)
    }
    _OnWindowFocus()
    {
        this._isPausedOnBlur && (this.SetSuspended(!1), this._isPausedOnBlur = !1)
    }
    _RequestAnimationFrame()
    {
        const a = this._tickCallbacks;
        "vsync" === this._framerateMode ? -1 === this._rafId &&
        (this._rafId = self.requestAnimationFrame(a.normal)) : "unlimited-tick" === this._framerateMode ? (-1 === this._ruafId && (this._ruafId = C3$jscomp$203.RequestUnlimitedAnimationFrame(a.tickOnly)), -1 === this._rafId && (this._rafId = self.requestAnimationFrame(a.renderOnly))) : -1 === this._ruafId && (this._ruafId = C3$jscomp$203.RequestUnlimitedAnimationFrame(a.normal))
    }
    _CancelAnimationFrame()
    {
        -1 !== this._rafId && (self.cancelAnimationFrame(this._rafId), this._rafId = -1);
        -1 !== this._ruafId && (C3$jscomp$203.CancelUnlimitedAnimationFrame(this._ruafId),
        this._ruafId = -1)
    }
    IsSuspended()
    {
        return 0 < this._suspendCount
    }
    SetSuspended(a)
    {
        if (!this.IsExportToVideo()) {
            var b = this.IsSuspended();
            this._suspendCount += a ? 1 : -1;
            0 > this._suspendCount && (this._suspendCount = 0);
            a = this.IsSuspended();
            !b && a ? (console.log("[Construct] Suspending"), this._CancelAnimationFrame(), this._dispatcher.dispatchEvent(C3$jscomp$203.New(C3$jscomp$203.Event, "suspend")), this.Trigger(C3$jscomp$203.Plugins.System.Cnds.OnSuspend, null, null)) : b && !a && (console.log("[Construct] Resuming"), this._fpsLastTime =
            this._lastTickTime = b = performance.now(), this._mainThreadTimeCounter = this._mainThreadTime = this._tps = this._tpsTickCount = this._fps = this._fpsFrameCount = 0, this._dispatcher.dispatchEvent(C3$jscomp$203.New(C3$jscomp$203.Event, "resume")), this.Trigger(C3$jscomp$203.Plugins.System.Cnds.OnResume, null, null), this.HitBreakpoint() || this.Tick(b))
        }
    }
    _AddBehInstToTick(a)
    {
        this._behInstsToTick.Add(a)
    }
    _AddBehInstToPostTick(a)
    {
        this._behInstsToPostTick.Add(a)
    }
    _AddBehInstToTick2(a)
    {
        this._behInstsToTick2.Add(a)
    }
    _RemoveBehInstToTick(a)
    {
        this._behInstsToTick.Remove(a)
    }
    _RemoveBehInstToPostTick(a)
    {
        this._behInstsToPostTick.Remove(a)
    }
    _RemoveBehInstToTick2(a)
    {
        this._behInstsToTick2.Remove(a)
    }
    _BehaviorTick()
    {
        const a =
        globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick)
            b instanceof a ? b._tick() : b.Tick();
        this._behInstsToTick.SetQueueingEnabled(!1)
    }
    _BehaviorPostTick()
    {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToPostTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToPostTick)
            b instanceof a ? b._postTick() : b.PostTick();
        this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    _BehaviorTick2()
    {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick2.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick2)
            b instanceof a ? b._tick2() : b.Tick2();
        this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick()
    {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick) {
            let c;
            c = b instanceof a ? b._tick() : b.Tick();
            C3$jscomp$203.IsIterator(c) && (yield *c)
        }
        this._behInstsToTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorPostTick()
    {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToPostTick.SetQueueingEnabled(!0);
        for (const b of this._behInstsToPostTick) {
            let c;
            c = b instanceof a ? b._postTick() : b.PostTick();
            C3$jscomp$203.IsIterator(c) && (yield *c)
        }
        this._behInstsToPostTick.SetQueueingEnabled(!1)
    }
    *_DebugBehaviorTick2()
    {
        const a = globalThis.ISDKBehaviorInstanceBase;
        this._behInstsToTick2.SetQueueingEnabled(!0);
        for (const b of this._behInstsToTick2) {
            let c;
            c = b instanceof a ? b._tick2() : b.Tick2();
            C3$jscomp$203.IsIterator(c) && (yield *c)
        }
        this._behInstsToTick2.SetQueueingEnabled(!1)
    }
    async Tick(a, b, c)
    {
        this._hasStartedTicking = !0;
        const d = "background-wake" === c;
        c = "background-wake" !== c && "skip-render" !== c;
        var e = this.GetLayoutManager(),
            f = this.GetCanvasManager();
        if (this._hasStarted && (!this.IsSuspended() || b || d)) {
            b = performance.now();
            this._isInTick = !0;
            this._MeasureDt(a || 0);
            this._tpsTickCount++;
            this._ReleasePendingInstances();
            a = this.Step_BeforePreTick();
            this.IsDebugging() && await a;
            a = this._dispatcher.dispatchEventAndWait_AsyncOptional(this._eventObjects.pretick);
            a instanceof Promise && await a;
            a = this.Step_AfterPreTick();
            this.IsDebugging() &&
            await a;
            this._NeedsHandleSaveOrLoad() && await this._HandleSaveOrLoad();
            e.IsPendingChangeMainLayout() && await this._MaybeChangeLayout();
            a = this.Step_RunEventsEtc();
            this.IsDebugging() && await a;
            a = e.GetMainRunningLayout();
            var g = a._GetPendingSetHTMLLayerCount();
            e = !1;
            -1 !== g && (a._ResetPendingHTMLLayerCount(), f.GetHTMLLayerCount() !== g && (f = this.GetCanvasManager().SetHTMLLayerCount(g), this.IsInWorker() && (e = !0, await f)));
            c && this.Render();
            e && this.PostComponentMessageToDOM("canvas", "cleanup-html-layers");
            if (this.IsExportToVideo() &&
            (await this._ExportToVideoAddFrame(), this.GetGameTime() >= this.GetExportVideoDuration())) {
                this._ExportToVideoFinish();
                return
            }
            this.IsSuspended() || d || this._RequestAnimationFrame();
            this._tickCount++;
            this._tickCountNoSave++;
            this._isInTick = !1;
            this._mainThreadTimeCounter += performance.now() - b
        }
    }
    async Step_BeforePreTick()
    {
        const a = this._eventSheetManager,
            b = this.IsDebug();
        this.FlushPendingInstances();
        a.BlockFlushingInstances(!0);
        this.PushCurrentLayout(this.GetMainRunningLayout());
        b && C3Debugger$jscomp$3.StartMeasuringTime();
        this.IsDebugging() ? await a.DebugRunScheduledWaits() : a.RunScheduledWaits();
        b && C3Debugger$jscomp$3.AddEventsTime();
        this.PopCurrentLayout();
        a.BlockFlushingInstances(!1);
        this.FlushPendingInstances();
        a.BlockFlushingInstances(!0)
    }
    async Step_AfterPreTick()
    {
        const a = this.IsDebug(),
            b = this.IsDebugging(),
            c = this._dispatcher,
            d = this._eventObjects,
            e = this._userScriptEventObjects;
        a && C3Debugger$jscomp$3.StartMeasuringTime();
        b ? await this.DebugIterateAndBreak(this._DebugBehaviorTick()) : this._BehaviorTick();
        b ? await this.DebugIterateAndBreak(this._DebugBehaviorPostTick()) :
        this._BehaviorPostTick();
        a && C3Debugger$jscomp$3.AddBehaviorTickTime();
        a && C3Debugger$jscomp$3.StartMeasuringTime();
        b ? await this.DebugFireGeneratorEventAndBreak(d.tick) : c.dispatchEvent(d.tick);
        a && C3Debugger$jscomp$3.AddPluginTickTime();
        this._eventSheetManager.BlockFlushingInstances(!1);
        this.DispatchUserScriptEvent(e.tick)
    }
    async Step_RunEventsEtc()
    {
        const a = this._eventSheetManager,
            b = this._dispatcher,
            c = this._eventObjects,
            d = this.IsDebug(),
            e = this.IsDebugging();
        d && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await a.DebugRunEvents(this._layoutManager) : a.RunEvents(this._layoutManager);
        d && C3Debugger$jscomp$3.AddEventsTime();
        this._collisionEngine.ClearRegisteredCollisions();
        this._ReleasePendingInstances();
        this._isLayoutFirstTick = !1;
        a.BlockFlushingInstances(!0);
        d && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await this.DebugIterateAndBreak(this._DebugBehaviorTick2()) : this._BehaviorTick2();
        d && C3Debugger$jscomp$3.AddBehaviorTickTime();
        d && C3Debugger$jscomp$3.StartMeasuringTime();
        e ? await this.DebugFireGeneratorEventAndBreak(c.tick2) :
        b.dispatchEvent(c.tick2);
        d && C3Debugger$jscomp$3.AddPluginTickTime();
        a.BlockFlushingInstances(!1);
        e && await a.RunQueuedDebugTriggersAsync()
    }
    _ReleasePendingInstances()
    {
        if (0 !== this._instancesPendingRelease.size) {
            var a = this._dispatcher;
            a.SetDelayRemoveEventsEnabled(!0);
            for (const b of this._instancesPendingReleaseAffectedObjectClasses)
                b.GetSolStack().RemoveInstances(this._instancesPendingRelease);
            this._instancesPendingReleaseAffectedObjectClasses.clear();
            this._eventSheetManager._OnInstancesReleased(this._instancesPendingRelease);
            for (const b of this._instancesPendingRelease)
                b.Release();
            this._instancesPendingRelease.clear();
            a.SetDelayRemoveEventsEnabled(!1)
        }
    }
    async _MaybeChangeLayout()
    {
        const a = this.GetLayoutManager();
        let b = 0;
        for (; a.IsPendingChangeMainLayout() && 10 > b++;)
            await this._DoChangeLayout(a.GetPendingChangeMainLayout())
    }
    _MeasureDt(a)
    {
        let b = 0;
        this.IsExportToVideo() ? this._dt1 = this._dtRaw = b = 1 / this.GetExportVideoFramerate() : 0 !== this._lastTickTime && (b = Math.max(a - this._lastTickTime, 0) / 1E3, .5 < b && (b = 0), this._dtRaw = b, this._dt1 =
        C3$jscomp$203.clamp(b, this._minDt, this._maxDt));
        this._lastTickTime = a;
        this._dt = this._dt1 * this._timeScale;
        this._gameTime.Add(this._dt);
        this._gameTimeRaw.Add(b * this._timeScale);
        this._wallTime.Add(this._dt1);
        for (const [c, d] of this._instanceTimes)
            d.Add(this._dt1 * c.GetTimeScale());
        this._canvasManager && this._canvasManager._UpdateTick();
        1E3 <= a - this._fpsLastTime && (this._fpsLastTime += 1E3, 1E3 <= a - this._fpsLastTime && (this._fpsLastTime = a), this._fps = this._fpsFrameCount, this._fpsFrameCount = 0, this._tps = this._tpsTickCount,
        this._tpsTickCount = 0, this._mainThreadTime = Math.min(this._mainThreadTimeCounter / 1E3, 1), this._mainThreadTimeCounter = 0, this._canvasManager && this._canvasManager._Update1sFrameRange(), this._collisionEngine._Update1sStats(), this.IsDebug() && C3Debugger$jscomp$3.Update1sPerfStats())
    }
    _SetTrackingInstanceTime(a, b)
    {
        b ? this._instanceTimes.has(a) || (b = C3$jscomp$203.New(C3$jscomp$203.KahanSum), b.Copy(this._gameTime), this._instanceTimes.set(a, b)) : this._instanceTimes.delete(a)
    }
    _GetInstanceGameTime(a)
    {
        return (a = this._instanceTimes.get(a)) ?
        a.Get() : this.GetGameTime()
    }
    async _DoChangeLayout(a)
    {
        const b = this._dispatcher,
            c = this.GetLayoutManager().GetMainRunningLayout();
        await c._StopRunning();
        c._Unload(a, this.GetRenderer());
        c === a && this._eventSheetManager.ClearAllScheduledWaits();
        this._collisionEngine.ClearRegisteredCollisions();
        this._ReleasePendingInstances();
        b.dispatchEvent(this._eventObjects.beforelayoutchange);
        C3$jscomp$203.Asyncify.SetHighThroughputMode(!0);
        await a._Load(c, this.GetRenderer());
        C3$jscomp$203.Asyncify.SetHighThroughputMode(!1);
        await a._StartRunning(!1);
        b.dispatchEvent(this._eventObjects.layoutchange);
        this.UpdateRender();
        this._isLayoutFirstTick = !0;
        this.FlushPendingInstances();
        this._ExportToVideoAddKeyframe()
    }
    UpdateRender()
    {
        this._needRender = !0
    }
    GetWebGLRenderer()
    {
        return this._canvasManager ? this._canvasManager.GetWebGLRenderer() : null
    }
    GetWebGPURenderer()
    {
        return this._canvasManager ? this._canvasManager.GetWebGPURenderer() : null
    }
    GetRenderer()
    {
        return this._canvasManager ? this._canvasManager.GetRenderer() : null
    }
    Render()
    {
        const a = this._canvasManager;
        if (a && !a.IsRendererContextLost()) {
            var b = this.GetRenderer(),
                c = b.SupportsGPUProfiling(),
                d = c && b.IsWebGL();
            c = c && b.IsWebGPU();
            d && b.CheckForQueryResults();
            if (this._needRender || this.IsExportToVideo()) {
                var e = this._layoutManager.GetMainRunningLayout();
                this._fpsFrameCount++;
                b.Start();
                var f = this.IsDebug();
                f && C3Debugger$jscomp$3.StartMeasuringTime();
                this._needRender = !1;
                var g = null;
                d && (g = a.GetGPUFrameTimingsBuffer().AddTimeElapsedQuery(), b.StartQuery(g));
                d = null;
                c && (d = b.StartFrameTiming(2 * (1 + e.GetLayerCount())),
                b.StartMeasuringRenderPassTime(0, 1));
                this.Uses3DFeatures() && "low" === a.GetCurrentFullscreenScalingQuality() ? b.SetFixedSizeDepthBuffer(a.GetDrawWidth(), a.GetDrawHeight()) : b.SetAutoSizeDepthBuffer();
                this._Render(this.GetRenderer(), e);
                g && b.EndQuery(g);
                c && (b.StopMeasuringRenderPassTime(), this._canvasManager._AddWebGPUFrameTiming(d));
                b.Finish();
                f && (C3Debugger$jscomp$3.AddDrawCallsTime(), C3Debugger$jscomp$3.UpdateInspectHighlight());
                a && a._MaybeTakeSnapshot()
            } else
                b.IncrementFrameNumber()
        }
    }
    _NeedsHTMLLayerCompositing(a)
    {
        return "low" ===
            this.GetCanvasManager().GetCurrentFullscreenScalingQuality() || a.IsWebGL() && (this.UsesAnyBackgroundBlending() || this.Uses3DFeatures())
    }
    _Render(a, b)
    {
        a.SetTextureFillMode();
        a.SetAlphaBlend();
        a.SetColorRgba(1, 1, 1, 1);
        a.SetRenderTarget(null);
        a.SetTexture(null);
        a.SetDepthEnabled(this.Uses3DFeatures());
        this._NeedsHTMLLayerCompositing(a) && b._MaybeStartDrawToOwnTexture(a);
        const c = b.GetHTMLLayerCount();
        for (let d = 1; d < c; ++d)
            b.DrawForHTMLLayerIndex(a, d),
            a.IsWebGPU() && a.Restart();
        this._NeedsHTMLLayerCompositing(a) ||
        b._MaybeStartDrawToOwnTexture(a);
        b.DrawMain(a)
    }
    Trigger(a, b, c)
    {
        if (!this._hasStarted)
            return !1;
        var d = !this._isInTick && !this._eventSheetManager.IsInTrigger();
        let e = 0;
        d && (e = performance.now());
        const f = this.IsDebug();
        f && this.SetDebuggingEnabled(!1);
        a = this._eventSheetManager._Trigger(this._layoutManager, a, b, c);
        d && (d = performance.now() - e, this._mainThreadTimeCounter += d, f && C3Debugger$jscomp$3.AddTriggersTime(d));
        f && this.SetDebuggingEnabled(!0);
        return a
    }
    DebugTrigger(a, b, c)
    {
        if (!this.IsDebugging())
            return this.Trigger(a,
            b, c);
        if (this.HitBreakpoint())
            throw Error("called DebugTrigger() while stopped on breakpoint");
        if (!this._isInTick && !this._eventSheetManager.IsInTrigger())
            throw Error("called DebugTrigger() outside of event code - use TriggerAsync() instead");
        return this._eventSheetManager._DebugTrigger(this._layoutManager, a, b, c)
    }
    async TriggerAsync(a, b, c)
    {
        if (!this.IsDebugging())
            return this.Trigger(a, b, c);
        if (!this._hasStarted)
            return !1;
        if (this.HitBreakpoint())
            return this._eventSheetManager.QueueDebugTrigger(a, b, c);
        if (!this.GetMainRunningLayout())
            return this._eventSheetManager.QueueTrigger(a,
            b, c);
        const d = performance.now();
        a = this._eventSheetManager._DebugTrigger(this._layoutManager, a, b, c);
        for (b = a.next(); !b.done;)
            await this.DebugBreak(b.value),
            b = a.next();
        this.IsSuspended() || this._eventSheetManager.IsInTrigger() || (await this._eventSheetManager.RunQueuedDebugTriggersAsync(), this._hasStartedTicking && !this._isInTick && this._RequestAnimationFrame());
        this._mainThreadTimeCounter += performance.now() - d;
        return b.value
    }
    FastTrigger(a, b, c)
    {
        const d = this.IsDebug();
        d && this.SetDebuggingEnabled(!1);
        a = this._eventSheetManager._FastTrigger(this._layoutManager,
        a, b, c);
        d && this.SetDebuggingEnabled(!0);
        return a
    }
    DebugFastTrigger(a, b, c)
    {
        return this._eventSheetManager._DebugFastTrigger(this._layoutManager, a, b, c)
    }
    ScheduleTriggers(a)
    {
        return this._scheduleTriggersThrottle.Add(a)
    }
    PushCurrentLayout(a)
    {
        this._currentLayoutStack.push(a)
    }
    PopCurrentLayout()
    {
        if (!this._currentLayoutStack.length)
            throw Error("layout stack empty");
        this._currentLayoutStack.pop()
    }
    GetCurrentLayout()
    {
        return this._currentLayoutStack.length ? this._currentLayoutStack.at(-1) : this.GetMainRunningLayout()
    }
    GetDt(a)
    {
        return a &&
        -1 !== a.GetTimeScale() ? this._dt1 * a.GetTimeScale() : this._dt
    }
    _GetDtFast()
    {
        return this._dt
    }
    GetDt1()
    {
        return this._dt1
    }
    GetDtRaw()
    {
        return this._dtRaw
    }
    GetTimeScale()
    {
        return this._timeScale
    }
    SetTimeScale(a)
    {
        if (isNaN(a) || 0 > a)
            a = 0;
        this._timeScale = a
    }
    SetMinDt(a)
    {
        this._minDt = Math.max(a, 0)
    }
    GetMinDt()
    {
        return this._minDt
    }
    SetMaxDt(a)
    {
        this._maxDt = Math.max(a, 0)
    }
    GetMaxDt()
    {
        return this._maxDt
    }
    GetFramesPerSecond()
    {
        return this._fps
    }
    GetTicksPerSecond()
    {
        return this._tps
    }
    GetMainThreadTime()
    {
        return this._mainThreadTime
    }
    GetStartTime()
    {
        return this._startTime
    }
    GetGameTime()
    {
        return this._gameTime.Get()
    }
    GetGameTimeRaw()
    {
        return this._gameTimeRaw.Get()
    }
    GetWallTime()
    {
        return this._wallTime.Get()
    }
    GetTickCount()
    {
        return this._tickCount
    }
    GetTickCountNoSave()
    {
        return this._tickCountNoSave
    }
    GetObjectCount()
    {
        return this._objectCount
    }
    GetProjectName()
    {
        return this._projectName
    }
    GetProjectVersion()
    {
        return this._projectVersion
    }
    GetProjectUniqueId()
    {
        return this._projectUniqueId
    }
    GetAppId()
    {
        return this._appId
    }
    GetInstanceByUID(a)
    {
        if (this._isLoadingState)
            throw Error("cannot call while loading state - wait until afterload event");
        return this._instancesByUid.get(a) || null
    }
    _RefreshUidMap()
    {
        this._instancesByUid.clear();
        for (const a of this._allObjectClasses)
            if (!a.IsFamily())
                for (const b of a.GetInstances())
                    this._instancesByUid.set(b.GetUID(), b)
    }
    IsPreview()
    {
        return "preview" === this._exportType
    }
    IsDebug()
    {
        return this._isDebug
    }
    GetExportType()
    {
        return this._exportType
    }
    IsCordova()
    {
        return "cordova" === this._exportType
    }
    IsAndroidWebView()
    {
        return "Android" === C3$jscomp$203.Platform.OS && ("cordova" === this._exportType || "playable-ad-single-file" ===
            this._exportType || "playable-ad-zip" === this._exportType || "instant-games" === this._exportType)
    }
    IsiOSCordova()
    {
        return this._isiOSCordova
    }
    IsiOSWebView()
    {
        return this._isiOSWebView
    }
    IsWindowsWebView2()
    {
        return this._isWindowsWebView2
    }
    IsAnyWebView2Wrapper()
    {
        return this._isAnyWebView2Wrapper
    }
    GetCollisionEngine()
    {
        return this._collisionEngine
    }
    GetSolidBehavior()
    {
        return this._addonManager.GetSolidBehavior()
    }
    GetJumpthruBehavior()
    {
        return this._addonManager.GetJumpthruBehavior()
    }
    Uses3DFeatures()
    {
        return this._uses3dFeatures
    }
    GetZScaleFactor()
    {
        return this.GetRenderer().GetZAxisScaleFactor(this.GetViewportHeight())
    }
    GetDefaultCameraZ(a)
    {
        return this.GetRenderer().GetDefaultCameraZ(a ||
        this.GetViewportHeight())
    }
    IsLayoutFirstTick()
    {
        return this._isLayoutFirstTick
    }
    SetPixelRoundingEnabled(a)
    {
        a = !!a;
        this._isPixelRoundingEnabled !== a && (this._isPixelRoundingEnabled = a, this.GetLayoutManager().SetAllLayerMVChanged(), this.UpdateRender())
    }
    IsPixelRoundingEnabled()
    {
        return this._isPixelRoundingEnabled
    }
    GetTextIconSet(a)
    {
        if (!this._iconChangeHandlers.has(a)) {
            var b = () => this.DeleteTextIconSet(a);
            this._iconChangeHandlers.set(a, b);
            a.Dispatcher().addEventListener("animationframeimagechange", b)
        }
        b = this._textIconManager.GetIconSet(a);
        b.HasLoaded() || b.LoadContent().then(() => this.UpdateRender());
        return b
    }
    DeleteTextIconSet(a)
    {
        this._textIconManager.DeleteIconSet(a)
    }
    _GetTextIconSetMeta(a)
    {
        const b = [];
        for (const c of a.GetAnimations())
            for (const d of c.GetFrames())
                a = d.GetImageInfo(),
                b.push({
                    source: d,
                    width: a.GetWidth(),
                    height: a.GetHeight(),
                    tag: d.GetTag()
                });
        return {
            icons: b
        }
    }
    async _GetTextIconSetContent(a)
    {
        const b = C3$jscomp$203.New(C3$jscomp$203.PromiseThrottle);
        var c = [];
        const d = new Map;
        for (const e of a.GetAnimations())
            for (const f of e.GetFrames()) {
                const g =
                f.GetImageInfo().GetImageAsset();
                d.has(g) || (d.set(g, null), c.push(b.Add(async () => {
                    const h = await g.LoadToDrawable();
                    d.set(g, h)
                })))
            }
        await Promise.all(c);
        c = [];
        for (const e of a.GetAnimations())
            for (const f of e.GetFrames())
                c.push(b.Add(async () => {
                    var g = f.GetImageInfo();
                    const h = d.get(g.GetImageAsset());
                    g = await g.ExtractImageToCanvas(h);
                    return {
                        drawable: await createImageBitmap(g)
                    }
                }));
        a = await Promise.all(c);
        for (const e of d.values())
            e instanceof ImageBitmap && e.close && e.close();
        return {
            icons: a
        }
    }
    SaveToSlot(a)
    {
        this._saveToSlotName =
        a
    }
    LoadFromSlot(a)
    {
        this._loadFromSlotName = a
    }
    LoadFromJsonString(a)
    {
        this._loadFromJson = a
    }
    GetLastSaveJsonString()
    {
        return this._lastSaveJson
    }
    _NeedsHandleSaveOrLoad()
    {
        return !(!this._saveToSlotName && !this._loadFromSlotName && null === this._loadFromJson)
    }
    async _HandleSaveOrLoad()
    {
        this._saveToSlotName && (this.FlushPendingInstances(), await this._DoSaveToSlot(this._saveToSlotName), this._ClearSaveOrLoad());
        this._loadFromSlotName && (await this._DoLoadFromSlot(this._loadFromSlotName), this._ClearSaveOrLoad(), this.IsDebug() &&
        C3Debugger$jscomp$3.StepIfPausedInDebugger());
        if (null !== this._loadFromJson) {
            this.FlushPendingInstances();
            try {
                await this._DoLoadFromJsonString(this._loadFromJson),
                this._lastSaveJson = this._loadFromJson,
                await this.TriggerAsync(C3$jscomp$203.Plugins.System.Cnds.OnLoadComplete, null),
                this._lastSaveJson = ""
            } catch (a) {
                console.error("[Construct] Failed to load state from JSON string: ", a),
                await this.TriggerAsync(C3$jscomp$203.Plugins.System.Cnds.OnLoadFailed, null)
            }
            this._ClearSaveOrLoad()
        }
    }
    _ClearSaveOrLoad()
    {
        this._loadFromSlotName =
        this._saveToSlotName = "";
        this._loadFromJson = null
    }
    _GetProjectStorage()
    {
        this._projectStorage || (this._projectStorage = localforage.createInstance({
            name: "c3-localstorage-" + this.GetProjectUniqueId(),
            description: this.GetProjectName()
        }));
        return this._projectStorage
    }
    _GetSavegamesStorage()
    {
        this._savegamesStorage || (this._savegamesStorage = localforage.createInstance({
            name: "c3-savegames-" + this.GetProjectUniqueId(),
            description: this.GetProjectName()
        }));
        return this._savegamesStorage
    }
    async _DoSaveToSlot(a)
    {
        const b = await this._SaveToJsonString();
        try {
            await this._GetSavegamesStorage().setItem(a, b),
            console.log("[Construct] Saved state to storage (" + b.length + " chars)"),
            this._lastSaveJson = b,
            await this.TriggerAsync(C3$jscomp$203.Plugins.System.Cnds.OnSaveComplete, null),
            this._lastSaveJson = ""
        } catch (c) {
            console.error("[Construct] Failed to save state to storage: ", c),
            await this.TriggerAsync(C3$jscomp$203.Plugins.System.Cnds.OnSaveFailed, null)
        }
    }
    async _DoLoadFromSlot(a)
    {
        try {
            const b = await this._GetSavegamesStorage().getItem(a);
            if (!b)
                throw Error("empty slot");
            console.log("[Construct] Loaded state from storage (" + b.length + " chars)");
            await this._DoLoadFromJsonString(b);
            this._lastSaveJson = b;
            await this.TriggerAsync(C3$jscomp$203.Plugins.System.Cnds.OnLoadComplete, null);
            this._lastSaveJson = ""
        } catch (b) {
            console.error("[Construct] Failed to load state from storage: ", b),
            await this.TriggerAsync(C3$jscomp$203.Plugins.System.Cnds.OnLoadFailed, null)
        }
    }
    async _SaveToJsonString()
    {
        const a = {
            c3save: !0,
            version: 1,
            rt: {
                time: this.GetGameTime(),
                timeRaw: this.GetGameTimeRaw(),
                walltime: this.GetWallTime(),
                timescale: this.GetTimeScale(),
                tickcount: this.GetTickCount(),
                next_uid: this._nextUid,
                running_layout: this.GetMainRunningLayout().GetSID(),
                start_time_offset: Date.now() - this._startTime
            },
            types: {},
            layouts: {},
            events: this._eventSheetManager._SaveToJson(),
            timelines: this._timelineManager._SaveToJson(),
            user_script_data: null
        };
        for (var b of this._allObjectClasses)
            b.IsFamily() || b.HasNoSaveBehavior() || (a.types[b.GetSID().toString()] = b._SaveToJson());
        for (const c of this._layoutManager.GetAllLayouts())
            a.layouts[c.GetSID().toString()] =
            c._SaveToJson();
        b = this._CreateUserScriptEvent("save");
        b.saveData = null;
        await this.DispatchUserScriptEventAsyncWait(b);
        a.user_script_data = b.saveData;
        return JSON.stringify(a)
    }
    IsLoadingState()
    {
        return this._isLoadingState
    }
    async _DoLoadFromJsonString(a)
    {
        var b = this.GetLayoutManager();
        a = JSON.parse(a);
        if (a.c2save)
            throw Error("C2 saves are incompatible with C3 runtime");
        if (!a.c3save)
            throw Error("not valid C3 save data");
        if (1 < a.version)
            throw Error("C3 save data from future version");
        this.ClearIntancesNeedingAfterLoad();
        this._dispatcher.dispatchEvent(C3$jscomp$203.New(C3$jscomp$203.Event, "beforeload"));
        for (var c of this.allInstances())
            c.GetObjectClass().HasNoSaveBehavior() || c._OnBeforeLoad();
        c = a.rt;
        this._gameTime.Set(c.time);
        c.hasOwnProperty("timeRaw") && this._gameTimeRaw.Set(c.timeRaw);
        this._wallTime.Set(c.walltime);
        this._timeScale = c.timescale;
        this._tickCount = c.tickcount;
        this._startTime = Date.now() - c.start_time_offset;
        var d = c.running_layout;
        this._isLoadingState = !0;
        let e = !1;
        if (d !== this.GetMainRunningLayout().GetSID())
            if (d =
            b.GetLayoutBySID(d))
                await this._DoChangeLayout(d),
                e = !0;
            else
                return;
        for (const [k, l] of Object.entries(a.layouts))
            d = parseInt(k, 10),
            (d = b.GetLayoutBySID(d)) && d._LoadFromJson(l);
        d = new Set;
        for (const [k, l] of Object.entries(a.types)) {
            var f = parseInt(k, 10);
            f = this.GetObjectClassBySID(f);
            !f || f.IsFamily() || f.HasNoSaveBehavior() || f._LoadFromJson(l, d)
        }
        for (var g of this._layoutManager.GetAllLayouts())
            for (const k of g.allLayers())
                k._LoadFromJsonAfterInstances();
        this.FlushPendingInstances();
        this._RefreshUidMap();
        this._isLoadingState =
        !1;
        if (e) {
            for (const k of this.allInstances())
                k.SetupInitialSceneGraphConnections();
            for (const [k, l] of Object.entries(a.types))
                g = parseInt(k, 10),
                g = this.GetObjectClassBySID(g),
                !g || g.IsFamily() || g.HasNoSaveBehavior() || g._SetupSceneGraphConnectionsOnChangeOfLayout(l)
        }
        this._nextUid = c.next_uid;
        this._eventSheetManager._LoadFromJson(a.events);
        for (const k of this._allObjectClasses)
            if (!k.IsFamily() && k.IsInContainer())
                for (const l of k.GetInstances()) {
                    c = l.GetIID();
                    for (const m of k.GetContainer().objectTypes())
                        if (m !==
                        k) {
                            g = m.GetInstances();
                            if (0 > c || c >= g.length)
                                throw Error("missing sibling instance");
                            l._AddSibling(g[c])
                        }
                }
        this._timelineManager._LoadFromJson(a.timelines);
        b.SetAllLayerProjectionChanged();
        b.SetAllLayerMVChanged();
        for (const k of d)
            k._OnCreatedForLoadingSavegame();
        this.DoAfterLoad();
        this._dispatcher.dispatchEvent(C3$jscomp$203.New(C3$jscomp$203.Event, "afterload"));
        this.DispatchUserScriptEvent(this._CreateUserScriptEvent("afterload"));
        for (var [h] of Object.entries(a.types))
            b = parseInt(h, 10),
            (b = this.GetObjectClassBySID(b)) &&
            b._ClearLoadInstancesJson();
        h = this._CreateUserScriptEvent("load");
        h.saveData = a.user_script_data;
        await this.DispatchUserScriptEventAsyncWait(h);
        this.UpdateRender()
    }
    SortOnTmpHierarchyPosition(a, b)
    {
        return a.GetWorldInfo().GetTmpHierarchyPosition() - b.GetWorldInfo().GetTmpHierarchyPosition()
    }
    AddInstanceNeedingAfterLoad(a, b)
    {
        a.GetWorldInfo() && !this._instancesNeedingAfterLoadMap.has(a) && (this._instancesNeedingAfterLoadMap.set(a, b), this._instancesNeedingAfterLoadArray.push(a))
    }
    ClearIntancesNeedingAfterLoad()
    {
        this._instancesNeedingAfterLoadMap =
        new WeakMap;
        C3$jscomp$203.clearArray(this._instancesNeedingAfterLoadArray)
    }
    DoAfterLoad(a="full", b=null)
    {
        this._instancesNeedingAfterLoadArray.sort(this.SortOnTmpHierarchyPosition);
        for (const c of this._instancesNeedingAfterLoadArray)
            c._OnAfterLoad(this._instancesNeedingAfterLoadMap.get(c), a, b);
        for (const c of this._instancesNeedingAfterLoadArray)
            c._OnAfterLoad2(this._instancesNeedingAfterLoadMap.get(c), a, b);
        this.ClearIntancesNeedingAfterLoad()
    }
    async AddJobWorkerScripts(a)
    {
        a = await Promise.all(a.map(async b =>
        this.IsCordova() && this._assetManager.IsFileProtocol() || "playable-ad-single-file" === this.GetExportType() ? (b = await this._assetManager.FetchBlob(b), URL.createObjectURL(b)) : (new URL(b, location.href)).toString()));
        this._jobScheduler.ImportScriptsToJobWorkers(a)
    }
    AddJobWorkerBlob(a, b)
    {
        this._jobScheduler.SendBlobToJobWorkers(a, b)
    }
    AddJobWorkerBuffer(a, b)
    {
        this._jobScheduler.SendBufferToJobWorkers(a, b)
    }
    AddJob(a, b, c, d)
    {
        return this._jobScheduler.AddJob(a, b, c, null, null, d)
    }
    BroadcastJob(a, b, c, d)
    {
        return this._jobScheduler.BroadcastJob(a,
        b, c, d)
    }
    GetMaxNumJobWorkers()
    {
        return this._jobScheduler.GetMaxNumWorkers()
    }
    InvokeDownload(a, b)
    {
        this.PostComponentMessageToDOM("runtime", "invoke-download", {
            url: a,
            filename: b
        })
    }
    async RasterSvgImage(a, b, c, d, e, f)
    {
        d = d || b;
        e = e || c;
        if (this.IsInWorker())
            return (await this.PostComponentMessageToDOMAsync("runtime", "raster-svg-image", {
                blob: a,
                imageWidth: b,
                imageHeight: c,
                surfaceWidth: d,
                surfaceHeight: e,
                imageBitmapOpts: f
            })).imageBitmap;
        a = await self.C3_RasterSvgImageBlob(a, b, c, d, e);
        return f ? await self.createImageBitmap(a,
        f) : a
    }
    async GetSvgImageSize(a)
    {
        return this.IsInWorker() ? await this.PostComponentMessageToDOMAsync("runtime", "get-svg-image-size", {
            blob: a
        }) : await self.C3_GetSvgImageSize(a)
    }
    RequestDeviceOrientationEvent()
    {
        this._didRequestDeviceOrientationEvent || (this._didRequestDeviceOrientationEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-orientation"))
    }
    RequestDeviceMotionEvent()
    {
        this._didRequestDeviceMotionEvent || (this._didRequestDeviceMotionEvent = !0, this.PostComponentMessageToDOM("runtime", "enable-device-motion"))
    }
    Random()
    {
        return this._randomNumberCallback()
    }
    SetRandomNumberGeneratorCallback(a)
    {
        this._randomNumberCallback =
        a
    }
    _GetRemotePreviewStatusInfo()
    {
        const a = this.GetRenderer();
        return {
            fps: this.GetFramesPerSecond(),
            tps: this.GetTicksPerSecond(),
            cpu: this.GetMainThreadTime(),
            gpu: this.GetGPUUtilisation(),
            layout: this.GetMainRunningLayout() ? this.GetMainRunningLayout().GetName() : "",
            renderer: a.IsWebGL() ? a.GetUnmaskedRenderer() : a.GetAdapterInfoString()
        }
    }
    HitBreakpoint()
    {
        return this.IsDebug() ? C3Debugger$jscomp$3.HitBreakpoint() : !1
    }
    DebugBreak(a)
    {
        return this.IsDebugging() ? C3Debugger$jscomp$3.DebugBreak(a) : Promise.resolve()
    }
    DebugBreakNext()
    {
        return this.IsDebugging() ?
        C3Debugger$jscomp$3.BreakNext() : !1
    }
    SetDebugBreakpointsEnabled(a)
    {
        this._breakpointsEnabled = !!a;
        this._UpdateDebuggingFlag()
    }
    AreDebugBreakpointsEnabled()
    {
        return this._breakpointsEnabled
    }
    IsDebugging()
    {
        return this._isDebugging
    }
    SetDebuggingEnabled(a)
    {
        a ? this._debuggingDisabled-- : this._debuggingDisabled++;
        this._UpdateDebuggingFlag()
    }
    _UpdateDebuggingFlag()
    {
        this._isDebugging = this.IsDebug() && this._breakpointsEnabled && 0 === this._debuggingDisabled
    }
    IsCPUProfiling()
    {
        return this.IsDebug() && C3Debugger$jscomp$3.IsCPUProfiling()
    }
    IsGPUProfiling()
    {
        return this.IsDebug() &&
            this.GetRenderer().SupportsGPUProfiling() && C3Debugger$jscomp$3.IsGPUProfiling()
    }
    async DebugIterateAndBreak(a)
    {
        if (a)
            for (const b of a)
                await this.DebugBreak(b)
    }
    DebugFireGeneratorEventAndBreak(a)
    {
        return this.DebugIterateAndBreak(this._dispatcher.dispatchGeneratorEvent(a))
    }
    _InvokeFunctionFromJS(a)
    {
        return this._eventSheetManager._InvokeFunctionFromJS(a.name, a.params)
    }
    _GetHTMLLayerWrapElement(a)
    {
        if (this.IsInWorker())
            throw Error("not supported in worker mode");
        return self.c3_runtimeInterface._GetHTMLWrapElement(a)
    }
    GetIRuntime()
    {
        return this._iRuntime
    }
    _CreateUserScriptEvent(a)
    {
        a =
        C3$jscomp$203.New(C3$jscomp$203.Event, a, !1);
        a.runtime = this._iRuntime;
        return a
    }
    _InitScriptInterfaces()
    {
        this._iRuntime = new self.IRuntime(this);
        this._userScriptEventObjects = {
            tick: this._CreateUserScriptEvent("tick")
        }
    }
    _InitObjectsScriptInterface()
    {
        const a = {};
        for (const b of this._allObjectClasses)
            a[b.GetJsPropName()] = {
                value: b.GetIObjectClass(),
                enumerable: !0,
                writable: !1
            };
        this._iRuntime._InitObjects(a)
    }
    _InitGlobalVariableScriptInterface()
    {
        const a = {};
        for (const b of this.GetEventSheetManager().GetAllGlobalVariables())
            a[b.GetJsPropName()] =
            b._GetScriptInterfaceDescriptor();
        this._iRuntime._InitGlobalVars(a)
    }
    _GetCommonScriptInterfaces()
    {
        return this._commonScriptInterfaces
    }
    _MapScriptInterface(a, b)
    {
        this._interfaceMap.set(a, b)
    }
    _UnwrapScriptInterface(a)
    {
        return this._interfaceMap.get(a)
    }
    _UnwrapIObjectClass(a)
    {
        if (!(a instanceof self.IObjectClass))
            throw new TypeError("expected IObjectClass");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$203.ObjectClass))
            throw Error("invalid IObjectClass");
        return a
    }
    _UnwrapIInstance(a)
    {
        if (!(a instanceof
        self.IInstance))
            throw new TypeError("expected IInstance");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$203.Instance))
            throw Error("invalid IInstance");
        return a
    }
    _UnwrapIWorldInstance(a)
    {
        if (!(a instanceof self.IWorldInstance))
            throw new TypeError("expected IWorldInstance");
        a = this._UnwrapScriptInterface(a);
        if (!(a && a instanceof C3$jscomp$203.Instance))
            throw Error("invalid IInstance");
        return a
    }
}
;
self.C3_CreateRuntime = C3$jscomp$203.Runtime.Create;
self.C3_InitRuntime = (a, b) => a.Init(b);
"use strict";
const C3$jscomp$204 = self.C3;
C3$jscomp$204.JobSchedulerRuntime = class  extends C3$jscomp$204.DefendedBase{
    constructor(a, b)
    {
        super();
        this._runtime = a;
        this._jobPromises = new Map;
        this._nextJobId = 0;
        this._inputPort = b.inputPort;
        b.outputPort.onmessage = c => this._OnJobWorkerMessage(c);
        this._maxNumWorkers = b.maxNumWorkers;
        this._jobWorkerCount = 1;
        this._hadErrorCreatingWorker = this._isCreatingWorker = !1
    }
    async Init() {}
    GetMaxNumWorkers()
    {
        return this._maxNumWorkers
    }
    ImportScriptsToJobWorkers(a)
    {
        this._inputPort.postMessage({
            type: "_import_scripts",
            scripts: a
        })
    }
    SendBlobToJobWorkers(a,
    b)
    {
        this._inputPort.postMessage({
            type: "_send_blob",
            blob: a,
            id: b
        })
    }
    SendBufferToJobWorkers(a, b)
    {
        this._inputPort.postMessage({
            type: "_send_buffer",
            buffer: a,
            id: b
        }, [a])
    }
    AddJob(a, b, c, d, e, f)
    {
        c || (c = []);
        if ("number" === typeof f && (f = Math.floor(f), 0 >= f))
            throw Error("invalid maxWorkerNum");
        const g = this._nextJobId++;
        a = {
            type: a,
            isBroadcast: !1,
            maxWorkerNum: f,
            jobId: g,
            params: b,
            transferables: c
        };
        b = new Promise((h, k) => {
            this._jobPromises.set(g, {
                resolve: h,
                progress: d,
                reject: k,
                cancelled: !1,
                maxWorkerNum: f
            })
        });
        e && e.SetAction(() =>
        this._CancelJob(g));
        this._inputPort.postMessage(a, c);
        this._MaybeCreateExtraWorker();
        return b
    }
    BroadcastJob(a, b, c, d)
    {
        c || (c = []);
        if ("number" === typeof d && (d = Math.floor(d), 0 >= d))
            throw Error("invalid maxWorkerNum");
        const e = this._nextJobId++;
        this._inputPort.postMessage({
            type: a,
            isBroadcast: !0,
            maxWorkerNum: d,
            jobId: e,
            params: b,
            transferables: c
        }, c)
    }
    _CancelJob(a)
    {
        const b = this._jobPromises.get(a);
        b && (b.cancelled = !0, b.resolve = null, b.progress = null, b.reject = null, this._inputPort.postMessage({
            type: "_cancel",
            jobId: a
        }))
    }
    _OnJobWorkerMessage(a)
    {
        a =
        a.data;
        const b = a.type,
            c = a.jobId;
        switch (b) {
        case "result":
            this._OnJobResult(c, a.result);
            break;
        case "progress":
            this._OnJobProgress(c, a.progress);
            break;
        case "error":
            this._OnJobError(c, a.error);
            break;
        case "ready":
            this._OnJobWorkerReady();
            break;
        default:
            throw Error(`unknown message from worker '${b}'`);
        }
    }
    _OnJobResult(a, b)
    {
        const c = this._jobPromises.get(a);
        if (!c)
            throw Error("invalid job ID");
        c.cancelled || c.resolve(b);
        this._jobPromises.delete(a)
    }
    _OnJobProgress(a, b)
    {
        a = this._jobPromises.get(a);
        if (!a)
            throw Error("invalid job ID");
        !a.cancelled && a.progress && a.progress(b)
    }
    _OnJobError(a, b)
    {
        const c = this._jobPromises.get(a);
        if (!c)
            throw Error("invalid job ID");
        c.cancelled || c.reject(b);
        this._jobPromises.delete(a)
    }
    _OnJobWorkerReady()
    {
        this._isCreatingWorker && (this._isCreatingWorker = !1, this._jobWorkerCount++, this._jobWorkerCount < this._maxNumWorkers ? this._MaybeCreateExtraWorker() : this._inputPort.postMessage({
            type: "_no_more_workers"
        }))
    }
    _GetWorkerCountNeededForPendingJobs()
    {
        let a = 0;
        const b = [...this._jobPromises.values()].sort((c, d) => (c.maxWorkerNum ||
        Infinity) - (d.maxWorkerNum || Infinity));
        for (const c of b)
            a < (c.maxWorkerNum || Infinity) && a++;
        return a
    }
    async _MaybeCreateExtraWorker()
    {
        if (!(this._jobWorkerCount >= this._maxNumWorkers || this._isCreatingWorker || this._hadErrorCreatingWorker || this._GetWorkerCountNeededForPendingJobs() <= this._jobWorkerCount))
            try {
                this._isCreatingWorker = !0,
                (await this._runtime.PostComponentMessageToDOMAsync("runtime", "create-job-worker")).outputPort.onmessage = a => this._OnJobWorkerMessage(a)
            } catch (a) {
                this._hadErrorCreatingWorker =
                !0,
                this._isCreatingWorker = !1,
                console.error(`[Construct] Failed to create job worker; stopping creating any more (created ${this._jobWorkerCount} so far)`, a)
            }
    }
}
;
self.C3_Shaders = {};
"use strict";
const C3$jscomp$205 = self.C3;
let cacheRegex = null,
    lastRegex = "",
    lastFlags = "",
    regexMatches = [],
    lastMatchesStr = "",
    lastMatchesRegex = "",
    lastMatchesFlags = "";
const forEachStack = C3$jscomp$205.New(C3$jscomp$205.ArrayStack);
function ForEachOrdered_SortInstances(a, b) {
    a = a[1];
    b = b[1];
    if ("number" === typeof a && "number" === typeof b)
        return a - b;
    a = "" + a;
    b = "" + b;
    return a < b ? -1 : a > b ? 1 : 0
}
C3$jscomp$205.Plugins.System = class  extends C3$jscomp$205.SDKPluginBase{
    constructor(a)
    {
        super(a);
        this._loopStack = this._runtime.GetEventSheetManager().GetLoopStack();
        this._eventStack = this._runtime.GetEventSheetManager().GetEventStack();
        this._imagesLoadingComplete = this._imagesLoadingTotal = 0;
        this._functionMaps = new Map
    }
    Release()
    {
        super.Release()
    }
    UpdateRender()
    {
        this._runtime.UpdateRender()
    }
    Trigger(a)
    {
        this._runtime.Trigger(a, null, null)
    }
    GetRegex(a, b)
    {
        cacheRegex && a === lastRegex && b === lastFlags || (cacheRegex = new RegExp(a,
        b), lastRegex = a, lastFlags = b);
        cacheRegex.lastIndex = 0;
        return cacheRegex
    }
    GetRegexMatches(a, b, c)
    {
        if (a === lastMatchesStr && b === lastMatchesRegex && c === lastMatchesFlags)
            return regexMatches;
        const d = this.GetRegex(b, c);
        regexMatches = a.match(d);
        lastMatchesStr = a;
        lastMatchesRegex = b;
        lastMatchesFlags = c;
        return regexMatches
    }
    async _LoadTexturesForObjectClasses(a, b)
    {
        if (b.length) {
            this._imagesLoadingTotal += b.length;
            var c = [];
            for (const d of b)
                c.push(a.MaybeLoadTexturesFor(d));
            await C3$jscomp$205.PromiseAllWithProgress(c, () =>
            {
                this._imagesLoadingComplete++
            });
            this._imagesLoadingComplete++;
            this._imagesLoadingComplete === this._imagesLoadingTotal && (this._imagesLoadingTotal = this._imagesLoadingComplete = 0, this._runtime.Trigger(C3$jscomp$205.Plugins.System.Cnds.OnImageLoadingComplete, null, null))
        }
    }
    _UnloadTexturesForObjectClasses(a, b)
    {
        for (const c of b)
            0 === c.GetInstanceCount() && a.MaybeUnloadTexturesFor(c)
    }
    _GetForEachStack()
    {
        return forEachStack
    }
    _Repeat(a)
    {
        var b = this._runtime.GetEventSheetManager();
        const c = b.GetEventStack(),
            d = c.GetCurrentStackFrame(),
            e = d.GetCurrentEvent(),
            f = e.GetSolModifiers();
        var g = d.IsSolModifierAfterCnds();
        const h = c.Push(e),
            k = b.GetLoopStack(),
            l = k.Push();
        l.SetEnd(a);
        if (g)
            for (g = 0; g < a && !l.IsStopped(); ++g)
                b.PushCopySol(f),
                l.SetIndex(g),
                e.Retrigger(d, h),
                b.PopSol(f);
        else
            for (b = 0; b < a && !l.IsStopped(); ++b)
                l.SetIndex(b),
                e.Retrigger(d, h);
        c.Pop();
        k.Pop();
        return !1
    }
    *_DebugRepeat(a)
    {
        var b = this._runtime.GetEventSheetManager();
        const c = b.GetEventStack(),
            d = c.GetCurrentStackFrame(),
            e = d.GetCurrentEvent(),
            f = e.GetSolModifiers();
        var g = d.IsSolModifierAfterCnds();
        const h = c.Push(e),
            k = b.GetLoopStack(),
            l = k.Push();
        l.SetEnd(a);
        if (g)
            for (g = 0; g < a && !l.IsStopped(); ++g)
                b.PushCopySol(f),
                l.SetIndex(g),
                yield *e.DebugRetrigger(d, h),
                b.PopSol(f);
        else
            for (b = 0; b < a && !l.IsStopped(); ++b)
                l.SetIndex(b),
                yield *e.DebugRetrigger(d, h);
        c.Pop();
        k.Pop();
        return !1
    }
    _While()
    {
        var a = this._runtime.GetEventSheetManager();
        const b = a.GetEventStack(),
            c = b.GetCurrentStackFrame(),
            d = c.GetCurrentEvent(),
            e = d.GetSolModifiers();
        var f = c.IsSolModifierAfterCnds();
        const g = b.Push(d),
            h = a.GetLoopStack(),
            k = h.Push();
        if (f)
            for (f = 0; !k.IsStopped(); ++f)
                a.PushCopySol(e),
                k.SetIndex(f),
                d.Retrigger(c, g) || k.Stop(),
                a.PopSol(e);
        else
            for (a = 0; !k.IsStopped(); ++a)
                k.SetIndex(a),
                d.Retrigger(c, g) || k.Stop();
        b.Pop();
        h.Pop();
        return !1
    }
    *_DebugWhile()
    {
        var a = this._runtime.GetEventSheetManager();
        const b = a.GetEventStack(),
            c = b.GetCurrentStackFrame(),
            d = c.GetCurrentEvent(),
            e = d.GetSolModifiers();
        var f = c.IsSolModifierAfterCnds();
        const g = b.Push(d),
            h = a.GetLoopStack(),
            k = h.Push();
        if (f)
            for (f = 0; !k.IsStopped(); ++f)
                a.PushCopySol(e),
                k.SetIndex(f),
                (yield *d.DebugRetrigger(c,
                g)) || k.Stop(),
                a.PopSol(e);
        else
            for (a = 0; !k.IsStopped(); ++a)
                k.SetIndex(a),
                (yield *d.DebugRetrigger(c, g)) || k.Stop();
        b.Pop();
        h.Pop();
        return !1
    }
    _For(a, b, c)
    {
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack(),
            f = e.GetCurrentStackFrame(),
            g = f.GetCurrentEvent(),
            h = g.GetSolModifiers(),
            k = f.IsSolModifierAfterCnds(),
            l = e.Push(g),
            m = d.GetLoopStack(),
            n = m.Push();
        n.SetName(a);
        n.SetEnd(c);
        if (c < b)
            if (k)
                for (a = b; a >= c && !n.IsStopped(); --a)
                    d.PushCopySol(h),
                    n.SetIndex(a),
                    g.Retrigger(f, l),
                    d.PopSol(h);
            else
                for (d =
                b; d >= c && !n.IsStopped(); --d)
                    n.SetIndex(d),
                    g.Retrigger(f, l);
        else if (k)
            for (a = b; a <= c && !n.IsStopped(); ++a)
                d.PushCopySol(h),
                n.SetIndex(a),
                g.Retrigger(f, l),
                d.PopSol(h);
        else
            for (d = b; d <= c && !n.IsStopped(); ++d)
                n.SetIndex(d),
                g.Retrigger(f, l);
        e.Pop();
        m.Pop();
        return !1
    }
    *_DebugFor(a, b, c)
    {
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack(),
            f = e.GetCurrentStackFrame(),
            g = f.GetCurrentEvent(),
            h = g.GetSolModifiers(),
            k = f.IsSolModifierAfterCnds(),
            l = e.Push(g),
            m = d.GetLoopStack(),
            n = m.Push();
        n.SetName(a);
        n.SetEnd(c);
        if (c < b)
            if (k)
                for (a = b; a >= c && !n.IsStopped(); --a)
                    d.PushCopySol(h),
                    n.SetIndex(a),
                    yield *g.DebugRetrigger(f, l),
                    d.PopSol(h);
            else
                for (d = b; d >= c && !n.IsStopped(); --d)
                    n.SetIndex(d),
                    yield *g.DebugRetrigger(f, l);
        else if (k)
            for (a = b; a <= c && !n.IsStopped(); ++a)
                d.PushCopySol(h),
                n.SetIndex(a),
                yield *g.DebugRetrigger(f, l),
                d.PopSol(h);
        else
            for (d = b; d <= c && !n.IsStopped(); ++d)
                n.SetIndex(d),
                yield *g.DebugRetrigger(f, l);
        e.Pop();
        m.Pop();
        return !1
    }
    _ForEach(a)
    {
        var b = a.GetCurrentSol();
        const c = b.GetInstances();
        if (0 === c.length)
            return !1;
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack(),
            f = e.GetCurrentStackFrame(),
            g = f.GetCurrentEvent(),
            h = g.GetSolModifiers(),
            k = f.IsSolModifierAfterCnds(),
            l = e.Push(g),
            m = d.GetLoopStack(),
            n = m.Push(),
            p = a.IsInContainer(),
            q = forEachStack.Push();
        C3$jscomp$205.shallowAssignArray(q, c);
        n.SetEnd(q.length);
        if (k)
            for (let r = 0, t = q.length; r < t && !n.IsStopped(); ++r)
                d.PushCopySol(h),
                b = q[r],
                a.GetCurrentSol().SetSinglePicked(b),
                p && b.SetSiblingsSinglePicked(),
                n.SetIndex(r),
                g.Retrigger(f, l),
                d.PopSol(h);
        else {
            b._SetSelectAll(!1);
            a = b._GetOwnInstances();
            C3$jscomp$205.clearArray(a);
            a.push(null);
            for (let r = 0, t = q.length; r < t && !n.IsStopped(); ++r)
                d = q[r],
                a[0] = d,
                p && d.SetSiblingsSinglePicked(),
                n.SetIndex(r),
                g.Retrigger(f, l)
        }
        e.Pop();
        m.Pop();
        C3$jscomp$205.clearArray(q);
        forEachStack.Pop();
        return !1
    }
    *_DebugForEach(a)
    {
        var b = a.GetCurrentSol();
        const c = b.GetInstances();
        if (0 === c.length)
            return !1;
        var d = this._runtime.GetEventSheetManager();
        const e = d.GetEventStack(),
            f = e.GetCurrentStackFrame(),
            g = f.GetCurrentEvent(),
            h = g.GetSolModifiers(),
            k = f.IsSolModifierAfterCnds(),
            l = e.Push(g),
            m = d.GetLoopStack(),
            n = m.Push(),
            p = a.IsInContainer(),
            q = forEachStack.Push();
        C3$jscomp$205.shallowAssignArray(q, c);
        n.SetEnd(q.length);
        if (k)
            for (let r = 0, t = q.length; r < t && !n.IsStopped(); ++r)
                d.PushCopySol(h),
                b = q[r],
                a.GetCurrentSol().SetSinglePicked(b),
                p && b.SetSiblingsSinglePicked(),
                n.SetIndex(r),
                yield *g.DebugRetrigger(f, l),
                d.PopSol(h);
        else {
            b._SetSelectAll(!1);
            a = b._GetOwnInstances();
            C3$jscomp$205.clearArray(a);
            a.push(null);
            for (let r = 0, t = q.length; r < t && !n.IsStopped(); ++r)
                d = q[r],
                a[0] = d,
                p && d.SetSiblingsSinglePicked(),
                n.SetIndex(r),
                yield *g.DebugRetrigger(f, l)
        }
        e.Pop();
        m.Pop();
        C3$jscomp$205.clearArray(q);
        forEachStack.Pop();
        return !1
    }
    _ForEachOrdered(a, b)
    {
        const c = a.GetCurrentSol(),
            d = c.GetInstances();
        if (0 === d.length)
            return !1;
        var e = this._runtime.GetEventSheetManager();
        const f = e.GetEventStack(),
            g = e.GetCurrentCondition(),
            h = f.GetCurrentStackFrame(),
            k = h.GetCurrentEvent(),
            l = k.GetSolModifiers(),
            m = h.IsSolModifierAfterCnds(),
            n = f.Push(k),
            p = e.GetLoopStack(),
            q = p.Push(),
            r = a.IsInContainer(),
            t = forEachStack.Push();
        C3$jscomp$205.clearArray(t);
        q.SetEnd(d.length);
        for (let u = 0, v = d.length; u < v; ++u)
            t.push([d[u], g.ReevaluateParameter(1, u)]);
        t.sort(ForEachOrdered_SortInstances);
        1 === b && t.reverse();
        if (m)
            for (let u = 0, v = t.length; u < v && !q.IsStopped(); ++u)
                e.PushCopySol(l),
                b = t[u][0],
                a.GetCurrentSol().SetSinglePicked(b),
                r && b.SetSiblingsSinglePicked(),
                q.SetIndex(u),
                k.Retrigger(h, n),
                e.PopSol(l);
        else {
            c._SetSelectAll(!1);
            a = c._GetOwnInstances();
            C3$jscomp$205.clearArray(a);
            a.push(null);
            for (let u = 0, v = t.length; u < v && !q.IsStopped(); ++u)
                e = t[u][0],
                a[0] = e,
                r && e.SetSiblingsSinglePicked(),
                q.SetIndex(u),
                k.Retrigger(h, n)
        }
        f.Pop();
        p.Pop();
        C3$jscomp$205.clearArray(t);
        forEachStack.Pop();
        return !1
    }
    *_DebugForEachOrdered(a, b)
    {
        const c = a.GetCurrentSol(),
            d = c.GetInstances();
        if (0 === d.length)
            return !1;
        var e = this._runtime.GetEventSheetManager();
        const f = e.GetEventStack(),
            g = e.GetCurrentCondition(),
            h = f.GetCurrentStackFrame(),
            k = h.GetCurrentEvent(),
            l = k.GetSolModifiers(),
            m = h.IsSolModifierAfterCnds(),
            n = f.Push(k),
            p = e.GetLoopStack(),
            q = p.Push(),
            r = a.IsInContainer(),
            t = forEachStack.Push();
        C3$jscomp$205.clearArray(t);
        q.SetEnd(d.length);
        for (let u = 0, v = d.length; u < v; ++u)
            t.push([d[u], g.ReevaluateParameter(1, u)]);
        t.sort(ForEachOrdered_SortInstances);
        1 === b && t.reverse();
        if (m)
            for (let u = 0, v = t.length; u < v && !q.IsStopped(); ++u)
                e.PushCopySol(l),
                b = t[u][0],
                a.GetCurrentSol().SetSinglePicked(b),
                r && b.SetSiblingsSinglePicked(),
                q.SetIndex(u),
                yield *k.DebugRetrigger(h, n),
                e.PopSol(l);
        else {
            c._SetSelectAll(!1);
            a = c._GetOwnInstances();
            C3$jscomp$205.clearArray(a);
            a.push(null);
            for (let u = 0, v = t.length; u < v && !q.IsStopped(); ++u)
                e = t[u][0],
                a[0] = e,
                r && e.SetSiblingsSinglePicked(),
                q.SetIndex(u),
                yield *k.DebugRetrigger(h, n)
        }
        f.Pop();
        p.Pop();
        C3$jscomp$205.clearArray(t);
        forEachStack.Pop();
        return !1
    }
    _GetFunctionMap(a, b)
    {
        let c = this._functionMaps.get(a);
        if (c)
            return c;
        if (!b)
            return null;
        c = {
            defaultFunc: null,
            strMap: new Map
        };
        this._functionMaps.set(a, c);
        return c
    }
    _DoCallMappedFunction(a, b, c, d, e)
    {
        b.GetEventBlock().RunAsMappedFunctionCall(c, b.IsCopyPicked());
        d && a.PopSol(e)
    }
    *_DebugDoCallMappedFunction(a, b, c, d, e)
    {
        yield *b.GetEventBlock().DebugRunAsMappedFunctionCall(c,
        b.IsCopyPicked());
        d && a.PopSol(e)
    }
}
;
const C3$jscomp$206 = self.C3;
C3$jscomp$206.Plugins.System.Type = class  extends C3$jscomp$206.DefendedBase{
    constructor(a)
    {
        super();
        this._objectClass = a;
        this._runtime = a.GetRuntime();
        this._plugin = a.GetPlugin()
    }
    OnCreate() {}
    Release()
    {
        this._plugin = this._runtime = this._objectClass = null
    }
}
;
const C3$jscomp$207 = self.C3;
C3$jscomp$207.Plugins.System.Instance = class  extends C3$jscomp$207.DefendedBase{
    constructor(a, b)
    {
        super();
        this._inst = a;
        this._objectClass = this._inst.GetObjectClass();
        this._sdkType = this._objectClass.GetSdkType();
        this._runtime = this._inst.GetRuntime()
    }
    Release()
    {
        this._runtime = this._sdkType = this._objectClass = this._inst = null
    }
}
;
const C3$jscomp$208 = self.C3,
    tmpPickArray = [];
C3$jscomp$208.Plugins.System.Cnds = {
    EveryTick() {
        return !0
    },
    OnLayoutStart() {
        return !0
    },
    OnLayoutEnd() {
        return !0
    },
    OnSuspend() {
        return !0
    },
    OnResume() {
        return !0
    },
    IsSuspended() {
        return this._runtime.IsSuspended()
    },
    Else() {
        const a = this._runtime.GetCurrentEventStackFrame();
        return a.GetElseBranchRan() ? !1 : !a.GetLastEventTrue()
    },
    TriggerOnce() {
        const a = this._runtime.GetCurrentCondition().GetSavedDataMap();
        let b = a.get("TriggerOnce_lastTick");
        "undefined" === typeof b && (b = -1, a.set("TriggerOnce_lastTick", -1));
        const c = this._runtime.GetTickCount();
        a.set("TriggerOnce_lastTick", c);
        return this._runtime.IsLayoutFirstTick() || b !== c - 1
    },
    Every(a) {
        const b = this._runtime.GetCurrentCondition().GetSavedDataMap(),
            c = b.get("Every_lastTime") || 0,
            d = this._runtime.GetGameTime();
        b.has("Every_seconds") || b.set("Every_seconds", a);
        const e = b.get("Every_seconds");
        if (d >= c + e)
            return b.set("Every_lastTime", c + e), d >= b.get("Every_lastTime") + .04 && b.set("Every_lastTime", d), b.set("Every_seconds", a), !0;
        d < c - .1 && b.set("Every_lastTime", d);
        return !1
    },
    IsGroupActive(a) {
        return (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) &&
            a.IsGroupActive()
    },
    IsPreview() {
        return this._runtime.IsPreview()
    },
    IsMobile() {
        return C3$jscomp$208.Platform.IsMobile
    },
    OnLoadFinished() {
        return !0
    },
    OnCanvasSnapshot() {
        return !0
    },
    EffectsSupported() {
        return !0
    },
    OnSaveComplete() {
        return !0
    },
    OnSaveFailed() {
        return !0
    },
    OnLoadComplete() {
        return !0
    },
    OnLoadFailed() {
        return !0
    },
    ObjectUIDExists(a) {
        return !!this._runtime.GetInstanceByUID(a)
    },
    IsOnPlatform(a) {
        switch (a) {
        case 0:
            return "browser" === C3$jscomp$208.Platform.Context;
        case 1:
            return "iOS" === C3$jscomp$208.Platform.OS;
        case 2:
            return "Android" ===
            C3$jscomp$208.Platform.OS;
        case 8:
            return "cordova" === C3$jscomp$208.Platform.Context;
        case 9:
            return "scirra-arcade" === this._runtime.GetExportType();
        case 10:
            return "nwjs" === C3$jscomp$208.Platform.Context;
        case 13:
            return "windows-uwp" === this._runtime.GetExportType();
        default:
            return !1
        }
    },
    RegexTest(a, b, c) {
        return this.GetRegex(b, c).test(a)
    },
    Compare(a, b, c) {
        return C3$jscomp$208.compare(a, b, c)
    },
    CompareBetween(a, b, c) {
        return a >= b && a <= c
    },
    CompareVar(a, b, c) {
        return C3$jscomp$208.compare(a.GetValue(), b, c)
    },
    CompareBoolVar(a) {
        return !!a.GetValue()
    },
    CompareTime(a, b) {
        const c = this._runtime.GetGameTime();
        return 0 === a ? (a = this._runtime.GetCurrentCondition().GetSavedDataMap(), !a.get("CompareTime_executed") && c >= b ? (a.set("CompareTime_executed", !0), !0) : !1) : C3$jscomp$208.compare(c, a, b)
    },
    IsNaN(a) {
        return isNaN(a)
    },
    AngleWithin(a, b, c) {
        return C3$jscomp$208.angleDiff(C3$jscomp$208.toRadians(a), C3$jscomp$208.toRadians(c)) <= C3$jscomp$208.toRadians(b)
    },
    IsClockwiseFrom(a, b) {
        return C3$jscomp$208.angleClockwise(C3$jscomp$208.toRadians(a), C3$jscomp$208.toRadians(b))
    },
    IsBetweenAngles(a, b, c) {
        a = C3$jscomp$208.toRadians(a);
        b = C3$jscomp$208.toRadians(b);
        c = C3$jscomp$208.toRadians(c);
        return C3$jscomp$208.angleClockwise(c, b) ? C3$jscomp$208.angleClockwise(a, b) && !C3$jscomp$208.angleClockwise(a, c) : !(!C3$jscomp$208.angleClockwise(a, b) && C3$jscomp$208.angleClockwise(a, c))
    },
    IsValueType(a, b) {
        return "number" === typeof a ? 0 === b : 1 === b
    },
    EvaluateExpression(a) {
        return !!a
    },
    OnSignal(a) {
        return a.toLowerCase() === this._runtime.GetEventSheetManager().GetCurrentSignalTag()
    },
    PickByComparison(a, b,
    c, d) {
        if (!a)
            return !1;
        const e = this._GetForEachStack(),
            f = e.Push(),
            g = a.GetCurrentSol();
        C3$jscomp$208.shallowAssignArray(f, g.GetInstances());
        g.IsSelectAll() && C3$jscomp$208.clearArray(g._GetOwnElseInstances());
        const h = this._runtime.GetCurrentCondition();
        let k = 0;
        for (let l = 0, m = f.length; l < m; ++l) {
            const n = f[l];
            f[k] = n;
            b = h.ReevaluateParameter(1, l);
            d = h.ReevaluateParameter(3, l);
            C3$jscomp$208.compare(b, c, d) ? ++k : g._PushElseInstance(n)
        }
        C3$jscomp$208.truncateArray(f, k);
        g.SetArrayPicked(f);
        b = !!f.length;
        C3$jscomp$208.clearArray(f);
        e.Pop();
        a.ApplySolToContainer();
        return b
    },
    PickByEvaluate(a, b) {
        if (!a)
            return !1;
        const c = this._GetForEachStack(),
            d = c.Push(),
            e = a.GetCurrentSol();
        C3$jscomp$208.shallowAssignArray(d, e.GetInstances());
        e.IsSelectAll() && C3$jscomp$208.clearArray(e._GetOwnElseInstances());
        const f = this._runtime.GetCurrentCondition();
        let g = 0;
        for (let h = 0, k = d.length; h < k; ++h) {
            const l = d[h];
            d[g] = l;
            (b = f.ReevaluateParameter(1, h)) ? ++g : e._PushElseInstance(l)
        }
        C3$jscomp$208.truncateArray(d, g);
        e.SetArrayPicked(d);
        b = !!d.length;
        C3$jscomp$208.clearArray(d);
        c.Pop();
        a.ApplySolToContainer();
        return b
    },
    PickByHighestLowestValue(a, b, c) {
        if (!a)
            return !1;
        const d = a.GetCurrentSol(),
            e = d.GetInstances();
        if (0 === e.length)
            return !1;
        const f = this._runtime.GetCurrentCondition();
        let g = null,
            h = 0;
        for (let k = 0, l = e.length; k < l; ++k) {
            const m = e[k];
            c = f.ReevaluateParameter(2, k);
            if (null === g || 0 === b && c < h || 1 === b && c > h)
                h = c,
                g = m
        }
        d.PickOne(g);
        a.ApplySolToContainer();
        return !0
    },
    PickNth(a, b) {
        if (!a)
            return !1;
        const c = a.GetCurrentSol(),
            d = c.GetInstances();
        b = Math.floor(b);
        if (b >= d.length)
            return !1;
        c.PickOne(d[b]);
        a.ApplySolToContainer();
        return !0
    },
    PickRandom(a) {
        if (!a)
            return !1;
        const b = a.GetCurrentSol(),
            c = b.GetInstances(),
            d = Math.floor(this._runtime.Random() * c.length);
        if (d >= c.length)
            return !1;
        b.PickOne(c[d]);
        a.ApplySolToContainer();
        return !0
    },
    PickAll(a) {
        if (!a || !a.GetInstanceCount())
            return !1;
        a.GetCurrentSol()._SetSelectAll(!0);
        a.ApplySolToContainer();
        return !0
    },
    PickOverlappingPoint(a, b, c) {
        if (!a)
            return !1;
        const d = a.GetCurrentSol();
        var e = d.GetInstances();
        const f = this._runtime.GetCurrentEvent().IsOrBlock(),
            g = this._runtime.GetCurrentCondition().IsInverted();
        d.IsSelectAll() ? (C3$jscomp$208.shallowAssignArray(tmpPickArray, e), d.ClearArrays(), d._SetSelectAll(!1)) : f ? (C3$jscomp$208.shallowAssignArray(tmpPickArray, d._GetOwnElseInstances()), C3$jscomp$208.clearArray(d._GetOwnElseInstances())) : (C3$jscomp$208.shallowAssignArray(tmpPickArray, d._GetOwnInstances()), C3$jscomp$208.clearArray(d._GetOwnInstances()));
        for (let h = 0, k = tmpPickArray.length; h < k; ++h)
            e = tmpPickArray[h],
            C3$jscomp$208.xor(e.GetWorldInfo().ContainsPoint(b, c), g) ? d._PushInstance(e) : d._PushElseInstance(e);
        a.ApplySolToContainer();
        return C3$jscomp$208.xor(!!d._GetOwnInstances().length, g)
    },
    PickLastCreated(a) {
        if (!a)
            return !1;
        var b = a.IsFamily();
        let c = null;
        const d = this._runtime._GetInstancesPendingCreate();
        for (let e = d.length - 1; 0 <= e; --e) {
            const f = d[e];
            if (b) {
                if (f.GetObjectClass().BelongsToFamily(a)) {
                    c = f;
                    break
                }
            } else if (f.GetObjectClass() === a) {
                c = f;
                break
            }
        }
        c || (b = a.GetInstances(), b.length && (c = b.at(-1)));
        if (!c)
            return !1;
        a.GetCurrentSol().PickOne(c);
        a.ApplySolToContainer();
        return !0
    },
    Repeat(a) {
        return this._runtime.IsDebugging() ?
        this._DebugRepeat(a) : this._Repeat(a)
    },
    While() {
        return this._runtime.IsDebugging() ? this._DebugWhile() : this._While()
    },
    For(a, b, c) {
        return this._runtime.IsDebugging() ? this._DebugFor(a, b, c) : this._For(a, b, c)
    },
    ForEach(a) {
        return this._runtime.IsDebugging() ? this._DebugForEach(a) : this._ForEach(a)
    },
    ForEachOrdered(a, b, c) {
        return this._runtime.IsDebugging() ? this._DebugForEachOrdered(a, c) : this._ForEachOrdered(a, c)
    },
    LayerVisible(a) {
        return a ? a.IsVisible() : !1
    },
    LayerInteractive(a) {
        return a ? a.IsSelfAndParentsInteractive() :
        !1
    },
    LayerIsHTML(a) {
        return a ? a.IsHTMLElementsLayer() : !1
    },
    LayerEmpty(a) {
        return a ? !a.GetInstanceCount() : !1
    },
    LayerCmpOpacity(a, b, c) {
        return a ? C3$jscomp$208.compare(100 * a.GetOpacity(), b, c) : !1
    },
    LayerNameExists(a) {
        const b = this._runtime.GetMainRunningLayout();
        return b ? b.HasLayerByName(a) : !1
    },
    OnImageLoadingComplete() {
        return !0
    },
    IsLoadingImages() {
        return 0 < this._imagesLoadingTotal
    },
    TemplateExists(a, b) {
        const c = this._runtime.GetTemplateManager();
        return c && b ? !!c.GetTemplateData(a, b) : !1
    }
};
const C3$jscomp$209 = self.C3;
function SortZOrderList$jscomp$1(a, b) {
    const c = a[0] - b[0];
    return 0 !== c ? c : a[1] - b[1]
}
function SortInstancesByValue(a, b) {
    return a[1] - b[1]
}
const tempZOrderList$jscomp$1 = [],
    tempInstValues = [],
    tempRect$jscomp$10 = C3$jscomp$209.New(C3$jscomp$209.Rect),
    tempColor$jscomp$7 = C3$jscomp$209.New(C3$jscomp$209.Color),
    EMPTY_ITERABLE = [];
C3$jscomp$209.Plugins.System.Acts = {
    SetVar(a, b) {
        a.SetValue(b)
    },
    AddVar(a, b) {
        a.IsNumber() && "number" !== typeof b && (b = parseFloat(b));
        a.SetValue(a.GetValue() + b)
    },
    SubVar(a, b) {
        a.IsNumber() && a.SetValue(a.GetValue() - b)
    },
    SetBoolVar(a, b) {
        a.SetValue(!!b)
    },
    ToggleBoolVar(a) {
        a.SetValue(!a.GetValue())
    },
    ResetEventVar(a) {
        a.SetValue(a.GetInitialValue())
    },
    ResetGlobals(a) {
        this._runtime.GetEventSheetManager().ResetAllGlobalsToInitialValue(a)
    },
    CreateObject(a, b, c, d, e, f) {
        if (a && b && (c = this._runtime.CreateInstance(a, b, c, d, e, f))) {
            e &&
            b.SortAndAddInstancesByZIndex(c);
            b = this._runtime.GetEventSheetManager();
            b.BlockFlushingInstances(!0);
            c._TriggerOnCreatedOnSelfAndRelated();
            b.BlockFlushingInstances(!1);
            b = new Map;
            c.CollectInstancesToPick(b, a, e);
            for (const [g, h] of b)
                g.GetCurrentSol().SetSetPicked(h)
        }
    },
    CreateObjectByName(a, b, c, d, e, f) {
        a && b && (a = this._runtime.GetObjectClassByName(a)) && C3$jscomp$209.Plugins.System.Acts.CreateObject.call(this, a, b, c, d, e, f)
    },
    RecreateInitialObjects(a, b, c, d, e, f, g, h, k, l, m) {
        if (a) {
            var n = this._runtime.GetCurrentLayout(),
                p = n;
            if (f && (p = this._runtime.GetLayoutManager().GetLayoutByName(f), !p))
                return;
            f = null;
            if ("number" !== typeof g || 0 <= g)
                if (f = p.GetLayer(g), !f)
                    return;
            g = null;
            if ("number" !== typeof h || 0 <= h)
                if (g = n.GetLayer(h), !g)
                    return;
            tempRect$jscomp$10.set(b, c, d, e);
            b = p.RecreateInitialObjects(a, tempRect$jscomp$10, f, g, k, l, m);
            a.GetCurrentSol().SetArrayPicked(b);
            a.ApplySolToContainer()
        }
    },
    StopLoop() {
        const a = this._loopStack;
        a.IsInLoop() && a.GetCurrent().Stop()
    },
    SetGroupActive(a, b) {
        (a = this._runtime.GetEventSheetManager().GetEventGroupByName(a)) &&
        (0 === b ? a.SetGroupActive(!1) : 1 === b ? a.SetGroupActive(!0) : a.SetGroupActive(!a.IsGroupActive()))
    },
    SetTimescale(a) {
        this._runtime.SetTimeScale(a)
    },
    SetObjectTimescale(a, b) {
        0 > b && (b = 0);
        if (a) {
            a = a.GetCurrentSol().GetInstances();
            for (const c of a)
                c.SetTimeScale(b)
        }
    },
    RestoreObjectTimescale(a) {
        if (a) {
            a = a.GetCurrentSol().GetInstances();
            for (const b of a)
                b.RestoreTimeScale()
        }
    },
    Wait(a) {
        if (!(0 > a))
            return this._runtime.GetEventSheetManager().AddScheduledWait().InitTimer(a), !0
    },
    WaitForSignal(a) {
        this._runtime.GetEventSheetManager().AddScheduledWait().InitSignal(a);
        return !0
    },
    WaitForPreviousActions() {
        const a = this._runtime.GetEventSheetManager();
        a.AddScheduledWait().InitPromise(a.GetPromiseForAllAsyncActions());
        return !0
    },
    Signal(a) {
        this._runtime.GetEventSheetManager().Signal(a)
    },
    async SnapshotCanvas(a, b, c, d, e, f) {
        const g = this._runtime.GetCanvasManager();
        g && (this.UpdateRender(), await g.SnapshotCanvas(0 === a ? "image/png" : "image/jpeg", b / 100, c, d, e, f), await this._runtime.TriggerAsync(C3$jscomp$209.Plugins.System.Cnds.OnCanvasSnapshot, null))
    },
    SetCanvasSize(a, b) {
        if (!(0 >=
        a || 0 >= b)) {
            this._runtime.SetViewportSize(a, b);
            this._runtime.GetCurrentLayout().BoundScrolling();
            var c = this._runtime.GetCanvasManager();
            c && ("off" !== c.GetCurrentFullscreenMode() && this._runtime.SetOriginalViewportSize(a, b), c.SetSize(c.GetLastWidth(), c.GetLastHeight(), !0), this._runtime.UpdateRender())
        }
    },
    SetFullscreenQuality(a) {
        const b = this._runtime.GetCanvasManager();
        b && "off" !== b.GetCurrentFullscreenMode() && (b.SetFullscreenScalingQuality(0 !== a ? "high" : "low"), b.SetSize(b.GetLastWidth(), b.GetLastHeight(),
        !0))
    },
    SaveState(a) {
        this._runtime.SaveToSlot(a)
    },
    LoadState(a) {
        this._runtime.LoadFromSlot(a)
    },
    LoadStateJSON(a) {
        this._runtime.LoadFromJsonString(a)
    },
    SetHalfFramerateMode(a) {},
    ResetPersisted() {
        for (const a of this._runtime.GetLayoutManager().GetAllLayouts())
            a.ResetPersistData()
    },
    SetPixelRounding(a) {
        this._runtime.SetPixelRoundingEnabled(0 !== a)
    },
    SetFramerateMinMax(a, b) {
        this._runtime.SetMaxDt(1 / a);
        this._runtime.SetMinDt(1 / b)
    },
    SetDeltaTimeMinMax(a, b) {
        this._runtime.SetMinDt(a);
        this._runtime.SetMaxDt(b)
    },
    SetFramerateMode(a) {
        this._runtime._SetFramerateMode(["vsync",
        "unlimited-tick", "unlimited-frame"][a])
    },
    SortZOrderByInstVar(a, b) {
        if (a) {
            var c = a.GetCurrentSol().GetInstances(),
                d = this._runtime.GetCurrentLayout(),
                e = a.IsFamily();
            a = a.GetFamilyIndex();
            for (let g = 0, h = c.length; g < h; ++g) {
                var f = c[g];
                const k = f.GetWorldInfo();
                if (!k)
                    continue;
                let l;
                l = e ? f.GetInstanceVariableValue(b + f.GetObjectClass().GetFamilyInstanceVariableOffset(a)) : f.GetInstanceVariableValue(b);
                tempZOrderList$jscomp$1.push([k.GetLayer().GetIndex(), k.GetZIndex()]);
                tempInstValues.push([f, l])
            }
            if (tempZOrderList$jscomp$1.length) {
                tempZOrderList$jscomp$1.sort(SortZOrderList$jscomp$1);
                tempInstValues.sort(SortInstancesByValue);
                b = !1;
                for (let g = 0, h = tempZOrderList$jscomp$1.length; g < h; ++g)
                    c = tempInstValues[g][0],
                    e = d.GetLayerByIndex(tempZOrderList$jscomp$1[g][0]),
                    a = tempZOrderList$jscomp$1[g][1],
                    f = e._GetInstances(),
                    f[a] !== c && (f[a] = c, c.GetWorldInfo()._SetLayer(e, !0), e.SetZIndicesChanged(c), b = !0);
                b && this._runtime.UpdateRender();
                C3$jscomp$209.clearArray(tempZOrderList$jscomp$1);
                C3$jscomp$209.clearArray(tempInstValues)
            }
        }
    },
    SetCollisionCellSize(a, b) {
        a = Math.floor(a);
        b = Math.floor(b);
        0 >= a || 0 >= b ||
        !Number.isFinite(a) || !Number.isFinite(b) || this._runtime.GetCollisionEngine().SetCollisionCellSize(a, b)
    },
    GoToLayout(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            b.IsPendingChangeMainLayout() || b.ChangeMainLayout(a)
        }
    },
    GoToLayoutByName(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            b.IsPendingChangeMainLayout() || (a = b.GetLayoutByName(a)) && b.ChangeMainLayout(a)
        }
    },
    NextPrevLayout(a) {
        if (!this._runtime.IsLoading()) {
            var b = this._runtime.GetLayoutManager();
            if (!b.IsPendingChangeMainLayout()) {
                var c = b.GetAllLayouts(),
                    d = c.indexOf(b.GetMainRunningLayout());
                a && 0 === d || (a || d !== c.length - 1) && b.ChangeMainLayout(c[d + (a ? -1 : 1)])
            }
        }
    },
    RestartLayout() {
        if (!this._runtime.IsLoading()) {
            var a = this._runtime.GetLayoutManager();
            a.IsPendingChangeMainLayout() || (a.ChangeMainLayout(a.GetMainRunningLayout()), this._runtime.GetEventSheetManager().ResetAllGroupsInitialActivation())
        }
    },
    SetLayerVisible(a, b) {
        a && a.SetVisible(b)
    },
    SetLayerInteractive(a, b) {
        a && a.SetInteractive(b)
    },
    SetLayerHTML(a,
    b) {
        a && a.SetIsHTMLElementsLayer(b)
    },
    SetLayerOpacity(a, b) {
        a && a.SetOpacity(b / 100)
    },
    SetLayerScale(a, b) {
        a && a.SetOwnScale(b)
    },
    SetLayerScaleRate(a, b) {
        a && a.SetScaleRate(b)
    },
    SetLayerAngle(a, b) {
        a && a.SetAngle(C3$jscomp$209.toRadians(+b))
    },
    SetLayerScroll(a, b, c) {
        a && (a.SetOwnScrollPositionEnabled(!0), a.SetScrollX(b), a.SetScrollY(c))
    },
    RestoreLayerScroll(a) {
        a && a.SetOwnScrollPositionEnabled(!1)
    },
    SetLayerParallax(a, b, c) {
        a && a.SetParallax(b / 100, c / 100)
    },
    SetLayerZElevation(a, b) {
        a && a.SetZElevation(+b)
    },
    SetLayerBackground(a,
    b) {
        a && (tempColor$jscomp$7.setFromRgbValue(b), tempColor$jscomp$7.clamp(), a = a.GetBackgroundColor(), a.equalsIgnoringAlpha(tempColor$jscomp$7) || (a.copyRgb(tempColor$jscomp$7), this.UpdateRender()))
    },
    SetLayerTransparent(a, b) {
        a && a.SetTransparent(b)
    },
    SetLayerBlendMode(a, b) {
        a && a.SetBlendMode(b)
    },
    SetLayerEffectEnabled(a, b, c) {
        a && (c = a.GetEffectList().GetEffectTypeByName(c)) && (b = 1 === b, c.IsActive() !== b && (c.SetActive(b), a.UpdateActiveEffects(), this._runtime.UpdateRender()))
    },
    SetLayerEffectParam(a, b, c, d) {
        if (a && (a =
        a.GetEffectList(), b = a.GetEffectTypeByName(b))) {
            c = Math.floor(c);
            var e = b.GetShaderProgram().GetParameterType(c);
            e && ("color" === e ? (tempColor$jscomp$7.setFromRgbValue(d), d = tempColor$jscomp$7) : "percent" === e && (d /= 100), a.SetEffectParameter(b.GetIndex(), c, d) && b.IsActive() && this._runtime.UpdateRender())
        }
    },
    SetLayerForceOwnTexture(a, b) {
        a && a.SetForceOwnTexture(b)
    },
    SetLayoutScale(a) {
        this._runtime.GetCurrentLayout().SetScale(+a)
    },
    SetLayoutAngle(a) {
        this._runtime.GetCurrentLayout().SetAngle(C3$jscomp$209.toRadians(+a))
    },
    SetLayoutEffectEnabled(a, b) {
        const c = this._runtime.GetCurrentLayout();
        if (b = c.GetEffectList().GetEffectTypeByName(b))
            a = 1 === a,
            b.IsActive() !== a && (b.SetActive(a), c.UpdateActiveEffects(), this._runtime.UpdateRender())
    },
    SetLayoutEffectParam(a, b, c) {
        const d = this._runtime.GetCurrentLayout().GetEffectList();
        if (a = d.GetEffectTypeByName(a)) {
            b = Math.floor(b);
            var e = a.GetShaderProgram().GetParameterType(b);
            e && ("color" === e ? (tempColor$jscomp$7.setFromRgbValue(c), c = tempColor$jscomp$7) : "percent" === e && (c /= 100), d.SetEffectParameter(a.GetIndex(),
            b, c) && a.IsActive() && this._runtime.UpdateRender())
        }
    },
    SetLayoutVanishingPoint(a, b) {
        this._runtime.GetCurrentLayout().SetVanishingPointXY(a / 100, b / 100)
    },
    SetLayoutProjection(a) {
        const b = this._runtime.GetCurrentLayout();
        0 === a ? b.SetPerspectiveProjection() : b.SetOrthographicProjection()
    },
    ScrollX(a) {
        this._runtime.GetCurrentLayout().SetScrollX(a)
    },
    ScrollY(a) {
        this._runtime.GetCurrentLayout().SetScrollY(a)
    },
    Scroll(a, b) {
        const c = this._runtime.GetCurrentLayout();
        c.SetScrollX(a);
        c.SetScrollY(b)
    },
    ScrollToObject(a) {
        if (a &&
        (a = a.GetFirstPicked()) && (a = a.GetWorldInfo())) {
            var b = this._runtime.GetCurrentLayout();
            b.SetScrollX(a.GetX());
            b.SetScrollY(a.GetY())
        }
    },
    AddLayer(a, b, c) {
        const d = this._runtime.GetCurrentLayout();
        try {
            d.AddLayer(a, b, c)
        } catch (e) {
            console.warn("[Construct] Cannot add layer: ", e)
        }
    },
    MoveLayer(a, b, c) {
        if (a) {
            var d = this._runtime.GetCurrentLayout();
            try {
                d.MoveLayer(a, b, c)
            } catch (e) {
                console.warn("[Construct] Cannot move layer: ", e)
            }
        }
    },
    RemoveLayer(a) {
        a && this._runtime.GetCurrentLayout().RemoveLayer(a)
    },
    RemoveAllDynamicLayers() {
        this._runtime.GetCurrentLayout().RemoveAllDynamicLayers()
    },
    async LoadObjectTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        b && a && !this._runtime.IsLoading() && (a = a.IsFamily() ? a.GetFamilyMembers() : [a], await this._LoadTexturesForObjectClasses(b, a))
    },
    async LoadObjectTexturesByName(a) {
        await C3$jscomp$209.Plugins.System.Acts.LoadObjectTextures.call(this, this._runtime.GetObjectClassByName(a))
    },
    UnloadObjectTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        b && a && (a = a.IsFamily() ? a.GetFamilyMembers() : [a], this._UnloadTexturesForObjectClasses(b, a))
    },
    UnloadObjectTexturesByName(a) {
        C3$jscomp$209.Plugins.System.Acts.UnloadObjectTextures.call(this,
        this._runtime.GetObjectClassByName(a))
    },
    UnloadUnusedTextures() {
        const a = this._runtime.GetMainRunningLayout();
        if (a) {
            var b = a._GetTextureLoadedObjectTypes();
            this._UnloadTexturesForObjectClasses(a, b)
        }
    },
    async LoadLayoutTextures(a) {
        const b = this._runtime.GetMainRunningLayout();
        a && b && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(b, a._GetInitialObjectClasses())
    },
    async LoadLayoutTexturesByName(a) {
        const b = this._runtime.GetMainRunningLayout();
        (a = this._runtime.GetLayoutManager().GetLayoutByName(a)) &&
        b && !this._runtime.IsLoading() && await this._LoadTexturesForObjectClasses(b, a._GetInitialObjectClasses())
    },
    SetFunctionReturnValue(a) {
        const b = this._eventStack.GetCurrentExpFuncStackFrame();
        if (b)
            switch (b.GetFunctionReturnType()) {
            case 1:
                "number" === typeof a && b.SetFunctionReturnValue(a);
                break;
            case 2:
                "string" === typeof a && b.SetFunctionReturnValue(a);
                break;
            case 3:
                b.SetFunctionReturnValue(a)
            }
    },
    MapFunction(a, b, c) {
        var d = this._GetFunctionMap(a.toLowerCase(), !0);
        const e = d.strMap,
            f = b.toLowerCase();
        e.has(f) && console.warn(`[Construct] Function map '${a}' string '${b}' already in map; overwriting entry`);
        if (d = C3$jscomp$209.first(e.values()) || d.defaultFunc) {
            d = 0 !== d.GetReturnType();
            const g = 0 !== c.GetReturnType();
            if (d !== g) {
                console.error(`[Construct] Function map '${a}' string '${b}' function return type not compatible with other functions in the map; entry ignored`);
                return
            }
        }
        e.set(f, c)
    },
    MapFunctionDefault(a, b) {
        const c = this._GetFunctionMap(a.toLowerCase(), !0);
        c.defaultFunc && console.warn(`[Construct] Function map '${a}' already has a default; overwriting entry`);
        var d = C3$jscomp$209.first(c.strMap.values()) ||
        c.defaultFunc;
        if (d) {
            d = 0 !== d.GetReturnType();
            const e = 0 !== b.GetReturnType();
            if (d !== e) {
                console.error(`[Construct] Function map '${a}' default: function return type not compatible with other functions in the map; entry ignored`);
                return
            }
        }
        c.defaultFunc = b
    },
    CallMappedFunction(a, b, c) {
        const d = this._runtime;
        var e = d.IsDebugging() ? EMPTY_ITERABLE : null;
        c = Math.floor(c);
        var f = this._GetFunctionMap(a.toLowerCase(), !1);
        if (!f)
            return console.warn(`[Construct] Call mapped function: map name '${a}' not found; call ignored`),
            e;
        let g = f.strMap.get(b.toLowerCase());
        if (!g)
            if (f.defaultFunc)
                g = f.defaultFunc,
                c = 0;
            else
                return console.warn(`[Construct] Call mapped function: no function associated with map '${a}' string '${b}'; call ignored (consider setting a default)`), e;
        if (!g.IsEnabled())
            return e;
        if (0 !== g.GetReturnType())
            return console.warn(`[Construct] Call mapped function: map '${a}' string '${b}' has a return type so cannot be called`), e;
        a = d.GetEventSheetManager();
        var h = a.GetCurrentEvent();
        b = h.GetSolModifiersIncludingParents();
        (e = 0 < b.length) && (g.IsCopyPicked() ? a.PushCopySol(b) : a.PushCleanSol(b));
        f = [];
        if (h = a.FindFirstFunctionBlockParent(h)) {
            h = h.GetFunctionParameters();
            for (let k = c, l = h.length; k < l; ++k)
                f.push(h[k].GetValue())
        }
        c = g.GetFunctionParameters();
        for (let k = f.length, l = c.length; k < l; ++k)
            f.push(c[k].GetInitialValue());
        return d.IsDebugging() ? this._DebugDoCallMappedFunction(a, g, f, e, b) : this._DoCallMappedFunction(a, g, f, e, b)
    }
};
const C3$jscomp$210 = self.C3;
C3$jscomp$210.Plugins.System.Exps = {
    int: function(a) {
        "string" === typeof a && (a = parseInt(a, 10), isNaN(a) && (a = 0));
        return Math.floor(a)
    },
    float: function(a) {
        "string" === typeof a && (a = parseFloat(a), isNaN(a) && (a = 0));
        return a
    },
    str(a) {
        return a.toString()
    },
    len(a) {
        return "string" === typeof a ? a.length : 0
    },
    random(a, b) {
        return "undefined" === typeof b ? this._runtime.Random() * a : this._runtime.Random() * (b - a) + a
    },
    choose(...a) {
        const b = Math.floor(this._runtime.Random() * a.length);
        return a[b]
    },
    chooseindex(a, ...b) {
        "number" !== typeof a &&
        (a = 0);
        a = C3$jscomp$210.clamp(Math.floor(a), 0, b.length - 1);
        return b[a]
    },
    pi() {
        return Math.PI
    },
    infinity() {
        return Infinity
    },
    sqrt(a) {
        return Math.sqrt(a)
    },
    abs(a) {
        return Math.abs(a)
    },
    round(a) {
        return Math.round(a)
    },
    roundtodp(a, b) {
        b = Math.max(Math.floor(b), 0);
        b = Math.pow(10, b);
        return Math.round((a + Number.EPSILON) * b) / b
    },
    floor(a) {
        return Math.floor(a)
    },
    ceil(a) {
        return Math.ceil(a)
    },
    sign(a) {
        return Math.sign(a)
    },
    sin(a) {
        return Math.sin(C3$jscomp$210.toRadians(a))
    },
    cos(a) {
        return Math.cos(C3$jscomp$210.toRadians(a))
    },
    tan(a) {
        return Math.tan(C3$jscomp$210.toRadians(a))
    },
    asin(a) {
        return C3$jscomp$210.toDegrees(Math.asin(a))
    },
    acos(a) {
        return C3$jscomp$210.toDegrees(Math.acos(a))
    },
    atan(a) {
        return C3$jscomp$210.toDegrees(Math.atan(a))
    },
    exp(a) {
        return Math.exp(a)
    },
    ln(a) {
        return Math.log(a)
    },
    log10(a) {
        return Math.log10(a)
    },
    max(...a) {
        let b = a[0];
        "number" !== typeof b && (b = 0);
        for (let c = 1, d = a.length; c < d; ++c) {
            let e = a[c];
            "number" === typeof e && b < e && (b = e)
        }
        return b
    },
    min(...a) {
        let b = a[0];
        "number" !== typeof b && (b = 0);
        for (let c = 1, d = a.length; c <
        d; ++c) {
            let e = a[c];
            "number" === typeof e && b > e && (b = e)
        }
        return b
    },
    clamp(a, b, c) {
        return C3$jscomp$210.clamp(a, b, c)
    },
    distance(a, b, c, d) {
        return C3$jscomp$210.distanceTo(a, b, c, d)
    },
    angle(a, b, c, d) {
        return C3$jscomp$210.toDegrees(C3$jscomp$210.angleTo(a, b, c, d))
    },
    lerp(a, b, c) {
        return C3$jscomp$210.lerp(a, b, c)
    },
    unlerp(a, b, c) {
        return C3$jscomp$210.unlerp(a, b, c)
    },
    qarp(a, b, c, d) {
        return C3$jscomp$210.qarp(a, b, c, d)
    },
    cubic(a, b, c, d, e) {
        return C3$jscomp$210.cubic(a, b, c, d, e)
    },
    cosp(a, b, c) {
        return C3$jscomp$210.cosp(a, b, c)
    },
    anglediff(a,
    b) {
        return C3$jscomp$210.toDegrees(C3$jscomp$210.angleDiff(C3$jscomp$210.toRadians(a), C3$jscomp$210.toRadians(b)))
    },
    anglelerp(a, b, c) {
        return C3$jscomp$210.toDegrees(C3$jscomp$210.angleLerp(C3$jscomp$210.toRadians(a), C3$jscomp$210.toRadians(b), c))
    },
    anglerotate(a, b, c) {
        return C3$jscomp$210.toDegrees(C3$jscomp$210.angleRotate(C3$jscomp$210.toRadians(a), C3$jscomp$210.toRadians(b), C3$jscomp$210.toRadians(c)))
    },
    setbit(a, b, c) {
        b |= 0;
        return (a | 0) & ~(1 << b) | (0 !== c ? 1 : 0) << b
    },
    togglebit(a, b) {
        return (a | 0) ^ 1 << (b | 0)
    },
    getbit(a,
    b) {
        return (a | 0) & 1 << (b | 0) ? 1 : 0
    },
    newline() {
        return "\n"
    },
    uppercase(a) {
        return "string" === typeof a ? a.toUpperCase() : ""
    },
    lowercase(a) {
        return "string" === typeof a ? a.toLowerCase() : ""
    },
    left(a, b) {
        return "string" === typeof a ? a.substr(0, b) : ""
    },
    mid(a, b, c) {
        return "string" !== typeof a ? "" : 0 > c ? a.substr(b) : a.substr(b, c)
    },
    right(a, b) {
        return "string" === typeof a ? a.substr(Math.max(a.length - b, 0)) : ""
    },
    trim(a) {
        return "string" === typeof a ? a.trim() : ""
    },
    tokenat(a, b, c) {
        if ("string" !== typeof a || "string" !== typeof c)
            return "";
        a = a.split(c);
        b = Math.floor(b);
        return 0 > b || b >= a.length ? "" : a[b]
    },
    tokencount(a, b) {
        return "string" === typeof a && "string" === typeof b && a.length ? a.split(b).length : 0
    },
    find(a, b) {
        return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(C3$jscomp$210.EscapeRegex(b), "i")) : -1
    },
    findcase(a, b) {
        return "string" === typeof a && "string" === typeof b ? a.search(new RegExp(C3$jscomp$210.EscapeRegex(b), "")) : -1
    },
    replace(a, b, c) {
        return "string" === typeof a && "string" === typeof b && "string" === typeof c ? a.replace(new RegExp(C3$jscomp$210.EscapeRegex(b), "gi"),
        c) : "string" === typeof a ? a : ""
    },
    stringsub(a, ...b) {
        for (let c = 0, d = b.length; c < d; ++c)
            a = a.replaceAll(`{${c}}`, b[c].toString());
        return a
    },
    regexsearch(a, b, c) {
        b = this.GetRegex(b, c);
        return a ? a.search(b) : -1
    },
    regexreplace(a, b, c, d) {
        b = this.GetRegex(b, c);
        return a ? a.replace(b, d) : ""
    },
    regexmatchcount(a, b, c) {
        return (a = this.GetRegexMatches(a.toString(), b, c)) ? a.length : 0
    },
    regexmatchat(a, b, c, d) {
        d = Math.floor(d);
        a = this.GetRegexMatches(a.toString(), b, c);
        return !a || 0 > d || d >= a.length ? "" : a[d]
    },
    zeropad(a, b) {
        let c = 0 > a ? "-" : "";
        0 > a && (a =
        -a);
        c += "0".repeat(Math.max(b - a.toString().length, 0));
        return c + a.toString()
    },
    urlencode(a) {
        return encodeURIComponent(a)
    },
    urldecode(a) {
        return decodeURIComponent(a)
    },
    dt() {
        return this._runtime._GetDtFast()
    },
    timescale() {
        return this._runtime.GetTimeScale()
    },
    wallclocktime() {
        return (Date.now() - this._runtime.GetStartTime()) / 1E3
    },
    unixtime() {
        return Date.now()
    },
    time() {
        return this._runtime.GetGameTime()
    },
    tickcount() {
        return this._runtime.GetTickCount()
    },
    objectcount() {
        return this._runtime.GetObjectCount()
    },
    fps() {
        return this._runtime.GetFramesPerSecond()
    },
    cpuutilisation() {
        return this._runtime.GetMainThreadTime()
    },
    gpuutilisation() {
        return this._runtime.GetGPUUtilisation()
    },
    windowwidth() {
        return this._runtime.GetCanvasManager().GetDeviceWidth()
    },
    windowheight() {
        return this._runtime.GetCanvasManager().GetDeviceHeight()
    },
    originalwindowwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalwindowheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    originalviewportwidth() {
        return this._runtime.GetOriginalViewportWidth()
    },
    originalviewportheight() {
        return this._runtime.GetOriginalViewportHeight()
    },
    scrollx() {
        return this._runtime.GetCurrentLayout().GetScrollX()
    },
    scrolly() {
        return this._runtime.GetCurrentLayout().GetScrollY()
    },
    layoutname() {
        return this._runtime.GetCurrentLayout().GetName()
    },
    layoutscale() {
        return this._runtime.GetCurrentLayout().GetScale()
    },
    layoutangle() {
        return C3$jscomp$210.toDegrees(this._runtime.GetCurrentLayout().GetAngle())
    },
    layoutwidth() {
        return this._runtime.GetCurrentLayout().GetWidth()
    },
    layoutheight() {
        return this._runtime.GetCurrentLayout().GetHeight()
    },
    vanishingpointx() {
        return 100 *
        this._runtime.GetCurrentLayout().GetVanishingPointX()
    },
    vanishingpointy() {
        return 100 * this._runtime.GetCurrentLayout().GetVanishingPointY()
    },
    viewportleft(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getLeft() : 0
    },
    viewporttop(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getTop() : 0
    },
    viewportright(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().getRight() : 0
    },
    viewportbottom(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ?
        a.GetViewport3D().getBottom() : 0
    },
    viewportwidth(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().width() : 0
    },
    viewportheight(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetViewport3D().height() : 0
    },
    viewportmidx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? (a = a.GetViewport3D(), (a.getLeft() + a.getRight()) / 2) : 0
    },
    viewportmidy(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? (a = a.GetViewport3D(), (a.getTop() + a.getBottom()) / 2) : 0
    },
    canvastolayerx(a,
    b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, c)[0] : 0
    },
    canvastolayery(a, b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.CanvasCssToLayer(b, c)[1] : 0
    },
    layertocanvasx(a, b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, c)[0] : 0
    },
    layertocanvasy(a, b, c) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.LayerToCanvasCss(b, c)[1] : 0
    },
    layertolayerx(a, b, c, d) {
        const e = this._runtime.GetCurrentLayout();
        a = e.GetLayer(a);
        b = e.GetLayer(b);
        if (!a || !b || a === b)
            return c;
        const [f, g] = a.LayerToCanvasCss(c, d);
        return b.CanvasCssToLayer(f, g)[0]
    },
    layertolayery(a, b, c, d) {
        const e = this._runtime.GetCurrentLayout();
        a = e.GetLayer(a);
        b = e.GetLayer(b);
        if (!a || !b || a === b)
            return d;
        const [f, g] = a.LayerToCanvasCss(c, d);
        return b.CanvasCssToLayer(f, g)[1]
    },
    layerscale(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetOwnScale() : 0
    },
    layerangle(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? C3$jscomp$210.toDegrees(a.GetOwnAngle()) : 0
    },
    layeropacity(a) {
        return (a =
        this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetOpacity() : 0
    },
    layerscalerate(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScaleRate() : 0
    },
    layerscrollx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollX() : 0
    },
    layerscrolly(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetScrollY() : 0
    },
    layerparallaxx(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? 100 * a.GetParallaxX() : 0
    },
    layerparallaxy(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ?
        100 * a.GetParallaxY() : 0
    },
    layerzelevation(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetZElevation() : 0
    },
    layerindex(a) {
        return (a = this._runtime.GetCurrentLayout().GetLayer(a)) ? a.GetIndex() : -1
    },
    canvassnapshot() {
        const a = this._runtime.GetCanvasManager();
        return a ? a.GetCanvasSnapshotUrl() : ""
    },
    loopindex(a) {
        const b = this._loopStack;
        return b.IsInLoop() ? a ? (a = b.FindByName(a)) ? a.GetIndex() : 0 : b.GetCurrent().GetIndex() : 0
    },
    savestatejson() {
        return this._runtime.GetLastSaveJsonString()
    },
    callmapped(a, b,
    ...c) {
        var d = this._GetFunctionMap(a.toLowerCase(), !1);
        if (!d)
            return console.warn(`[Construct] Call mapped function: map name '${a}' not found; returning 0`), 0;
        let e = d.strMap.get(b.toLowerCase());
        if (!e)
            if (d.defaultFunc)
                e = d.defaultFunc;
            else
                return console.warn(`[Construct] Call mapped function: no function associated with map '${a}' string '${b}'; returning 0 (consider setting a default)`), 0;
        d = e.GetReturnType();
        const f = e.GetDefaultReturnValue();
        if (0 === d)
            return console.warn(`[Construct] Call mapped function: map '${a}' string '${b}' has no return type so cannot be called from an expression; returning 0`),
            0;
        if (!e.IsEnabled())
            return f;
        a = this._runtime.GetEventSheetManager();
        b = a.GetCurrentEvent().GetSolModifiersIncludingParents();
        const g = 0 < b.length;
        g && (e.IsCopyPicked() ? a.PushCopySol(b) : a.PushCleanSol(b));
        var h = e.GetFunctionParameters();
        for (let k = c.length, l = h.length; k < l; ++k)
            c.push(h[k].GetInitialValue());
        h = e.GetEventBlock();
        c = h.RunAsExpressionFunctionCall(h.GetSolModifiersIncludingParents(), e.IsCopyPicked(), d, f, ...c);
        g && a.PopSol(b);
        return c
    },
    loadingprogress() {
        return this._runtime.GetAssetManager().GetLoadProgress()
    },
    imageloadingprogress() {
        return 0 === this._imagesLoadingTotal ? 1 : this._imagesLoadingComplete / this._imagesLoadingTotal
    },
    renderer() {
        return this._runtime.GetWebGPURenderer() ? "webgpu" : "webgl"
    },
    rendererdetail() {
        return this._runtime.GetWebGPURenderer() ? this._runtime.GetWebGPURenderer().GetAdapterInfoString() : this._runtime.GetWebGLRenderer().GetUnmaskedRenderer()
    },
    imagememoryusage() {
        let a = this._runtime.GetRenderer().GetEstimatedTextureMemoryUsage();
        return Math.round(100 * a / 1048576) / 100
    },
    rgb(a, b, c) {
        return C3$jscomp$210.PackRGB(a,
        b, c)
    },
    rgbex(a, b, c) {
        return C3$jscomp$210.PackRGBEx(a / 100, b / 100, c / 100)
    },
    rgba(a, b, c, d) {
        return C3$jscomp$210.PackRGBAEx(a / 100, b / 100, c / 100, d / 100)
    },
    rgbex255(a, b, c) {
        return C3$jscomp$210.PackRGBEx(a / 255, b / 255, c / 255)
    },
    rgba255(a, b, c, d) {
        return C3$jscomp$210.PackRGBAEx(a / 255, b / 255, c / 255, d / 255)
    },
    projectname() {
        return this._runtime.GetProjectName()
    },
    projectversion() {
        return this._runtime.GetProjectVersion()
    },
    currenteventsheetname() {
        return this._runtime.GetCurrentEvent().GetEventSheet().GetName()
    },
    currenteventnumber() {
        return this._runtime.GetCurrentEvent().GetDisplayNumber()
    }
};
"use strict";
const C3$jscomp$211 = self.C3;
C3$jscomp$211.Plugins.Sprite = class  extends C3$jscomp$211.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$212 = self.C3,
    C3X$jscomp$36 = self.C3X,
    spawnPickStack = [];
C3$jscomp$212.Plugins.Sprite.Type = class  extends C3$jscomp$212.SDKTypeBase{
    constructor(a)
    {
        super(a);
        this._animations = a.GetAnimations()
    }
    Release()
    {
        C3$jscomp$212.clearArray(this._animations);
        super.Release()
    }
    OnCreate()
    {
        for (const a of this._animations)
            a.LoadAllAssets(this._runtime)
    }
    LoadTextures(a)
    {
        const b = {
            sampling: this._runtime.GetSampling()
        };
        return Promise.all(this._animations.map(c => c.LoadAllTextures(a, b)))
    }
    ReleaseTextures()
    {
        for (const a of this._animations)
            a.ReleaseAllTextures()
    }
    OnDynamicTextureLoadComplete()
    {
        this._UpdateAllCurrentTexture()
    }
    _UpdateAllCurrentTexture()
    {
        for (const a of this._objectClass.instancesIncludingPendingCreate())
            a.GetSdkInstance()._UpdateCurrentTexture()
    }
    FinishCondition(a)
    {
        C3$jscomp$212.Plugins.Sprite.FinishCollisionCondition(this,
        a)
    }
    BeforeRunAction(a)
    {
        spawnPickStack.push({
            objectClass: null,
            createHierarchy: !1,
            instances: []
        })
    }
    _SpawnPickInstance(a, b, c)
    {
        const d = spawnPickStack.at(-1);
        d.objectClass = a;
        d.createHierarchy = c;
        d.instances.push(b)
    }
    AfterRunAction(a)
    {
        a = spawnPickStack.pop();
        const b = a.objectClass,
            c = a.createHierarchy;
        if (b) {
            var d = new Map;
            for (const e of a.instances)
                e.CollectInstancesToPick(d, b, c);
            for (const [e, f] of d)
                e.GetCurrentSol().SetSetPicked(f)
        }
    }
    _AddAnimation(a)
    {
        a = this.GetObjectClass().AddAnimation(a);
        const b = this.GetRuntime();
        a.GetFrameAt(0).GetImageInfo().LoadStaticTexture(b.GetRenderer(), {
            sampling: b.GetSampling()
        }).then(() => this._UpdateAllCurrentTexture());
        return a
    }
    _RemoveAnimation(a)
    {
        for (const b of this._objectClass.instancesIncludingPendingCreate())
            b.GetSdkInstance()._OnAnimationRemoved(a);
        this.GetObjectClass().RemoveAnimation(a)
    }
    _AddAnimationFrame(a, b)
    {
        var c = this._objectClass.GetAnimationByName(a);
        if (!c)
            throw Error(`cannot find animation name '${a}'`);
        b = c.FrameTagOrIndexToIndex(b);
        0 > b && (b += c.GetFrameCount() + 1);
        a =
        C3$jscomp$212.AnimationFrameInfo.CreateDynamic(this.GetRuntime());
        c.InsertFrameAt(a, b);
        c = this.GetRuntime();
        a.GetImageInfo().LoadStaticTexture(c.GetRenderer(), {
            sampling: c.GetSampling()
        }).then(() => this._UpdateAllCurrentTexture());
        for (const d of this._objectClass.instancesIncludingPendingCreate())
            d.GetSdkInstance()._OnAnimationFramesChanged();
        return a
    }
    _RemoveAnimationFrame(a, b)
    {
        const c = this._objectClass.GetAnimationByName(a);
        if (!c)
            throw Error(`cannot find animation name '${a}'`);
        if (1 === c.GetFrameCount())
            throw Error(`cannot remove last frame from animation '${a}'`);
        a = c.FrameTagOrIndexToIndex(b);
        0 > a && (a += c.GetFrameCount());
        c.RemoveFrameAt(a);
        for (const d of this._objectClass.instancesIncludingPendingCreate())
            d.GetSdkInstance()._OnAnimationFramesChanged()
    }
    GetScriptInterfaceClass()
    {
        return self.ISpriteObjectType
    }
}
;
const map$jscomp$30 = new WeakMap;
self.ISpriteObjectType = class  extends self.IObjectClass{
    constructor(a)
    {
        super(a);
        map$jscomp$30.set(this, a.GetSdkType())
    }
    getAnimation(a)
    {
        C3X$jscomp$36.RequireString(a);
        return (a = map$jscomp$30.get(this).GetObjectClass().GetAnimationByName(a)) ? a.GetIAnimation() : null
    }
    getAllAnimations()
    {
        return map$jscomp$30.get(this).GetObjectClass().GetAllAnimations().map(a => a.GetIAnimation())
    }
    addAnimation(a)
    {
        C3X$jscomp$36.RequireString(a);
        return map$jscomp$30.get(this)._AddAnimation(a).GetIAnimation()
    }
    removeAnimation(a)
    {
        C3X$jscomp$36.RequireString(a);
        map$jscomp$30.get(this)._RemoveAnimation(a)
    }
    addAnimationFrame(a, b)
    {
        C3X$jscomp$36.RequireString(a);
        if ("number" !== typeof b && "string" !== typeof b)
            throw new TypeError("invalid insert location");
        return map$jscomp$30.get(this)._AddAnimationFrame(a, b).GetIAnimationFrame()
    }
    removeAnimationFrame(a, b)
    {
        C3X$jscomp$36.RequireString(a);
        if ("number" !== typeof b && "string" !== typeof b)
            throw new TypeError("invalid insert location");
        map$jscomp$30.get(this)._RemoveAnimationFrame(a, b)
    }
}
;
const C3$jscomp$213 = self.C3,
    C3X$jscomp$37 = self.C3X,
    tempRect$jscomp$11 = C3$jscomp$213.New(C3$jscomp$213.Rect),
    tempQuad$jscomp$6 = C3$jscomp$213.New(C3$jscomp$213.Quad),
    tempVec2$jscomp$1 = C3$jscomp$213.New(C3$jscomp$213.Vector2),
    FLAG_PLAYING_FORWARDS = 1,
    FLAG_ANIMATION_PLAYING = 2,
    FLAG_ANIMATION_TRIGGER = 4;
C3$jscomp$213.Plugins.Sprite.Instance = class  extends C3$jscomp$213.SDKWorldInstanceBase{
    constructor(a, b)
    {
        super(a);
        let c = !0,
            d = "",
            e = 0,
            f = !0;
        b && (c = !!b[0], d = b[1], e = b[2], f = b[3]);
        this._currentAnimation = this._objectClass.GetAnimationByName(d) || this._objectClass.GetAnimations()[0];
        this._currentFrameIndex = C3$jscomp$213.clamp(e, 0, this._currentAnimation.GetFrameCount() - 1);
        this._currentAnimationFrame = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        b = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture =
        b.GetTexture();
        this._currentRcTex = b.GetTexRect();
        this._currentQuadTex = b.GetTexQuad();
        this.HandleRendererContextLoss();
        a.SetFlag(FLAG_ANIMATION_PLAYING, !0);
        a.SetFlag(FLAG_PLAYING_FORWARDS, 0 <= this._currentAnimation.GetSpeed());
        this._currentAnimationSpeed = Math.abs(this._currentAnimation.GetSpeed());
        this._currentAnimationRepeatTo = this._currentAnimation.GetRepeatTo();
        this._animationTimer = C3$jscomp$213.New(C3$jscomp$213.KahanSum);
        this._animationRepeats = this._frameStartTime = 0;
        this._animTriggerName = "";
        this._changeAnimFrameIndex =
        -1;
        this._changeAnimationName = "";
        this._changeAnimationFrom = 0;
        a = this.GetWorldInfo();
        this._bquadRef = a.GetBoundingQuad();
        a.SetVisible(c);
        a.SetCollisionEnabled(f);
        a.SetOriginX(this._currentAnimationFrame.GetOriginX());
        a.SetOriginY(this._currentAnimationFrame.GetOriginY());
        a.SetSourceCollisionPoly(this._currentAnimationFrame.GetCollisionPoly());
        a.SetBboxChanged();
        1 === this._objectClass.GetAnimationCount() && 1 === this._objectClass.GetAnimations()[0].GetFrameCount() || 0 === this._currentAnimationSpeed || this._StartTicking()
    }
    Release()
    {
        this._animationTimer =
        this._currentTexture = this._currentAnimationFrame = this._currentAnimation = null;
        super.Release()
    }
    GetCurrentImageInfo()
    {
        return this._currentAnimationFrame.GetImageInfo()
    }
    IsOriginalSizeKnown()
    {
        return !0
    }
    OnRendererContextLost()
    {
        this._currentTexture = null
    }
    OnRendererContextRestored()
    {
        this._UpdateCurrentTexture()
    }
    Draw(a)
    {
        var b = this._currentTexture;
        null !== b && (a.SetTexture(b), b = this.GetWorldInfo(), b.HasMesh() ? this._DrawMesh(b, a) : this._DrawStandard(b, a))
    }
    _DrawStandard(a, b)
    {
        let c = this._bquadRef;
        this._runtime.IsPixelRoundingEnabled() &&
        (c = a.PixelRoundQuad(c));
        b.Quad4(c, this._currentQuadTex)
    }
    _DrawMesh(a, b)
    {
        const c = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$11, tempQuad$jscomp$6, !1);
            let d = tempQuad$jscomp$6;
            this._runtime.IsPixelRoundingEnabled() && (d = a.PixelRoundQuad(d));
            c.CalculateTransformedMesh(a.GetSourceMesh(), d, this._currentQuadTex);
            a.SetMeshChanged(!1)
        }
        c.Draw(b)
    }
    GetAnimationTime()
    {
        return this._animationTimer.Get()
    }
    IsAnimationPlaying()
    {
        return this._inst.GetFlag(FLAG_ANIMATION_PLAYING)
    }
    SetAnimationPlaying(a)
    {
        this._inst.SetFlag(FLAG_ANIMATION_PLAYING,
        a)
    }
    IsPlayingForwards()
    {
        return this._inst.GetFlag(FLAG_PLAYING_FORWARDS)
    }
    SetPlayingForwards(a)
    {
        this._inst.SetFlag(FLAG_PLAYING_FORWARDS, a)
    }
    IsInAnimationTrigger()
    {
        return this._inst.GetFlag(FLAG_ANIMATION_TRIGGER)
    }
    SetInAnimationTrigger(a)
    {
        this._inst.SetFlag(FLAG_ANIMATION_TRIGGER, a)
    }
    Tick()
    {
        this._changeAnimationName && this._DoChangeAnimation();
        0 <= this._changeAnimFrameIndex && this._DoChangeAnimFrame();
        const a = this._currentAnimationSpeed;
        if (this.IsAnimationPlaying() && 0 !== a) {
            var b = this._runtime.GetDt(this._inst);
            this._animationTimer.Add(b);
            b = this.GetAnimationTime();
            var c = this._currentAnimationFrame,
                d = c.GetDuration() / a;
            if (!(b < this._frameStartTime + d)) {
                var e = this._currentAnimation,
                    f = this._currentAnimationRepeatTo,
                    g = e.GetFrameCount(),
                    h = e.GetRepeatCount(),
                    k = e.IsLooping(),
                    l = e.IsPingPong();
                this.IsPlayingForwards() ? this._currentFrameIndex++ : this._currentFrameIndex--;
                this._frameStartTime += d;
                this._currentFrameIndex >= g && (l ? (this.SetPlayingForwards(!1), this._currentFrameIndex = g - 2) : k ? this._currentFrameIndex = f : (this._animationRepeats++,
                this._animationRepeats >= h ? this._FinishAnimation(!1) : this._currentFrameIndex = f));
                0 > this._currentFrameIndex && (l ? (this._currentFrameIndex = 1, this.SetPlayingForwards(!0), k || (this._animationRepeats++, this._animationRepeats >= h && this._FinishAnimation(!0))) : k ? this._currentFrameIndex = f : (this._animationRepeats++, this._animationRepeats >= h ? this._FinishAnimation(!0) : this._currentFrameIndex = f));
                this._currentFrameIndex = C3$jscomp$213.clamp(this._currentFrameIndex, 0, g - 1);
                d = e.GetFrameAt(this._currentFrameIndex);
                b > this._frameStartTime +
                d.GetDuration() / a && (this._frameStartTime = b);
                this._OnFrameChanged(c, d)
            }
        } else
            this._StopTicking()
    }
    _FinishAnimation(a)
    {
        this._currentFrameIndex = a ? 0 : this._currentAnimation.GetFrameCount() - 1;
        this.SetAnimationPlaying(!1);
        this._animTriggerName = this._currentAnimation.GetName();
        this.SetInAnimationTrigger(!0);
        this.DispatchScriptEvent("animationend", !1, {
            animationName: this._animTriggerName
        });
        this.Trigger(C3$jscomp$213.Plugins.Sprite.Cnds.OnAnyAnimFinished);
        this.Trigger(C3$jscomp$213.Plugins.Sprite.Cnds.OnAnimFinished);
        this.SetInAnimationTrigger(!1);
        this._animationRepeats = 0
    }
    _OnFrameChanged(a, b, c)
    {
        if (a !== b) {
            var d = this.GetWorldInfo(),
                e = a.GetImageInfo(),
                f = b.GetImageInfo(),
                g = e.GetWidth();
            e = e.GetHeight();
            var h = f.GetWidth(),
                k = f.GetHeight();
            if (c && c.onFrameChange)
                c.onFrameChange(d, g, e, h, k);
            else
                g !== h && d.SetWidth(d.GetWidth() * (h / g)),
                e !== k && d.SetHeight(d.GetHeight() * (k / e));
            d.SetOriginX(b.GetOriginX());
            d.SetOriginY(b.GetOriginY());
            d.SetSourceCollisionPoly(b.GetCollisionPoly());
            d.SetBboxChanged();
            this._currentAnimationFrame =
            b;
            this._currentTexture = f.GetTexture();
            this._currentRcTex = f.GetTexRect();
            this._currentQuadTex = f.GetTexQuad();
            c = this.GetInstance().GetBehaviorInstances();
            for (let l = 0, m = c.length; l < m; ++l)
                c[l].OnSpriteFrameChanged(a, b);
            this.DispatchScriptEvent("framechange", !1, {
                animationName: this._currentAnimation.GetName(),
                animationFrame: this._currentFrameIndex
            });
            this.Trigger(C3$jscomp$213.Plugins.Sprite.Cnds.OnFrameChanged);
            this._runtime.UpdateRender()
        }
    }
    _StartAnim(a)
    {
        this.SetAnimationPlaying(!0);
        this._frameStartTime =
        this.GetAnimationTime();
        1 === a && 0 !== this._currentFrameIndex && (this._changeAnimFrameIndex = 0, this.IsInAnimationTrigger() || this._DoChangeAnimFrame());
        this._StartTicking()
    }
    _SetAnim(a, b, c)
    {
        this._changeAnimationName = a;
        this._changeAnimationFrom = b;
        this._StartTicking();
        !c && this.IsInAnimationTrigger() || this._DoChangeAnimation()
    }
    _GetCurrentAnimation()
    {
        return this._currentAnimation
    }
    _GetCurrentAnimationName()
    {
        return this._changeAnimationName ? this._changeAnimationName : this._currentAnimation.GetName()
    }
    _OnAnimationRemoved(a)
    {
        C3$jscomp$213.equalsNoCase(a,
        this._GetCurrentAnimationName()) && this._SetAnim(this._objectClass.GetFirstAnimation().GetName(), 1, !0)
    }
    _SetAnimFrame(a)
    {
        if ("string" === typeof a)
            if (String(Number(a)) === a)
                a = Number(a);
            else {
                const b = this._objectClass.GetAnimationByName(this._GetCurrentAnimationName());
                if (!b)
                    return;
                a = b.GetFrameIndexByTag(a);
                if (-1 === a)
                    return
            }
        isFinite(a) && (this._changeAnimFrameIndex = a, this.IsInAnimationTrigger() || this._DoChangeAnimFrame())
    }
    _OnAnimationFramesChanged()
    {
        if (!this._changeAnimationName && -1 === this._changeAnimFrameIndex) {
            var a =
                this._currentAnimationFrame,
                b = this._currentAnimation.GetFrameAt(C3$jscomp$213.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1));
            a !== b && this._OnFrameChanged(a, b);
            1 < this._currentAnimation.GetFrameCount() && 0 < this._currentAnimationSpeed && this._StartTicking()
        }
    }
    _GetAnimFrame()
    {
        return this._currentFrameIndex
    }
    _GetAnimFrameTag()
    {
        return this._currentAnimationFrame.GetTag()
    }
    _SetAnimSpeed(a)
    {
        this._currentAnimationSpeed = Math.abs(a);
        this.SetPlayingForwards(0 <= a);
        0 < this._currentAnimationSpeed &&
        this._StartTicking()
    }
    _GetAnimSpeed()
    {
        return this.IsPlayingForwards() ? this._currentAnimationSpeed : -this._currentAnimationSpeed
    }
    _SetAnimRepeatToFrame(a)
    {
        if ("string" === typeof a && (a = this._currentAnimation.GetFrameIndexByTag(a), -1 === a))
            return;
        this._currentAnimationRepeatTo = a = C3$jscomp$213.clamp(Math.floor(a), 0, this._currentAnimation.GetFrameCount() - 1)
    }
    _GetAnimRepeatToFrame()
    {
        return this._currentAnimationRepeatTo
    }
    _DoChangeAnimation(a)
    {
        const b = this._currentAnimationFrame;
        var c = this._objectClass.GetAnimationByName(this._changeAnimationName);
        this._changeAnimationName = "";
        !c || c === this._currentAnimation && this.IsAnimationPlaying() || (this._currentAnimation = c, this.SetPlayingForwards(0 <= c.GetSpeed()), this._currentAnimationSpeed = Math.abs(c.GetSpeed()), this._currentAnimationRepeatTo = c.GetRepeatTo(), this._currentFrameIndex = C3$jscomp$213.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1), 1 === this._changeAnimationFrom && (this._currentFrameIndex = 0), this.SetAnimationPlaying(!0), this._frameStartTime = this.GetAnimationTime(), c = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
        this._OnFrameChanged(b, c, a))
    }
    _DoChangeAnimFrame(a)
    {
        const b = this._currentAnimationFrame,
            c = this._currentFrameIndex;
        this._currentFrameIndex = C3$jscomp$213.clamp(Math.floor(this._changeAnimFrameIndex), 0, this._currentAnimation.GetFrameCount() - 1);
        this._changeAnimFrameIndex = -1;
        if (a || c !== this._currentFrameIndex)
            a = this._currentAnimation.GetFrameAt(this._currentFrameIndex),
            this._OnFrameChanged(b, a),
            this._frameStartTime = this.GetAnimationTime()
    }
    _UpdateCurrentTexture()
    {
        const a = this._currentAnimationFrame.GetImageInfo();
        this._currentTexture = a.GetTexture();
        this._currentRcTex = a.GetTexRect();
        this._currentQuadTex = a.GetTexQuad();
        this.GetWorldInfo().SetMeshChanged(!0)
    }
    GetTexture()
    {
        return this._currentTexture
    }
    GetTexRect()
    {
        return this._currentRcTex
    }
    GetTexQuad()
    {
        return this._currentQuadTex
    }
    GetImagePointCount()
    {
        return this._currentAnimationFrame.GetImagePointCount()
    }
    GetImagePoint(a)
    {
        const b = this._currentAnimationFrame,
            c = this.GetWorldInfo();
        if ("string" === typeof a)
            a = b.GetImagePointByName(a);
        else if ("number" === typeof a)
            a = b.GetImagePointByIndex(a -
            1);
        else
            throw new TypeError("expected string or number");
        let d = c.GetTotalZElevation();
        if (!a)
            return [c.GetX(), c.GetY(), d];
        tempVec2$jscomp$1.copy(a.GetVec2());
        if (c.HasMesh()) {
            const [e, f, g] = c.GetSourceMesh().TransformPoint(tempVec2$jscomp$1.getX(), tempVec2$jscomp$1.getY());
            tempVec2$jscomp$1.set(e, f);
            d += g
        }
        tempVec2$jscomp$1.offset(-b.GetOriginX(), -b.GetOriginY());
        tempVec2$jscomp$1.scale(c.GetWidth(), c.GetHeight());
        tempVec2$jscomp$1.rotate(c.GetAngle());
        tempVec2$jscomp$1.offset(c.GetX(), c.GetY());
        return [tempVec2$jscomp$1.getX(),
        tempVec2$jscomp$1.getY(), d]
    }
    GetCollisionPolyPointCount()
    {
        return this.GetWorldInfo().GetTransformedCollisionPoly().pointCount()
    }
    GetCollisionPolyPoint(a)
    {
        a = Math.floor(a);
        const b = this.GetWorldInfo();
        var c = b.GetTransformedCollisionPoly();
        const d = c.pointCount();
        a === d && (a = 0);
        if (0 > a || a >= d)
            return [0, 0];
        c = c.pointsArr();
        return [c[2 * a] + b.GetX(), c[2 * a + 1] + b.GetY()]
    }
    GetDebuggerProperties()
    {
        const a = C3$jscomp$213.Plugins.Sprite.Acts;
        return [{
            title: "plugins.sprite.debugger.animation-properties.title",
            properties: [{
                name: "plugins.sprite.debugger.animation-properties.current-animation",
                value: this._currentAnimation.GetName(),
                onedit: b => this.CallAction(a.SetAnim, b, 0)
            }, {
                name: "plugins.sprite.debugger.animation-properties.current-frame",
                value: this._currentFrameIndex,
                onedit: b => this.CallAction(a.SetAnimFrame, b)
            }, {
                name: "plugins.sprite.debugger.animation-properties.is-playing",
                value: this.IsAnimationPlaying(),
                onedit: b => b ? this.CallAction(a.StartAnim, 0) : this.CallAction(a.StopAnim)
            }, {
                name: "plugins.sprite.debugger.animation-properties.speed",
                value: this._currentAnimationSpeed,
                onedit: b => this.CallAction(a.SetAnimSpeed,
                b)
            }, {
                name: "plugins.sprite.debugger.animation-properties.repeats",
                value: this._animationRepeats,
                onedit: b => this._animationRepeats = b
            }]
        }]
    }
    SaveToJson()
    {
        const a = {
            a: this._currentAnimation.GetSID()
        };
        0 !== this._frameStartTime && (a.fs = this._frameStartTime);
        var b = this.GetAnimationTime();
        0 !== b && (a.at = b);
        0 !== this._currentFrameIndex && (a.f = this._currentFrameIndex);
        0 !== this._currentAnimationSpeed && (a.cas = this._currentAnimationSpeed);
        1 !== this._animationRepeats && (a.ar = this._animationRepeats);
        0 !== this._currentAnimationRepeatTo &&
        (a.rt = this._currentAnimationRepeatTo);
        this.IsAnimationPlaying() || (a.ap = this.IsAnimationPlaying());
        this.IsPlayingForwards() || (a.af = this.IsPlayingForwards());
        b = this.GetWorldInfo();
        b.IsCollisionEnabled() && (a.ce = b.IsCollisionEnabled());
        return a
    }
    LoadFromJson(a)
    {
        var b = this.GetObjectClass().GetAnimationBySID(a.a);
        b && (this._currentAnimation = b);
        this._frameStartTime = a.hasOwnProperty("fs") ? a.fs : 0;
        this._animationTimer.Set(a.hasOwnProperty("at") ? a.at : 0);
        b = a.hasOwnProperty("f") ? a.f : 0;
        this._currentFrameIndex = C3$jscomp$213.clamp(b,
        0, this._currentAnimation.GetFrameCount() - 1);
        this._currentAnimationSpeed = a.hasOwnProperty("cas") ? a.cas : 0;
        this._animationRepeats = a.hasOwnProperty("ar") ? a.ar : 1;
        b = a.hasOwnProperty("rt") ? a.rt : 0;
        this._currentAnimationRepeatTo = C3$jscomp$213.clamp(b, 0, this._currentAnimation.GetFrameCount() - 1);
        this.SetAnimationPlaying(a.hasOwnProperty("ap") ? !!a.ap : !0);
        this.SetPlayingForwards(a.hasOwnProperty("af") ? !!a.af : !0);
        this._currentAnimationFrame = b = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
        this._UpdateCurrentTexture();
        const c = this.GetWorldInfo();
        c.SetOriginX(b.GetOriginX());
        c.SetOriginY(b.GetOriginY());
        c.SetSourceCollisionPoly(b.GetCollisionPoly());
        c.SetCollisionEnabled(!!a.ce);
        this.IsAnimationPlaying() && this._StartTicking()
    }
    GetPropertyValueByIndex(a)
    {
        const b = this.GetWorldInfo();
        switch (a) {
        case 3:
            return b.IsCollisionEnabled();
        case 2:
            return C3$jscomp$213.clamp(this._currentFrameIndex, 0, this._currentAnimation.GetFrameCount() - 1);
        case 1:
            return this._currentAnimation.GetName()
        }
    }
    SetPropertyValueByIndex(a, b, c)
    {
        var d = this.GetWorldInfo();
        switch (a) {
        case 3:
            d.SetCollisionEnabled(!!b);
            break;
        case 2:
            this.SetAnimationPlaying(!1);
            a = this._currentAnimation.GetFrameCount() - 1;
            d = b = C3$jscomp$213.clamp(b, 0, a);
            b = this._currentAnimation.GetFrameAt(this._currentFrameIndex);
            const e = this._currentAnimation.GetFrameAt(d);
            this._OnFrameChanged(b, e, c);
            this._currentFrameIndex = C3$jscomp$213.clamp(d, 0, a);
            break;
        case 1:
            this._changeAnimationName = b,
            this._DoChangeAnimation(c),
            1 < this._currentAnimation.GetFrameCount() && 0 < this._currentAnimation.GetSpeed() ? this._StartTicking() :
            this._StopTicking()
        }
    }
    GetScriptInterfaceClass()
    {
        return self.ISpriteInstance
    }
}
;
const map$jscomp$31 = new WeakMap,
    ANIM_FROM_MODES = new Map([["current-frame", 0], ["beginning", 1]]);
self.ISpriteInstance = class  extends self.IWorldInstance{
    constructor()
    {
        super();
        map$jscomp$31.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    getImagePointCount()
    {
        return map$jscomp$31.get(this).GetImagePointCount()
    }
    getImagePointX(a)
    {
        return this.getImagePoint(a)[0]
    }
    getImagePointY(a)
    {
        return this.getImagePoint(a)[1]
    }
    getImagePointZ(a)
    {
        return this.getImagePoint(a)[2]
    }
    getImagePoint(a)
    {
        if ("string" !== typeof a && "number" !== typeof a)
            throw new TypeError("expected string or number");
        return map$jscomp$31.get(this).GetImagePoint(a)
    }
    getPolyPointCount()
    {
        return map$jscomp$31.get(this).GetCollisionPolyPointCount()
    }
    getPolyPointX(a)
    {
        C3X$jscomp$37.RequireFiniteNumber(a);
        return map$jscomp$31.get(this).GetCollisionPolyPoint(a)[0]
    }
    getPolyPointY(a)
    {
        C3X$jscomp$37.RequireFiniteNumber(a);
        return map$jscomp$31.get(this).GetCollisionPolyPoint(a)[1]
    }
    getPolyPoint(a)
    {
        C3X$jscomp$37.RequireFiniteNumber(a);
        return map$jscomp$31.get(this).GetCollisionPolyPoint(a)
    }
    stopAnimation()
    {
        map$jscomp$31.get(this).SetAnimationPlaying(!1)
    }
    startAnimation(a="current-frame")
    {
        C3X$jscomp$37.RequireString(a);
        a = ANIM_FROM_MODES.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$31.get(this)._StartAnim(a)
    }
    setAnimation(a,
    b="beginning")
    {
        C3X$jscomp$37.RequireString(a);
        C3X$jscomp$37.RequireString(b);
        b = ANIM_FROM_MODES.get(b);
        if ("undefined" === typeof b)
            throw Error("invalid mode");
        const c = map$jscomp$31.get(this);
        if (!c.GetObjectClass().GetAnimationByName(a))
            throw Error(`animation name "${a}" does not exist`);
        c._SetAnim(a, b)
    }
    getAnimation(a)
    {
        C3X$jscomp$37.RequireString(a);
        return (a = map$jscomp$31.get(this).GetObjectClass().GetAnimationByName(a)) ? a.GetIAnimation() : null
    }
    get animation()
    {
        return map$jscomp$31.get(this)._GetCurrentAnimation().GetIAnimation()
    }
    get animationName()
    {
        return map$jscomp$31.get(this)._GetCurrentAnimationName()
    }
    set animationFrame(a)
    {
        C3X$jscomp$37.RequireFiniteNumber(a);
        map$jscomp$31.get(this)._SetAnimFrame(a)
    }
    get animationFrame()
    {
        return map$jscomp$31.get(this)._GetAnimFrame()
    }
    set animationFrameTag(a)
    {
        C3X$jscomp$37.RequireString(a);
        map$jscomp$31.get(this)._SetAnimFrame(a)
    }
    get animationFrameTag()
    {
        return map$jscomp$31.get(this)._GetAnimFrameTag()
    }
    set animationSpeed(a)
    {
        C3X$jscomp$37.RequireFiniteNumber(a);
        map$jscomp$31.get(this)._SetAnimSpeed(a)
    }
    get animationSpeed()
    {
        return map$jscomp$31.get(this)._GetAnimSpeed()
    }
    set animationRepeatToFrame(a)
    {
        C3X$jscomp$37.RequireFiniteNumber(a);
        map$jscomp$31.get(this)._SetAnimRepeatToFrame(a)
    }
    get animationRepeatToFrame()
    {
        return map$jscomp$31.get(this)._GetAnimRepeatToFrame()
    }
    get imageWidth()
    {
        return map$jscomp$31.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight()
    {
        return map$jscomp$31.get(this).GetCurrentImageInfo().GetHeight()
    }
    getImageSize()
    {
        const a = map$jscomp$31.get(this).GetCurrentImageInfo();
        return [a.GetWidth(), a.GetHeight()]
    }
    async replaceCurrentAnimationFrame(a)
    {
        C3X$jscomp$37.RequireInstanceOf(a, Blob);
        const b = map$jscomp$31.get(this),
            c = b.GetRuntime(),
            d = b.GetCurrentImageInfo(),
            e = C3$jscomp$213.New(C3$jscomp$213.ImageInfo);
        e.LoadDynamicBlobAsset(c, a);
        await e.LoadStaticTexture(c.GetRenderer(), {
            sampling: c.GetSampling()
        });
        b.WasReleased() ? e.Release() : (d.ReplaceWith(e), a = b.GetSdkType(), a._UpdateAllCurrentTexture(), a.GetObjectClass().Dispatcher().dispatchEvent(new C3$jscomp$213.Event("animationframeimagechange")), c.UpdateRender())
    }
    setSolidCollisionFilter(a, b)
    {
        C3X$jscomp$37.RequireString(b);
        map$jscomp$31.get(this).GetWorldInfo().SetSolidCollisionFilter(!!a,
        b)
    }
}
;
const C3$jscomp$214 = self.C3;
C3$jscomp$214.Plugins.Sprite.Cnds = {
    IsAnimPlaying(a) {
        return C3$jscomp$214.equalsNoCase(this._GetCurrentAnimationName(), a)
    },
    CompareFrame(a, b) {
        return C3$jscomp$214.compare(this._currentFrameIndex, a, b)
    },
    CompareFrameTag(a, b) {
        if ("string" !== typeof b)
            return !1;
        const c = this._currentAnimationFrame.GetTag();
        return C3$jscomp$214.compare(c.toLowerCase(), a, b.toLowerCase())
    },
    CompareAnimSpeed(a, b) {
        return C3$jscomp$214.compare(this._GetAnimSpeed(), a, b)
    },
    OnAnimFinished(a) {
        return C3$jscomp$214.equalsNoCase(this._animTriggerName, a)
    },
    OnAnyAnimFinished() {
        return !0
    },
    OnFrameChanged() {
        return !0
    },
    IsMirrored() {
        return 0 > this.GetWorldInfo().GetWidth()
    },
    IsFlipped() {
        return 0 > this.GetWorldInfo().GetHeight()
    },
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    },
    IsCollisionEnabled() {
        return this.GetWorldInfo().IsCollisionEnabled()
    }
};
const C3$jscomp$215 = self.C3;
C3$jscomp$215.Plugins.Sprite.Acts = {
    Spawn(a, b, c, d, e) {
        if (a && b) {
            var [f, g] = this.GetImagePoint(c);
            if (c = this._runtime.CreateInstance(a, b, f, g, d, e))
                d && b.SortAndAddInstancesByZIndex(c),
                a.GetPlugin().IsRotatable() && (b = c.GetWorldInfo(), b.SetAngle(this.GetWorldInfo().GetAngle()), b.SetBboxChanged()),
                b = this._runtime.GetEventSheetManager(),
                b.BlockFlushingInstances(!0),
                c._TriggerOnCreatedOnSelfAndRelated(),
                b.BlockFlushingInstances(!1),
                a !== this._runtime.GetCurrentAction().GetObjectClass() && this._sdkType._SpawnPickInstance(a,
                c, d)
        }
    },
    StopAnim() {
        this.SetAnimationPlaying(!1)
    },
    StartAnim(a) {
        this._StartAnim(a)
    },
    SetAnim(a, b) {
        this._SetAnim(a, b)
    },
    SetAnimFrame(a) {
        this._SetAnimFrame(a)
    },
    SetAnimSpeed(a) {
        this._SetAnimSpeed(a)
    },
    SetAnimRepeatToFrame(a) {
        this._SetAnimRepeatToFrame(a)
    },
    AddRemoveAnimation(a, b) {
        try {
            0 === a ? this.GetSdkType()._AddAnimation(b) : this.GetSdkType()._RemoveAnimation(b)
        } catch (c) {
            console.error(`[Construct] Error ${0 === a ? "adding" : "removing"} animation: `, c)
        }
    },
    AddRemoveAnimationFrame(a, b, c) {
        try {
            0 === a ? this.GetSdkType()._AddAnimationFrame(b,
            c) : this.GetSdkType()._RemoveAnimationFrame(b, c)
        } catch (d) {
            console.error(`[Construct] Error ${0 === a ? "adding" : "removing"} animation frame: `, d)
        }
    },
    SetMirrored(a) {
        const b = this.GetWorldInfo(),
            c = b.GetWidth();
        a = Math.abs(c) * (0 === a ? -1 : 1);
        c !== a && (b.SetWidth(a), b.SetBboxChanged())
    },
    SetFlipped(a) {
        const b = this.GetWorldInfo(),
            c = b.GetHeight();
        a = Math.abs(c) * (0 === a ? -1 : 1);
        c !== a && (b.SetHeight(a), b.SetBboxChanged())
    },
    SetScale(a) {
        const b = this._currentAnimationFrame.GetImageInfo(),
            c = this.GetWorldInfo();
        var d = 0 > c.GetWidth() ?
        -1 : 1;
        const e = 0 > c.GetHeight() ? -1 : 1;
        d *= b.GetWidth() * a;
        a = b.GetHeight() * a * e;
        if (c.GetWidth() !== d || c.GetHeight() !== a)
            c.SetSize(d, a),
            c.SetBboxChanged()
    },
    async LoadURL(a, b, c) {
        c = this._currentAnimationFrame.GetImageInfo();
        const d = this.GetWorldInfo(),
            e = this._runtime,
            f = this._sdkType;
        if (c.GetURL() === a)
            0 === b && (d.SetSize(c.GetWidth(), c.GetHeight()), d.SetBboxChanged()),
            this.Trigger(C3$jscomp$215.Plugins.Sprite.Cnds.OnURLLoaded);
        else {
            var g = C3$jscomp$215.New(C3$jscomp$215.ImageInfo);
            try {
                await g.LoadDynamicAsset(e,
                a);
                if (!g.IsLoaded())
                    throw Error("image failed to load");
                if (this.WasReleased()) {
                    g.Release();
                    return
                }
                await g.LoadStaticTexture(e.GetRenderer(), {
                    sampling: e.GetSampling()
                })
            } catch (h) {
                console.error("Load image from URL failed: ", h);
                this.WasReleased() || this.Trigger(C3$jscomp$215.Plugins.Sprite.Cnds.OnURLFailed);
                return
            }
            this.WasReleased() ? g.Release() : (c.ReplaceWith(g), f._UpdateAllCurrentTexture(), f.GetObjectClass().Dispatcher().dispatchEvent(new C3$jscomp$215.Event("animationframeimagechange")), e.UpdateRender(),
            0 === b && (d.SetSize(c.GetWidth(), c.GetHeight()), d.SetBboxChanged()), await this.TriggerAsync(C3$jscomp$215.Plugins.Sprite.Cnds.OnURLLoaded))
        }
    },
    SetCollisions(a) {
        this.GetWorldInfo().SetCollisionEnabled(a)
    },
    SetSolidCollisionFilter(a, b) {
        this.GetWorldInfo().SetSolidCollisionFilter(0 === a, b)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    }
};
self.C3.Plugins.Sprite.Exps = {
    AnimationFrame() {
        return this._GetAnimFrame()
    },
    AnimationFrameTag() {
        return this._GetAnimFrameTag()
    },
    AnimationFrameCount() {
        return this._currentAnimation.GetFrameCount()
    },
    AnimationName() {
        return this._currentAnimation.GetName()
    },
    AnimationSpeed() {
        return this._GetAnimSpeed()
    },
    OriginalAnimationSpeed() {
        return this._currentAnimation.GetSpeed()
    },
    ImagePointX(a) {
        return this.GetImagePoint(a)[0]
    },
    ImagePointY(a) {
        return this.GetImagePoint(a)[1]
    },
    ImagePointZ(a) {
        return this.GetImagePoint(a)[2]
    },
    ImagePointCount() {
        return this.GetImagePointCount()
    },
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    PolyPointXAt(a) {
        return this.GetCollisionPolyPoint(a)[0]
    },
    PolyPointYAt(a) {
        return this.GetCollisionPolyPoint(a)[1]
    },
    PolyPointCount() {
        return this.GetCollisionPolyPointCount()
    }
};
"use strict";
const C3$jscomp$217 = self.C3;
C3$jscomp$217.Plugins.Text = class  extends C3$jscomp$217.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$218 = self.C3;
C3$jscomp$218.Plugins.Text.Type = class  extends C3$jscomp$218.SDKTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
    LoadTextures(a) {}
    ReleaseTextures() {}
}
;
const C3$jscomp$219 = self.C3,
    C3X$jscomp$38 = self.C3X,
    TEMP_COLOR_ARRAY$jscomp$1 = [0, 0, 0],
    HORIZONTAL_ALIGNMENTS = ["left", "center", "right"],
    VERTICAL_ALIGNMENTS = ["top", "center", "bottom"],
    TEXT_DIRECTIONS = ["ltr", "rtl"],
    WORD_WRAP_MODES = ["word", "cjk", "character"],
    tempRect$jscomp$12 = new C3$jscomp$219.Rect,
    tempQuad$jscomp$7 = new C3$jscomp$219.Quad,
    tempColor$jscomp$8 = new C3$jscomp$219.Color,
    tempVec2$jscomp$2 = C3$jscomp$219.New(C3$jscomp$219.Vector2),
    BBCODE_TAG_TO_HTML = new Map([["b", "strong"], ["i", "em"], ["s", "s"],
    ["u", "u"], ["iconoffsety", null]]);
C3$jscomp$219.Plugins.Text.Instance = class  extends C3$jscomp$219.SDKWorldInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._text = "";
        this._enableBBcode = !0;
        this._faceName = "Arial";
        this._ptSize = 12;
        this._lineHeightOffset = 0;
        this._isItalic = this._isBold = !1;
        this._color = C3$jscomp$219.New(C3$jscomp$219.Color);
        this._verticalAlign = this._horizontalAlign = 0;
        this._wrapMode = "word";
        this._textDirection = 0;
        this._resolutionMode = "auto";
        this._fixedScaleFactor = 1;
        this._iconObjectClass = null;
        this._htmlString = "";
        this._readAloud = this._isHtmlStringUpToDate =
        !1;
        this._screenReaderText = null;
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        this._rendererText = C3$jscomp$219.New(C3$jscomp$219.Gfx.RendererText, this._runtime.GetRenderer(), {
            timeout: 5
        });
        this._rendererText.ontextureupdate = () => this._runtime.UpdateRender();
        this._animationframeimagechange_handler = () => this._OnIconObjectClassImageChanged();
        this._pendingUpdateIconSet = !1;
        b && (this._text = b[0], this._enableBBcode = !!b[1], this._faceName = b[2], this._ptSize = b[3], this._lineHeightOffset =
        b[4], this._isBold = !!b[5], this._isItalic = !!b[6], this._horizontalAlign = b[8], this._verticalAlign = b[9], this._wrapMode = WORD_WRAP_MODES[b[10]], this._textDirection = b[11], this._SetIconObjectClass(this._runtime.GetObjectClassBySID(b[12])), a = b[7], this._color.setRgb(a[0], a[1], a[2]), this.GetWorldInfo().SetVisible(b[13]), this._readAloud = !!b[15]);
        this._UpdateTextSettings();
        this._UpdateScreenReaderText()
    }
    Release()
    {
        this._SetIconObjectClass(null);
        this._CancelTypewriter();
        this._screenReaderText && (this._screenReaderText.Release(),
        this._screenReaderText = null);
        this._rendererText.Release();
        this._rendererText = null;
        super.Release()
    }
    _UpdateTextSettings()
    {
        const a = this._rendererText;
        a.SetText(this._text);
        a.SetBBCodeEnabled(this._enableBBcode);
        this._rendererText.IsBBCodeEnabled() && this._iconObjectClass ? this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)) : this._rendererText.SetIconSet(null);
        a.SetIconSmoothing("nearest" !== this._runtime.GetSampling());
        a.SetFontName(this._faceName);
        a.SetLineHeight(this._lineHeightOffset);
        a.SetBold(this._isBold);
        a.SetItalic(this._isItalic);
        a.SetColor(this._color);
        a.SetHorizontalAlignment(HORIZONTAL_ALIGNMENTS[this._horizontalAlign]);
        a.SetVerticalAlignment(VERTICAL_ALIGNMENTS[this._verticalAlign]);
        a.SetWordWrapMode(this._wrapMode);
        a.SetTextDirection(TEXT_DIRECTIONS[this._textDirection])
    }
    _UpdateTextSize()
    {
        const a = this.GetWorldInfo();
        this._rendererText.SetFontSize(this._ptSize);
        this._rendererText.SetFontSizeScale(a.GetSceneGraphScale());
        const b = a.GetLayer();
        let c;
        "auto" === this._resolutionMode ?
        c = b.GetResolutionScaleFactorToZ(a.GetTotalZElevation()) : "fixed" === this._resolutionMode && (c = this._fixedScaleFactor);
        a.HasMesh() && c !== this._rendererText.GetZoom() && a.SetMeshChanged(!0);
        this._rendererText.SetSize(a.GetWidth(), a.GetHeight(), c)
    }
    _SetIconObjectClass(a)
    {
        a && (a.IsFamily() || a.GetPlugin().constructor !== C3$jscomp$219.Plugins.Sprite) || a === this._iconObjectClass || (this._iconObjectClass && this._iconObjectClass.Dispatcher().removeEventListener("animationframeimagechange", this._animationframeimagechange_handler),
        (this._iconObjectClass = a) && this._iconObjectClass.Dispatcher().addEventListener("animationframeimagechange", this._animationframeimagechange_handler), this._UpdateTextSettings(), this._isHtmlStringUpToDate = !1, this._runtime.UpdateRender())
    }
    _OnIconObjectClassImageChanged()
    {
        this._runtime.DeleteTextIconSet(this._iconObjectClass);
        this._runtime.UpdateRender();
        this._pendingUpdateIconSet = !0
    }
    _UpdateScreenReaderText()
    {
        if (this._readAloud) {
            let a = this._text;
            this._enableBBcode && (a = C3$jscomp$219.BBString.StripAnyTags(a));
            this._screenReaderText ? this._screenReaderText.SetText(a) : this._screenReaderText = C3$jscomp$219.New(C3$jscomp$219.ScreenReaderText, this._runtime, a)
        } else
            this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null)
    }
    Draw(a)
    {
        var b = this.GetWorldInfo();
        this._UpdateTextSize();
        this._pendingUpdateIconSet && (this._pendingUpdateIconSet = !1, this._rendererText.IsBBCodeEnabled() && this._iconObjectClass && this._rendererText.SetIconSet(this.GetRuntime().GetTextIconSet(this._iconObjectClass)));
        const c = this._rendererText.GetTexture();
        if (c) {
            var d = b.GetLayer();
            if (0 === b.GetAngle() && 0 === d.GetAngle() && 0 === b.GetTotalZElevation() && !b.HasMesh() && d.RendersIn2DMode()) {
                b = b.GetBoundingQuad();
                const [e, f] = d.LayerToDrawSurface(b.getTlx(), b.getTly()),
                    [g, h] = d.LayerToDrawSurface(b.getBrx(), b.getBry());
                b = e - Math.round(e);
                const k = f - Math.round(f);
                tempRect$jscomp$12.set(e, f, g, h);
                tempRect$jscomp$12.offset(-b, -k);
                tempQuad$jscomp$7.setFromRect(tempRect$jscomp$12);
                const [l, m] = a.GetRenderTargetSize(a.GetRenderTarget());
                this._runtime.GetCanvasManager().SetDeviceTransform(a, l, m);
                a.SetTexture(c);
                a.Quad3(tempQuad$jscomp$7, this._rendererText.GetTexRect());
                d._SetTransform(a)
            } else
                a.SetTexture(c),
                b.HasMesh() ? this._DrawMesh(b, a) : this._DrawStandard(b, a)
        }
    }
    _DrawStandard(a, b)
    {
        a = a.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() && (a = this._PixelRoundQuad(a));
        b.Quad3(a, this._rendererText.GetTexRect())
    }
    _DrawMesh(a, b)
    {
        const c = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$12, tempQuad$jscomp$7,
            !1);
            let d = tempQuad$jscomp$7;
            this._runtime.IsPixelRoundingEnabled() && (d = this._PixelRoundQuad(d));
            c.CalculateTransformedMesh(a.GetSourceMesh(), d, this._rendererText.GetTexRect());
            a.SetMeshChanged(!1)
        }
        c.Draw(b)
    }
    _PixelRoundQuad(a)
    {
        const b = a.getTlx() - Math.round(a.getTlx()),
            c = a.getTly() - Math.round(a.getTly());
        if (0 === b && 0 === c)
            return a;
        tempQuad$jscomp$7.copy(a);
        tempQuad$jscomp$7.offset(-b, -c);
        return tempQuad$jscomp$7
    }
    GetCurrentSurfaceSize()
    {
        const a = this._rendererText.GetTexture();
        return a ? [a.GetWidth(), a.GetHeight()] :
        [100, 100]
    }
    GetCurrentTexRect()
    {
        return this._rendererText.GetTexRect()
    }
    IsCurrentTexRotated()
    {
        return !1
    }
    SaveToJson()
    {
        const a = {
            t: this._text,
            c: this._color.toJSON(),
            fn: this._faceName,
            ps: this._ptSize
        };
        this._enableBBcode && (a.bbc = this._enableBBcode);
        0 !== this._horizontalAlign && (a.ha = this._horizontalAlign);
        0 !== this._verticalAlign && (a.va = this._verticalAlign);
        "word" !== this._wrapMode && (a.wr = this._wrapMode);
        0 !== this._lineHeightOffset && (a.lho = this._lineHeightOffset);
        this._isBold && (a.b = this._isBold);
        this._isItalic &&
        (a.i = this._isItalic);
        -1 !== this._typewriterEndTime && (a.tw = {
            st: this._typewriterStartTime,
            en: this._typewriterEndTime,
            l: this._typewriterLength
        });
        this._iconObjectClass && (a.ioc = this._iconObjectClass.GetSID());
        "fixed" === this._resolutionMode && (a.fs = this._fixedScaleFactor);
        return a
    }
    LoadFromJson(a)
    {
        this._CancelTypewriter();
        this._text = a.t;
        this._color.setFromJSON(a.c);
        this._faceName = a.fn;
        this._ptSize = a.ps;
        this._enableBBcode = a.hasOwnProperty("bbc") ? a.bbc : !1;
        this._horizontalAlign = a.hasOwnProperty("ha") ? a.ha : 0;
        this._verticalAlign = a.hasOwnProperty("va") ? a.va : 0;
        if (a.hasOwnProperty("wr")) {
            var b = a.wr;
            this._wrapMode = "boolean" === typeof b ? b ? "word" : "character" : b
        } else
            this._wrapMode = "word";
        this._lineHeightOffset = a.hasOwnProperty("lho") ? a.lho : 0;
        this._isBold = a.hasOwnProperty("b") ? a.b : !1;
        this._isItalic = a.hasOwnProperty("i") ? a.i : !1;
        a.hasOwnProperty("tw") && (b = a.tw, this._typewriterStartTime = b.st, this._typewriterEndTime = b.en, this._typewriterLength = b.l);
        a.hasOwnProperty("ioc") ? (b = this.GetRuntime().GetObjectClassBySID(a.ioc)) &&
        this._SetIconObjectClass(b) : this._SetIconObjectClass(null);
        a.hasOwnProperty("fs") ? (this._resolutionMode = "fixed", this._fixedScaleFactor = a.fs) : this._resolutionMode = "auto";
        this._UpdateTextSettings();
        this._UpdateScreenReaderText();
        this._isHtmlStringUpToDate = !1;
        -1 !== this._typewriterEndTime && this._StartTicking()
    }
    GetPropertyValueByIndex(a)
    {
        switch (a) {
        case 0:
            return this.GetText();
        case 1:
            return this._enableBBcode;
        case 2:
            return this._GetFontFace();
        case 3:
            return this._GetFontSize();
        case 4:
            return this._GetLineHeight();
        case 5:
            return this._IsBold();
        case 6:
            return this._IsItalic();
        case 7:
            return TEMP_COLOR_ARRAY$jscomp$1[0] = this._color.getR(), TEMP_COLOR_ARRAY$jscomp$1[1] = this._color.getG(), TEMP_COLOR_ARRAY$jscomp$1[2] = this._color.getB(), TEMP_COLOR_ARRAY$jscomp$1;
        case 8:
            return this._GetHAlign();
        case 9:
            return this._GetVAlign();
        case 10:
            return this._GetWrapMode();
        case 15:
            return this._IsReadAloud()
        }
    }
    SetPropertyValueByIndex(a, b)
    {
        switch (a) {
        case 0:
            this._SetText(b);
            break;
        case 1:
            if (this._enableBBcode === !!b)
                break;
            this._enableBBcode =
            !!b;
            this._UpdateTextSettings();
            break;
        case 2:
            this._SetFontFace(b);
            break;
        case 3:
            this._SetFontSize(b);
            break;
        case 4:
            this._SetLineHeight(b);
            break;
        case 5:
            this._SetBold(b);
            break;
        case 6:
            this._SetItalic(b);
            break;
        case 7:
            a = this._color;
            if (a.getR() === b[0] && a.getG() === b[1] && a.getB() === b[2])
                break;
            this._color.setRgb(b[0], b[1], b[2]);
            this._UpdateTextSettings();
            break;
        case 8:
            this._SetHAlign(b);
            break;
        case 9:
            this._SetVAlign(b);
            break;
        case 10:
            this._SetWrapMode(b)
        }
    }
    SetPropertyColorOffsetValueByIndex(a, b, c, d)
    {
        if (0 !== b || 0 !==
        c || 0 !== d)
            switch (a) {
            case 7:
                this._color.addRgb(b, c, d),
                this._UpdateTextSettings()
            }
    }
    _SetText(a)
    {
        this._text !== a && (this._text = a, this._rendererText.SetText(a), this._UpdateScreenReaderText(), this._isHtmlStringUpToDate = !1, this._runtime.UpdateRender())
    }
    GetText()
    {
        return this._text
    }
    _StartTypewriter(a, b)
    {
        this._UpdateTextSize();
        this._SetText(a);
        this._typewriterStartTime = this._runtime.GetWallTime();
        this._typewriterEndTime = this._typewriterStartTime + b / this.GetInstance().GetActiveTimeScale();
        this._typewriterLength =
        this._rendererText.GetLengthInGraphemes();
        this._rendererText.SetDrawMaxCharacterCount(0);
        this._StartTicking()
    }
    _CancelTypewriter()
    {
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        this._rendererText.SetDrawMaxCharacterCount(-1);
        this._StopTicking()
    }
    _FinishTypewriter()
    {
        -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(C3$jscomp$219.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
    }
    _SetFontFace(a)
    {
        this._faceName !== a && (this._faceName =
        a, this._rendererText.SetFontName(a), this._runtime.UpdateRender())
    }
    _GetFontFace()
    {
        return this._faceName
    }
    _SetBold(a)
    {
        a = !!a;
        this._isBold !== a && (this._isBold = a, this._rendererText.SetBold(a), this._runtime.UpdateRender())
    }
    _IsBold()
    {
        return this._isBold
    }
    _SetItalic(a)
    {
        a = !!a;
        this._isItalic !== a && (this._isItalic = a, this._rendererText.SetItalic(a), this._runtime.UpdateRender())
    }
    _IsItalic()
    {
        return this._isItalic
    }
    _SetFontSize(a)
    {
        this._ptSize !== a && (this._ptSize = a, this._runtime.UpdateRender())
    }
    _GetFontSize()
    {
        return this._ptSize
    }
    _SetFontColor(a)
    {
        this._color.equalsIgnoringAlpha(a) ||
        (this._color.copyRgb(a), this._rendererText.SetColor(this._color), this._runtime.UpdateRender())
    }
    _GetFontColor()
    {
        return this._color
    }
    _SetLineHeight(a)
    {
        this._lineHeightOffset !== a && (this._lineHeightOffset = a, this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetLineHeight()
    {
        return this._lineHeightOffset
    }
    _SetHAlign(a)
    {
        this._horizontalAlign !== a && (this._horizontalAlign = a, this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetHAlign()
    {
        return this._horizontalAlign
    }
    _SetVAlign(a)
    {
        this._verticalAlign !==
        a && (this._verticalAlign = a, this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetVAlign()
    {
        return this._verticalAlign
    }
    _SetWrapModeByIndex(a)
    {
        this._SetWrapMode(WORD_WRAP_MODES[a])
    }
    _SetWrapMode(a)
    {
        this._wrapMode !== a && (this._wrapMode = a, this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetWrapMode()
    {
        return this._wrapMode
    }
    _SetTextDirection(a)
    {
        this._textDirection !== a && (this._textDirection = a, this._UpdateTextSettings(), this._runtime.UpdateRender())
    }
    _GetTextDirection()
    {
        return this._textDirection
    }
    _SetReadAloud(a)
    {
        this._readAloud =
        !!a;
        this._UpdateScreenReaderText()
    }
    _IsReadAloud()
    {
        return this._readAloud
    }
    _SetResolutionMode(a)
    {
        this._resolutionMode !== a && (this._resolutionMode = a, this._runtime.UpdateRender())
    }
    _GetResolutionMode()
    {
        return this._resolutionMode
    }
    _SetFixedScaleFactor(a)
    {
        this._fixedScaleFactor !== a && (this._fixedScaleFactor = a, "fixed" === this._resolutionMode && this._runtime.UpdateRender())
    }
    _GetFixedScaleFactor()
    {
        return this._fixedScaleFactor
    }
    _GetTextWidth()
    {
        this._UpdateTextSize();
        return this._rendererText.GetTextWidth()
    }
    _GetTextHeight()
    {
        this._UpdateTextSize();
        return this._rendererText.GetTextHeight()
    }
    _GetTagAtPosition(a, b)
    {
        this._UpdateTextSize();
        const c = this.GetWorldInfo();
        tempVec2$jscomp$2.set(a - c.GetX(), b - c.GetY());
        tempVec2$jscomp$2.rotate(-c.GetAngle());
        tempVec2$jscomp$2.offset(c.GetWidth() * c.GetOriginX(), c.GetHeight() * c.GetOriginY());
        tempVec2$jscomp$2.divide(c.GetWidth(), c.GetHeight());
        tempVec2$jscomp$2.scale(this._rendererText.GetWidth(), this._rendererText.GetHeight());
        if (a = this._rendererText.HitTestFragment(tempVec2$jscomp$2.getX(), tempVec2$jscomp$2.getY()))
            if (a =
            a.GetStyleTag("tag"))
                return a.param;
        return ""
    }
    _HasTagAtPosition(a, b, c)
    {
        return (b = this._GetTagAtPosition(b, c)) && C3$jscomp$219.equalsNoCase(a, b)
    }
    _GetTagPosition(a, b)
    {
        this._UpdateTextSize();
        b = Math.floor(b);
        var c = this._rendererText.FindFragmentWithTag(a, b);
        if (!c)
            return null;
        a = this.GetWorldInfo();
        const d = this._rendererText.GetDrawScale();
        b = c.GetPosX();
        const e = c.GetPosY() - (c.GetHeight() - c.GetFontBoundingBoxDescent()) * d,
            f = c.GetWidth() * d / this._rendererText.GetWidth() * a.GetWidth();
        c = c.GetHeight() * d / this._rendererText.GetHeight() *
        a.GetHeight();
        tempVec2$jscomp$2.set(b, e);
        tempVec2$jscomp$2.divide(this._rendererText.GetWidth(), this._rendererText.GetHeight());
        tempVec2$jscomp$2.scale(a.GetWidth(), a.GetHeight());
        tempVec2$jscomp$2.offset(-a.GetWidth() * a.GetOriginX(), -a.GetHeight() * a.GetOriginY());
        tempVec2$jscomp$2.rotate(a.GetAngle());
        tempVec2$jscomp$2.offset(a.GetX(), a.GetY());
        return {
            x: tempVec2$jscomp$2.getX(),
            y: tempVec2$jscomp$2.getY(),
            width: f,
            height: c
        }
    }
    _GetTagCount(a)
    {
        this._UpdateTextSize();
        return this._rendererText.CountFragmentsWithTag(a)
    }
    _GetHTMLCloseTag(a)
    {
        a =
        BBCODE_TAG_TO_HTML.get(a);
        if (null === a)
            return "";
        a || (a = "span");
        return `</${a || "span"}>`
    }
    _GetHTMLOpenTag(a, b)
    {
        let c = BBCODE_TAG_TO_HTML.get(a);
        if (null === c)
            return "";
        c || (c = "span");
        switch (a) {
        case "color":
            return `<${c} style="color: ${b}">`;
        case "font":
            return `<${c} style="font-family: '${b}'">`;
        case "opacity":
            return `<${c} style="opacity: ${b}%">`;
        case "size":
            return `<${c} style="font-size: ${b}pt">`;
        case "background":
            return `<${c} style="background-color: ${b}">`;
        case "hide":
            return `<${c} style="visibility: hidden">`;
        case "class":
            return `<${c} class="${b}">`;
        case "tag":
            return `<${c} data-tag="${b}">`;
        default:
            return `<${c}>`
        }
    }
    async _UpdateHTMLString()
    {
        if (this._isHtmlStringUpToDate)
            return this._htmlString;
        var a = (new C3$jscomp$219.BBString(this._text, {
            noEscape: !0
        })).toFragmentList();
        const b = new Map;
        let c = '<span class="c3-text"';
        var d = [];
        d.push(`font-family: '${this._GetFontFace()}';`);
        this._IsBold() && d.push("font-weight: bold;");
        this._IsItalic() && d.push("font-style: italic;");
        "character" === this._GetWrapMode() && d.push("word-break: break-all;");
        c += ` style="${d.join(" ")}">`;
        d = this._iconObjectClass ? this.GetRuntime().GetTextIconSet(this._iconObjectClass) : null;
        if (this._iconObjectClass) {
            var e = C3$jscomp$219.New(C3$jscomp$219.PromiseThrottle),
                f = [];
            const m = new Map;
            for (var g of a)
                if (g.IsIcon()) {
                    const n = g.GetTextIcon(d);
                    if (n) {
                        const p = n.GetSource().GetImageInfo().GetImageAsset();
                        m.has(p) || (m.set(p, null), f.push(e.Add(async () => {
                            const q = await p.LoadToDrawable();
                            m.set(p, q)
                        })))
                    }
                }
            await Promise.all(f);
            g = [];
            for (var h of a)
                if (h.IsIcon()) {
                    const n = h.GetTextIcon(d);
                    if (n) {
                        const p = n.GetSource(),
                            q = p.GetImageInfo().GetImageAsset();
                        g.push(e.Add(async () => {
                            const r = await p.GetImageInfo().ExtractImageToBlobURL(m.get(q));
                            b.set(n, r)
                        }))
                    }
                }
            await Promise.all(g);
            for (var k of m.values())
                k instanceof ImageBitmap && k.close && k.close()
        }
        h = new Map;
        for (var l of a) {
            g = l.GetStyleMap();
            a = [...h.keys()];
            a.reverse();
            for (const m of a)
                g.has(m) && g.get(m) === h.get(m) || (h.delete(m), c += this._GetHTMLCloseTag(m));
            for (const [m, n] of g)
                h.has(m) || (h.set(m, n), c += this._GetHTMLOpenTag(m, n));
            l.IsText() && (c +=
            C3$jscomp$219.ReplaceAll(C3$jscomp$219.EscapeHTML(l.GetCharacterArray().join("")), "\n", "<br>"));
            if (l.IsIcon() && d && (a = l.GetTextIcon(d)) && (k = b.get(a))) {
                e = [];
                f = "0.2em";
                if (g = g.get("iconoffsety"))
                    g = g.trim(),
                    f = g.endsWith("%") ? parseFloat(g) / 100 + "em" : g + "px";
                e.push(`top: ${f}`);
                "nearest" === this._runtime.GetSampling() && e.push("image-rendering: pixelated");
                c += `<img class="c3-text-icon" data-icon="${l.GetIconParameter()}" width="${a.GetWidth()}" height="${a.GetHeight()}" style="${e.join(";")}" src="${k}">`
            }
        }
        l =
        [...h.keys()];
        l.reverse();
        for (const m of l)
            c += this._GetHTMLCloseTag(m);
        this._htmlString = c + "</span>";
        this._isHtmlStringUpToDate = !0;
        return this._htmlString
    }
    Tick()
    {
        var a = this._runtime.GetWallTime();
        a >= this._typewriterEndTime ? (this._CancelTypewriter(), this.Trigger(C3$jscomp$219.Plugins.Text.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()) : (a = C3$jscomp$219.relerp(this._typewriterStartTime, this._typewriterEndTime, a, 0, this._typewriterLength), a = Math.floor(a), a !== this._rendererText.GetDrawMaxCharacterCount() &&
        (this._rendererText.SetDrawMaxCharacterCount(a), this._runtime.UpdateRender()))
    }
    GetDebuggerProperties()
    {
        return [{
            title: "plugins.text.name",
            properties: [{
                name: "plugins.text.properties.text.name",
                value: this.GetText(),
                onedit: a => this._SetText(a)
            }, {
                name: "plugins.text.properties.font.name",
                value: this._GetFontFace(),
                onedit: a => this._SetFontFace(a)
            }, {
                name: "plugins.text.properties.size.name",
                value: this._GetFontSize(),
                onedit: a => this._SetFontSize(a)
            }, {
                name: "plugins.text.properties.line-height.name",
                value: this._GetLineHeight(),
                onedit: a => this._SetLineHeight(a)
            }, {
                name: "plugins.text.properties.bold.name",
                value: this._IsBold(),
                onedit: a => this._SetBold(a)
            }, {
                name: "plugins.text.properties.italic.name",
                value: this._IsItalic(),
                onedit: a => this._SetItalic(a)
            }]
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.ITextInstance
    }
}
;
const map$jscomp$32 = new WeakMap,
    SCRIPT_HORIZONTAL_ALIGNMENTS = new Map([["left", 0], ["center", 1], ["right", 2]]),
    SCRIPT_VERTICAL_ALIGNMENTS = new Map([["top", 0], ["center", 1], ["bottom", 2]]),
    SCRIPT_TEXT_DIRECTIONS = ["ltr", "rtl"];
new Set(["auto", "fixed"]);
self.ITextInstance = class  extends self.IWorldInstance{
    constructor()
    {
        super();
        map$jscomp$32.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get text()
    {
        return map$jscomp$32.get(this).GetText()
    }
    set text(a)
    {
        C3X$jscomp$38.RequireString(a);
        const b = map$jscomp$32.get(this);
        b._CancelTypewriter();
        b._SetText(a)
    }
    typewriterText(a, b)
    {
        C3X$jscomp$38.RequireString(a);
        C3X$jscomp$38.RequireFiniteNumber(b);
        const c = map$jscomp$32.get(this);
        c._CancelTypewriter();
        c._StartTypewriter(a, b)
    }
    typewriterFinish()
    {
        map$jscomp$32.get(this)._FinishTypewriter()
    }
    set fontFace(a)
    {
        C3X$jscomp$38.RequireString(a);
        map$jscomp$32.get(this)._SetFontFace(a)
    }
    get fontFace()
    {
        return map$jscomp$32.get(this)._GetFontFace()
    }
    set isBold(a)
    {
        map$jscomp$32.get(this)._SetBold(a)
    }
    get isBold()
    {
        return map$jscomp$32.get(this)._IsBold()
    }
    set isItalic(a)
    {
        map$jscomp$32.get(this)._SetItalic(a)
    }
    get isItalic()
    {
        return map$jscomp$32.get(this)._IsItalic()
    }
    set sizePt(a)
    {
        C3X$jscomp$38.RequireFiniteNumber(a);
        map$jscomp$32.get(this)._SetFontSize(a)
    }
    get sizePt()
    {
        return map$jscomp$32.get(this)._GetFontSize()
    }
    set fontColor(a)
    {
        C3X$jscomp$38.RequireArray(a);
        if (3 > a.length)
            throw Error("expected 3 elements");
        tempColor$jscomp$8.setRgb(a[0], a[1], a[2]);
        map$jscomp$32.get(this)._SetFontColor(tempColor$jscomp$8)
    }
    get fontColor()
    {
        const a = map$jscomp$32.get(this)._GetFontColor();
        return [a.getR(), a.getG(), a.getB()]
    }
    set lineHeight(a)
    {
        C3X$jscomp$38.RequireFiniteNumber(a);
        map$jscomp$32.get(this)._SetLineHeight(a)
    }
    get lineHeight()
    {
        return map$jscomp$32.get(this)._GetLineHeight()
    }
    set horizontalAlign(a)
    {
        C3X$jscomp$38.RequireString(a);
        a = SCRIPT_HORIZONTAL_ALIGNMENTS.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$32.get(this)._SetHAlign(a)
    }
    get horizontalAlign()
    {
        return HORIZONTAL_ALIGNMENTS[map$jscomp$32.get(this)._GetHAlign()]
    }
    set verticalAlign(a)
    {
        C3X$jscomp$38.RequireString(a);
        a = SCRIPT_VERTICAL_ALIGNMENTS.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$32.get(this)._SetVAlign(a)
    }
    get verticalAlign()
    {
        return VERTICAL_ALIGNMENTS[map$jscomp$32.get(this)._GetVAlign()]
    }
    set wordWrapMode(a)
    {
        if (!WORD_WRAP_MODES.includes(a))
            throw Error("invalid mode");
        map$jscomp$32.get(this)._SetWrapMode(a)
    }
    get wordWrapMode()
    {
        return map$jscomp$32.get(this)._GetWrapMode()
    }
    set textDirection(a)
    {
        C3X$jscomp$38.RequireString(a);
        a = SCRIPT_TEXT_DIRECTIONS.indexOf(a);
        if (-1 === a)
            throw Error("invalid text direction");
        map$jscomp$32.get(this)._SetTextDirection(a)
    }
    get textDirection()
    {
        return SCRIPT_TEXT_DIRECTIONS[map$jscomp$32.get(this)._GetTextDirection()]
    }
    set readAloud(a)
    {
        map$jscomp$32.get(this)._SetReadAloud(!!a)
    }
    get readAloud()
    {
        return map$jscomp$32.get(this)._IsReadAloud()
    }
    setFixedResolutionMode(a)
    {
        C3X$jscomp$38.RequireFiniteNumber(a);
        const b = map$jscomp$32.get(this);
        b._SetResolutionMode("fixed");
        b._SetFixedScaleFactor(a)
    }
    setAutoResolutionMode()
    {
        map$jscomp$32.get(this)._SetResolutionMode("auto")
    }
    get textWidth()
    {
        return map$jscomp$32.get(this)._GetTextWidth()
    }
    get textHeight()
    {
        return map$jscomp$32.get(this)._GetTextHeight()
    }
    getTextSize()
    {
        const a = map$jscomp$32.get(this);
        return [a._GetTextWidth(), a._GetTextHeight()]
    }
    hasTagAtPosition(a, b, c)
    {
        C3X$jscomp$38.RequireString(a);
        C3X$jscomp$38.RequireFiniteNumber(b);
        C3X$jscomp$38.RequireFiniteNumber(c);
        return map$jscomp$32.get(this)._HasTagAtPosition(a, b, c)
    }
    getTagAtPosition(a, b)
    {
        C3X$jscomp$38.RequireFiniteNumber(a);
        C3X$jscomp$38.RequireFiniteNumber(b);
        return map$jscomp$32.get(this)._GetTagAtPosition(a, b)
    }
    getTagPositionAndSize(a, b=0)
    {
        C3X$jscomp$38.RequireString(a);
        C3X$jscomp$38.RequireFiniteNumber(b);
        return map$jscomp$32.get(this)._GetTagPosition(a, b)
    }
    getTagCount(a)
    {
        C3X$jscomp$38.RequireString(a);
        return map$jscomp$32.get(this)._GetTagCount(a)
    }
    changeIconSet(a)
    {
        const b = map$jscomp$32.get(this);
        a = b.GetRuntime()._UnwrapIObjectClass(a);
        b._SetIconObjectClass(a)
    }
    getAsHtmlString()
    {
        return map$jscomp$32.get(this)._UpdateHTMLString()
    }
}
;
const C3$jscomp$220 = self.C3;
C3$jscomp$220.Plugins.Text.Cnds = {
    CompareText(a, b) {
        return b ? this._text === a : C3$jscomp$220.equalsNoCase(this._text, a)
    },
    IsRunningTypewriterText() {
        return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
        return !0
    },
    HasTagAtPosition(a, b, c) {
        return this._HasTagAtPosition(a, b, c)
    }
};
const C3$jscomp$221 = self.C3,
    tempColor$jscomp$9 = C3$jscomp$221.New(C3$jscomp$221.Color);
C3$jscomp$221.Plugins.Text.Acts = {
    SetText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._SetText(a.toString())
    },
    AppendText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        (a = a.toString()) && this._SetText(this._text + a)
    },
    TypewriterText(a, b) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._StartTypewriter(a.toString(), b)
    },
    SetFontFace(a, b) {
        let c = !1,
            d = !1;
        switch (b) {
        case 1:
            c = !0;
            break;
        case 2:
            d =
            !0;
            break;
        case 3:
            d = c = !0
        }
        if (a !== this._faceName || c !== this._isBold || d !== this._isItalic)
            this._SetFontFace(a),
            this._SetBold(c),
            this._SetItalic(d)
    },
    SetFontSize(a) {
        this._SetFontSize(a)
    },
    SetFontColor(a) {
        tempColor$jscomp$9.setFromRgbValue(a);
        tempColor$jscomp$9.clamp();
        this._SetFontColor(tempColor$jscomp$9)
    },
    SetWebFont(a, b) {
        console.warn("[Text] 'Set web font' action is deprecated and no longer has any effect")
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetLineHeight(a) {
        this._SetLineHeight(a)
    },
    SetHAlign(a) {
        this._SetHAlign(a)
    },
    SetVAlign(a) {
        this._SetVAlign(a)
    },
    SetWrapping(a) {
        this._SetWrapModeByIndex(a)
    },
    SetTextDirection(a) {
        this._SetTextDirection(a)
    },
    ChangeIconSet(a) {
        this._SetIconObjectClass(a)
    },
    UpdateHTML() {
        return this._UpdateHTMLString()
    },
    SetReadAloud(a) {
        this._SetReadAloud(a)
    },
    SetResolutionMode(a, b) {
        this._SetResolutionMode(["auto", "fixed"][a]);
        this._SetFixedScaleFactor(b)
    }
};
const C3$jscomp$222 = self.C3;
C3$jscomp$222.Plugins.Text.Exps = {
    Text() {
        return this._text
    },
    PlainText() {
        return this._enableBBcode ? C3$jscomp$222.BBString.StripAnyTags(this._text) : this._text
    },
    FaceName() {
        return this._faceName
    },
    FaceSize() {
        return this._ptSize
    },
    TextWidth() {
        return this._GetTextWidth()
    },
    TextHeight() {
        return this._GetTextHeight()
    },
    LineHeight() {
        return this._lineHeightOffset
    },
    TagAtPosition(a, b) {
        return this._GetTagAtPosition(a, b)
    },
    TagCount(a) {
        return this._GetTagCount(a)
    },
    TagX(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.x : 0
    },
    TagY(a,
    b) {
        return (a = this._GetTagPosition(a, b)) ? a.y : 0
    },
    TagWidth(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.width : 0
    },
    TagHeight(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.height : 0
    },
    AsHTML() {
        return this._htmlString
    }
};
"use strict";
const C3$jscomp$223 = self.C3;
C3$jscomp$223.Plugins.Touch = class  extends C3$jscomp$223.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$224 = self.C3,
    C3X$jscomp$39 = self.C3X;
C3$jscomp$224.Plugins.Touch.Type = class  extends C3$jscomp$224.SDKTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass()
    {
        return self.ITouchObjectType
    }
}
;
let touchObjectType = null;
function GetTouchSdkInstance() {
    return touchObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.ITouchObjectType = class  extends self.IObjectClass{
    constructor(a)
    {
        super(a);
        touchObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().touch = this
    }
    requestPermission(a)
    {
        C3X$jscomp$39.RequireString(a);
        const b = GetTouchSdkInstance();
        if ("orientation" === a)
            return b._RequestPermission(0);
        if ("motion" === a)
            return b._RequestPermission(1);
        throw Error("invalid type");
    }
}
;
const C3$jscomp$225 = self.C3;
C3$jscomp$225.Plugins.Touch.Instance = class  extends C3$jscomp$225.SDKInstanceBase{
    constructor(a, b)
    {
        super(a, "touch");
        this._touches = new Map;
        this._isMouseDown = this._useMouseInput = !1;
        this._triggerType = this._getTouchIndex = this._curTouchY = this._curTouchX = this._triggerPermission = this._triggerId = this._triggerIndex = this._accWithGZ = this._accWithGY = this._accWithGX = this._accZ = this._accY = this._accX = this._orientGamma = this._orientBeta = this._orientAlpha = this._orientCompassHeading = 0;
        this._permissionPromises = [];
        b &&
        (this._useMouseInput = b[0]);
        this.AddDOMMessageHandler("permission-result", c => this._OnPermissionResult(c));
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$225.CompositeDisposable(C3$jscomp$225.Disposable.From(a, "pointerdown", c => this._OnPointerDown(c.data)), C3$jscomp$225.Disposable.From(a, "pointermove", c => this._OnPointerMove(c.data)), C3$jscomp$225.Disposable.From(a, "pointerup", c => this._OnPointerUp(c.data, !1)), C3$jscomp$225.Disposable.From(a, "pointercancel", c => this._OnPointerUp(c.data,
        !0)), C3$jscomp$225.Disposable.From(a, "deviceorientation", c => this._OnDeviceOrientation(c.data)), C3$jscomp$225.Disposable.From(a, "deviceorientationabsolute", c => this._OnDeviceOrientationAbsolute(c.data)), C3$jscomp$225.Disposable.From(a, "devicemotion", c => this._OnDeviceMotion(c.data)), C3$jscomp$225.Disposable.From(a, "tick2", c => this._OnTick2()))
    }
    Release()
    {
        this._touches.clear();
        super.Release()
    }
    _OnPointerDown(a)
    {
        if ("mouse" === a.pointerType)
            if (this._useMouseInput)
                this._isMouseDown = !0;
            else
                return;
        const b = a.pointerId;
        if (!this._touches.has(b)) {
            var c = a.pageX - this._runtime.GetCanvasClientX();
            a = a.pageY - this._runtime.GetCanvasClientY();
            var d = performance.now(),
                e = this._touches.size;
            this._triggerIndex = e;
            this._triggerId = b;
            var f = C3$jscomp$225.New(C3$jscomp$225.Plugins.Touch.TouchInfo);
            f.Init(d, c, a, b, e);
            this._touches.set(b, f);
            this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnNthTouchStart);
            this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnTouchStart);
            this._curTouchX = c;
            this._curTouchY = a;
            this._triggerType = 0;
            this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnTouchObject)
        }
    }
    _OnPointerMove(a)
    {
        if ("mouse" !==
        a.pointerType || this._isMouseDown) {
            var b = this._touches.get(a.pointerId);
            if (b) {
                var c = performance.now();
                if (!(2 > c - b.GetTime())) {
                    var d = a.pageX - this._runtime.GetCanvasClientX(),
                        e = a.pageY - this._runtime.GetCanvasClientY();
                    b.Update(c, d, e, a.width, a.height, a.pressure)
                }
            }
        }
    }
    _OnPointerUp(a, b)
    {
        if ("mouse" === a.pointerType)
            if (this._isMouseDown)
                this._isMouseDown = !1;
            else
                return;
        const c = performance.now(),
            d = a.pointerId,
            e = this._touches.get(d);
        if (e) {
            this._triggerIndex = e.GetStartIndex();
            this._triggerId = e.GetId();
            if (!b) {
                const f =
                a.pageX - this._runtime.GetCanvasClientX();
                a = a.pageY - this._runtime.GetCanvasClientY();
                this._curTouchX = f;
                this._curTouchY = a;
                this._triggerType = 1;
                this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnTouchObject)
            }
            this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnNthTouchEnd);
            this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnTouchEnd);
            b || (b = e.ShouldTriggerTap(c), "single-tap" === b ? (this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnTapGesture), this._curTouchX = e.GetX(), this._curTouchY = e.GetY(), this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnTapGestureObject)) :
            "double-tap" === b && (this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnDoubleTapGesture), this._curTouchX = e.GetX(), this._curTouchY = e.GetY(), this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnDoubleTapGestureObject)));
            e.Release();
            this._touches.delete(d)
        }
    }
    _RequestPermission(a)
    {
        this._PostToDOMMaybeSync("request-permission", {
            type: a
        });
        return new Promise((b, c) => {
            this._permissionPromises.push({
                type: a,
                resolve: b,
                reject: c
            })
        })
    }
    _OnPermissionResult(a)
    {
        const b = a.result,
            c = a.type;
        this._triggerPermission = c;
        a = this._permissionPromises.filter(d =>
        d.type === c);
        for (const d of a)
            d.resolve(b ? "granted" : "denied");
        this._permissionPromises = this._permissionPromises.filter(d => d.type !== c);
        b ? (this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnPermissionGranted), 0 === c ? this._runtime.RequestDeviceOrientationEvent() : this._runtime.RequestDeviceMotionEvent()) : this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnPermissionDenied)
    }
    _OnDeviceOrientation(a)
    {
        "number" === typeof a.webkitCompassHeading ? this._orientCompassHeading = a.webkitCompassHeading : a.absolute && (this._orientCompassHeading =
        a.alpha);
        this._orientAlpha = a.alpha;
        this._orientBeta = a.beta;
        this._orientGamma = a.gamma
    }
    _OnDeviceOrientationAbsolute(a)
    {
        this._orientCompassHeading = a.alpha
    }
    _OnDeviceMotion(a)
    {
        const b = a.acceleration;
        b && (this._accX = b.x, this._accY = b.y, this._accZ = b.z);
        if (a = a.accelerationIncludingGravity)
            this._accWithGX = a.x,
            this._accWithGY = a.y,
            this._accWithGZ = a.z
    }
    _OnTick2()
    {
        const a = performance.now();
        let b = 0;
        for (const c of this._touches.values())
            c.GetTime() <= a - 50 && c._SetLastTime(a),
            c.ShouldTriggerHold(a) && (this._triggerIndex =
            c.GetStartIndex(), this._triggerId = c.GetId(), this._getTouchIndex = b, this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnHoldGesture), this._curTouchX = c.GetX(), this._curTouchY = c.GetY(), this.Trigger(C3$jscomp$225.Plugins.Touch.Cnds.OnHoldGestureObject), this._getTouchIndex = 0),
            ++b
    }
    _GetTouchByIndex(a)
    {
        a = Math.floor(a);
        for (const b of this._touches.values()) {
            if (0 === a)
                return b;
            --a
        }
        return null
    }
    _IsClientPosOnCanvas(a, b)
    {
        return 0 <= a && 0 <= b && a < this._runtime.GetCanvasCssWidth() && b < this._runtime.GetCanvasCssHeight()
    }
    GetDebuggerProperties()
    {
        return [{
            title: "plugins.touch.debugger.touches",
            properties: [...this._touches.values()].map(a => ({
                name: "$" + a.GetId(),
                value: a.GetX() + ", " + a.GetY()
            }))
        }]
    }
}
;
const C3$jscomp$226 = self.C3;
C3$jscomp$226.Plugins.Touch.Cnds = {
    OnTouchStart() {
        return !0
    },
    OnTouchEnd() {
        return !0
    },
    IsInTouch() {
        return 0 < this._touches.size
    },
    OnTouchObject(a, b) {
        return a && b === this._triggerType && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX, this._curTouchY]], !1) : !1
    },
    IsTouchingObject(a) {
        if (!a)
            return !1;
        const b = this._runtime.GetCurrentCondition().IsInverted(),
            c = [...this._touches.values()].filter(d => this._IsClientPosOnCanvas(d.GetX(),
            d.GetY())).map(d => [d.GetX(), d.GetY()]);
        return C3$jscomp$226.xor(this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, c, b), b)
    },
    CompareTouchSpeed(a, b, c) {
        return (a = this._GetTouchByIndex(a)) ? C3$jscomp$226.compare(a.GetSpeed(), b, c) : !1
    },
    OrientationSupported() {
        return !0
    },
    MotionSupported() {
        return !0
    },
    CompareOrientation(a, b, c) {
        this._runtime.RequestDeviceOrientationEvent();
        return C3$jscomp$226.compare(0 === a ? this._orientAlpha : 1 === a ? this._orientBeta : this._orientGamma, b, c)
    },
    CompareAcceleration(a,
    b, c) {
        this._runtime.RequestDeviceMotionEvent();
        return C3$jscomp$226.compare(0 === a ? this._accWithGX : 1 === a ? this._accWithGY : 2 === a ? this._accWithGZ : 3 === a ? this._accX : 4 === a ? this._accY : this._accZ, b, c)
    },
    OnNthTouchStart(a) {
        a = Math.floor(a);
        return a === this._triggerIndex
    },
    OnNthTouchEnd(a) {
        a = Math.floor(a);
        return a === this._triggerIndex
    },
    HasNthTouch(a) {
        a = Math.floor(a);
        return this._touches.size >= a + 1
    },
    OnHoldGesture() {
        return !0
    },
    OnTapGesture() {
        return !0
    },
    OnDoubleTapGesture() {
        return !0
    },
    OnHoldGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX,
        this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX, this._curTouchY]], !1) : !1
    },
    OnTapGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX, this._curTouchY]], !1) : !1
    },
    OnDoubleTapGestureObject(a) {
        return a && this._IsClientPosOnCanvas(this._curTouchX, this._curTouchY) ? this._runtime.GetCollisionEngine().TestAndSelectCanvasPointOverlap(a, [[this._curTouchX,
        this._curTouchY]], !1) : !1
    },
    OnPermissionGranted(a) {
        return this._triggerPermission === a
    },
    OnPermissionDenied(a) {
        return this._triggerPermission === a
    }
};
self.C3.Plugins.Touch.Acts = {
    RequestPermission(a) {
        this._RequestPermission(a)
    }
};
const C3$jscomp$228 = self.C3;
C3$jscomp$228.Plugins.Touch.Exps = {
    TouchCount() {
        return this._touches.size
    },
    X(a) {
        const b = this._GetTouchByIndex(this._getTouchIndex);
        return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !0) : 0
    },
    Y(a) {
        const b = this._GetTouchByIndex(this._getTouchIndex);
        return b ? b.GetPositionForLayer(this._runtime.GetCurrentLayout(), a, !1) : 0
    },
    XAt(a, b) {
        return (a = this._GetTouchByIndex(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
    },
    YAt(a, b) {
        return (a = this._GetTouchByIndex(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(),
        b, !1) : 0
    },
    XForID(a, b) {
        return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !0) : 0
    },
    YForID(a, b) {
        return (a = this._touches.get(a)) ? a.GetPositionForLayer(this._runtime.GetCurrentLayout(), b, !1) : 0
    },
    AbsoluteX() {
        const a = this._GetTouchByIndex(0);
        return a ? a.GetX() : 0
    },
    AbsoluteY() {
        const a = this._GetTouchByIndex(0);
        return a ? a.GetY() : 0
    },
    AbsoluteXAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetX() : 0
    },
    AbsoluteYAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetY() : 0
    },
    AbsoluteXForID(a) {
        return (a =
        this._touches.get(a)) ? a.GetX() : 0
    },
    AbsoluteYForID(a) {
        return (a = this._touches.get(a)) ? a.GetY() : 0
    },
    SpeedAt(a) {
        return (a = this._GetTouchByIndex(a)) ? a.GetSpeed() : 0
    },
    SpeedForID(a) {
        return (a = this._touches.get(a)) ? a.GetSpeed() : 0
    },
    AngleAt(a) {
        return (a = this._GetTouchByIndex(a)) ? C3$jscomp$228.toDegrees(a.GetAngle()) : 0
    },
    AngleForID(a) {
        return (a = this._touches.get(a)) ? C3$jscomp$228.toDegrees(a.GetAngle()) : 0
    },
    CompassHeading() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientCompassHeading
    },
    Alpha() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientAlpha
    },
    Beta() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientBeta
    },
    Gamma() {
        this._runtime.RequestDeviceOrientationEvent();
        return this._orientGamma
    },
    AccelerationXWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGX
    },
    AccelerationYWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGY
    },
    AccelerationZWithG() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accWithGZ
    },
    AccelerationX() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accX
    },
    AccelerationY() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accY
    },
    AccelerationZ() {
        this._runtime.RequestDeviceMotionEvent();
        return this._accZ
    },
    TouchIndex() {
        return this._triggerIndex
    },
    TouchID() {
        return this._triggerId
    },
    WidthForID(a) {
        return (a = this._touches.get(a)) ? a.GetWidth() : 0
    },
    HeightForID(a) {
        return (a = this._touches.get(a)) ? a.GetHeight() : 0
    },
    PressureForID(a) {
        return (a = this._touches.get(a)) ? a.GetPressure() : 0
    }
};
"use strict";
const C3$jscomp$229 = self.C3;
let lastTapX = -1E3,
    lastTapY = -1E3,
    lastTapTime = -1E4;
C3$jscomp$229.Plugins.Touch.TouchInfo = class  extends C3$jscomp$229.DefendedBase{
    constructor()
    {
        super();
        this._pressure = this._height = this._width = this._lastY = this._lastX = this._y = this._x = this._startY = this._startX = this._lastTime = this._time = this._startTime = this._startIndex = this._pointerId = 0;
        this._isTooFarForHold = this._hasTriggeredHold = !1
    }
    Release() {}
    Init(a, b, c, d, e)
    {
        this._pointerId = d;
        this._startIndex = e;
        this._startTime = this._lastTime = this._time = a;
        this._startX = b;
        this._startY = c;
        this._x = b;
        this._y = c;
        this._lastX =
        b;
        this._lastY = c
    }
    Update(a, b, c, d, e, f)
    {
        this._lastTime = this._time;
        this._time = a;
        this._lastX = this._x;
        this._lastY = this._y;
        this._x = b;
        this._y = c;
        this._width = d;
        this._height = e;
        this._pressure = f;
        !this._isTooFarForHold && 15 <= C3$jscomp$229.distanceTo(this._startX, this._startY, this._x, this._y) && (this._isTooFarForHold = !0)
    }
    GetId()
    {
        return this._pointerId
    }
    GetStartIndex()
    {
        return this._startIndex
    }
    GetTime()
    {
        return this._time
    }
    _SetLastTime(a)
    {
        this._lastTime = a
    }
    GetX()
    {
        return this._x
    }
    GetY()
    {
        return this._y
    }
    GetSpeed()
    {
        const a = C3$jscomp$229.distanceTo(this._x,
            this._y, this._lastX, this._lastY),
            b = (this._time - this._lastTime) / 1E3;
        return 0 < b ? a / b : 0
    }
    GetAngle()
    {
        return C3$jscomp$229.angleTo(this._lastX, this._lastY, this._x, this._y)
    }
    GetWidth()
    {
        return this._width
    }
    GetHeight()
    {
        return this._height
    }
    GetPressure()
    {
        return this._pressure
    }
    ShouldTriggerHold(a)
    {
        return this._hasTriggeredHold ? !1 : 500 <= a - this._startTime && !this._isTooFarForHold && 15 > C3$jscomp$229.distanceTo(this._startX, this._startY, this._x, this._y) ? this._hasTriggeredHold = !0 : !1
    }
    ShouldTriggerTap(a)
    {
        if (this._hasTriggeredHold)
            return "";
        if (333 >= a - this._startTime && !this._isTooFarForHold && 15 > C3$jscomp$229.distanceTo(this._startX, this._startY, this._x, this._y)) {
            if (666 >= a - lastTapTime && 25 > C3$jscomp$229.distanceTo(lastTapX, lastTapY, this._x, this._y))
                return lastTapY = lastTapX = -1E3, lastTapTime = -1E4, "double-tap";
            lastTapX = this._x;
            lastTapY = this._y;
            lastTapTime = a;
            return "single-tap"
        }
        return ""
    }
    GetPositionForLayer(a, b, c)
    {
        return "undefined" === typeof b ? a.GetLayerByIndex(0).CanvasCssToLayer_DefaultTransform(this._x, this._y)[c ? 0 : 1] : (a = a.GetLayer(b)) ? a.CanvasCssToLayer(this._x,
        this._y)[c ? 0 : 1] : 0
    }
}
;
"use strict";
const C3$jscomp$230 = self.C3;
C3$jscomp$230.Plugins.Spritefont2 = class  extends C3$jscomp$230.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$231 = self.C3;
C3$jscomp$231.Plugins.Spritefont2.Type = class  extends C3$jscomp$231.SDKTypeBase{
    constructor(a)
    {
        super(a);
        this._spriteFont = C3$jscomp$231.New(self.SpriteFont)
    }
    Release()
    {
        super.Release()
    }
    OnCreate()
    {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a)
    {
        return this.GetImageInfo().LoadStaticTexture(a, {
            sampling: this._runtime.GetSampling()
        })
    }
    ReleaseTextures()
    {
        this.GetImageInfo().ReleaseTexture()
    }
    GetSpriteFont()
    {
        return this._spriteFont
    }
    UpdateSettings(a, b, c, d)
    {
        const e = this.GetImageInfo(),
            f = this._spriteFont;
        f.SetWidth(e.GetWidth());
        f.SetHeight(e.GetHeight());
        f.SetCharacterWidth(a);
        f.SetCharacterHeight(b);
        f.SetCharacterSet(c);
        f.SetSpacingData(d);
        f.UpdateCharacterMap()
    }
}
;
const C3$jscomp$232 = self.C3,
    C3X$jscomp$40 = self.C3X,
    tempVec2$jscomp$3 = C3$jscomp$232.New(C3$jscomp$232.Vector2),
    HORIZONTAL_ALIGNMENTS$jscomp$1 = ["left", "center", "right"],
    VERTICAL_ALIGNMENTS$jscomp$1 = ["top", "center", "bottom"],
    WORD_WRAP_MODES$jscomp$1 = ["word", "cjk", "character"];
C3$jscomp$232.Plugins.Spritefont2.Instance = class  extends C3$jscomp$232.SDKWorldInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._text = "";
        this._enableBBcode = !0;
        this._characterHeight = this._characterWidth = 16;
        this._characterSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:?!-_~#\"'&()[]|`\\/@\u00b0+=*$\u00a3\u20ac<>";
        a = "";
        this._characterScale = 1;
        this._verticalAlign = this._horizontalAlign = this._lineHeight = this._characterSpacing = 0;
        this._wrapMode = "word";
        this._needsTextLayout = !0;
        this._readAloud =
        !1;
        this._spriteFontText = this._screenReaderText = null;
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        b && (this._text = b[0], this._enableBBcode = b[1], this._characterWidth = b[2], this._characterHeight = b[3], this._characterSet = b[4], a = b[5], this._characterScale = b[6], this._characterSpacing = b[7], this._lineHeight = b[8], this._horizontalAlign = b[9], this._verticalAlign = b[10], this._wrapMode = WORD_WRAP_MODES$jscomp$1[b[11]], this.GetWorldInfo().SetVisible(b[12]), this._readAloud = !!b[14]);
        this._sdkType.UpdateSettings(this._characterWidth,
        this._characterHeight, this._characterSet, a);
        this._spriteFontText = C3$jscomp$232.New(self.SpriteFontText, this._sdkType.GetSpriteFont());
        b = this.GetWorldInfo();
        this._spriteFontText.SetSize(b.GetWidth(), b.GetHeight());
        this._UpdateSettings();
        this._UpdateScreenReaderText();
        this._inst.SetMustMitigateZFighting()
    }
    Release()
    {
        this._CancelTypewriter();
        this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null);
        this._spriteFontText.Release();
        this._spriteFontText = null;
        super.Release()
    }
    _UpdateSettings()
    {
        const a =
        this._spriteFontText;
        a && (a.SetBBCodeEnabled(this._enableBBcode), a.SetText(this._text), a.SetWordWrapMode(this._wrapMode), a.SetHorizontalAlign(HORIZONTAL_ALIGNMENTS$jscomp$1[this._horizontalAlign]), a.SetVerticalAlign(VERTICAL_ALIGNMENTS$jscomp$1[this._verticalAlign]), a.SetSpacing(this._characterSpacing), a.SetLineHeight(this._lineHeight))
    }
    _UpdateTextSize()
    {
        const a = this.GetWorldInfo();
        this._spriteFontText.SetSize(a.GetWidth(), a.GetHeight());
        this._spriteFontText.SetScale(this._characterScale)
    }
    _UpdateScreenReaderText()
    {
        if (this._readAloud) {
            let a =
            this._text;
            this._enableBBcode && (a = C3$jscomp$232.BBString.StripAnyTags(a));
            this._screenReaderText ? this._screenReaderText.SetText(a) : this._screenReaderText = C3$jscomp$232.New(C3$jscomp$232.ScreenReaderText, this._runtime, a)
        } else
            this._screenReaderText && (this._screenReaderText.Release(), this._screenReaderText = null)
    }
    Draw(a)
    {
        const b = this._objectClass.GetImageInfo();
        var c = b.GetTexture();
        if (c) {
            a.SetTexture(c);
            c = this.GetWorldInfo();
            var d = c.GetBoundingQuad(),
                e = this._spriteFontText;
            e.SetScale(this._characterScale);
            e.SetSceneGraphScale(c.GetSceneGraphScale());
            this._runtime.IsPixelRoundingEnabled() && (d = c.PixelRoundQuad(d));
            e.SetSize(c.GetWidth(), c.GetHeight());
            e.GetSpriteFont().SetTexRect(b.GetTexRect());
            e.SetColor(c.GetUnpremultipliedColor());
            e.Draw(a, d.getTlx(), d.getTly(), c.GetAngle());
            this._needsTextLayout = !1
        }
    }
    SaveToJson()
    {
        const a = {
            t: this._text,
            ebbc: this._enableBBcode,
            csc: this._characterScale,
            csp: this._characterSpacing,
            lh: this._lineHeight,
            ha: this._horizontalAlign,
            va: this._verticalAlign,
            w: this._wrapMode,
            cw: this._sdkType.GetSpriteFont().GetCharacterWidth(),
            ch: this._sdkType.GetSpriteFont().GetCharacterHeight(),
            cs: this._sdkType.GetSpriteFont().GetCharacterSet(),
            sd: this._sdkType.GetSpriteFont().GetSpacingData()
        };
        -1 !== this._typewriterEndTime && (a.tw = {
            st: this._typewriterStartTime,
            en: this._typewriterEndTime,
            l: this._typewriterLength
        });
        return a
    }
    LoadFromJson(a)
    {
        this._CancelTypewriter();
        this._text = a.t;
        this._enableBBcode = a.ebbc;
        this._characterScale = a.csc;
        this._characterSpacing = a.csp;
        this._lineHeight = a.lh;
        this._horizontalAlign = a.ha;
        this._verticalAlign = a.va;
        if (a.hasOwnProperty("w")) {
            var b =
            a.w;
            this._wrapMode = "boolean" === typeof b ? b ? "word" : "character" : b
        } else
            this._wrapMode = "word";
        a.hasOwnProperty("tw") && (b = a.tw, this._typewriterStartTime = b.st, this._typewriterEndTime = b.en, this._typewriterLength = a.l);
        b = this._sdkType.GetSpriteFont();
        b.SetCharacterWidth(a.cw);
        b.SetCharacterHeight(a.ch);
        b.SetCharacterSet(a.cs);
        b.SetSpacingData(a.sd);
        this._UpdateSettings();
        this._UpdateScreenReaderText();
        -1 !== this._typewriterEndTime && this._StartTicking()
    }
    GetPropertyValueByIndex(a)
    {
        switch (a) {
        case 0:
            return this.GetText();
        case 1:
            return this._enableBBcode;
        case 2:
            return this._sdkType.GetSpriteFont().GetCharacterWidth();
        case 3:
            return this._sdkType.GetSpriteFont().GetCharacterHeight();
        case 4:
            return this._sdkType.GetSpriteFont().GetCharacterSet();
        case 5:
            return this._sdkType.GetSpriteFont().GetSpacingData();
        case 6:
            return this._GetScale();
        case 7:
            return this._GetCharacterSpacing();
        case 8:
            return this._GetLineHeight();
        case 9:
            return this._GetHAlign();
        case 10:
            return this._GetVAlign();
        case 11:
            return this._GetWrapMode()
        }
    }
    SetPropertyValueByIndex(a,
    b)
    {
        switch (a) {
        case 0:
            this._SetText(b);
            break;
        case 1:
            if (this._enableBBcode === !!b)
                break;
            this._enableBBcode = !!b;
            this._UpdateSettings();
            break;
        case 2:
            this._sdkType.GetSpriteFont().SetCharacterWidth(b);
            break;
        case 3:
            this._sdkType.GetSpriteFont().SetCharacterHeight(b);
            break;
        case 4:
            this._sdkType.GetSpriteFont().SetCharacterSet(b);
            break;
        case 5:
            this._sdkType.GetSpriteFont().SetSpacingData(b);
            break;
        case 6:
            this._SetScale(b);
            break;
        case 7:
            this._SetCharacterSpacing(b);
            break;
        case 8:
            this._SetLineHeight(b);
            break;
        case 9:
            this._SetHAlign(b);
            break;
        case 10:
            this._SetVAlign(b);
            break;
        case 11:
            this._SetWrapMode(b)
        }
    }
    _SetText(a)
    {
        this._text !== a && (this._text = a, this._spriteFontText.SetText(a), this._UpdateScreenReaderText(), this._runtime.UpdateRender())
    }
    GetText()
    {
        return this._text
    }
    _StartTypewriter(a, b)
    {
        this._SetText(a);
        this._typewriterStartTime = this._runtime.GetWallTime();
        this._typewriterEndTime = this._typewriterStartTime + b / this.GetInstance().GetActiveTimeScale();
        this._typewriterLength = C3$jscomp$232.CountGraphemes(C3$jscomp$232.BBString.StripAnyTags(a));
        this._spriteFontText.SetDrawMaxCharacterCount(0);
        this._StartTicking()
    }
    _CancelTypewriter()
    {
        this._typewriterEndTime = this._typewriterStartTime = -1;
        this._typewriterLength = 0;
        this._spriteFontText.SetDrawMaxCharacterCount(-1);
        this._StopTicking()
    }
    _FinishTypewriter()
    {
        -1 !== this._typewriterEndTime && (this._CancelTypewriter(), this.Trigger(C3$jscomp$232.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender())
    }
    _SetScale(a)
    {
        this._characterScale !== a && (this._characterScale = a, this._spriteFontText.SetScale(this._characterScale),
        this._runtime.UpdateRender())
    }
    _GetScale()
    {
        return this._characterScale
    }
    _SetCharacterSpacing(a)
    {
        this._characterSpacing !== a && (this._characterSpacing = a, this._spriteFontText.SetSpacing(this._characterSpacing), this._runtime.UpdateRender())
    }
    _GetCharacterSpacing()
    {
        return this._characterSpacing
    }
    _SetLineHeight(a)
    {
        this._lineHeight !== a && (this._lineHeight = a, this._spriteFontText.SetLineHeight(this._lineHeight), this._runtime.UpdateRender())
    }
    _GetLineHeight()
    {
        return this._lineHeight
    }
    _SetHAlign(a)
    {
        this._horizontalAlign !==
        a && (this._horizontalAlign = a, this._UpdateSettings(), this._runtime.UpdateRender())
    }
    _GetHAlign()
    {
        return this._horizontalAlign
    }
    _SetVAlign(a)
    {
        this._verticalAlign !== a && (this._verticalAlign = a, this._UpdateSettings(), this._runtime.UpdateRender())
    }
    _GetVAlign()
    {
        return this._verticalAlign
    }
    _SetWrapModeByIndex(a)
    {
        this._SetWrapMode(WORD_WRAP_MODES$jscomp$1[a])
    }
    _SetWrapMode(a)
    {
        this._wrapMode !== a && (this._wrapMode = a, this._UpdateSettings(), this._runtime.UpdateRender())
    }
    _GetWrapMode()
    {
        return this._wrapMode
    }
    _SetReadAloud(a)
    {
        this._readAloud =
        !!a;
        this._UpdateScreenReaderText()
    }
    _IsReadAloud()
    {
        return this._readAloud
    }
    _GetTextWidth()
    {
        this._UpdateTextSize();
        return this._spriteFontText.GetTextWidth()
    }
    _GetTextHeight()
    {
        this._UpdateTextSize();
        return this._spriteFontText.GetTextHeight()
    }
    _GetTagAtPosition(a, b)
    {
        this._UpdateTextSize();
        const c = this.GetWorldInfo();
        tempVec2$jscomp$3.set(a - c.GetX(), b - c.GetY());
        tempVec2$jscomp$3.rotate(-c.GetAngle());
        tempVec2$jscomp$3.offset(c.GetWidth() * c.GetOriginX(), c.GetHeight() * c.GetOriginY());
        if (a = this._spriteFontText.HitTestFragment(tempVec2$jscomp$3.getX(),
        tempVec2$jscomp$3.getY()))
            if (a = a.GetStyleTag("tag"))
                return a.param;
        return ""
    }
    _HasTagAtPosition(a, b, c)
    {
        return (b = this._GetTagAtPosition(b, c)) && C3$jscomp$232.equalsNoCase(a, b)
    }
    _GetTagPosition(a, b)
    {
        this._UpdateTextSize();
        b = Math.floor(b);
        a = this._spriteFontText.FindFragmentWithTag(a, b);
        if (!a)
            return null;
        b = this.GetWorldInfo();
        tempVec2$jscomp$3.set(a.GetPosX(), a.GetPosY());
        tempVec2$jscomp$3.offset(-b.GetWidth() * b.GetOriginX(), -b.GetHeight() * b.GetOriginY());
        tempVec2$jscomp$3.rotate(b.GetAngle());
        tempVec2$jscomp$3.offset(b.GetX(),
        b.GetY());
        return {
            x: tempVec2$jscomp$3.getX(),
            y: tempVec2$jscomp$3.getY(),
            width: a.GetWidth(),
            height: a.GetHeight()
        }
    }
    _GetTagCount(a)
    {
        this._UpdateTextSize();
        return this._spriteFontText.CountFragmentsWithTag(a)
    }
    Tick()
    {
        var a = this._runtime.GetWallTime();
        a >= this._typewriterEndTime ? (this._CancelTypewriter(), this.Trigger(C3$jscomp$232.Plugins.Spritefont2.Cnds.OnTypewriterTextFinished), this._runtime.UpdateRender()) : (a = C3$jscomp$232.relerp(this._typewriterStartTime, this._typewriterEndTime, a, 0, this._typewriterLength),
        a = Math.floor(a), a !== this._spriteFontText.GetDrawMaxCharacterCount() && (this._spriteFontText.SetDrawMaxCharacterCount(a), this._runtime.UpdateRender()))
    }
    GetDebuggerProperties()
    {
        return [{
            title: "plugins.spritefont2.name",
            properties: [{
                name: "plugins.spritefont2.properties.text.name",
                value: this.GetText(),
                onedit: a => this._SetText(a)
            }, {
                name: "plugins.spritefont2.properties.scale.name",
                value: this._GetScale(),
                onedit: a => this._SetScale(a)
            }, {
                name: "plugins.spritefont2.properties.character-spacing.name",
                value: this._GetCharacterSpacing(),
                onedit: a => this._SetCharacterSpacing(a)
            }, {
                name: "plugins.spritefont2.properties.line-height.name",
                value: this._GetLineHeight(),
                onedit: a => this._SetLineHeight(a)
            }]
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.ISpriteFontInstance
    }
}
;
const map$jscomp$33 = new WeakMap,
    SCRIPT_HORIZONTAL_ALIGNMENTS$jscomp$1 = new Map([["left", 0], ["center", 1], ["right", 2]]),
    SCRIPT_VERTICAL_ALIGNMENTS$jscomp$1 = new Map([["top", 0], ["center", 1], ["bottom", 2]]);
self.ISpriteFontInstance = class  extends self.IWorldInstance{
    constructor()
    {
        super();
        map$jscomp$33.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    get text()
    {
        return map$jscomp$33.get(this).GetText()
    }
    set text(a)
    {
        C3X$jscomp$40.RequireString(a);
        const b = map$jscomp$33.get(this);
        b._CancelTypewriter();
        b._SetText(a)
    }
    typewriterText(a, b)
    {
        C3X$jscomp$40.RequireString(a);
        C3X$jscomp$40.RequireFiniteNumber(b);
        const c = map$jscomp$33.get(this);
        c._CancelTypewriter();
        c._StartTypewriter(a, b)
    }
    typewriterFinish()
    {
        map$jscomp$33.get(this)._FinishTypewriter()
    }
    set characterScale(a)
    {
        C3X$jscomp$40.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetScale(a)
    }
    get characterScale()
    {
        return map$jscomp$33.get(this)._GetScale()
    }
    set characterSpacing(a)
    {
        C3X$jscomp$40.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetCharacterSpacing(a)
    }
    get characterSpacing()
    {
        return map$jscomp$33.get(this)._GetCharacterSpacing()
    }
    set lineHeight(a)
    {
        C3X$jscomp$40.RequireFiniteNumber(a);
        map$jscomp$33.get(this)._SetLineHeight(a)
    }
    get lineHeight()
    {
        return map$jscomp$33.get(this)._GetLineHeight()
    }
    set horizontalAlign(a)
    {
        C3X$jscomp$40.RequireString(a);
        a = SCRIPT_HORIZONTAL_ALIGNMENTS$jscomp$1.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$33.get(this)._SetHAlign(a)
    }
    get horizontalAlign()
    {
        return HORIZONTAL_ALIGNMENTS$jscomp$1[map$jscomp$33.get(this)._GetHAlign()]
    }
    set verticalAlign(a)
    {
        C3X$jscomp$40.RequireString(a);
        a = SCRIPT_VERTICAL_ALIGNMENTS$jscomp$1.get(a);
        if ("undefined" === typeof a)
            throw Error("invalid mode");
        map$jscomp$33.get(this)._SetVAlign(a)
    }
    get verticalAlign()
    {
        return VERTICAL_ALIGNMENTS$jscomp$1[map$jscomp$33.get(this)._GetVAlign()]
    }
    set wordWrapMode(a)
    {
        if (!WORD_WRAP_MODES$jscomp$1.includes(a))
            throw Error("invalid mode");
        map$jscomp$33.get(this)._SetWrapMode(a)
    }
    get wordWrapMode()
    {
        return map$jscomp$33.get(this)._GetWrapMode()
    }
    set readAloud(a)
    {
        map$jscomp$33.get(this)._SetReadAloud(!!a)
    }
    get readAloud()
    {
        return map$jscomp$33.get(this)._IsReadAloud()
    }
    get textWidth()
    {
        return map$jscomp$33.get(this)._GetTextWidth()
    }
    get textHeight()
    {
        return map$jscomp$33.get(this)._GetTextHeight()
    }
    getTextSize()
    {
        const a = map$jscomp$33.get(this);
        return [a._GetTextWidth(), a._GetTextHeight()]
    }
    hasTagAtPosition(a, b, c)
    {
        C3X$jscomp$40.RequireString(a);
        C3X$jscomp$40.RequireFiniteNumber(b);
        C3X$jscomp$40.RequireFiniteNumber(c);
        return map$jscomp$33.get(this)._HasTagAtPosition(a, b, c)
    }
    getTagAtPosition(a, b)
    {
        C3X$jscomp$40.RequireFiniteNumber(a);
        C3X$jscomp$40.RequireFiniteNumber(b);
        return map$jscomp$33.get(this)._GetTagAtPosition(a, b)
    }
    getTagPositionAndSize(a, b=0)
    {
        C3X$jscomp$40.RequireString(a);
        C3X$jscomp$40.RequireFiniteNumber(b);
        return map$jscomp$33.get(this)._GetTagPosition(a, b)
    }
    getTagCount(a)
    {
        C3X$jscomp$40.RequireString(a);
        return map$jscomp$33.get(this)._GetTagCount(a)
    }
}
;
const C3$jscomp$233 = self.C3;
C3$jscomp$233.Plugins.Spritefont2.Cnds = {
    CompareText(a, b) {
        return b ? this._text === a : C3$jscomp$233.equalsNoCase(this._text, a)
    },
    IsRunningTypewriterText() {
        return -1 !== this._typewriterEndTime
    },
    OnTypewriterTextFinished() {
        return !0
    },
    HasTagAtPosition(a, b, c) {
        return this._HasTagAtPosition(a, b, c)
    }
};
self.C3.Plugins.Spritefont2.Acts = {
    SetText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._SetText(a.toString())
    },
    AppendText(a) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        (a = a.toString()) && this._SetText(this._text + a)
    },
    TypewriterText(a, b) {
        this._CancelTypewriter();
        "number" === typeof a && 1E9 > a && (a = Math.round(1E10 * a) / 1E10);
        this._StartTypewriter(a.toString(), b)
    },
    TypewriterFinish() {
        this._FinishTypewriter()
    },
    SetScale(a) {
        this._SetScale(a)
    },
    SetCharacterSpacing(a) {
        this._SetCharacterSpacing(a)
    },
    SetLineHeight(a) {
        this._SetLineHeight(a)
    },
    SetCharacterWidth(a, b) {
        let c = !1;
        const d = this._sdkType.GetSpriteFont();
        for (const e of a)
            if (" " === e)
                d.SetSpaceWidth(b),
                c = !0;
            else if (a = d.GetCharacter(e))
                a.SetDisplayWidth(b),
                c = !0;
        c && d.SetCharacterWidthsChanged();
        this._runtime.UpdateRender()
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    SetHAlign(a) {
        this._SetHAlign(a)
    },
    SetVAlign(a) {
        this._SetVAlign(a)
    },
    SetWrapping(a) {
        this._SetWrapModeByIndex(a)
    },
    SetReadAloud(a) {
        this._SetReadAloud(a)
    }
};
const C3$jscomp$235 = self.C3;
C3$jscomp$235.Plugins.Spritefont2.Exps = {
    CharacterWidth(a) {
        return (a = this._sdkType.GetSpriteFont().GetCharacter(a)) ? a.GetDisplayWidth() : this._sdkType.GetSpriteFont().GetCharacterWidth()
    },
    CharacterHeight() {
        return this._characterHeight
    },
    CharacterScale() {
        return this._characterScale
    },
    CharacterSpacing() {
        return this._characterSpacing
    },
    LineHeight() {
        return this._lineHeight
    },
    Text() {
        return this._text
    },
    PlainText() {
        return this._enableBBcode ? C3$jscomp$235.BBString.StripAnyTags(this._text) : this._text
    },
    TextWidth() {
        return this._GetTextWidth()
    },
    TextHeight() {
        return this._GetTextHeight()
    },
    TagAtPosition(a, b) {
        return this._GetTagAtPosition(a, b)
    },
    TagCount(a) {
        return this._GetTagCount(a)
    },
    TagX(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.x : 0
    },
    TagY(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.y : 0
    },
    TagWidth(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.width : 0
    },
    TagHeight(a, b) {
        return (a = this._GetTagPosition(a, b)) ? a.height : 0
    }
};
"use strict";
const C3$jscomp$236 = self.C3;
self.SpriteFontCharacter = class {
    constructor(a, b, c, d)
    {
        let e = a.GetCharacterWidth(),
            f = a.GetCharacterHeight();
        this._spriteFont = a;
        this._char = b;
        this._pxRect = new C3$jscomp$236.Rect(c, d, c + e, d + f);
        this._texRect = new C3$jscomp$236.Rect;
        this._displayWidth = -1;
        this._UpdateTexRect()
    }
    Release()
    {
        this._texRect = this._pxRect = this._spriteFont = null
    }
    _UpdateTexRect()
    {
        let a = this._spriteFont.GetWidth(),
            b = this._spriteFont.GetHeight();
        this._texRect.copy(this._pxRect);
        this._texRect.divide(a, b);
        this._texRect.lerpInto(this._spriteFont.GetTexRect())
    }
    GetSpriteFont()
    {
        return this._spriteFont
    }
    GetChar()
    {
        return this._char
    }
    GetTexRect()
    {
        return this._texRect
    }
    SetDisplayWidth(a)
    {
        this._displayWidth =
        a
    }
    GetDisplayWidth()
    {
        return 0 > this._displayWidth ? this._spriteFont.GetCharacterWidth() : this._displayWidth
    }
}
;
"use strict";
const C3$jscomp$237 = self.C3,
    tmpRect$jscomp$3 = new C3$jscomp$237.Rect,
    tmpQuad$jscomp$3 = new C3$jscomp$237.Quad,
    tmpColor = new C3$jscomp$237.Color,
    VALID_HORIZ_ALIGNMENTS$jscomp$1 = new Set(["left", "center", "right"]),
    VALID_VERT_ALIGNMENTS$jscomp$1 = new Set(["top", "center", "bottom"]),
    VALID_WORD_WRAP_MODES$jscomp$1 = new Set(["word", "cjk", "character"]);
function getOffsetParam$jscomp$1(a, b) {
    a = a.trim();
    const c = parseFloat(a);
    return isFinite(c) ? a.endsWith("%") ? b * c / 100 : c : 0
}
let canvasColorCtx = null;
function normalizeCssColorString(a) {
    canvasColorCtx || (canvasColorCtx = C3$jscomp$237.CreateCanvas(32, 32).getContext("2d"));
    canvasColorCtx.fillStyle = "#FFFFFF";
    canvasColorCtx.fillStyle = a;
    return canvasColorCtx.fillStyle
}
self.SpriteFontText = class {
    constructor(a)
    {
        this._spriteFont = a;
        this._cssHeight = this._cssWidth = 0;
        this._text = "";
        this._isBBcodeEnabled = !1;
        this._bbString = null;
        this._wrappedText = C3$jscomp$237.New(C3$jscomp$237.WordWrap);
        this._wrapMode = "word";
        this._textLayoutChanged = this._wordWrapChanged = !1;
        this._horizontalAlign = "left";
        this._verticalAlign = "top";
        this._sceneGraphScale = this._scale = 1;
        this._lineHeight = this._spacing = 0;
        this._color = C3$jscomp$237.New(C3$jscomp$237.Color);
        this._drawMaxCharCount = -1;
        this._drawCharCount =
        0;
        this._measureTextCallback = b => this._MeasureText(b);
        this._spriteFont._AddSpriteFontText(this)
    }
    Release()
    {
        this._spriteFont._RemoveSpriteFontText(this);
        this._measureTextCallback = this._color = null;
        this._wrappedText.Clear();
        this._bbString = this._spriteFont = this._wrappedText = null
    }
    _MeasureText(a)
    {
        if (a.IsIcon())
            return {
                width: 0,
                height: 0
            };
        var b = a.GetCharacterArray(),
            c = a.GetStyleTag("scale"),
            d = (c ? parseFloat(c.param) : this._scale) * this._sceneGraphScale;
        c = a.GetStyleTag("scalex");
        c = (c ? parseFloat(c.param) : 1) * d;
        a = a.GetStyleTag("scaley");
        a = (a ? parseFloat(a.param) : 1) * d;
        a = this._spriteFont.GetCharacterHeight() * a + this._lineHeight;
        const e = this.GetSpriteFont();
        d = e.GetCharacterWidth() * c;
        const f = this.GetSpacing();
        if (e.HasAnyCustomWidths()) {
            let h = 0,
                k = 0;
            for (var g of b) {
                b = d;
                const l = e.GetCharacter(g);
                l ? b = l.GetDisplayWidth() * c : " " === g && (b = e.GetSpaceWidth() * c);
                k += b;
                ++h
            }
            return {
                width: k + h * f,
                height: a
            }
        }
        g = b.length;
        return {
            width: d * g + Math.max(g, 0) * f,
            height: a
        }
    }
    _SetTextLayoutChanged()
    {
        this._textLayoutChanged = !0
    }
    _SetWordWrapChanged()
    {
        this._SetTextLayoutChanged();
        this._wordWrapChanged = !0;
        this._wrappedText.Clear()
    }
    SetSize(a, b)
    {
        0 >= a || 0 >= b || this._cssWidth === a && this._cssHeight === b || (this._cssWidth !== a ? this._SetWordWrapChanged() : this._SetTextLayoutChanged(), this._cssWidth = a, this._cssHeight = b)
    }
    SetDrawMaxCharacterCount(a)
    {
        this._drawMaxCharCount = Math.floor(a)
    }
    GetDrawMaxCharacterCount()
    {
        return this._drawMaxCharCount
    }
    HitTestFragment(a, b)
    {
        this._UpdateTextMeasurements();
        const c = this._wrappedText.GetLines();
        for (const d of c)
            if (b > d.GetPosY() && b < d.GetPosY() + d.GetHeight())
                for (const e of d.fragments())
                    if (a >=
                    e.GetPosX() && a < e.GetPosX() + e.GetWidth())
                        return e;
        return null
    }
    *fragmentsWithTag(a)
    {
        this._UpdateTextMeasurements();
        var b = this._wrappedText.GetLines();
        for (const c of b)
            for (const d of c.fragments())
                (b = d.GetStyleTag("tag")) && C3$jscomp$237.equalsNoCase(b.param, a) && (yield d)
    }
    FindFragmentWithTag(a, b)
    {
        for (const c of this.fragmentsWithTag(a)) {
            if (0 === b)
                return c;
            --b
        }
        return null
    }
    CountFragmentsWithTag(a)
    {
        let b = 0;
        for (const c of this.fragmentsWithTag(a))
            ++b;
        return b
    }
    _UpdateTextMeasurements()
    {
        this._UpdateWordWrap();
        this._UpdateTextLayout()
    }
    _UpdateWordWrap()
    {
        if (this._wordWrapChanged) {
            !this._isBBcodeEnabled || this._bbString && this._bbString.toString() === this._text || (this._bbString = new C3$jscomp$237.BBString(this._text, {
                noEscape: !0
            }));
            var a = -this.GetSpacing();
            this._wrappedText.WordWrap(this._isBBcodeEnabled ? this._bbString.toFragmentList() : this._text, this._measureTextCallback, this._cssWidth, this._wrapMode, a);
            this._wordWrapChanged = !1
        }
    }
    _UpdateTextLayout()
    {
        this._textLayoutChanged && (this._LayoutText(), this._textLayoutChanged =
        !1)
    }
    _LayoutText()
    {
        let a = 0;
        const b = this._lineHeight,
            c = C3$jscomp$237.cloneArray(this._wrappedText.GetLines());
        for (var d of c) {
            d.SetPosX(NaN);
            d.SetPosY(NaN);
            for (var e of d.fragments())
                e.SetPosX(NaN),
                e.SetPosY(NaN)
        }
        d = c.reduce((f, g) => f + g.GetHeight(), 0) - b;
        "center" === this._verticalAlign ? a = Math.max(Math.floor(this._cssHeight / 2 - d / 2), 0) : "bottom" === this._verticalAlign && (a = Math.floor(this._cssHeight - d));
        for (let f = 0, g = c.length; f < g; ++f) {
            d = c[f];
            e = d.GetHeight();
            if (0 < f && a > this._cssHeight - (e - b))
                break;
            0 <= a && this._LayoutTextLine(d,
            a);
            a += e
        }
    }
    _LayoutTextLine(a, b)
    {
        let c = 0;
        "center" === this._horizontalAlign ? c = Math.max(Math.floor((this._cssWidth - a.GetWidth()) / 2), 0) : "right" === this._horizontalAlign && (c = Math.max(Math.floor(this._cssWidth - a.GetWidth()), 0));
        a.SetPosX(c);
        a.SetPosY(b);
        for (const d of a.fragments())
            d.IsIcon() || (this._LayoutTextFragment(d, c, b), c += d.GetWidth())
    }
    _LayoutTextFragment(a, b, c)
    {
        var d = a.GetStyleTag("offsetx");
        b += d ? getOffsetParam$jscomp$1(d.param, a.GetHeight()) : 0;
        d = a.GetStyleTag("offsety");
        c += d ? getOffsetParam$jscomp$1(d.param,
        a.GetHeight()) : 0;
        a.SetPosX(b);
        a.SetPosY(c)
    }
    Draw(a, b, c, d)
    {
        this._UpdateTextMeasurements();
        this._drawCharCount = 0;
        const e = C3$jscomp$237.cloneArray(this._wrappedText.GetLines()),
            f = Math.sin(d);
        d = Math.cos(d);
        for (const g of e)
            this._DrawLine(a, g, b, c, f, d)
    }
    _DrawLine(a, b, c, d, e, f)
    {
        var g = b.GetPosX();
        const h = b.GetPosY();
        if (Number.isFinite(g) && Number.isFinite(h)) {
            g = b.GetHeight();
            for (const k of b.fragments())
                this._DrawFragment(a, k, c, d, e, f, g)
        }
    }
    _DrawFragment(a, b, c, d, e, f, g)
    {
        let h = b.GetPosX(),
            k = b.GetPosY();
        if (Number.isFinite(h) &&
        Number.isFinite(k)) {
            var l = b.GetCharacterArray(),
                m = b.GetWidth();
            if (-1 !== this._drawMaxCharCount) {
                if (this._drawCharCount >= this._drawMaxCharCount)
                    return;
                this._drawCharCount + l.length > this._drawMaxCharCount && (l = l.slice(0, this._drawMaxCharCount - this._drawCharCount), m = this._MeasureText(b).width);
                this._drawCharCount += l.length
            }
            var n = b.GetStyleTag("background");
            if (!(C3$jscomp$237.IsCharArrayAllWhitespace(l) && !n || b.HasStyleTag("hide"))) {
                var p = b.GetStyleTag("scale"),
                    q = (p ? parseFloat(p.param) : this._scale) * this._sceneGraphScale;
                p = b.GetStyleTag("scalex");
                p = (p ? parseFloat(p.param) : 1) * q;
                var r = b.GetStyleTag("scaley");
                q *= r ? parseFloat(r.param) : 1;
                q *= this._spriteFont.GetCharacterHeight();
                k += g - this._lineHeight - q;
                g = 1;
                (r = b.GetStyleTag("opacity")) && (g = parseFloat(r.param) / 100);
                n && (a.SetColorFillMode(), tmpColor.parseString(normalizeCssColorString(n.param)), tmpColor.setA(tmpColor.getA() * g * this._color.getA()), tmpColor.premultiply(), a.SetColor(tmpColor), tmpRect$jscomp$3.set(h, k, h + m, k + q), tmpRect$jscomp$3.getRight() > this._cssWidth && tmpRect$jscomp$3.setRight(this._cssWidth),
                tmpQuad$jscomp$3.setFromRotatedRectPrecalc(tmpRect$jscomp$3, e, f), tmpQuad$jscomp$3.offset(c, d), a.Quad(tmpQuad$jscomp$3), a.SetTextureFillMode());
                (b = b.GetStyleTag("color")) ? (tmpColor.parseString(normalizeCssColorString(b.param)), tmpColor.setA(this._color.getA())) : tmpColor.copy(this._color);
                tmpColor.setA(tmpColor.getA() * g);
                tmpColor.premultiply();
                a.SetColor(tmpColor);
                b = this._spriteFont.GetCharacterWidth() * p;
                m = Math.abs(this.GetSpacing());
                for (const t of l)
                    if (l = this._spriteFont.GetCharacter(t)) {
                        n = l.GetDisplayWidth() *
                        p;
                        if (h + n > this._cssWidth + m + 1E-5)
                            break;
                        tmpRect$jscomp$3.set(h, k, h + b, k + q);
                        tmpQuad$jscomp$3.setFromRotatedRectPrecalc(tmpRect$jscomp$3, e, f);
                        tmpQuad$jscomp$3.offset(c, d);
                        a.Quad3(tmpQuad$jscomp$3, l.GetTexRect());
                        h += n + this._spacing
                    } else
                        h += this._spriteFont.GetSpaceWidth() * p + this._spacing
            }
        }
    }
    GetSpriteFont()
    {
        return this._spriteFont
    }
    SetBBCodeEnabled(a)
    {
        a = !!a;
        this._isBBcodeEnabled !== a && (this._isBBcodeEnabled = a, this._SetWordWrapChanged())
    }
    IsBBCodeEnabled()
    {
        return this._isBBcodeEnabled
    }
    SetText(a)
    {
        this._text !==
        a && (this._text = a, this._SetWordWrapChanged())
    }
    SetWordWrapMode(a)
    {
        if (!VALID_WORD_WRAP_MODES$jscomp$1.has(a))
            throw Error("invalid word wrap mode");
        this._wrapMode !== a && (this._wrapMode = a, this._SetWordWrapChanged())
    }
    SetHorizontalAlign(a)
    {
        if (!VALID_HORIZ_ALIGNMENTS$jscomp$1.has(a))
            throw Error("invalid alignment");
        this._horizontalAlign !== a && (this._horizontalAlign = a, this._SetTextLayoutChanged())
    }
    SetVerticalAlign(a)
    {
        if (!VALID_VERT_ALIGNMENTS$jscomp$1.has(a))
            throw Error("invalid alignment");
        this._verticalAlign !==
        a && (this._verticalAlign = a, this._SetTextLayoutChanged())
    }
    SetScale(a)
    {
        this._scale !== a && (this._scale = a, this._SetWordWrapChanged())
    }
    GetScale()
    {
        return this._scale
    }
    SetSceneGraphScale(a)
    {
        this._sceneGraphScale !== a && (this._sceneGraphScale = a, this._SetWordWrapChanged())
    }
    GetSceneGraphScale()
    {
        return this._sceneGraphScale
    }
    SetSpacing(a)
    {
        this._spacing !== a && (this._spacing = a, this._SetWordWrapChanged())
    }
    GetSpacing()
    {
        return this._spacing
    }
    SetLineHeight(a)
    {
        this._lineHeight = a;
        this._SetWordWrapChanged()
    }
    GetLineHeight()
    {
        return this._lineHeight
    }
    SetOpacity(a)
    {
        a =
        C3$jscomp$237.clamp(a, 0, 1);
        this._color.a = a
    }
    SetColor(a)
    {
        this._color.equals(a) || this._color.copy(a)
    }
    GetColor()
    {
        return this._color
    }
    GetTextWidth()
    {
        this._UpdateTextMeasurements();
        return this._wrappedText.GetMaxLineWidth()
    }
    GetTextHeight()
    {
        this._UpdateTextMeasurements();
        var a = this._spriteFont.GetCharacterHeight() * this._scale;
        const b = this._lineHeight;
        a += b;
        return this._wrappedText.GetLineCount() * a - b
    }
}
;
"use strict";
const C3$jscomp$238 = self.C3,
    DEFAULT_SPRITEFONT_OPTS = {
        width: 256,
        height: 256,
        characterWidth: 16,
        characterHeight: 16,
        characterSet: ""
    };
self.SpriteFont = class {
    constructor(a)
    {
        a = Object.assign({}, DEFAULT_SPRITEFONT_OPTS, a);
        if (0 >= a.width || 0 >= a.height || 0 >= a.characterWidth || 0 >= a.characterHeight)
            throw Error("invalid size");
        this._width = a.width;
        this._height = a.height;
        this._characterWidth = a.characterWidth;
        this._characterHeight = a.characterHeight;
        this._characterSet = a.characterSet;
        this._spacingData = "";
        this._spacingParsed = null;
        this._hasAnyCustomWidths = !1;
        this._spaceWidth = -1;
        this._texRect = new C3$jscomp$238.Rect(0, 0, 1, 1);
        this._characterMap = new Map;
        this._mapChanged = !0;
        this._allTexts = new Set
    }
    Release()
    {
        this._texRect = null;
        this._ReleaseCharacters();
        this._characterMap = null;
        this._allTexts && this._allTexts.clear();
        this._allTexts = null
    }
    _ReleaseCharacters()
    {
        for (let a of this._characterMap.values())
            a.Release();
        this._characterMap.clear()
    }
    _AddSpriteFontText(a)
    {
        this._allTexts.add(a)
    }
    _RemoveSpriteFontText(a)
    {
        this._allTexts.delete(a)
    }
    UpdateCharacterMap()
    {
        if (this._mapChanged) {
            this._ReleaseCharacters();
            var a = C3$jscomp$238.SplitGraphemes(this._characterSet),
                b =
                Math.floor(this._width / this._characterWidth),
                c = b * Math.floor(this._height / this._characterHeight);
            for (let d = 0, e = a.length; d < e && !(d >= c); ++d) {
                let f = a[d];
                this._characterMap.has(f) || this._characterMap.set(f, C3$jscomp$238.New(self.SpriteFontCharacter, this, f, d % b * this._characterWidth, Math.floor(d / b) * this._characterHeight))
            }
            this._hasAnyCustomWidths = !1;
            this._spaceWidth = -1;
            if (Array.isArray(this._spacingParsed))
                for (let d of this._spacingParsed)
                    if (Array.isArray(d) && 2 === d.length && (a = d[0], b = d[1], "number" === typeof a &&
                    isFinite(a) && "string" === typeof b && a !== this._characterWidth))
                        for (let e of b)
                            (b = this._characterMap.get(e)) ? (b.SetDisplayWidth(a), this._hasAnyCustomWidths = !0) : " " === e && (this._spaceWidth = a, this._hasAnyCustomWidths = !0);
            this._mapChanged = !1;
            for (let d of this._allTexts)
                d._SetWordWrapChanged()
        }
    }
    SetCharacterWidthsChanged()
    {
        this._hasAnyCustomWidths = !0;
        for (const a of this._allTexts)
            a._SetWordWrapChanged()
    }
    GetCharacter(a)
    {
        this.UpdateCharacterMap();
        return this._characterMap.get(a) || null
    }
    HasAnyCustomWidths()
    {
        return this._hasAnyCustomWidths
    }
    SetWidth(a)
    {
        a =
        Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._width !== a && (this._width = a, this._mapChanged = !0)
    }
    GetWidth()
    {
        return this._width
    }
    SetHeight(a)
    {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._height !== a && (this._height = a, this._mapChanged = !0)
    }
    GetHeight()
    {
        return this._height
    }
    SetTexRect(a)
    {
        if (!this._texRect.equals(a)) {
            this._texRect.copy(a);
            for (const b of this._characterMap.values())
                b._UpdateTexRect()
        }
    }
    GetTexRect()
    {
        return this._texRect
    }
    SetCharacterWidth(a)
    {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._characterWidth !== a && (this._characterWidth = a, this._mapChanged = !0)
    }
    GetCharacterWidth()
    {
        return this._characterWidth
    }
    SetCharacterHeight(a)
    {
        a = Math.floor(a);
        if (0 >= a)
            throw Error("invalid size");
        this._characterHeight !== a && (this._characterHeight = a, this._mapChanged = !0)
    }
    GetCharacterHeight()
    {
        return this._characterHeight
    }
    SetCharacterSet(a)
    {
        this._characterSet !== a && (this._characterSet = a, this._mapChanged = !0)
    }
    GetCharacterSet()
    {
        return this._characterSet
    }
    SetSpacingData(a)
    {
        if (this._spacingData !== a && (this._spacingData =
        a, this._mapChanged = !0, this._spacingParsed = null, this._spacingData.length))
            try {
                this._spacingParsed = JSON.parse(this._spacingData)
            } catch (b) {
                this._spacingParsed = null
            }
    }
    GetSpacingData()
    {
        return this._spacingData
    }
    SetSpaceWidth(a)
    {
        0 > a && (a = -1);
        this._spaceWidth !== a && (this._spaceWidth = a, 0 <= this._spaceWidth && (this._hasAnyCustomWidths = !0))
    }
    GetSpaceWidth()
    {
        return 0 > this._spaceWidth ? this._characterWidth : this._spaceWidth
    }
}
;
"use strict";
const C3$jscomp$239 = self.C3,
    actionPromises = [];
C3$jscomp$239.Plugins.Audio = class  extends C3$jscomp$239.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    _AddActionPromise(a)
    {
        actionPromises.push(a)
    }
    static async WaitForAllActionPromises()
    {
        await Promise.all(actionPromises);
        C3$jscomp$239.clearArray(actionPromises)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$240 = self.C3,
    C3X$jscomp$41 = self.C3X;
C3$jscomp$240.Plugins.Audio.Type = class  extends C3$jscomp$240.SDKTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass()
    {
        return self.IAudioObjectType
    }
}
;
let audioObjectType = null;
function GetAudioSdkInstance() {
    return audioObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
function GetAudioDOMInterface() {
    if (self.C3Audio_DOMInterface)
        return self.C3Audio_DOMInterface;
    throw Error("audio scripting API cannot be used here - make sure the project is using DOM mode, not worker mode");
}
self.IAudioObjectType = class  extends self.IObjectClass{
    constructor(a)
    {
        super(a);
        audioObjectType = a
    }
    get audioContext()
    {
        return GetAudioDOMInterface().GetAudioContextExtern()
    }
    get destinationNode()
    {
        return GetAudioDOMInterface().GetDestinationNodeExtern()
    }
    get isSilent()
    {
        return GetAudioSdkInstance()._IsSilent()
    }
    set isSilent(a)
    {
        GetAudioSdkInstance()._SetSilent(a)
    }
    get masterVolume()
    {
        return GetAudioSdkInstance()._GetMasterVolume()
    }
    set masterVolume(a)
    {
        C3X$jscomp$41.RequireFiniteNumber(a);
        GetAudioSdkInstance()._SetMasterVolume(a)
    }
    stopAll()
    {
        GetAudioSdkInstance()._StopAll()
    }
}
;
const C3$jscomp$241 = self.C3,
    LATENCY_HINTS = ["interactive", "balanced", "playback"];
C3$jscomp$241.Plugins.Audio.Instance = class  extends C3$jscomp$241.SDKInstanceBase{
    constructor(a, b)
    {
        super(a, "audio");
        this._nextPlayTime = 0;
        this._triggerTags = [];
        this._enableMultiTags = !0;
        this._saveLoadMode = this._timeScaleMode = 0;
        this._playInBackground = !1;
        this._distanceModel = this._panningModel = 1;
        this._listenerPos = [this._runtime.GetViewportWidth() / 2, this._runtime.GetViewportHeight() / 2, 600];
        this._listenerForwardVec = [0, 0, -1];
        this._listenerUpVec = [0, 1, 0];
        this._referenceDistance = 600;
        this._maxDistance = 1E4;
        this._rolloffFactor =
        1;
        this._listenerInst = null;
        this._loadListenerUid = -1;
        this._masterVolume = 1;
        this._isSilent = !1;
        this._sampleRate = 0;
        this._audioContextState = "suspended";
        this._outputLatency = 0;
        this._effectCount = new Map;
        this._preloadCount = this._preloadTotal = 0;
        this._bufferMetadata = new Map;
        this._remoteUrls = new Map;
        a = "interactive";
        b && (this._timeScaleMode = b[0], this._saveLoadMode = b[1], this._playInBackground = b[2], a = LATENCY_HINTS[b[3]], this._enableMultiTags = b[4], this._panningModel = b[5], this._distanceModel = b[6], this._listenerPos[2] =
        b[7], this._referenceDistance = b[8], this._maxDistance = b[9], this._rolloffFactor = b[10]);
        this._lastAIState = [];
        this._lastFxState = [];
        this._lastAnalysersData = [];
        this.AddDOMMessageHandlers([["state", f => this._OnUpdateState(f)], ["audiocontext-state", f => this._OnAudioContextStateChanged(f)], ["fxstate", f => this._OnUpdateFxState(f)], ["trigger", f => this._OnTrigger(f)], ["buffer-metadata", f => this._OnBufferMetadata(f)]]);
        b = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$241.CompositeDisposable(C3$jscomp$241.Disposable.From(b,
        "instancedestroy", f => this._OnInstanceDestroyed(f.instance)), C3$jscomp$241.Disposable.From(b, "afterload", () => this._OnAfterLoad()), C3$jscomp$241.Disposable.From(b, "suspend", () => this._OnSuspend()), C3$jscomp$241.Disposable.From(b, "resume", () => this._OnResume()));
        b = "Safari" === C3$jscomp$241.Platform.Browser;
        const c = this._runtime.IsiOSWebView(),
            d = this._runtime.GetAssetManager().IsFileProtocol(),
            e = "playable-ad-single-file" === this._runtime.GetExportType();
        b = b || c || d || e;
        this._runtime.AddLoadPromise(this.PostToDOMAsync("create-audio-context",
        {
            preloadList: this._runtime.GetAssetManager().GetAudioToPreload().map(f => ({
                originalUrl: f.originalUrl,
                url: f.url,
                type: f.type,
                fileSize: f.fileSize
            })),
            timeScaleMode: this._timeScaleMode,
            latencyHint: a,
            panningModel: this._panningModel,
            distanceModel: this._distanceModel,
            refDistance: this._referenceDistance,
            maxDistance: this._maxDistance,
            rolloffFactor: this._rolloffFactor,
            listenerPos: this._listenerPos,
            usePlayMusicAsSoundWorkaround: b
        }).then(f => {
            this._sampleRate = f.sampleRate;
            this._audioContextState = f.audioContextState;
            this._outputLatency = f.outputLatency
        }));
        this._StartTicking()
    }
    Release()
    {
        this._listenerInst = null;
        super.Release()
    }
    _SplitTags(a)
    {
        return this._enableMultiTags ? a.split(" ").filter(b => !!b) : a ? [a] : []
    }
    _MatchTagLists(a, b)
    {
        for (const c of b) {
            b = !1;
            for (const d of a)
                if (C3$jscomp$241.equalsNoCase(d, c)) {
                    b = !0;
                    break
                }
            if (!b)
                return !1
        }
        return !0
    }
    _MatchTagListToStr(a, b)
    {
        return this._MatchTagLists(a, this._SplitTags(b))
    }
    _AddActionPromise(a)
    {
        this.GetPlugin()._AddActionPromise(a)
    }
    _OnInstanceDestroyed(a)
    {
        this._listenerInst === a &&
        (this._listenerInst = null)
    }
    DbToLinearNoCap(a)
    {
        return Math.pow(10, a / 20)
    }
    DbToLinear(a)
    {
        a = this.DbToLinearNoCap(a);
        return isFinite(a) ? Math.max(Math.min(a, 1), 0) : 0
    }
    LinearToDbNoCap(a)
    {
        return Math.log(a) / Math.log(10) * 20
    }
    LinearToDb(a)
    {
        return this.LinearToDbNoCap(Math.max(Math.min(a, 1), 0))
    }
    _OnSuspend()
    {
        this._playInBackground || this.PostToDOM("set-suspended", {
            isSuspended: !0
        })
    }
    _OnResume()
    {
        this._playInBackground || this.PostToDOM("set-suspended", {
            isSuspended: !1
        })
    }
    _OnUpdateState(a)
    {
        const b = a.tickCount;
        this._outputLatency =
        a.outputLatency;
        const c = this._lastAIState.filter(d => d.hasOwnProperty("placeholder") && (d.placeholder > b || -1 === d.placeholder));
        this._lastAIState = a.audioInstances;
        this._lastAnalysersData = a.analysers;
        0 < c.length && C3$jscomp$241.appendArray(this._lastAIState, c)
    }
    _OnBufferMetadata(a)
    {
        this._bufferMetadata.set(a.originalUrl, {
            duration: a.duration
        })
    }
    _OnAudioContextStateChanged(a)
    {
        this._audioContextState = a.audioContextState
    }
    GetAudioContextState()
    {
        return this._runtime.IsExportToVideo() ? "running" : this._audioContextState
    }
    _OnUpdateFxState(a)
    {
        this._lastFxState =
        a.fxstate
    }
    _GetFirstAudioStateByTags(a)
    {
        a = this._SplitTags(a);
        for (const b of this._lastAIState)
            if (this._MatchTagLists(b.tags, a))
                return b;
        return null
    }
    _IsTagPlaying(a)
    {
        const b = this._SplitTags(a);
        return this._lastAIState.some(c => this._MatchTagLists(c.tags, b) && c.isPlaying)
    }
    _MaybeMarkAsPlaying(a, b, c, d, e)
    {
        if (this._IsTagPlaying(b))
            return null;
        const f = this._bufferMetadata.get(a);
        a = {
            tags: this._SplitTags(b),
            duration: f ? f.duration : 0,
            volume: e,
            isPlaying: !0,
            playbackTime: 0,
            playbackRate: 1,
            uid: -1,
            bufferOriginalUrl: a,
            bufferUrl: "",
            bufferType: "",
            isMusic: c,
            isLooping: d,
            isMuted: !1,
            resumePosition: 0,
            pan: null,
            placeholder: -1
        };
        this._lastAIState.push(a);
        return a
    }
    _MaybeMarkAsStopped(a)
    {
        a = this._SplitTags(a);
        for (const b of this._lastAIState)
            this._MatchTagLists(b.tags, a) && (b.isPlaying = !1)
    }
    async _OnTrigger(a)
    {
        const b = a.type;
        this._triggerTags = a.tags;
        a = a.aiid;
        if ("ended" === b) {
            for (const c of this._lastAIState)
                if (c.aiid === a) {
                    c.isPlaying = !1;
                    break
                }
            await this.TriggerAsync(C3$jscomp$241.Plugins.Audio.Cnds.OnEnded)
        } else
            "fade-ended" ===
            b && await this.TriggerAsync(C3$jscomp$241.Plugins.Audio.Cnds.OnFadeEnded)
    }
    _MatchTriggerTag(a)
    {
        return this._MatchTagListToStr(this._triggerTags, a)
    }
    Tick()
    {
        const a = {
            timeScale: this._runtime.GetTimeScale(),
            gameTime: this._runtime.GetGameTimeRaw(),
            instPans: this.GetInstancePans(),
            tickCount: this._runtime.GetTickCountNoSave()
        };
        if (this._listenerInst) {
            const b = this._listenerInst.GetWorldInfo();
            this._listenerPos[0] = b.GetX();
            this._listenerPos[1] = b.GetY();
            a.listenerPos = this._listenerPos;
            a.listenerOrientation = [...this._listenerForwardVec,
            ...this._listenerUpVec]
        }
        this.PostToDOM("tick", a)
    }
    rotatePtAround(a, b, c, d, e)
    {
        if (0 === c)
            return [a, b];
        const f = Math.sin(c);
        c = Math.cos(c);
        a -= d;
        b -= e;
        const g = a * f;
        a = a * c - b * f;
        b = b * c + g;
        return [a + d, b + e]
    }
    GetInstancePans()
    {
        return this._lastAIState.filter(a => -1 !== a.uid).map(a => this._runtime.GetInstanceByUID(a.uid)).filter(a => a).map(a => {
            const b = a.GetWorldInfo(),
                c = b.GetLayer().GetAngle(),
                [d, e] = this.rotatePtAround(b.GetX(), b.GetY(), -c, this._listenerPos[0], this._listenerPos[1]);
            return {
                uid: a.GetUID(),
                x: d,
                y: e,
                z: b.GetTotalZElevation(),
                angle: b.GetAngle() - c
            }
        })
    }
    GetAnalyserData(a, b)
    {
        for (const c of this._lastAnalysersData)
            if (c.index === b && C3$jscomp$241.equalsNoCase(c.tag, a))
                return c;
        return null
    }
    _IncrementEffectCount(a)
    {
        for (const b of this._SplitTags(a))
            a = b.toLowerCase(),
            this._effectCount.set(a, (this._effectCount.get(a) || 0) + 1)
    }
    _IsSilent()
    {
        return this._isSilent
    }
    _SetSilent(a)
    {
        a = !!a;
        this._isSilent !== a && (this._isSilent = a, this.PostToDOM("set-silent", {
            isSilent: a
        }))
    }
    _GetMasterVolume()
    {
        return this._masterVolume
    }
    _SetMasterVolume(a)
    {
        this._masterVolume !==
        a && (this._masterVolume = a, this.PostToDOM("set-master-volume", {
            vol: a
        }))
    }
    _StopAll()
    {
        this.PostToDOM("stop-all");
        for (const a of this._lastAIState)
            a.isPlaying = !1
    }
    _ShouldSave(a)
    {
        return a.hasOwnProperty("placeholder") || 3 === this._saveLoadMode ? !1 : a.isMusic && 1 === this._saveLoadMode ? !1 : a.isMusic || 2 !== this._saveLoadMode ? !0 : !1
    }
    SaveToJson()
    {
        return {
            isSilent: this._isSilent,
            masterVolume: this._masterVolume,
            listenerZ: this._listenerPos[2],
            listenerForwardVec: this._listenerForwardVec,
            listenerUpVec: this._listenerUpVec,
            listenerUid: this._listenerInst ?
            this._listenerInst.GetUID() : -1,
            remoteUrls: [...this._remoteUrls.entries()],
            playing: this._lastAIState.filter(a => this._ShouldSave(a)),
            effects: this._lastFxState,
            analysers: this._lastAnalysersData
        }
    }
    LoadFromJson(a)
    {
        this._isSilent = a.isSilent;
        this._masterVolume = a.masterVolume;
        this._listenerPos[2] = a.listenerZ;
        this._listenerInst = null;
        this._loadListenerUid = a.listenerUid;
        a.hasOwnProperty("listenerForwardVec") ? this._listenerForwardVec = a.listenerForwardVec : this._listenerForwardVec = [0, 0, -1];
        a.hasOwnProperty("listenerUpVec") ?
        this._listenerUpVec = a.listenerUpVec : this._listenerUpVec = [0, 1, 0];
        this._remoteUrls.clear();
        if (a.remoteUrls)
            for (const [b, c] of a.remoteUrls)
                this._remoteUrls.set(b, c);
        this._lastAIState = a.playing;
        for (const b of this._lastAIState)
            b.hasOwnProperty("tag") && !b.hasOwnProperty("tags") && (b.tags = [b.tag].filter(c => !!c));
        this._lastFxState = a.effects;
        this._lastAnalysersData = a.analysers
    }
    _OnAfterLoad()
    {
        if (-1 !== this._loadListenerUid && (this._listenerInst = this._runtime.GetInstanceByUID(this._loadListenerUid), this._loadListenerUid =
        -1, this._listenerInst)) {
            var a = this._listenerInst.GetWorldInfo();
            this._listenerPos[0] = a.GetX();
            this._listenerPos[1] = a.GetY()
        }
        for (var b of this._lastAIState)
            (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b.bufferOriginalUrl)) ? (b.bufferUrl = a.url, b.bufferType = a.type) : b.bufferUrl = null;
        for (const c of Object.values(this._lastFxState))
            for (const d of c)
                d.hasOwnProperty("bufferOriginalUrl") && (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(d.bufferOriginalUrl)) && (d.bufferUrl = b.url, d.bufferType =
                b.type);
        this.PostToDOM("load-state", {
            saveLoadMode: this._saveLoadMode,
            timeScale: this._runtime.GetTimeScale(),
            gameTime: this._runtime.GetGameTimeRaw(),
            listenerPos: this._listenerPos,
            listenerOrientation: [...this._listenerForwardVec, ...this._listenerUpVec],
            isSilent: this._isSilent,
            masterVolume: this._masterVolume,
            playing: this._lastAIState.filter(c => null !== c.bufferUrl),
            effects: this._lastFxState
        })
    }
    GetDebuggerProperties()
    {
        const a = [];
        for (const [b, c] of Object.entries(this._lastFxState))
            a.push({
                name: "$" + b,
                value: c.map(d =>
                d.type).join(", ")
            });
        return [{
            title: "plugins.audio.debugger.tag-effects",
            properties: a
        }, {
            title: "plugins.audio.debugger.currently-playing",
            properties: [{
                name: "plugins.audio.debugger.currently-playing-count",
                value: this._lastAIState.length
            }, ...this._lastAIState.map((b, c) => ({
                name: "$#" + c,
                value: `${b.bufferOriginalUrl} ("${b.tags}") ${Math.round(10 * b.playbackTime) / 10} / ${Math.round(10 * b.duration) / 10}`
            }))]
        }]
    }
}
;
self.C3.Plugins.Audio.Cnds = {
    OnEnded(a) {
        return this._MatchTriggerTag(a)
    },
    OnFadeEnded(a) {
        return this._MatchTriggerTag(a)
    },
    PreloadsComplete() {
        return this._preloadCount === this._preloadTotal
    },
    AdvancedAudioSupported() {
        return !0
    },
    IsSilent() {
        return this._IsSilent()
    },
    IsAnyPlaying() {
        for (const a of this._lastAIState)
            if (a.isPlaying)
                return !0;
        return !1
    },
    IsTagPlaying(a) {
        return this._IsTagPlaying(a)
    }
};
const C3$jscomp$243 = self.C3,
    FILTER_TYPES = "lowpass highpass bandpass lowshelf highshelf peaking notch allpass".split(" ");
C3$jscomp$243.Plugins.Audio.Acts = {
    Play(a, b, c, d, e) {
        a = C3$jscomp$243.Plugins.Audio.Acts._DoPlay.call(this, a, b, c, d, e);
        this._AddActionPromise(a);
        return a
    },
    PlayFromTimeline(a, b, c, d) {
        C3$jscomp$243.Plugins.Audio.Acts._DoPlay.call(this, a, 0, b, 0, c, d)
    },
    async _DoPlay(a, b, c, d, e, f) {
        if (!this._isSilent) {
            var g = a[1],
                h = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (h) {
                var k = this._nextPlayTime;
                this._nextPlayTime = 0;
                var l = this._MaybeMarkAsPlaying(a[0], e, g, 0 !== b, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play",
                    {
                        originalUrl: a[0],
                        url: h.url,
                        type: h.type,
                        isMusic: g,
                        tags: this._SplitTags(e),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(c),
                        stereoPan: C3$jscomp$243.clamp(d / 100, -1, 1),
                        pos: f || 0,
                        off: k,
                        trueClock: !!self.C3_GetAudioContextCurrentTime
                    })
                } finally {
                    l && (l.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtPosition(a, b, c, d, e, f, g, h, k, l, m) {
        if (!this._isSilent) {
            var n = a[1],
                p = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (p) {
                var q = this._nextPlayTime;
                this._nextPlayTime = 0;
                var r = this._MaybeMarkAsPlaying(a[0],
                m, n, 0 !== b, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: p.url,
                        type: p.type,
                        isMusic: n,
                        tags: this._SplitTags(m),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(c),
                        pos: 0,
                        off: q,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: d,
                            y: e,
                            z: f,
                            angle: C3$jscomp$243.toRadians(g),
                            innerAngle: C3$jscomp$243.toRadians(h),
                            outerAngle: C3$jscomp$243.toRadians(k),
                            outerGain: this.DbToLinear(l)
                        }
                    })
                } finally {
                    r && (r.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtObject(a, b, c, d, e, f, g, h) {
        if (!this._isSilent &&
        d && (d = d.GetFirstPicked()) && d.GetWorldInfo()) {
            var k = d.GetWorldInfo(),
                l = k.GetLayer().GetAngle(),
                [m, n] = this.rotatePtAround(k.GetX(), k.GetY(), -l, this._listenerPos[0], this._listenerPos[1]),
                p = a[1],
                q = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
            if (q) {
                var r = this._nextPlayTime;
                this._nextPlayTime = 0;
                var t = this._MaybeMarkAsPlaying(a[0], h, p, 0 !== b, this.DbToLinear(c));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: a[0],
                        url: q.url,
                        type: q.type,
                        isMusic: p,
                        tags: this._SplitTags(h),
                        isLooping: 0 !== b,
                        vol: this.DbToLinear(c),
                        pos: 0,
                        off: r,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: m,
                            y: n,
                            z: k.GetTotalZElevation(),
                            angle: k.GetAngle() - l,
                            innerAngle: C3$jscomp$243.toRadians(e),
                            outerAngle: C3$jscomp$243.toRadians(f),
                            outerGain: this.DbToLinear(g),
                            uid: d.GetUID()
                        }
                    })
                } finally {
                    t && (t.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayByName(a, b, c, d, e, f) {
        if (!this._isSilent) {
            a = 1 === a;
            var g = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (g) {
                var h = this._nextPlayTime;
                this._nextPlayTime = 0;
                var k = this._MaybeMarkAsPlaying(b, f, a, 0 !== c, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: g.url,
                        type: g.type,
                        isMusic: a,
                        tags: this._SplitTags(f),
                        isLooping: 0 !== c,
                        vol: this.DbToLinear(d),
                        stereoPan: C3$jscomp$243.clamp(e / 100, -1, 1),
                        pos: 0,
                        off: h,
                        trueClock: !!self.C3_GetAudioContextCurrentTime
                    })
                } finally {
                    k && (k.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtPositionByName(a, b, c, d, e, f, g, h, k, l, m, n) {
        if (!this._isSilent) {
            a = 1 === a;
            var p = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) ||
            this._remoteUrls.get(b.toLowerCase());
            if (p) {
                var q = this._nextPlayTime;
                this._nextPlayTime = 0;
                var r = this._MaybeMarkAsPlaying(b, n, a, 0 !== c, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: p.url,
                        type: p.type,
                        isMusic: a,
                        tags: this._SplitTags(n),
                        isLooping: 0 !== c,
                        vol: this.DbToLinear(d),
                        pos: 0,
                        off: q,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: e,
                            y: f,
                            z: g,
                            angle: C3$jscomp$243.toRadians(h),
                            innerAngle: C3$jscomp$243.toRadians(k),
                            outerAngle: C3$jscomp$243.toRadians(l),
                            outerGain: this.DbToLinear(m)
                        }
                    })
                } finally {
                    r &&
                    (r.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    async PlayAtObjectByName(a, b, c, d, e, f, g, h, k) {
        if (!this._isSilent && !this._isSilent && e && (e = e.GetFirstPicked()) && e.GetWorldInfo()) {
            var l = e.GetWorldInfo(),
                m = l.GetLayer().GetAngle(),
                [n, p] = this.rotatePtAround(l.GetX(), l.GetY(), -m, this._listenerPos[0], this._listenerPos[1]);
            a = 1 === a;
            var q = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
            if (q) {
                var r = this._nextPlayTime;
                this._nextPlayTime = 0;
                var t = this._MaybeMarkAsPlaying(b,
                k, a, 0 !== c, this.DbToLinear(d));
                try {
                    await this.PostToDOMAsync("play", {
                        originalUrl: b,
                        url: q.url,
                        type: q.type,
                        isMusic: a,
                        tags: this._SplitTags(k),
                        isLooping: 0 !== c,
                        vol: this.DbToLinear(d),
                        pos: 0,
                        off: r,
                        trueClock: !!self.C3_GetAudioContextCurrentTime,
                        panning: {
                            x: n,
                            y: p,
                            z: l.GetTotalZElevation(),
                            angle: l.GetAngle() - m,
                            innerAngle: C3$jscomp$243.toRadians(f),
                            outerAngle: C3$jscomp$243.toRadians(g),
                            outerGain: this.DbToLinear(h),
                            uid: e.GetUID()
                        }
                    })
                } finally {
                    t && (t.placeholder = this._runtime.GetTickCountNoSave())
                }
            }
        }
    },
    SetLooping(a,
    b) {
        this.PostToDOM("set-looping", {
            tags: this._SplitTags(a),
            isLooping: 0 === b
        })
    },
    SetMuted(a, b) {
        this.PostToDOM("set-muted", {
            tags: this._SplitTags(a),
            isMuted: 0 === b
        })
    },
    SetVolume(a, b) {
        this.PostToDOM("set-volume", {
            tags: this._SplitTags(a),
            vol: this.DbToLinear(b)
        })
    },
    FadeVolume(a, b, c, d) {
        this.PostToDOM("fade-volume", {
            tags: this._SplitTags(a),
            vol: this.DbToLinear(b),
            duration: c,
            stopOnEnd: 0 === d
        })
    },
    SetStereoPan(a, b) {
        this.PostToDOM("set-stereo-pan", {
            tags: this._SplitTags(a),
            p: C3$jscomp$243.clamp(b / 100, -1, 1)
        })
    },
    async Preload(a) {
        const b =
            a[1],
            c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0]);
        c && (this._preloadTotal++, await this.PostToDOMAsync("preload", {
            originalUrl: a[0],
            url: c.url,
            type: c.type,
            isMusic: b
        }), this._preloadCount++)
    },
    async PreloadByName(a, b) {
        a = 1 === a;
        const c = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase());
        c && (this._preloadTotal++, await this.PostToDOMAsync("preload", {
            originalUrl: b,
            url: c.url,
            type: c.type,
            isMusic: a
        }), this._preloadCount++)
    },
    SetPlaybackRate(a, b) {
        this.PostToDOM("set-playback-rate",
        {
            tags: this._SplitTags(a),
            rate: Math.max(b, 0)
        })
    },
    Stop(a) {
        this._MaybeMarkAsStopped(a);
        this.PostToDOM("stop", {
            tags: this._SplitTags(a)
        })
    },
    StopAll() {
        this._StopAll()
    },
    SetPaused(a, b) {
        this.PostToDOM("set-paused", {
            tags: this._SplitTags(a),
            paused: 0 === b
        })
    },
    Seek(a, b) {
        this.PostToDOM("seek", {
            tags: this._SplitTags(a),
            pos: b
        })
    },
    SetSilent(a) {
        2 === a && (a = this._IsSilent() ? 1 : 0);
        this._SetSilent(0 === a)
    },
    SetMasterVolume(a) {
        a = this.DbToLinear(a);
        this._SetMasterVolume(a)
    },
    AddFilterEffect(a, b, c, d, e, f, g) {
        b = FILTER_TYPES[b];
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "filter",
            tags: this._SplitTags(a),
            params: [b, c, d, e, f, C3$jscomp$243.clamp(g / 100, 0, 1)]
        })
    },
    AddDelayEffect(a, b, c, d) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "delay",
            tags: this._SplitTags(a),
            params: [b, this.DbToLinear(c), C3$jscomp$243.clamp(d / 100, 0, 1)]
        })
    },
    AddFlangerEffect(a, b, c, d, e, f) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "flanger",
            tags: this._SplitTags(a),
            params: [b / 1E3, c / 1E3, d, e / 100, C3$jscomp$243.clamp(f / 100, 0, 1)]
        })
    },
    AddPhaserEffect(a,
    b, c, d, e, f, g) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "phaser",
            tags: this._SplitTags(a),
            params: [b, c, d, e, f, C3$jscomp$243.clamp(g / 100, 0, 1)]
        })
    },
    AddConvolutionEffect(a, b, c, d) {
        const e = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b[0]);
        e && (this._IncrementEffectCount(a), this.PostToDOM("add-effect", {
            type: "convolution",
            tags: this._SplitTags(a),
            bufferOriginalUrl: b[0],
            bufferUrl: e.url,
            bufferType: e.type,
            params: [0 === c, C3$jscomp$243.clamp(d / 100, 0, 1)]
        }))
    },
    AddGainEffect(a, b) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "gain",
            tags: this._SplitTags(a),
            params: [this.DbToLinear(b)]
        })
    },
    AddStereoPanEffect(a, b) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "stereopan",
            tags: this._SplitTags(a),
            params: [C3$jscomp$243.clamp(b / 100, -1, 1)]
        })
    },
    AddMuteEffect(a) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "gain",
            tags: this._SplitTags(a),
            params: [0]
        })
    },
    AddTremoloEffect(a, b, c) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "tremolo",
            tags: this._SplitTags(a),
            params: [b, C3$jscomp$243.clamp(c / 100, 0, 1)]
        })
    },
    AddRingModEffect(a, b, c) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "ringmod",
            tags: this._SplitTags(a),
            params: [b, C3$jscomp$243.clamp(c / 100, 0, 1)]
        })
    },
    AddDistortionEffect(a, b, c, d, e, f) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "distortion",
            tags: this._SplitTags(a),
            params: [this.DbToLinearNoCap(b), this.DbToLinearNoCap(c), d, this.DbToLinearNoCap(e), C3$jscomp$243.clamp(f / 100, 0, 1)]
        })
    },
    AddCompressorEffect(a, b, c, d, e, f) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "compressor",
            tags: this._SplitTags(a),
            params: [b, c, d, e / 1E3, f / 1E3]
        })
    },
    AddAnalyserEffect(a, b, c) {
        this._IncrementEffectCount(a);
        this.PostToDOM("add-effect", {
            type: "analyser",
            tags: this._SplitTags(a),
            params: [b, c]
        })
    },
    RemoveEffects(a) {
        a = this._SplitTags(a);
        for (const b of a)
            this._effectCount.set(b.toLowerCase(), 0);
        this.PostToDOM("remove-effects", {
            tags: a
        });
        this._lastFxState = {}
    },
    SetEffectParameter(a, b, c, d, e, f) {
        this.PostToDOM("set-effect-param", {
            tags: this._SplitTags(a),
            index: Math.floor(b),
            param: c,
            value: d,
            ramp: e,
            time: f
        })
    },
    SetListenerObject(a) {
        a && (a = a.GetFirstPicked()) && a.GetWorldInfo() && (this._listenerInst = a)
    },
    SetListenerZ(a) {
        this._listenerPos[2] = a
    },
    SetListenerOrientation(a, b, c, d, e, f) {
        this._listenerForwardVec[0] = a;
        this._listenerForwardVec[1] = b;
        this._listenerForwardVec[2] = -c;
        this._listenerUpVec[0] = d;
        this._listenerUpVec[1] = e;
        this._listenerUpVec[2] = -f
    },
    ScheduleNextPlay(a) {
        this._nextPlayTime = Math.max(a, 0)
    },
    UnloadAudio(a) {
        const b = a[1];
        (a = this._runtime.GetAssetManager().GetProjectAudioFileUrl(a[0])) &&
        this.PostToDOM("unload", {
            url: a.url,
            type: a.type,
            isMusic: b
        })
    },
    UnloadAudioByName(a, b) {
        a = 1 === a;
        (b = this._runtime.GetAssetManager().GetProjectAudioFileUrl(b) || this._remoteUrls.get(b.toLowerCase())) && this.PostToDOM("unload", {
            url: b.url,
            type: b.type,
            isMusic: a
        })
    },
    UnloadAll() {
        this.PostToDOM("unload-all")
    },
    AddRemoteURL(a, b, c) {
        this._remoteUrls.set(c.toLowerCase(), {
            url: a,
            type: b
        })
    }
};
const C3$jscomp$244 = self.C3;
C3$jscomp$244.Plugins.Audio.Exps = {
    Duration(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.duration : 0
    },
    PlaybackTime(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.playbackTime : 0
    },
    PlaybackRate(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? a.playbackRate : 0
    },
    Volume(a) {
        return (a = this._GetFirstAudioStateByTags(a)) ? this.LinearToDb(a.volume) : 0
    },
    MasterVolume() {
        return this.LinearToDb(this._GetMasterVolume())
    },
    EffectCount(a) {
        return this._effectCount.get(a.toLowerCase()) || 0
    },
    AnalyserFreqBinCount(a, b) {
        return (a =
        this.GetAnalyserData(a, Math.floor(b))) ? a.binCount : 0
    },
    AnalyserFreqBinAt(a, b, c) {
        a = this.GetAnalyserData(a, Math.floor(b));
        if (!a)
            return 0;
        c = Math.floor(c);
        return 0 > c || c >= a.binCount ? 0 : a.freqBins[c]
    },
    AnalyserPeakLevel(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.peak : 0
    },
    AnalyserRMSLevel(a, b) {
        return (a = this.GetAnalyserData(a, Math.floor(b))) ? a.rms : 0
    },
    SampleRate() {
        return this._sampleRate
    },
    CurrentTime() {
        return self.C3_GetAudioContextCurrentTime ? self.C3_GetAudioContextCurrentTime() : performance.now() /
        1E3
    },
    OutputLatency() {
        return this._outputLatency
    },
    NormalizedVolume(a, b) {
        a = C3$jscomp$244.clamp(+a, 0, 100) / 100;
        return 0 === a ? -Infinity : .1 > a ? this.LinearToDb(C3$jscomp$244.lerp(0, this.DbToLinear(b), 10 * a)) : C3$jscomp$244.lerp(b, 0, (a - .1) / .9)
    }
};
"use strict";
const C3$jscomp$245 = self.C3;
C3$jscomp$245.Plugins.TiledBg = class  extends C3$jscomp$245.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$246 = self.C3;
function WrapModeToStr(a) {
    switch (a) {
    case 0:
        return "clamp-to-edge";
    case 2:
        return "mirror-repeat"
    }
    return "repeat"
}
C3$jscomp$246.Plugins.TiledBg.Type = class  extends C3$jscomp$246.SDKTypeBase{
    constructor(a, b)
    {
        super(a);
        this._wrapY = this._wrapX = "repeat";
        b && (this._wrapX = WrapModeToStr(b[0]), this._wrapY = WrapModeToStr(b[1]))
    }
    Release()
    {
        super.Release()
    }
    OnCreate()
    {
        this.GetImageInfo().LoadAsset(this._runtime)
    }
    LoadTextures(a)
    {
        return this.GetImageInfo().LoadStaticTexture(a, {
            sampling: this._runtime.GetSampling(),
            wrapX: this._wrapX,
            wrapY: this._wrapY
        })
    }
    ReleaseTextures()
    {
        this.GetImageInfo().ReleaseTexture()
    }
}
;
const C3$jscomp$247 = self.C3,
    C3X$jscomp$42 = self.C3X,
    tempRect$jscomp$13 = C3$jscomp$247.New(C3$jscomp$247.Rect),
    tempQuad$jscomp$8 = C3$jscomp$247.New(C3$jscomp$247.Quad),
    rcTex$jscomp$3 = C3$jscomp$247.New(C3$jscomp$247.Rect),
    qTex = C3$jscomp$247.New(C3$jscomp$247.Quad);
C3$jscomp$247.Plugins.TiledBg.Instance = class  extends C3$jscomp$247.SDKWorldInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._imageOffsetY = this._imageOffsetX = 0;
        this._imageScaleY = this._imageScaleX = 1;
        this._imageAngle = 0;
        this._enableTileRandomization = !1;
        this._tileBlendMarginY = this._tileBlendMarginX = this._tileAngleRandom = this._tileYRandom = this._tileXRandom = 0;
        this._ownImageInfo = null;
        b && (this.GetWorldInfo().SetVisible(!!b[0]), this._imageOffsetX = b[4], this._imageOffsetY = b[5], this._imageScaleX = b[6], this._imageScaleY =
        b[7], this._imageAngle = C3$jscomp$247.toRadians(b[8]), this._enableTileRandomization = !!b[9], this._tileXRandom = b[10], this._tileYRandom = b[11], this._tileAngleRandom = b[12], this._tileBlendMarginX = b[13], this._tileBlendMarginY = b[14])
    }
    Release()
    {
        this._ReleaseOwnImage();
        super.Release()
    }
    _ReleaseOwnImage()
    {
        this._ownImageInfo && (this._ownImageInfo.Release(), this._ownImageInfo = null)
    }
    CalculateTextureCoordsFor3DFace(a, b, c)
    {
        var d = this.GetCurrentImageInfo();
        const e = d.GetWidth();
        d = d.GetHeight();
        const f = this._imageOffsetX /
            e,
            g = this._imageOffsetY / d,
            h = this._imageAngle;
        rcTex$jscomp$3.set(0, 0, a / (e * this._imageScaleX), b / (d * this._imageScaleY));
        rcTex$jscomp$3.offset(-f, -g);
        0 === h ? c.setFromRect(rcTex$jscomp$3) : c.setFromRotatedRect(rcTex$jscomp$3, -h)
    }
    SetTilingShaderProgram(a, b=!0)
    {
        this._enableTileRandomization ? (b = this.GetCurrentImageInfo(), a.SetTileRandomizationMode(), a.SetTileRandomizationInfo(b.GetWidth() * this._imageScaleX, b.GetHeight() * this._imageScaleY, this._tileXRandom, this._tileYRandom, this._tileAngleRandom, this._tileBlendMarginX,
        this._tileBlendMarginY)) : b && a.SetTextureFillMode()
    }
    Draw(a)
    {
        var b = this.GetCurrentImageInfo(),
            c = b.GetTexture();
        if (null !== c) {
            this.SetTilingShaderProgram(a);
            a.SetTexture(c);
            c = b.GetWidth();
            b = b.GetHeight();
            var d = this._imageOffsetX / c,
                e = this._imageOffsetY / b,
                f = this.GetWorldInfo();
            rcTex$jscomp$3.set(0, 0, f.GetWidth() / (c * this._imageScaleX), f.GetHeight() / (b * this._imageScaleY));
            rcTex$jscomp$3.offset(-d, -e);
            f.HasMesh() ? this._DrawMesh(f, a) : this._DrawStandard(f, a)
        }
    }
    _DrawStandard(a, b)
    {
        let c = a.GetBoundingQuad();
        this._runtime.IsPixelRoundingEnabled() &&
        (c = a.PixelRoundQuad(c));
        0 === this._imageAngle ? b.Quad3(c, rcTex$jscomp$3) : (qTex.setFromRotatedRect(rcTex$jscomp$3, -this._imageAngle), b.Quad4(c, qTex))
    }
    _DrawMesh(a, b)
    {
        const c = a.GetTransformedMesh();
        if (a.IsMeshChanged()) {
            a.CalculateBbox(tempRect$jscomp$13, tempQuad$jscomp$8, !1);
            let d = tempQuad$jscomp$8;
            this._runtime.IsPixelRoundingEnabled() && (d = a.PixelRoundQuad(d));
            let e = rcTex$jscomp$3;
            0 !== this._imageAngle && (qTex.setFromRotatedRect(rcTex$jscomp$3, -this._imageAngle), e = qTex);
            c.CalculateTransformedMesh(a.GetSourceMesh(),
            d, e);
            a.SetMeshChanged(!1)
        }
        c.Draw(b)
    }
    GetCurrentImageInfo()
    {
        return this._ownImageInfo || this._objectClass.GetImageInfo()
    }
    IsOriginalSizeKnown()
    {
        return !0
    }
    GetTexture()
    {
        return this.GetCurrentImageInfo().GetTexture()
    }
    _SetMeshChanged()
    {
        this.GetWorldInfo().SetMeshChanged(!0)
    }
    _SetImageOffsetX(a)
    {
        this._imageOffsetX !== a && (this._imageOffsetX = a, this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageOffsetX()
    {
        return this._imageOffsetX
    }
    _SetImageOffsetY(a)
    {
        this._imageOffsetY !== a && (this._imageOffsetY = a, this._runtime.UpdateRender(),
        this._SetMeshChanged())
    }
    _GetImageOffsetY()
    {
        return this._imageOffsetY
    }
    _SetImageScaleX(a)
    {
        this._imageScaleX !== a && (this._imageScaleX = a, this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageScaleX()
    {
        return this._imageScaleX
    }
    _SetImageScaleY(a)
    {
        this._imageScaleY !== a && (this._imageScaleY = a, this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageScaleY()
    {
        return this._imageScaleY
    }
    _SetImageAngle(a)
    {
        this._imageAngle !== a && (this._imageAngle = a, this._runtime.UpdateRender(), this._SetMeshChanged())
    }
    _GetImageAngle()
    {
        return this._imageAngle
    }
    _SetTileRandomizationEnabled(a)
    {
        a =
        !!a;
        this._enableTileRandomization !== a && (this._enableTileRandomization = a, this._runtime.UpdateRender())
    }
    _IsTileRandomizationEnabled()
    {
        return this._enableTileRandomization
    }
    _SetTileXRandom(a)
    {
        this._tileXRandom !== a && (this._tileXRandom = a, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileXRandom()
    {
        return this._tileXRandom
    }
    _SetTileYRandom(a)
    {
        this._tileYRandom !== a && (this._tileYRandom = a, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileYRandom()
    {
        return this._tileYRandom
    }
    _SetTileAngleRandom(a)
    {
        this._tileAngleRandom !==
        a && (this._tileAngleRandom = a, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileAngleRandom()
    {
        return this._tileAngleRandom
    }
    _SetTileBlendMarginX(a)
    {
        this._tileBlendMarginX !== a && (this._tileBlendMarginX = a, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileBlendMarginX()
    {
        return this._tileBlendMarginX
    }
    _SetTileBlendMarginY(a)
    {
        this._tileBlendMarginY !== a && (this._tileBlendMarginY = a, this._IsTileRandomizationEnabled() && this._runtime.UpdateRender())
    }
    _GetTileBlendMarginY()
    {
        return this._tileBlendMarginY
    }
    SaveToJson()
    {
        const a =
        {};
        0 !== this._imageOffsetX && (a.iox = this._imageOffsetX);
        0 !== this._imageOffsetY && (a.ioy = this._imageOffsetY);
        1 !== this._imageScaleX && (a.isx = this._imageScaleX);
        1 !== this._imageScaleY && (a.isy = this._imageScaleY);
        0 !== this._imageAngle && (a.ia = this._imageAngle);
        this._enableTileRandomization && (a.tr = !0);
        1 !== this._tileXRandom && (a.trx = this._tileXRandom);
        1 !== this._tileYRandom && (a["try"] = this._tileYRandom);
        1 !== this._tileAngleRandom && (a.tra = this._tileAngleRandom);
        .1 !== this._tileBlendMarginX && (a.trbmx = this._tileBlendMarginX);
        .1 !== this._tileBlendMarginY && (a.trbmy = this._tileBlendMarginY);
        return a
    }
    LoadFromJson(a)
    {
        this._imageOffsetX = a.iox || 0;
        this._imageOffsetY = a.ioy || 0;
        this._imageScaleX = a.hasOwnProperty("isx") ? a.isx : 1;
        this._imageScaleY = a.hasOwnProperty("isy") ? a.isy : 1;
        this._imageAngle = a.ia || 0;
        this._enableTileRandomization = !!a.tr;
        this._tileXRandom = a.hasOwnProperty("trx") ? a.trx : 1;
        this._tileYRandom = a.hasOwnProperty("try") ? a["try"] : 1;
        this._tileAngleRandom = a.hasOwnProperty("tra") ? a.tra : 1;
        this._tileBlendMarginX = a.hasOwnProperty("trbmx") ?
        a.trbmx : .1;
        this._tileBlendMarginY = a.hasOwnProperty("trbmy") ? a.trbmy : .1
    }
    GetDebuggerProperties()
    {
        return [{
            title: "plugins.tiledbg.properties.image-transform.name",
            properties: [{
                name: "plugins.tiledbg.properties.image-offset-x.name",
                value: this._GetImageOffsetX(),
                onedit: a => this._SetImageOffsetX(a)
            }, {
                name: "plugins.tiledbg.properties.image-offset-y.name",
                value: this._GetImageOffsetY(),
                onedit: a => this._SetImageOffsetY(a)
            }, {
                name: "plugins.tiledbg.properties.image-scale-x.name",
                value: 100 * this._GetImageScaleX(),
                onedit: a =>
                this._SetImageScaleX(a / 100)
            }, {
                name: "plugins.tiledbg.properties.image-scale-y.name",
                value: 100 * this._GetImageScaleY(),
                onedit: a => this._SetImageScaleY(a / 100)
            }, {
                name: "plugins.tiledbg.properties.image-angle.name",
                value: C3$jscomp$247.toDegrees(this._GetImageAngle()),
                onedit: a => this._SetImageAngle(C3$jscomp$247.toRadians(a))
            }]
        }, {
            title: "plugins.tiledbg.properties.tile-randomization.name",
            properties: [{
                name: "plugins.tiledbg.properties.enable-tile-randomization.name",
                value: this._IsTileRandomizationEnabled(),
                onedit: a =>
                this._SetTileRandomizationEnabled(a)
            }, {
                name: "plugins.tiledbg.properties.x-random.name",
                value: 100 * this._GetTileXRandom(),
                onedit: a => this._SetTileXRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.y-random.name",
                value: 100 * this._GetTileYRandom(),
                onedit: a => this._SetTileYRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.angle-random.name",
                value: 100 * this._GetTileAngleRandom(),
                onedit: a => this._SetTileAngleRandom(a / 100)
            }, {
                name: "plugins.tiledbg.properties.blend-margin-x.name",
                value: 100 * this._GetTileBlendMarginX(),
                onedit: a => this._SetTileBlendMarginX(a / 100)
            }, {
                name: "plugins.tiledbg.properties.blend-margin-y.name",
                value: 100 * this._GetTileBlendMarginY(),
                onedit: a => this._SetTileBlendMarginY(a / 100)
            }]
        }]
    }
    GetPropertyValueByIndex(a)
    {
        switch (a) {
        case 4:
            return this._GetImageOffsetX();
        case 5:
            return this._GetImageOffsetY();
        case 6:
            return this._GetImageScaleX();
        case 7:
            return this._GetImageScaleY();
        case 8:
            return this._GetImageAngle();
        case 9:
            return this._IsTileRandomizationEnabled();
        case 10:
            return this._GetTileXRandom();
        case 11:
            return this._GetTileYRandom();
        case 12:
            return this._GetTileAngleRandom();
        case 13:
            return this._GetTileBlendMarginX();
        case 14:
            return this._GetTileBlendMarginY()
        }
    }
    SetPropertyValueByIndex(a, b)
    {
        switch (a) {
        case 4:
            this._SetImageOffsetX(b);
            break;
        case 5:
            this._SetImageOffsetY(b);
            break;
        case 6:
            this._SetImageScaleX(b);
            break;
        case 7:
            this._SetImageScaleY(b);
            break;
        case 8:
            this._SetImageAngle(b);
            break;
        case 9:
            this._SetTileRandomizationEnabled(!!b);
            break;
        case 10:
            this._SetTileXRandom(b);
            break;
        case 11:
            this._SetTileYRandom(b);
            break;
        case 12:
            this._SetTileAngleRandom(b);
            break;
        case 13:
            this._SetTileBlendMarginX(b);
            break;
        case 14:
            this._SetTileBlendMarginY(b)
        }
    }
    GetScriptInterfaceClass()
    {
        return self.ITiledBackgroundInstance
    }
}
;
const map$jscomp$34 = new WeakMap;
self.ITiledBackgroundInstance = class  extends self.IWorldInstance{
    constructor()
    {
        super();
        map$jscomp$34.set(this, self.IInstance._GetInitInst().GetSdkInstance())
    }
    set imageOffsetX(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetImageOffsetX(a)
    }
    get imageOffsetX()
    {
        return map$jscomp$34.get(this)._GetImageOffsetX()
    }
    set imageOffsetY(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetImageOffsetY(a)
    }
    get imageOffsetY()
    {
        return map$jscomp$34.get(this)._GetImageOffsetY()
    }
    setImageOffset(a,
    b)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        C3X$jscomp$42.RequireFiniteNumber(b);
        const c = map$jscomp$34.get(this);
        c._SetImageOffsetX(a);
        c._SetImageOffsetY(b)
    }
    getImageOffset()
    {
        const a = map$jscomp$34.get(this);
        return [a._GetImageOffsetX(), a._GetImageOffsetY()]
    }
    set imageScaleX(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetImageScaleX(a)
    }
    get imageScaleX()
    {
        return map$jscomp$34.get(this)._GetImageScaleX()
    }
    set imageScaleY(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetImageScaleY(a)
    }
    get imageScaleY()
    {
        return map$jscomp$34.get(this)._GetImageScaleY()
    }
    setImageScale(a,
    b)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        C3X$jscomp$42.RequireFiniteNumber(b);
        const c = map$jscomp$34.get(this);
        c._SetImageScaleX(a);
        c._SetImageScaleY(b)
    }
    getImageScale()
    {
        const a = map$jscomp$34.get(this);
        return [a._GetImageScaleX(), a._GetImageScaleY()]
    }
    set imageAngle(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetImageAngle(a)
    }
    get imageAngle()
    {
        return map$jscomp$34.get(this)._GetImageAngle()
    }
    set imageAngleDegrees(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetImageAngle(C3$jscomp$247.toRadians(a))
    }
    get imageAngleDegrees()
    {
        return C3$jscomp$247.toDegrees(map$jscomp$34.get(this)._GetImageAngle())
    }
    get imageWidth()
    {
        return map$jscomp$34.get(this).GetCurrentImageInfo().GetWidth()
    }
    get imageHeight()
    {
        return map$jscomp$34.get(this).GetCurrentImageInfo().GetHeight()
    }
    getImageSize()
    {
        const a =
        map$jscomp$34.get(this).GetCurrentImageInfo();
        return [a.GetWidth(), a.GetHeight()]
    }
    set enableTileRandomization(a)
    {
        map$jscomp$34.get(this)._SetTileRandomizationEnabled(!!a)
    }
    get enableTileRandomization()
    {
        return map$jscomp$34.get(this)._IsTileRandomizationEnabled()
    }
    set tileXRandom(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetTileXRandom(a)
    }
    get tileXRandom()
    {
        return map$jscomp$34.get(this)._GetTileXRandom()
    }
    set tileYRandom(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetTileYRandom(a)
    }
    get tileYRandom()
    {
        return map$jscomp$34.get(this)._GetTileYRandom()
    }
    setTileRandom(a,
    b)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        C3X$jscomp$42.RequireFiniteNumber(b);
        const c = map$jscomp$34.get(this);
        c._SetTileXRandom(a);
        c._SetTileYRandom(b)
    }
    getTileRandom()
    {
        const a = map$jscomp$34.get(this);
        return [a._GetTileXRandom(), a._GetTileYRandom()]
    }
    set tileAngleRandom(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetTileAngleRandom(a)
    }
    get tileAngleRandom()
    {
        return map$jscomp$34.get(this)._GetTileAngleRandom()
    }
    set tileBlendMarginX(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetTileBlendMarginX(a)
    }
    get tileBlendMarginX()
    {
        return map$jscomp$34.get(this)._GetTileBlendMarginX()
    }
    set tileBlendMarginY(a)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        map$jscomp$34.get(this)._SetTileBlendMarginY(a)
    }
    get tileBlendMarginY()
    {
        return map$jscomp$34.get(this)._GetTileBlendMarginY()
    }
    setTileBlendMargin(a, b)
    {
        C3X$jscomp$42.RequireFiniteNumber(a);
        C3X$jscomp$42.RequireFiniteNumber(b);
        const c = map$jscomp$34.get(this);
        c._SetTileBlendMarginX(a);
        c._SetTileBlendMarginY(b)
    }
    getTileBlendMargin()
    {
        const a = map$jscomp$34.get(this);
        return [a._GetTileBlendMarginX(), a._GetTileBlendMarginY()]
    }
    async replaceImage(a)
    {
        C3X$jscomp$42.RequireInstanceOf(a, Blob);
        const b = map$jscomp$34.get(this),
            c = b.GetRuntime(),
            d = C3$jscomp$247.New(C3$jscomp$247.ImageInfo);
        d.LoadDynamicBlobAsset(c, a);
        await d.LoadStaticTexture(c.GetRenderer(), {
            sampling: c.GetSampling(),
            wrapX: "repeat",
            wrapY: "repeat"
        });
        b.WasReleased() ? d.Release() : (b._ReleaseOwnImage(), b._ownImageInfo = d, c.UpdateRender())
    }
}
;
self.C3.Plugins.TiledBg.Cnds = {
    OnURLLoaded() {
        return !0
    },
    OnURLFailed() {
        return !0
    },
    IsTileRandomizationEnabled() {
        return this._IsTileRandomizationEnabled()
    }
};
const C3$jscomp$249 = self.C3;
C3$jscomp$249.Plugins.TiledBg.Acts = {
    SetImageOffsetX(a) {
        this._SetImageOffsetX(a)
    },
    SetImageOffsetY(a) {
        this._SetImageOffsetY(a)
    },
    SetImageScaleX(a) {
        this._SetImageScaleX(a / 100)
    },
    SetImageScaleY(a) {
        this._SetImageScaleY(a / 100)
    },
    SetImageAngle(a) {
        this._SetImageAngle(C3$jscomp$249.toRadians(a))
    },
    SetTileRandomizationEnabled(a) {
        this._SetTileRandomizationEnabled(a)
    },
    SetTilePosRandom(a, b) {
        this._SetTileXRandom(a / 100);
        this._SetTileYRandom(b / 100)
    },
    SetTileAngleRandom(a) {
        this._SetTileAngleRandom(a / 100)
    },
    SetTileBlendMargin(a,
    b) {
        this._SetTileBlendMarginX(a / 100);
        this._SetTileBlendMarginY(b / 100)
    },
    SetEffect(a) {
        this.GetWorldInfo().SetBlendMode(a);
        this._runtime.UpdateRender()
    },
    async LoadURL(a, b) {
        if (!this._ownImageInfo || this._ownImageInfo.GetURL() !== a) {
            b = this._runtime;
            var c = C3$jscomp$249.New(C3$jscomp$249.ImageInfo);
            try {
                await c.LoadDynamicAsset(b, a);
                if (!c.IsLoaded())
                    throw Error("image failed to load");
                if (this.WasReleased())
                    return c.Release(), null;
                if (!await c.LoadStaticTexture(b.GetRenderer(), {
                    sampling: b.GetSampling(),
                    wrapX: "repeat",
                    wrapY: "repeat"
                }))
                    return
            } catch (d) {
                console.error("Load image from URL failed: ", d);
                this.WasReleased() || this.Trigger(C3$jscomp$249.Plugins.TiledBg.Cnds.OnURLFailed);
                return
            }
            this.WasReleased() ? c.Release() : (this._ReleaseOwnImage(), this._ownImageInfo = c, b.UpdateRender(), await this.TriggerAsync(C3$jscomp$249.Plugins.TiledBg.Cnds.OnURLLoaded))
        }
    }
};
const C3$jscomp$250 = self.C3;
C3$jscomp$250.Plugins.TiledBg.Exps = {
    ImageWidth() {
        return this.GetCurrentImageInfo().GetWidth()
    },
    ImageHeight() {
        return this.GetCurrentImageInfo().GetHeight()
    },
    ImageOffsetX() {
        return this._imageOffsetX
    },
    ImageOffsetY() {
        return this._imageOffsetY
    },
    ImageScaleX() {
        return 100 * this._imageScaleX
    },
    ImageScaleY() {
        return 100 * this._imageScaleY
    },
    ImageAngle() {
        return C3$jscomp$250.toDegrees(this._imageAngle)
    },
    TileXRandom() {
        return 100 * this._GetTileXRandom()
    },
    TileYRandom() {
        return 100 * this._GetTileYRandom()
    },
    TileAngleRandom() {
        return 100 *
        this._GetTileAngleRandom()
    },
    TileBlendMarginX() {
        return 100 * this._GetTileBlendMarginX()
    },
    TileBlendMarginY() {
        return 100 * this._GetTileBlendMarginY()
    }
};
"use strict";
const C3$jscomp$251 = self.C3;
C3$jscomp$251.Plugins.Arr = class  extends C3$jscomp$251.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$252 = self.C3;
C3$jscomp$252.Plugins.Arr.Type = class  extends C3$jscomp$252.SDKTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$253 = self.C3,
    C3X$jscomp$43 = self.C3X,
    IInstance$jscomp$3 = self.IInstance;
function ResizeArray(a, b, c) {
    if (b < a.length)
        C3$jscomp$253.truncateArray(a, b);
    else if (b > a.length)
        if ("function" === typeof c)
            for (var d = a.length; d < b; ++d)
                a.push(c());
        else
            for (d = a.length; d < b; ++d)
                a.push(c)
}
C3$jscomp$253.Plugins.Arr.Instance = class  extends C3$jscomp$253.SDKInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._cx = 10;
        this._cz = this._cy = 1;
        this._arr = null;
        this._forX = [];
        this._forY = [];
        this._forZ = [];
        this._forDepth = -1;
        b && (this._cx = b[0], this._cy = b[1], this._cz = b[2]);
        this._arr = C3$jscomp$253.MakeFilledArray(this._cx, () => C3$jscomp$253.MakeFilledArray(this._cy, () => C3$jscomp$253.MakeFilledArray(this._cz, 0)))
    }
    Release()
    {
        this._arr = null;
        super.Release()
    }
    At(a, b, c)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        return 0 <=
        a && a < this._cx && 0 <= b && b < this._cy && 0 <= c && c < this._cz ? this._arr[a][b][c] : 0
    }
    Set(a, b, c, d)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        0 <= a && a < this._cx && 0 <= b && b < this._cy && 0 <= c && c < this._cz && (this._arr[a][b][c] = d)
    }
    SetSize(a, b, c)
    {
        a = Math.floor(a);
        b = Math.floor(b);
        c = Math.floor(c);
        0 > a && (a = 0);
        0 > b && (b = 0);
        0 > c && (c = 0);
        if (this._cx !== a || this._cy !== b || this._cz !== c) {
            this._cx = a;
            this._cy = b;
            this._cz = c;
            var d = this._arr;
            ResizeArray(d, a, () => C3$jscomp$253.MakeFilledArray(b, () => C3$jscomp$253.MakeFilledArray(c, 0)));
            for (let e =
            0; e < a; ++e) {
                ResizeArray(d[e], b, () => C3$jscomp$253.MakeFilledArray(c, 0));
                for (let f = 0; f < b; ++f)
                    ResizeArray(d[e][f], c, 0)
            }
        }
    }
    GetWidth()
    {
        return this._cx
    }
    GetHeight()
    {
        return this._cy
    }
    GetDepth()
    {
        return this._cz
    }
    _ShuffleHelper(a, b, c, d, e)
    {
        for (; 0 < b;) {
            const h = Math.floor(this._runtime.Random() * b);
            --b;
            if (0 === a) {
                var f = this.At(b, d, e),
                    g = this.At(h, d, e);
                this.Set(b, d, e, g);
                this.Set(h, d, e, f)
            } else
                1 === a ? (f = this.At(c, b, e), g = this.At(c, h, e), this.Set(c, b, e, g), this.Set(c, h, e, f)) : 2 === a && (f = this.At(c, d, b), g = this.At(c, d, h), this.Set(c,
                d, b, g), this.Set(c, d, h, f))
        }
    }
    GetDebuggerProperties()
    {
        const a = [{
                title: "plugins.arr.debugger.array-properties.title",
                properties: [{
                    name: "plugins.arr.properties.width.name",
                    value: this._cx,
                    onedit: c => this.SetSize(c, this._cy, this._cz)
                }, {
                    name: "plugins.arr.properties.height.name",
                    value: this._cy,
                    onedit: c => this.SetSize(this._cx, c, this._cz)
                }, {
                    name: "plugins.arr.properties.depth.name",
                    value: this._cz,
                    onedit: c => this.SetSize(this._cx, this._cy, c)
                }, {
                    name: "plugins.arr.properties.elements.name",
                    value: this._cx * this._cy *
                    this._cz
                }]
            }],
            b = [];
        if (1 === this._cy && 1 === this._cz)
            for (let c = 0; c < this._cx; ++c)
                b.push({
                    name: "$" + c,
                    value: this._arr[c][0][0],
                    onedit: d => this._arr[c][0][0] = d
                });
        else
            for (let c = 0; c < this._cx; ++c)
                b.push({
                    name: "$" + c,
                    value: this._arr[c].toString()
                });
        b.length && a.push({
            title: "plugins.arr.debugger.array-data.title",
            properties: b
        });
        return a
    }
    GetAsJsonString()
    {
        return JSON.stringify({
            c2array: !0,
            size: [this._cx, this._cy, this._cz],
            data: this._arr
        })
    }
    SaveToJson()
    {
        return {
            size: [this._cx, this._cy, this._cz],
            data: this._arr
        }
    }
    LoadFromJson(a)
    {
        const b =
        a.size;
        this._cx = b[0];
        this._cy = b[1];
        this._cz = b[2];
        this._arr = a.data
    }
    _GetForX()
    {
        return 0 <= this._forDepth && this._forDepth < this._forX.length ? this._forX[this._forDepth] : 0
    }
    _GetForY()
    {
        return 0 <= this._forDepth && this._forDepth < this._forY.length ? this._forY[this._forDepth] : 0
    }
    _GetForZ()
    {
        return 0 <= this._forDepth && this._forDepth < this._forZ.length ? this._forZ[this._forDepth] : 0
    }
    GetScriptInterfaceClass()
    {
        return self.IArrayInstance
    }
}
;
const map$jscomp$35 = new WeakMap;
self.IArrayInstance = class  extends IInstance$jscomp$3{
    constructor()
    {
        super();
        map$jscomp$35.set(this, IInstance$jscomp$3._GetInitInst().GetSdkInstance())
    }
    get width()
    {
        return map$jscomp$35.get(this).GetWidth()
    }
    get height()
    {
        return map$jscomp$35.get(this).GetHeight()
    }
    get depth()
    {
        return map$jscomp$35.get(this).GetDepth()
    }
    setSize(a, b=1, c=1)
    {
        C3X$jscomp$43.RequireFiniteNumber(a);
        C3X$jscomp$43.RequireFiniteNumber(b);
        C3X$jscomp$43.RequireFiniteNumber(c);
        map$jscomp$35.get(this).SetSize(a, b, c)
    }
    getAt(a, b=0, c=0)
    {
        C3X$jscomp$43.RequireFiniteNumber(a);
        C3X$jscomp$43.RequireFiniteNumber(b);
        C3X$jscomp$43.RequireFiniteNumber(c);
        return map$jscomp$35.get(this).At(a, b, c)
    }
    setAt(a, b, c=0, d=0)
    {
        C3X$jscomp$43.RequireFiniteNumber(b);
        C3X$jscomp$43.RequireFiniteNumber(c);
        C3X$jscomp$43.RequireFiniteNumber(d);
        if ("number" !== typeof a && "string" !== typeof a)
            throw new TypeError("invalid type");
        map$jscomp$35.get(this).Set(b, c, d, a)
    }
}
;
const C3$jscomp$254 = self.C3;
function DoForEachTrigger(a, b, c, d, e, f) {
    a.PushCopySol(c);
    f.GetObjectClass().GetCurrentSol().PickOne(f.GetInstance());
    b.Retrigger(d, e);
    a.PopSol(c)
}
C3$jscomp$254.Plugins.Arr.Cnds = {
    CompareX(a, b, c) {
        return C3$jscomp$254.compare(this.At(a, 0, 0), b, c)
    },
    CompareXY(a, b, c, d) {
        return C3$jscomp$254.compare(this.At(a, b, 0), c, d)
    },
    CompareXYZ(a, b, c, d, e) {
        return C3$jscomp$254.compare(this.At(a, b, c), d, e)
    },
    ArrForEach(a) {
        const b = this._runtime,
            c = b.GetEventSheetManager(),
            d = b.GetCurrentEvent(),
            e = d.GetSolModifiers(),
            f = b.GetEventStack(),
            g = f.GetCurrentStackFrame(),
            h = f.Push(d),
            k = ++this._forDepth,
            l = this._forX;
        var m = this._forY,
            n = this._forZ;
        const p = this._cx,
            q = this._cy;
        var r =
        this._cz;
        k === this._forX.length ? (l.push(0), m.push(0), n.push(0)) : (l[k] = 0, m[k] = 0, n[k] = 0);
        b.SetDebuggingEnabled(!1);
        if (0 === a)
            for (a = 0; a < p; ++a)
                for (let t = 0; t < q; ++t)
                    for (let u = 0; u < r; ++u)
                        l[k] = a,
                        m[k] = t,
                        n[k] = u,
                        DoForEachTrigger(c, d, e, g, h, this);
        else if (1 === a)
            for (n = 0; n < p; ++n)
                for (r = 0; r < q; ++r)
                    l[k] = n,
                    m[k] = r,
                    DoForEachTrigger(c, d, e, g, h, this);
        else
            for (m = 0; m < p; ++m)
                l[k] = m,
                DoForEachTrigger(c, d, e, g, h, this);
        b.SetDebuggingEnabled(!0);
        this._forDepth--;
        f.Pop();
        return !1
    },
    CompareCurrent(a, b) {
        return C3$jscomp$254.compare(this.At(this._GetForX(),
        this._GetForY(), this._GetForZ()), a, b)
    },
    Contains(a) {
        const b = this._cx,
            c = this._cy,
            d = this._cz,
            e = this._arr;
        for (let f = 0; f < b; ++f)
            for (let g = 0; g < c; ++g)
                for (let h = 0; h < d; ++h)
                    if (e[f][g][h] === a)
                        return !0;
        return !1
    },
    IsEmpty() {
        return 0 === this._cx || 0 === this._cy || 0 === this._cz
    },
    CompareSize(a, b, c) {
        let d = 0;
        switch (a) {
        case 0:
            d = this._cx;
            break;
        case 1:
            d = this._cy;
            break;
        case 2:
            d = this._cz
        }
        return C3$jscomp$254.compare(d, b, c)
    }
};
const C3$jscomp$255 = self.C3;
function CompareValues(a, b) {
    if ("number" === typeof a && "number" === typeof b)
        return a - b;
    a = a.toString();
    b = b.toString();
    return a < b ? -1 : a > b ? 1 : 0
}
C3$jscomp$255.Plugins.Arr.Acts = {
    Clear(a) {
        const b = this._cx,
            c = this._cy,
            d = this._cz,
            e = this._arr;
        for (let f = 0; f < b; ++f)
            for (let g = 0; g < c; ++g)
                for (let h = 0; h < d; ++h)
                    e[f][g][h] = a
    },
    SetSize(a, b, c) {
        this.SetSize(a, b, c)
    },
    SetX(a, b) {
        this.Set(a, 0, 0, b)
    },
    SetXY(a, b, c) {
        this.Set(a, b, 0, c)
    },
    SetXYZ(a, b, c, d) {
        this.Set(a, b, c, d)
    },
    Push(a, b, c) {
        var d = this._cx,
            e = this._cy;
        const f = this._cz,
            g = this._arr;
        if (0 === c)
            d = C3$jscomp$255.MakeFilledArray(e, () => C3$jscomp$255.MakeFilledArray(f, b)),
            0 === a ? g.push(d) : g.unshift(d),
            this._cx++;
        else if (1 === c) {
            for (e =
            0; e < d; ++e)
                c = C3$jscomp$255.MakeFilledArray(f, b),
                0 === a ? g[e].push(c) : g[e].unshift(c);
            this._cy++
        } else {
            for (c = 0; c < d; ++c)
                for (let h = 0; h < e; ++h)
                    0 === a ? g[c][h].push(b) : g[c][h].unshift(b);
            this._cz++
        }
    },
    Pop(a, b) {
        const c = this._cx;
        var d = this._cy,
            e = this._cz;
        const f = this._arr;
        if (0 === b)
            0 !== c && (0 === a ? f.pop() : f.shift(), this._cx--);
        else if (1 === b) {
            if (0 !== d) {
                for (d = 0; d < c; ++d)
                    0 === a ? f[d].pop() : f[d].shift();
                this._cy--
            }
        } else if (0 !== e) {
            for (b = 0; b < c; ++b)
                for (e = 0; e < d; ++e)
                    0 === a ? f[b][e].pop() : f[b][e].shift();
            this._cz--
        }
    },
    Reverse(a) {
        const b =
        this._cx;
        var c = this._cy,
            d = this._cz;
        const e = this._arr;
        if (0 !== b && 0 !== c && 0 !== d)
            if (0 === a)
                e.reverse();
            else if (1 === a)
                for (c = 0; c < b; ++c)
                    e[c].reverse();
            else
                for (a = 0; a < b; ++a)
                    for (d = 0; d < c; ++d)
                        e[a][d].reverse()
    },
    Sort(a) {
        const b = this._cx;
        var c = this._cy,
            d = this._cz;
        const e = this._arr;
        if (0 !== b && 0 !== c && 0 !== d)
            if (0 === a)
                e.sort((f, g) => CompareValues(f[0][0], g[0][0]));
            else if (1 === a)
                for (c = 0; c < b; ++c)
                    e[c].sort((f, g) => CompareValues(f[0], g[0]));
            else
                for (a = 0; a < b; ++a)
                    for (d = 0; d < c; ++d)
                        e[a][d].sort(CompareValues)
    },
    Shuffle(a) {
        const b =
            this._cx,
            c = this._cy,
            d = this._cz;
        if (0 !== b && 0 !== c && 0 !== d)
            if (0 === a)
                for (var e = 0; e < c; ++e)
                    for (var f = 0; f < d; ++f)
                        this._ShuffleHelper(a, b, 0, e, f);
            else if (1 === a)
                for (e = 0; e < b; ++e)
                    for (f = 0; f < d; ++f)
                        this._ShuffleHelper(a, c, e, 0, f);
            else
                for (e = 0; e < b; ++e)
                    for (f = 0; f < c; ++f)
                        this._ShuffleHelper(a, d, e, f, 0)
    },
    Delete(a, b) {
        a = Math.floor(a);
        if (!(0 > a)) {
            var c = this._cx,
                d = this._cy,
                e = this._cz,
                f = this._arr;
            if (0 === b)
                a >= c || (f.splice(a, 1), this._cx--);
            else if (1 === b) {
                if (!(a >= d)) {
                    for (d = 0; d < c; ++d)
                        f[d].splice(a, 1);
                    this._cy--
                }
            } else if (!(a >= e)) {
                for (b =
                0; b < c; ++b)
                    for (e = 0; e < d; ++e)
                        f[b][e].splice(a, 1);
                this._cz--
            }
        }
    },
    Insert(a, b, c) {
        b = Math.floor(b);
        if (!(0 > b)) {
            var d = this._cx,
                e = this._cy,
                f = this._cz,
                g = this._arr;
            if (0 === c)
                b > d || (g.splice(b, 0, C3$jscomp$255.MakeFilledArray(e, () => C3$jscomp$255.MakeFilledArray(f, a))), this._cx++);
            else if (1 === c) {
                if (!(b > e)) {
                    for (e = 0; e < d; ++e)
                        g[e].splice(b, 0, C3$jscomp$255.MakeFilledArray(f, a));
                    this._cy++
                }
            } else if (!(b > f)) {
                for (c = 0; c < d; ++c)
                    for (let h = 0; h < e; ++h)
                        g[c][h].splice(b, 0, a);
                this._cz++
            }
        }
    },
    SplitString(a, b, c) {
        a = a.split(b);
        this.SetSize(a.length,
        1, 1);
        for (let d = 0, e = a.length; d < e; ++d)
            b = a[d],
            0 === c ? String(Number(b)) === b && (b = Number(b)) : 2 === c && (b = Number(b)),
            this.Set(d, 0, 0, b)
    },
    JSONLoad(a) {
        let b = null;
        try {
            b = JSON.parse(a)
        } catch (c) {
            console.error("[Construct] Failed to parse JSON: ", c);
            return
        }
        b.c2array && (a = b.size, this._cx = a[0], this._cy = a[1], this._cz = a[2], this._arr = b.data)
    },
    JSONDownload(a) {
        const b = URL.createObjectURL(new Blob([this.GetAsJsonString()], {
            type: "application/json"
        }));
        this._runtime.InvokeDownload(b, a)
    }
};
self.C3.Plugins.Arr.Exps = {
    At(a, b, c) {
        return this.At(a, b || 0, c || 0)
    },
    Width() {
        return this._cx
    },
    Height() {
        return this._cy
    },
    Depth() {
        return this._cz
    },
    CurX() {
        return this._GetForX()
    },
    CurY() {
        return this._GetForY()
    },
    CurZ() {
        return this._GetForZ()
    },
    CurValue() {
        return this.At(this._GetForX(), this._GetForY(), this._GetForZ())
    },
    Front() {
        return this.At(0, 0, 0)
    },
    Back() {
        return this.At(this._cx - 1, 0, 0)
    },
    IndexOf(a) {
        const b = this._arr;
        for (let c = 0, d = this._cx; c < d; ++c)
            if (b[c][0][0] === a)
                return c;
        return -1
    },
    LastIndexOf(a) {
        const b = this._arr;
        for (let c = this._cx - 1; 0 <= c; --c)
            if (b[c][0][0] === a)
                return c;
        return -1
    },
    JoinString(a) {
        let b = [];
        for (let c = 0; c < this._cx; ++c)
            b.push(this.At(c, 0, 0));
        return b.join(a)
    },
    AsJSON() {
        return this.GetAsJsonString()
    }
};
"use strict";
const C3$jscomp$257 = self.C3;
C3$jscomp$257.Plugins.Keyboard = class  extends C3$jscomp$257.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$258 = self.C3;
C3$jscomp$258.Plugins.Keyboard.Type = class  extends C3$jscomp$258.SDKTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
    GetScriptInterfaceClass()
    {
        return self.IKeyboardObjectType
    }
}
;
let keyboardObjectType = null;
function GetKeyboardSdkInstance() {
    return keyboardObjectType.GetSingleGlobalInstance().GetSdkInstance()
}
self.IKeyboardObjectType = class  extends self.IObjectClass{
    constructor(a)
    {
        super(a);
        keyboardObjectType = a;
        a.GetRuntime()._GetCommonScriptInterfaces().keyboard = this
    }
    isKeyDown(a)
    {
        const b = GetKeyboardSdkInstance();
        if ("string" === typeof a)
            return b.IsKeyDown(a);
        if ("number" === typeof a)
            return b.IsKeyCodeDown(a);
        throw new TypeError("expected string or number");
    }
}
;
const C3$jscomp$259 = self.C3;
C3$jscomp$259.Plugins.Keyboard.Instance = class  extends C3$jscomp$259.SDKInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._keysDownByString = new Set;
        this._keysDownByWhich = new Set;
        this._triggerWhich = 0;
        this._triggerTypedKey = this._triggerString = "";
        a = this.GetRuntime().Dispatcher();
        this._disposables = new C3$jscomp$259.CompositeDisposable(C3$jscomp$259.Disposable.From(a, "keydown", c => this._OnKeyDown(c.data)), C3$jscomp$259.Disposable.From(a, "keyup", c => this._OnKeyUp(c.data)), C3$jscomp$259.Disposable.From(a, "window-blur",
        () => this._OnWindowOrKeyboardBlur()), C3$jscomp$259.Disposable.From(a, "keyboard-blur", () => this._OnWindowOrKeyboardBlur()))
    }
    Release()
    {
        super.Release()
    }
    _OnKeyDown(a)
    {
        const b = a.which,
            c = a.code || b.toString();
        a = a.key;
        this._keysDownByString.has(c) || (this._keysDownByString.add(c), this._keysDownByWhich.add(b), this._triggerString = c, this._triggerWhich = b, this._triggerTypedKey = a, this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnAnyKey), this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnKey), this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnLeftRightKeyPressed),
        this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnKeyCode))
    }
    _OnKeyUp(a)
    {
        const b = a.which,
            c = a.code || b.toString();
        a = a.key;
        this._keysDownByString.delete(c);
        this._keysDownByWhich.delete(b);
        this._triggerString = c;
        this._triggerWhich = b;
        this._triggerTypedKey = a;
        this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnAnyKeyReleased);
        this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnKeyReleased);
        this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnLeftRightKeyReleased);
        this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnKeyCodeReleased)
    }
    _OnWindowOrKeyboardBlur()
    {
        for (const a of this._keysDownByWhich)
            this._keysDownByWhich.delete(a),
            this._triggerWhich = a,
            this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnAnyKeyReleased),
            this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnKeyReleased),
            this.Trigger(C3$jscomp$259.Plugins.Keyboard.Cnds.OnKeyCodeReleased);
        this._keysDownByString.clear()
    }
    IsKeyDown(a)
    {
        return this._keysDownByString.has(a)
    }
    IsKeyCodeDown(a)
    {
        return this._keysDownByWhich.has(a)
    }
    SaveToJson()
    {
        return {
            tk: this._triggerWhich,
            tkk: this._triggerTypedKey
        }
    }
    LoadFromJson(a)
    {
        this._triggerWhich = a.tk;
        a.hasOwnProperty("tkk") && (this._triggerTypedKey =
        a.tkk)
    }
    GetDebuggerProperties()
    {
        return [{
            title: "plugins.keyboard.name",
            properties: [{
                name: "plugins.keyboard.debugger.last-key-code",
                value: this._triggerWhich
            }, {
                name: "plugins.keyboard.debugger.last-key-string",
                value: C3$jscomp$259.Plugins.Keyboard.Exps.StringFromKeyCode(this._triggerWhich)
            }, {
                name: "plugins.keyboard.debugger.last-typed-key",
                value: this._triggerTypedKey
            }]
        }]
    }
}
;
const LEFTRIGHT_KEY_STRINGS = "ShiftLeft ShiftRight ControlLeft ControlRight AltLeft AltRight MetaLeft MetaRight".split(" ");
self.C3.Plugins.Keyboard.Cnds = {
    IsKeyDown(a) {
        return this._keysDownByWhich.has(a)
    },
    OnKey(a) {
        return this._triggerWhich === a
    },
    OnAnyKey() {
        return !0
    },
    OnAnyKeyReleased() {
        return !0
    },
    OnKeyReleased(a) {
        return this._triggerWhich === a
    },
    IsKeyCodeDown(a) {
        a = Math.floor(a);
        return this._keysDownByWhich.has(a)
    },
    OnKeyCode(a) {
        return this._triggerWhich === a
    },
    OnKeyCodeReleased(a) {
        return this._triggerWhich === a
    },
    OnLeftRightKeyPressed(a) {
        return this._triggerString === LEFTRIGHT_KEY_STRINGS[a]
    },
    OnLeftRightKeyReleased(a) {
        return this._triggerString ===
        LEFTRIGHT_KEY_STRINGS[a]
    },
    IsLeftRightKeyDown(a) {
        return this._keysDownByString.has(LEFTRIGHT_KEY_STRINGS[a])
    }
};
self.C3.Plugins.Keyboard.Acts = {};
function StringFromCharCode(a) {
    a = Math.floor(a);
    switch (a) {
    case 8:
        return "backspace";
    case 9:
        return "tab";
    case 13:
        return "enter";
    case 16:
        return "shift";
    case 17:
        return "control";
    case 18:
        return "alt";
    case 19:
        return "pause";
    case 20:
        return "capslock";
    case 27:
        return "esc";
    case 33:
        return "pageup";
    case 34:
        return "pagedown";
    case 35:
        return "end";
    case 36:
        return "home";
    case 37:
        return "\u2190";
    case 38:
        return "\u2191";
    case 39:
        return "\u2192";
    case 40:
        return "\u2193";
    case 45:
        return "insert";
    case 46:
        return "del";
    case 91:
        return "left window key";
    case 92:
        return "right window key";
    case 93:
        return "select";
    case 96:
        return "numpad 0";
    case 97:
        return "numpad 1";
    case 98:
        return "numpad 2";
    case 99:
        return "numpad 3";
    case 100:
        return "numpad 4";
    case 101:
        return "numpad 5";
    case 102:
        return "numpad 6";
    case 103:
        return "numpad 7";
    case 104:
        return "numpad 8";
    case 105:
        return "numpad 9";
    case 106:
        return "numpad *";
    case 107:
        return "numpad +";
    case 109:
        return "numpad -";
    case 110:
        return "numpad .";
    case 111:
        return "numpad /";
    case 112:
        return "F1";
    case 113:
        return "F2";
    case 114:
        return "F3";
    case 115:
        return "F4";
    case 116:
        return "F5";
    case 117:
        return "F6";
    case 118:
        return "F7";
    case 119:
        return "F8";
    case 120:
        return "F9";
    case 121:
        return "F10";
    case 122:
        return "F11";
    case 123:
        return "F12";
    case 144:
        return "numlock";
    case 145:
        return "scroll lock";
    case 186:
        return ";";
    case 187:
        return "=";
    case 188:
        return ",";
    case 189:
        return "-";
    case 190:
        return ".";
    case 191:
        return "/";
    case 192:
        return "'";
    case 219:
        return "[";
    case 220:
        return "\\";
    case 221:
        return "]";
    case 222:
        return "#";
    case 223:
        return "`";
    default:
        return String.fromCharCode(a)
    }
}
self.C3.Plugins.Keyboard.Exps = {
    LastKeyCode() {
        return this._triggerWhich
    },
    StringFromKeyCode(a) {
        return StringFromCharCode(a)
    },
    TypedKey() {
        return this._triggerTypedKey
    }
};
"use strict";
const C3$jscomp$263 = self.C3;
C3$jscomp$263.Plugins.LocalStorage = class  extends C3$jscomp$263.SDKPluginBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$264 = self.C3;
C3$jscomp$264.Plugins.LocalStorage.Type = class  extends C3$jscomp$264.SDKTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$265 = self.C3;
C3$jscomp$265.Plugins.LocalStorage.Instance = class  extends C3$jscomp$265.SDKInstanceBase{
    constructor(a, b)
    {
        super(a, "localstorage");
        this._lastValue = this._currentKey = "";
        this._keyNamesList = [];
        this._errorMessage = "";
        this._isPersistent = !1;
        this._pendingSets = this._pendingGets = 0;
        this._storage = this._runtime._GetProjectStorage();
        this._debugCache = new Map;
        this._isLoadingDebugCache = !1;
        this._runtime.AddLoadPromise(this._Init())
    }
    async _Init()
    {
        const a = await Promise.race([this.PostToDOMAsync("init"), C3$jscomp$265.Wait(3E3)]);
        a && (this._isPersistent = a.isPersistent)
    }
    Release()
    {
        super.Release()
    }
    async _TriggerStorageError(a)
    {
        this._errorMessage = this._GetErrorString(a);
        await this.TriggerAsync(C3$jscomp$265.Plugins.LocalStorage.Cnds.OnError)
    }
    _GetErrorString(a)
    {
        return a ? "string" === typeof a ? a : "string" === typeof a.message ? a.message : "string" === typeof a.name ? a.name : "string" === typeof a.data ? a.data : "unknown error" : "unknown error"
    }
    GetDebuggerProperties()
    {
        this._isLoadingDebugCache || this._DebugCacheStorage();
        return [{
            title: "plugins.localstorage.name",
            properties: [...this._debugCache.entries()].map(a => ({
                name: "$" + a[0],
                value: a[1],
                onedit: b => this._storage.setItem(a[0], b)
            }))
        }]
    }
    async _DebugCacheStorage()
    {
        this._isLoadingDebugCache = !0;
        try {
            const a = await this._storage.keys();
            a.sort((c, d) => {
                c = c.toLowerCase();
                d = d.toLowerCase();
                return c < d ? -1 : d < c ? 1 : 0
            });
            const b = await Promise.all(a.map(c => this._storage.getItem(c)));
            this._debugCache.clear();
            for (let c = 0, d = a.length; c < d; ++c)
                this._debugCache.set(a[c], b[c])
        } catch (a) {
            console.warn("[C3 debugger] Error displaying local storage: ",
            a)
        } finally {
            this._isLoadingDebugCache = !1
        }
    }
}
;
const C3$jscomp$266 = self.C3;
C3$jscomp$266.Plugins.LocalStorage.Cnds = {
    OnItemSet(a) {
        return this._currentKey === a
    },
    OnAnyItemSet() {
        return !0
    },
    OnItemGet(a) {
        return this._currentKey === a
    },
    OnAnyItemGet() {
        return !0
    },
    OnItemRemoved(a) {
        return this._currentKey === a
    },
    OnAnyItemRemoved() {
        return !0
    },
    OnCleared() {
        return !0
    },
    OnAllKeyNamesLoaded() {
        return !0
    },
    OnError() {
        return !0
    },
    OnItemExists(a) {
        return this._currentKey === a
    },
    OnItemMissing(a) {
        return this._currentKey === a
    },
    CompareKey(a, b) {
        return C3$jscomp$266.compare(this._currentKey, a, b)
    },
    CompareValue(a, b) {
        return C3$jscomp$266.compare(this._lastValue,
        a, b)
    },
    IsProcessingSets() {
        return 0 < this._pendingSets
    },
    IsProcessingGets() {
        return 0 < this._pendingGets
    },
    OnAllSetsComplete() {
        return !0
    },
    OnAllGetsComplete() {
        return !0
    },
    IsPersistent() {
        return this._isPersistent
    }
};
const C3$jscomp$267 = self.C3;
function IsExpressionType(a) {
    return "string" === typeof a || "number" === typeof a
}
C3$jscomp$267.Plugins.LocalStorage.Acts = {
    async SetItem(a, b) {
        this._pendingSets++;
        try {
            const c = await this._storage.setItem(a, b);
            await this.ScheduleTriggers(async () => {
                this._currentKey = a;
                this._lastValue = c;
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAnyItemSet);
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnItemSet)
            })
        } catch (c) {
            await this._TriggerStorageError(c)
        } finally {
            this._pendingSets--,
            0 === this._pendingSets && await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAllSetsComplete)
        }
    },
    async SetBinaryItem(a, b) {
        if (b && (b = b.GetFirstPicked(this._inst)) && (b = b.GetSdkInstance())) {
            b = b.GetArrayBufferReadOnly();
            this._pendingSets++;
            try {
                await this._storage.setItem(a, b),
                await this.ScheduleTriggers(async () => {
                    this._currentKey = a;
                    this._lastValue = "";
                    await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAnyItemSet);
                    await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnItemSet)
                })
            } catch (c) {
                await this._TriggerStorageError(c)
            } finally {
                this._pendingSets--,
                0 === this._pendingSets &&
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAllSetsComplete)
            }
        }
    },
    async GetItem(a) {
        this._pendingGets++;
        try {
            const b = await this._storage.getItem(a);
            await this.ScheduleTriggers(async () => {
                this._currentKey = a;
                this._lastValue = IsExpressionType(b) ? b : "";
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAnyItemGet);
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnItemGet)
            })
        } catch (b) {
            await this._TriggerStorageError(b)
        } finally {
            this._pendingGets--,
            0 === this._pendingGets &&
            await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAllGetsComplete)
        }
    },
    async GetBinaryItem(a, b) {
        if (b && (b = b.GetFirstPicked(this._inst))) {
            var c = b.GetSdkInstance();
            this._pendingGets++;
            try {
                let d = await this._storage.getItem(a);
                d = d instanceof ArrayBuffer ? d : new ArrayBuffer(0);
                await this.ScheduleTriggers(async () => {
                    this._lastValue = "";
                    this._currentKey = a;
                    c.SetArrayBufferTransfer(d);
                    await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAnyItemGet);
                    await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnItemGet)
                })
            } catch (d) {
                await this._TriggerStorageError(d)
            } finally {
                this._pendingGets--,
                0 === this._pendingGets && await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAllGetsComplete)
            }
        }
    },
    async CheckItemExists(a) {
        try {
            const b = await this._storage.getItem(a);
            await this.ScheduleTriggers(async () => {
                this._currentKey = a;
                "undefined" === typeof b || null === b ? (this._lastValue = "", await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnItemMissing)) : (this._lastValue = IsExpressionType(b) ? b : "", await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnItemExists))
            })
        } catch (b) {
            await this._TriggerStorageError(b)
        }
    },
    async RemoveItem(a) {
        try {
            await this._storage.removeItem(a),
            await this.ScheduleTriggers(async () => {
                this._currentKey = a;
                this._lastValue = "";
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAnyItemRemoved);
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnItemRemoved)
            })
        } catch (b) {
            await this._TriggerStorageError(b)
        }
    },
    async ClearStorage() {
        try {
            await this._storage.clear(),
            await this.ScheduleTriggers(async () => {
                this._lastValue = this._currentKey = "";
                C3$jscomp$267.clearArray(this._keyNamesList);
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnCleared)
            })
        } catch (a) {
            await this._TriggerStorageError(a)
        }
    },
    async GetAllKeyNames() {
        try {
            const a = await this._storage.keys();
            await this.ScheduleTriggers(async () => {
                this._keyNamesList = a;
                await this.TriggerAsync(C3$jscomp$267.Plugins.LocalStorage.Cnds.OnAllKeyNamesLoaded)
            })
        } catch (a) {
            await this._TriggerStorageError(a)
        }
    },
    async RequestPersistent() {
        const a = await this.PostToDOMAsync("request-persistent");
        a.isOk && (this._isPersistent = a.isPersistent)
    }
};
self.C3.Plugins.LocalStorage.Exps = {
    ItemValue() {
        return this._lastValue
    },
    Key() {
        return this._currentKey
    },
    KeyCount() {
        return this._keyNamesList.length
    },
    KeyAt(a) {
        a = Math.floor(a);
        return 0 > a || a >= this._keyNamesList.length ? "" : this._keyNamesList[a]
    },
    ErrorMessage() {
        return this._errorMessage
    }
};
"use strict";
const C3$jscomp$269 = self.C3;
C3$jscomp$269.Behaviors.Fade = class  extends C3$jscomp$269.SDKBehaviorBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$270 = self.C3;
C3$jscomp$270.Behaviors.Fade.Type = class  extends C3$jscomp$270.SDKBehaviorTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$271 = self.C3,
    C3X$jscomp$45 = self.C3X,
    IBehaviorInstance$jscomp$2 = self.IBehaviorInstance;
C3$jscomp$271.Behaviors.Fade.Instance = class  extends C3$jscomp$271.SDKBehaviorInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._fadeOutTime = this._waitTime = this._fadeInTime = 0;
        this._activeAtStart = this._destroy = !0;
        this._setMaxOpacity = !1;
        this._stage = 0;
        this._stageTime = C3$jscomp$271.New(C3$jscomp$271.KahanSum);
        this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1;
        b && (this._fadeInTime = b[0], this._waitTime = b[1], this._fadeOutTime = b[2], this._destroy = !!b[3], this._stage = (this._activeAtStart = !!b[4]) ? 0 : 3);
        this._activeAtStart &&
        (0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender()));
        this._StartTicking()
    }
    Release()
    {
        super.Release()
    }
    SaveToJson()
    {
        return {
            fit: this._fadeInTime,
            wt: this._waitTime,
            fot: this._fadeOutTime,
            d: this._destroy,
            s: this._stage,
            st: this._stageTime.Get(),
            mo: this._maxOpacity
        }
    }
    LoadFromJson(a)
    {
        this._fadeInTime = a.fit;
        this._waitTime = a.wt;
        this._fadeOutTime = a.fot;
        this._destroy = a.d;
        this._stage = a.s;
        this._stageTime.Set(a.st);
        this._maxOpacity =
        a.mo;
        3 === this._stage ? this._StopTicking() : this._StartTicking()
    }
    Tick()
    {
        var a = this._runtime.GetDt(this._inst);
        this._stageTime.Add(a);
        a = this._inst.GetWorldInfo();
        0 === this._stage && (a.SetOpacity(this._stageTime.Get() / this._fadeInTime * this._maxOpacity), this._runtime.UpdateRender(), a.GetOpacity() >= this._maxOpacity && (a.SetOpacity(this._maxOpacity), this._stage = 1, this._stageTime.Reset(), this.DispatchScriptEvent("fadeinend"), this.Trigger(C3$jscomp$271.Behaviors.Fade.Cnds.OnFadeInEnd)));
        1 === this._stage && this._stageTime.Get() >=
        this._waitTime && (this._stage = 2, this._stageTime.Reset(), this.DispatchScriptEvent("waitend"), this.Trigger(C3$jscomp$271.Behaviors.Fade.Cnds.OnWaitEnd));
        2 === this._stage && (0 !== this._fadeOutTime ? (a.SetOpacity(this._maxOpacity - this._stageTime.Get() / this._fadeOutTime * this._maxOpacity), this._runtime.UpdateRender(), 0 >= a.GetOpacity() && (this._stage = 3, this._stageTime.Reset(), this.DispatchScriptEvent("fadeoutend"), this.Trigger(C3$jscomp$271.Behaviors.Fade.Cnds.OnFadeOutEnd), this._destroy && this._runtime.DestroyInstance(this._inst))) :
        (this._stage = 3, this._stageTime.Reset()));
        3 === this._stage && this._StopTicking()
    }
    _StartFade()
    {
        this._activeAtStart || this._setMaxOpacity || (this._maxOpacity = this._inst.GetWorldInfo().GetOpacity() || 1, this._setMaxOpacity = !0);
        3 === this._stage && this.Start()
    }
    _RestartFade()
    {
        this.Start()
    }
    Start()
    {
        this._stage = 0;
        this._stageTime.Reset();
        0 === this._fadeInTime ? (this._stage = 1, 0 === this._waitTime && (this._stage = 2)) : (this._inst.GetWorldInfo().SetOpacity(0), this._runtime.UpdateRender());
        this._StartTicking()
    }
    _SetFadeInTime(a)
    {
        this._fadeInTime =
        Math.max(a, 0)
    }
    _GetFadeInTime()
    {
        return this._fadeInTime
    }
    _SetWaitTime(a)
    {
        this._waitTime = Math.max(a, 0)
    }
    _GetWaitTime()
    {
        return this._waitTime
    }
    _SetFadeOutTime(a)
    {
        this._fadeOutTime = Math.max(a, 0)
    }
    _GetFadeOutTime()
    {
        return this._fadeOutTime
    }
    GetPropertyValueByIndex(a)
    {
        switch (a) {
        case 0:
            return this._GetFadeInTime();
        case 1:
            return this._GetWaitTime();
        case 2:
            return this._GetFadeOutTime();
        case 3:
            return this._destroy
        }
    }
    SetPropertyValueByIndex(a, b)
    {
        switch (a) {
        case 0:
            this._SetFadeInTime(b);
            break;
        case 1:
            this._SetWaitTime(b);
            break;
        case 2:
            this._SetFadeOutTime(b);
            break;
        case 3:
            this._destroy = !!b
        }
    }
    GetDebuggerProperties()
    {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.fade.properties.fade-in-time.name",
                value: this._GetFadeInTime(),
                onedit: a => this._SetFadeInTime(a)
            }, {
                name: "behaviors.fade.properties.wait-time.name",
                value: this._GetWaitTime(),
                onedit: a => this._SetWaitTime(a)
            }, {
                name: "behaviors.fade.properties.fade-out-time.name",
                value: this._GetFadeOutTime(),
                onedit: a => this._SetFadeOutTime(a)
            }, {
                name: "behaviors.fade.debugger.stage",
                value: ["behaviors.fade.debugger." + ["fade-in", "wait", "fade-out", "done"][this._stage]]
            }]
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.IFadeBehaviorInstance
    }
}
;
const map$jscomp$36 = new WeakMap;
self.IFadeBehaviorInstance = class  extends IBehaviorInstance$jscomp$2{
    constructor()
    {
        super();
        map$jscomp$36.set(this, IBehaviorInstance$jscomp$2._GetInitInst().GetSdkInstance())
    }
    startFade()
    {
        map$jscomp$36.get(this)._StartFade()
    }
    restartFade()
    {
        map$jscomp$36.get(this)._RestartFade()
    }
    set fadeInTime(a)
    {
        C3X$jscomp$45.RequireFiniteNumber(a);
        map$jscomp$36.get(this)._SetFadeInTime(a)
    }
    get fadeInTime()
    {
        return map$jscomp$36.get(this)._GetFadeInTime()
    }
    set waitTime(a)
    {
        C3X$jscomp$45.RequireFiniteNumber(a);
        map$jscomp$36.get(this)._SetWaitTime(a)
    }
    get waitTime()
    {
        return map$jscomp$36.get(this)._GetWaitTime()
    }
    set fadeOutTime(a)
    {
        C3X$jscomp$45.RequireFiniteNumber(a);
        map$jscomp$36.get(this)._SetFadeOutTime(a)
    }
    get fadeOutTime()
    {
        return map$jscomp$36.get(this)._GetFadeOutTime()
    }
}
;
self.C3.Behaviors.Fade.Cnds = {
    OnFadeOutEnd() {
        return !0
    },
    OnFadeInEnd() {
        return !0
    },
    OnWaitEnd() {
        return !0
    }
};
self.C3.Behaviors.Fade.Acts = {
    StartFade() {
        this._StartFade()
    },
    RestartFade() {
        this._RestartFade()
    },
    SetFadeInTime(a) {
        this._SetFadeInTime(a)
    },
    SetWaitTime(a) {
        this._SetWaitTime(a)
    },
    SetFadeOutTime(a) {
        this._SetFadeOutTime(a)
    }
};
self.C3.Behaviors.Fade.Exps = {
    FadeInTime() {
        return this._GetFadeInTime()
    },
    WaitTime() {
        return this._GetWaitTime()
    },
    FadeOutTime() {
        return this._GetFadeOutTime()
    }
};
"use strict";
const C3$jscomp$275 = self.C3;
C3$jscomp$275.Behaviors.Sin = class  extends C3$jscomp$275.SDKBehaviorBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$276 = self.C3;
C3$jscomp$276.Behaviors.Sin.Type = class  extends C3$jscomp$276.SDKBehaviorTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$277 = self.C3,
    C3X$jscomp$46 = self.C3X,
    IBehaviorInstance$jscomp$3 = self.IBehaviorInstance,
    _2pi = 2 * Math.PI,
    _pi_2 = Math.PI / 2,
    _3pi_2 = 3 * Math.PI / 2,
    MOVEMENT_LOOKUP = [0, 1, 8, 3, 4, 2, 5, 6, 9, 7];
C3$jscomp$277.Behaviors.Sin.Instance = class  extends C3$jscomp$277.SDKBehaviorInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._mag = this._period = this._wave = this._movement = this._i = 0;
        this._isEnabled = !0;
        this._ratio = this._lastKnownValue2 = this._lastKnownValue = this._initialValue2 = this._initialValue = this._magnitudeRandom = this._periodOffsetRandom = this._periodRandom = this._baseMag = this._basePeriodOffset = this._basePeriod = 0;
        b && (this._movement = MOVEMENT_LOOKUP[b[0]], this._wave = b[1], this._periodRandom = this._runtime.Random() *
        b[3], this._basePeriod = b[2], this._period = b[2], this._period += this._periodRandom, this._basePeriodOffset = b[4], 0 !== this._period && (this._periodOffsetRandom = this._runtime.Random() * b[5], this._i = b[4] / this._period * _2pi, this._i += this._periodOffsetRandom / this._period * _2pi), this._magnitudeRandom = this._runtime.Random() * b[7], this._baseMag = b[6], this._mag = b[6], this._mag += this._magnitudeRandom, this._isEnabled = !!b[8]);
        5 === this._movement && (this._mag = C3$jscomp$277.toRadians(this._mag));
        this.Init();
        this._isEnabled && this._StartTicking()
    }
    Release()
    {
        super.Release()
    }
    SaveToJson()
    {
        return {
            i: this._i,
            e: this._isEnabled,
            mv: this._movement,
            w: this._wave,
            p: this._period,
            mag: this._mag,
            iv: this._initialValue,
            iv2: this._initialValue2,
            r: this._ratio,
            lkv: this._lastKnownValue,
            lkv2: this._lastKnownValue2
        }
    }
    LoadFromJson(a)
    {
        this._i = a.i;
        this._SetEnabled(a.e);
        this._movement = a.mv;
        this._wave = a.w;
        this._period = a.p;
        this._mag = a.mag;
        this._initialValue = a.iv;
        this._initialValue2 = a.iv2;
        this._ratio = a.r;
        this._lastKnownValue = a.lkv;
        this._lastKnownValue2 = a.lkv2
    }
    Init()
    {
        const a = this._inst.GetWorldInfo();
        switch (this._movement) {
        case 0:
            this._initialValue =
            a.GetX();
            break;
        case 1:
            this._initialValue = a.GetY();
            break;
        case 2:
            this._initialValue = a.GetWidth();
            this._ratio = a.GetHeight() / a.GetWidth();
            break;
        case 3:
            this._initialValue = a.GetWidth();
            break;
        case 4:
            this._initialValue = a.GetHeight();
            break;
        case 5:
            this._initialValue = a.GetAngle();
            break;
        case 6:
            this._initialValue = a.GetOpacity();
            break;
        case 7:
            this._initialValue = 0;
            break;
        case 8:
            this._initialValue = a.GetX();
            this._initialValue2 = a.GetY();
            break;
        case 9:
            this._initialValue = a.GetZElevation()
        }
        this._lastKnownValue = this._initialValue;
        this._lastKnownValue2 = this._initialValue2
    }
    WaveFunc(a)
    {
        a %= _2pi;
        switch (this._wave) {
        case 0:
            return Math.sin(a);
        case 1:
            return a <= _pi_2 ? a / _pi_2 : a <= _3pi_2 ? 1 - 2 * (a - _pi_2) / Math.PI : (a - _3pi_2) / _pi_2 - 1;
        case 2:
            return 2 * a / _2pi - 1;
        case 3:
            return -2 * a / _2pi + 1;
        case 4:
            return a < Math.PI ? -1 : 1
        }
        return 0
    }
    Tick()
    {
        const a = this._runtime.GetDt(this._inst);
        this._isEnabled && 0 !== a && (this._i = 0 === this._period ? 0 : (this._i + a / this._period * _2pi) % _2pi, this._UpdateFromPhase())
    }
    _UpdateFromPhase()
    {
        const a = this._inst.GetWorldInfo();
        switch (this._movement) {
        case 0:
            a.GetX() !==
            this._lastKnownValue && (this._initialValue += a.GetX() - this._lastKnownValue);
            a.SetX(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetX();
            break;
        case 1:
            a.GetY() !== this._lastKnownValue && (this._initialValue += a.GetY() - this._lastKnownValue);
            a.SetY(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetY();
            break;
        case 2:
            a.SetWidth(this._initialValue + this.WaveFunc(this._i) * this._mag);
            a.SetHeight(a.GetWidth() * this._ratio);
            break;
        case 3:
            a.SetWidth(this._initialValue +
            this.WaveFunc(this._i) * this._mag);
            break;
        case 4:
            a.SetHeight(this._initialValue + this.WaveFunc(this._i) * this._mag);
            break;
        case 5:
            a.GetAngle() !== this._lastKnownValue && (this._initialValue = C3$jscomp$277.clampAngle(this._initialValue + (a.GetAngle() - this._lastKnownValue)));
            a.SetAngle(this._initialValue + this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetAngle();
            break;
        case 6:
            a.SetOpacity(this._initialValue + this.WaveFunc(this._i) * this._mag / 100);
            break;
        case 8:
            a.GetX() !== this._lastKnownValue && (this._initialValue +=
            a.GetX() - this._lastKnownValue);
            a.GetY() !== this._lastKnownValue2 && (this._initialValue2 += a.GetY() - this._lastKnownValue2);
            a.SetX(this._initialValue + Math.cos(a.GetAngle()) * this.WaveFunc(this._i) * this._mag);
            a.SetY(this._initialValue2 + Math.sin(a.GetAngle()) * this.WaveFunc(this._i) * this._mag);
            this._lastKnownValue = a.GetX();
            this._lastKnownValue2 = a.GetY();
            break;
        case 9:
            a.SetZElevation(this._initialValue + this.WaveFunc(this._i) * this._mag)
        }
        a.SetBboxChanged()
    }
    _OnSpriteFrameChanged(a, b) {}
    _SetPeriod(a)
    {
        this._period =
        a
    }
    _GetPeriod()
    {
        return this._period
    }
    _SetMagnitude(a)
    {
        this._mag = a
    }
    _SetMagnitude_ConvertAngle(a)
    {
        5 === this._movement && (a = C3$jscomp$277.toRadians(a));
        this._SetMagnitude(a)
    }
    _GetMagnitude()
    {
        return this._mag
    }
    _GetMagnitude_ConvertAngle()
    {
        let a = this._GetMagnitude();
        5 === this._movement && (a = C3$jscomp$277.toDegrees(a));
        return a
    }
    _SetMovement(a)
    {
        5 === this._movement && 5 !== a && (this._mag = C3$jscomp$277.toDegrees(this._mag));
        this._movement = a;
        this.Init()
    }
    _GetMovement()
    {
        return this._movement
    }
    _SetWave(a)
    {
        this._wave = a
    }
    _GetWave()
    {
        return this._wave
    }
    _SetPhase(a)
    {
        this._i =
        C3$jscomp$277.clamp(a, 0, 2 * Math.PI);
        this._UpdateFromPhase()
    }
    _GetPhase()
    {
        return this._i
    }
    _SetEnabled(a)
    {
        (this._isEnabled = !!a) ? this._StartTicking() : this._StopTicking()
    }
    _IsEnabled()
    {
        return this._isEnabled
    }
    GetPropertyValueByIndex(a)
    {
        switch (a) {
        case 0:
            return this._movement;
        case 1:
            return this._wave;
        case 2:
            return this._basePeriod;
        case 6:
            return this._baseMag;
        case 8:
            return this._isEnabled
        }
    }
    SetPropertyValueByIndex(a, b)
    {
        switch (a) {
        case 0:
            this._movement = MOVEMENT_LOOKUP[b];
            this.Init();
            break;
        case 1:
            this._wave = b;
            break;
        case 2:
            this._basePeriod = b;
            this._period = this._basePeriod + this._periodRandom;
            this._isEnabled || (0 !== this._period ? (this._i = this._basePeriodOffset / this._period * _2pi, this._i += this._periodOffsetRandom / this._period * _2pi) : this._i = 0);
            break;
        case 6:
            this._baseMag = b;
            this._mag = this._baseMag + this._magnitudeRandom;
            5 === this._movement && (this._mag = C3$jscomp$277.toRadians(this._mag));
            break;
        case 8:
            this._isEnabled = !!b
        }
    }
    GetDebuggerProperties()
    {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.sin.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a => this._SetEnabled(a)
            }, {
                name: "behaviors.sin.properties.period.name",
                value: this._GetPeriod(),
                onedit: a => this._SetPeriod(a)
            }, {
                name: "behaviors.sin.properties.magnitude.name",
                value: this._GetMagnitude_ConvertAngle(),
                onedit: a => this._SetMagnitude_ConvertAngle(a)
            }, {
                name: "behaviors.sin.debugger.value",
                value: this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
            }]
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.ISineBehaviorInstance
    }
}
;
const map$jscomp$37 = new WeakMap,
    VALID_MOVEMENTS = "horizontal vertical size width height angle opacity value-only forwards-backwards z-elevation".split(" "),
    VALID_WAVES = ["sine", "triangle", "sawtooth", "reverse-sawtooth", "square"];
self.ISineBehaviorInstance = class  extends IBehaviorInstance$jscomp$3{
    constructor()
    {
        super();
        map$jscomp$37.set(this, IBehaviorInstance$jscomp$3._GetInitInst().GetSdkInstance())
    }
    set period(a)
    {
        C3X$jscomp$46.RequireFiniteNumber(a);
        map$jscomp$37.get(this)._SetPeriod(a)
    }
    get period()
    {
        return map$jscomp$37.get(this)._GetPeriod()
    }
    set magnitude(a)
    {
        C3X$jscomp$46.RequireFiniteNumber(a);
        map$jscomp$37.get(this)._SetMagnitude(a)
    }
    get magnitude()
    {
        return map$jscomp$37.get(this)._GetMagnitude()
    }
    set phase(a)
    {
        map$jscomp$37.get(this)._SetPhase(a)
    }
    get phase()
    {
        return map$jscomp$37.get(this)._GetPhase()
    }
    set movement(a)
    {
        C3X$jscomp$46.RequireString(a);
        a = VALID_MOVEMENTS.indexOf(a);
        if (-1 === a)
            throw Error("invalid movement");
        map$jscomp$37.get(this)._SetMovement(a)
    }
    get movement()
    {
        return VALID_MOVEMENTS[map$jscomp$37.get(this)._GetMovement()]
    }
    set wave(a)
    {
        C3X$jscomp$46.RequireString(a);
        a = VALID_WAVES.indexOf(a);
        if (-1 === a)
            throw Error("invalid wave");
        map$jscomp$37.get(this)._SetWave(a)
    }
    get wave()
    {
        return VALID_WAVES[map$jscomp$37.get(this)._GetWave()]
    }
    get value()
    {
        const a = map$jscomp$37.get(this);
        return a.WaveFunc(a._GetPhase()) * a._GetMagnitude()
    }
    updateInitialState()
    {
        map$jscomp$37.get(this).Init()
    }
    set isEnabled(a)
    {
        map$jscomp$37.get(this)._SetEnabled(!!a)
    }
    get isEnabled()
    {
        return map$jscomp$37.get(this)._IsEnabled()
    }
}
;
const C3$jscomp$278 = self.C3;
C3$jscomp$278.Behaviors.Sin.Cnds = {
    IsEnabled() {
        return this._IsEnabled()
    },
    CompareMovement(a) {
        return this._GetMovement() === a
    },
    ComparePeriod(a, b) {
        return C3$jscomp$278.compare(this._GetPeriod(), a, b)
    },
    CompareMagnitude(a, b) {
        return C3$jscomp$278.compare(this._GetMagnitude_ConvertAngle(), a, b)
    },
    CompareWave(a) {
        return this._GetWave() === a
    }
};
self.C3.Behaviors.Sin.Acts = {
    SetEnabled(a) {
        this._SetEnabled(0 !== a)
    },
    SetPeriod(a) {
        this._SetPeriod(a)
    },
    SetMagnitude(a) {
        this._SetMagnitude_ConvertAngle(a)
    },
    SetMovement(a) {
        this._SetMovement(a)
    },
    SetWave(a) {
        this._wave = a
    },
    SetPhase(a) {
        const b = 2 * Math.PI;
        this._SetPhase(a * b % b)
    },
    UpdateInitialState() {
        this.Init()
    }
};
self.C3.Behaviors.Sin.Exps = {
    CyclePosition() {
        return this._GetPhase() / (2 * Math.PI)
    },
    Period() {
        return this._GetPeriod()
    },
    Magnitude() {
        return this._GetMagnitude_ConvertAngle()
    },
    Value() {
        return this.WaveFunc(this._GetPhase()) * this._GetMagnitude_ConvertAngle()
    }
};
"use strict";
const C3$jscomp$281 = self.C3;
C3$jscomp$281.Behaviors.Anchor = class  extends C3$jscomp$281.SDKBehaviorBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$282 = self.C3;
C3$jscomp$282.Behaviors.Anchor.Type = class  extends C3$jscomp$282.SDKBehaviorTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$283 = self.C3,
    IBehaviorInstance$jscomp$4 = self.IBehaviorInstance;
C3$jscomp$283.Behaviors.Anchor.Instance = class  extends C3$jscomp$283.SDKBehaviorInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._anchorTop = this._anchorLeft = 2;
        this._anchorBottom = this._anchorRight = 0;
        this._isEnabled = !0;
        a = this._inst.GetWorldInfo().GetBoundingBox();
        this._xLeft = a.getLeft();
        this._yTop = a.getTop();
        this._xRight = this._runtime.GetOriginalViewportWidth() - a.getLeft();
        this._yBottom = this._runtime.GetOriginalViewportHeight() - a.getTop();
        this._rDiff = this._runtime.GetOriginalViewportWidth() - a.getRight();
        this._bDiff = this._runtime.GetOriginalViewportHeight() - a.getBottom();
        b && (this._anchorLeft = b[0], this._anchorTop = b[1], this._anchorRight = b[2], this._anchorBottom = b[3], this._isEnabled = !!b[4]);
        b = this._runtime.Dispatcher();
        this._disposables = new C3$jscomp$283.CompositeDisposable(C3$jscomp$283.Disposable.From(b, "layoutchange", () => this._OnLayoutChange()));
        this._isEnabled && this._StartTicking()
    }
    Release()
    {
        super.Release()
    }
    SaveToJson()
    {
        return {
            xl: this._xLeft,
            yt: this._yTop,
            xr: this._xRight,
            yb: this._yBottom,
            rd: this._rDiff,
            bd: this._bDiff,
            al: this._anchorLeft,
            at: this._anchorTop,
            ar: this._anchorRight,
            ab: this._anchorBottom,
            e: this._isEnabled
        }
    }
    LoadFromJson(a)
    {
        this._xLeft = a.xl;
        this._yTop = a.yt;
        this._xRight = a.xr;
        this._yBottom = a.yb;
        this._rDiff = a.rd;
        this._bDiff = a.bd;
        this._anchorLeft = a.al;
        this._anchorTop = a.at;
        this._anchorRight = a.ar;
        this._anchorBottom = a.ab;
        (this._isEnabled = a.e) ? this._StartTicking() : this._StopTicking()
    }
    _SetEnabled(a)
    {
        this._isEnabled && !a ? (this._isEnabled = !1, this._StopTicking()) : !this._isEnabled && a && (a = this._inst.GetWorldInfo().GetBoundingBox(),
        this._xLeft = a.getLeft(), this._yTop = a.getTop(), this._xRight = this._runtime.GetOriginalViewportWidth() - a.getLeft(), this._yBottom = this._runtime.GetOriginalViewportHeight() - a.getTop(), this._rDiff = this._runtime.GetOriginalViewportWidth() - a.getRight(), this._bDiff = this._runtime.GetOriginalViewportHeight() - a.getBottom(), this._isEnabled = !0, this._StartTicking())
    }
    _IsEnabled()
    {
        return this._isEnabled
    }
    _UpdatePosition()
    {
        if (this._isEnabled) {
            var a = this._inst.GetWorldInfo(),
                b = a.GetLayer().GetViewport();
            if (0 === this._anchorLeft) {
                var c =
                b.getLeft() + this._xLeft - a.GetBoundingBox().getLeft();
                0 !== c && (a.OffsetX(c), a.SetBboxChanged())
            } else
                1 === this._anchorLeft && (c = b.getRight() - this._xRight - a.GetBoundingBox().getLeft(), 0 !== c && (a.OffsetX(c), a.SetBboxChanged()));
            0 === this._anchorTop ? (c = b.getTop() + this._yTop - a.GetBoundingBox().getTop(), 0 !== c && (a.OffsetY(c), a.SetBboxChanged())) : 1 === this._anchorTop && (c = b.getBottom() - this._yBottom - a.GetBoundingBox().getTop(), 0 !== c && (a.OffsetY(c), a.SetBboxChanged()));
            1 === this._anchorRight && (c = b.getRight() - this._rDiff -
            a.GetBoundingBox().getRight(), 0 !== c && (a.OffsetX(a.GetOriginX() * c), a.SetWidth(Math.max(a.GetWidth() + c), 0), a.SetBboxChanged(), this._rDiff = b.getRight() - a.GetBoundingBox().getRight()));
            1 === this._anchorBottom && (c = b.getBottom() - this._bDiff - a.GetBoundingBox().getBottom(), 0 !== c && (a.OffsetY(a.GetOriginY() * c), a.SetHeight(Math.max(a.GetHeight() + c, 0)), a.SetBboxChanged(), this._bDiff = b.getBottom() - a.GetBoundingBox().getBottom()))
        }
    }
    Tick()
    {
        this._UpdatePosition()
    }
    _OnLayoutChange()
    {
        this._UpdatePosition()
    }
    GetPropertyValueByIndex(a)
    {
        switch (a) {
        case 0:
            return this._anchorLeft;
        case 1:
            return this._anchorTop;
        case 2:
            return this._anchorRight;
        case 3:
            return this._anchorBottom;
        case 4:
            return this._isEnabled
        }
    }
    SetPropertyValueByIndex(a, b)
    {
        switch (a) {
        case 0:
            this._anchorLeft = b;
            break;
        case 1:
            this._anchorTop = b;
            break;
        case 2:
            this._anchorRight = b;
            break;
        case 3:
            this._anchorBottom = b;
            break;
        case 4:
            (this._isEnabled = !!b) ? this._StartTicking() : this._StopTicking()
        }
    }
    GetDebuggerProperties()
    {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.anchor.properties.enabled.name",
                value: this._IsEnabled(),
                onedit: a => this._SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.IAnchorBehaviorInstance
    }
}
;
const map$jscomp$38 = new WeakMap;
self.IAnchorBehaviorInstance = class  extends IBehaviorInstance$jscomp$4{
    constructor()
    {
        super();
        map$jscomp$38.set(this, IBehaviorInstance$jscomp$4._GetInitInst().GetSdkInstance())
    }
    get isEnabled()
    {
        return map$jscomp$38.get(this)._IsEnabled()
    }
    set isEnabled(a)
    {
        map$jscomp$38.get(this)._SetEnabled(a)
    }
}
;
self.C3.Behaviors.Anchor.Cnds = {
    IsEnabled() {
        return this._IsEnabled()
    }
};
self.C3.Behaviors.Anchor.Acts = {
    SetEnabled(a) {
        this._SetEnabled(0 !== a)
    }
};
self.C3.Behaviors.Anchor.Exps = {};
"use strict";
const C3$jscomp$287 = self.C3;
C3$jscomp$287.Behaviors.Tween = class  extends C3$jscomp$287.SDKBehaviorBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$288 = self.C3;
C3$jscomp$288.Behaviors.Tween.Type = class  extends C3$jscomp$288.SDKBehaviorTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$289 = self.C3,
    NAMESPACE = C3$jscomp$289.Behaviors.Tween;
NAMESPACE.Instance = class  extends C3$jscomp$289.SDKBehaviorInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._allowMultiple = !1;
        this._enabled = !0;
        b && (this._allowMultiple = !1, this._enabled = !!b[0]);
        this._activeTweens = new Map;
        this._disabledTweens = [];
        this._waitingForReleaseTweens = new Map;
        this._waitingForReleaseTweensJson = this._disabledTweensJson = this._activeTweensJson = this._finishingTween = null;
        this._finishingTweenName = "";
        this._triggerTweens = [];
        this._afterLoad = c => this._OnAfterLoad();
        this.GetRuntime().Dispatcher().addEventListener("afterload",
        this._afterLoad)
    }
    Release()
    {
        this.GetRuntime().Dispatcher().removeEventListener("afterload", this._afterLoad);
        this._afterLoad = null;
        this._finishingTween && (this.ReleaseAndCompleteTween(this._finishingTween), this._finishingTween = null);
        this.ReleaseAndCompleteTweens();
        this._tweens = null;
        this.ClearDisabledList();
        this._disabledTweens = null;
        this._ReleaseWaitingTweens();
        this._triggerTweens = this._waitingForReleaseTweens = null;
        super.Release()
    }
    PushTriggerTween(a)
    {
        this._triggerTweens.push(a)
    }
    PopTriggerTween()
    {
        this._triggerTweens.pop()
    }
    GetTriggerTween()
    {
        return this._triggerTweens[this._triggerTweens.length -
        1]
    }
    SetEnabled(a)
    {
        this._enabled = !!a;
        a ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2();
        for (const b of this.AllTweens())
            a ? this.IsInDisabledList(b) && b.Resume() : ((b.IsPlaying() || b.IsScheduled()) && this.AddToDisabledList(b), b.Stop());
        a && this.ClearDisabledList()
    }
    IsEnabled()
    {
        return this._enabled
    }
    AddToDisabledList(a)
    {
        this._disabledTweens.push(a)
    }
    IsInDisabledList(a)
    {
        return this._disabledTweens.includes(a)
    }
    ClearDisabledList()
    {
        C3$jscomp$289.clearArray(this._disabledTweens)
    }
    GetFinishingTween()
    {
        return this._finishingTween
    }
    IsInstanceValid()
    {
        const a =
        this.GetObjectInstance();
        return a ? !a.IsDestroyed() : !1
    }
    GetTween(a, b, c=!1)
    {
        if ((b = b ? this.PropertyTweens(b, c) : this.AllTweens(c)) && b.length)
            for (const d of b)
                if (d.HasTags(a))
                    return d
    }
    CheckTweensWithTags(a, b)
    {
        for (const c of this._activeTweens.values())
            for (const d of c)
                if (!d.IsReleased() && d.HasTags(a) && b(d))
                    return !0;
        for (const c of this._waitingForReleaseTweens.values())
            for (const d of c)
                if (!d.IsReleased() && d.HasTags(a) && b(d))
                    return !0;
        return !1
    }
    CheckTweens(a)
    {
        for (const b of this._activeTweens.values())
            for (const c of b)
                if (!c.IsReleased() &&
                a(c))
                    return !0;
        for (const b of this._waitingForReleaseTweens.values())
            for (const c of b)
                if (!c.IsReleased() && a(c))
                    return !0;
        return !1
    }
    GetTweenIncludingWaitingForRelease(a, b)
    {
        return this.GetTween(a, b, !0)
    }
    *GetTweens(a, b, c=!1)
    {
        if ((b = b ? this.PropertyTweens(b, c) : this.AllTweens(c)) && b.length)
            for (const d of b)
                d.HasTags(a) && (yield d)
    }
    *GetTweensIncludingWaitingForRelease(a, b)
    {
        yield *this.GetTweens(a, b, !0)
    }
    PropertyTweens(a, b)
    {
        if (b)
            return b = this._activeTweens.get(a), a = this._waitingForReleaseTweens.get(a), b || (b = []),
            a || (a = []), b.concat(a).filter(c => c).filter(c => !c.IsReleased());
        (a = this._activeTweens.get(a)) || (a = []);
        return a.filter(c => c).filter(c => !c.IsReleased())
    }
    AllTweens(a)
    {
        if (a) {
            a = [...this._activeTweens.values()].flat();
            const b = [...this._waitingForReleaseTweens.values()].flat();
            return a.concat(b).filter(c => c).filter(c => !c.IsReleased())
        }
        return [...this._activeTweens.values()].flat().filter(b => b).filter(b => !b.IsReleased())
    }
    AllTweensIncludingWaitingForRelease()
    {
        return this.AllTweens(!0)
    }
    SaveToJson(a)
    {
        return {
            s: !1,
            e: !!this._enabled,
            at: this._SaveActiveTweensToJson(),
            dt: this._SaveDisabledTweensToJson(),
            wt: this._SaveWaitingForReleaseTweensToJson(),
            ft: this._SaveFinishingTweenToJson()
        }
    }
    LoadFromJson(a, b="full")
    {
        a && (this._activeTweensJson = a.at, this._disabledTweensJson = a.dt, this._waitingForReleaseTweensJson = a.wt, this._finishingTweenName = a.ft, this._allowMultiple = !1, this._enabled = !!a.e, "state" === b && this._OnAfterLoad())
    }
    _OnAfterLoad()
    {
        const a = this.GetRuntime().GetTimelineManager();
        this._PopulateTweenMap(this._activeTweensJson,
        this._activeTweens, a);
        if (this._disabledTweensJson) {
            C3$jscomp$289.clearArray(this._disabledTweens);
            for (const b of this._disabledTweensJson)
                this._PopulateTweenArray(this._disabledTweens, b, a)
        }
        this._PopulateTweenMap(this._waitingForReleaseTweensJson, this._waitingForReleaseTweens, a);
        this._finishingTween = this._GetTween(this._finishingTweenName, a);
        this._enabled ? this._waitingForReleaseTweens && this._waitingForReleaseTweens.size && this._StartTicking2() : this._StopTicking2()
    }
    _PopulateTweenMap(a, b, c)
    {
        if (a)
            for (const e in a) {
                let f =
                b.get(e);
                f ? C3$jscomp$289.clearArray(f) : f = [];
                var d = a[e];
                for (const g of d)
                    this._PopulateTweenArray(f, g.name, c) ? this._LoadTweenFromJson(g.name, g, c) : (d = C3$jscomp$289.TweenState.Build({
                        runtime: this.GetRuntime(),
                        json: g
                    }), C3$jscomp$289.TweenState.SetInstanceUID(d, this.GetObjectInstance().GetUID()), d.AddCompletedCallback(h => this._FinishTriggers(h)), c.AddScheduledTimeline(d), this._PopulateTweenArray(f, d, c));
                b.set(e, f)
            }
    }
    _GetTween(a, b)
    {
        return b.GetScheduledOrPlayingTimelineByName(a)
    }
    _PopulateTweenArray(a, b,
    c)
    {
        if ("string" === typeof b) {
            if (b = this._GetTween(b, c))
                return !!a.push(b)
        } else
            return !!a.push(b);
        return !1
    }
    _LoadTweenFromJson(a, b, c)
    {
        if ("string" === typeof a) {
            if (a = this._GetTween(a, c))
                a._LoadFromJson(b),
                C3$jscomp$289.TweenState.SetInstanceUID(a, this.GetObjectInstance().GetUID())
        } else
            a._LoadFromJson(b),
            C3$jscomp$289.TweenState.SetInstanceUID(a, this.GetObjectInstance().GetUID())
    }
    _SaveActiveTweensToJson()
    {
        const a = {};
        for (const [b, c] of this._activeTweens)
            a[b] = c.filter(d => !d.IsReleased()).map(d => d._SaveToJson());
        return a
    }
    _SaveDisabledTweensToJson()
    {
        return this._disabledTweens.filter(a => !a.IsReleased()).map(a => a.GetName())
    }
    _SaveWaitingForReleaseTweensToJson()
    {
        const a = {};
        for (const [b, c] of this._waitingForReleaseTweens)
            a[b] = c.map(d => d._SaveToJson());
        return a
    }
    _SaveFinishingTweenToJson()
    {
        return this._finishingTween ? this._finishingTween.GetName() : ""
    }
    Tick2()
    {
        this._ReleaseWaitingTweens()
    }
    CreateTween(a)
    {
        var b = NAMESPACE.Config.GetPropertyTracksConfig(a.property, a.startValue, a.endValue, a.ease, a.resultMode, this.GetObjectInstance());
        const c = NAMESPACE.Maps.GetPropertyFromIndex(a.property);
        NAMESPACE.Maps.IsValueId(c) || this.ReleaseTweens(a.property);
        b = C3$jscomp$289.TweenState.Build({
            runtime: this.GetRuntime(),
            id: c,
            tags: a.tags,
            time: a.time,
            instance: this.GetObjectInstance(),
            releaseOnComplete: !!a.releaseOnComplete,
            loop: !!a.loop,
            pingPong: !!a.pingPong,
            repeatCount: a.repeatCount,
            initialValueMode: a.initialValueMode,
            propertyTracksConfig: b
        });
        b.AddCompletedCallback(d => this._FinishTriggers(d));
        this._AddTween(b, a.property);
        return b
    }
    _MaybeRemoveFromActiveTweenMap(a)
    {
        var b =
        a.GetId();
        this._activeTweens.has(b) && (b = this._activeTweens.get(b)) && (a = b.indexOf(a), -1 !== a && b.splice(a, 1))
    }
    ReleaseTween(a, b=!1)
    {
        this._MaybeRemoveFromActiveTweenMap(a);
        a.IsReleased() || this._IsInWaitingList(a) || (a.Stop(b), this._AddToWaitingList(a))
    }
    ReleaseTweens(a, b=!1)
    {
        if (C3$jscomp$289.IsFiniteNumber(a)) {
            var c = NAMESPACE.Maps.GetPropertyFromIndex(a);
            if (this._activeTweens.has(c)) {
                c = this._activeTweens.get(c);
                var d = this.GetFinishingTween();
                for (var e of c)
                    e === d || e.IsReleased() || this._IsInWaitingList(e) ||
                    (e.Stop(b), e.Release());
                C3$jscomp$289.clearArray(c)
            }
        } else {
            e = this.GetFinishingTween();
            for (c of this.AllTweens())
                c === e || c.IsReleased() || this._IsInWaitingList(c) || (c.Stop(b), c.Release());
            for (d of this._activeTweens.keys())
                C3$jscomp$289.clearArray(this._activeTweens.get(d)),
                this._activeTweens.delete(d);
            this._activeTweens.clear()
        }
    }
    ReleaseAndCompleteTween(a)
    {
        this.ReleaseTween(a, !0)
    }
    ReleaseAndCompleteTweens()
    {
        this.ReleaseTweens(NaN, !0)
    }
    GetPropertyValueByIndex(a)
    {
        switch (a) {
        case 0:
            return this._enabled
        }
    }
    SetPropertyValueByIndex(a,
    b)
    {
        switch (a) {
        case 0:
            this._enabled = !!b
        }
    }
    _GetBehaviorType(a)
    {
        a = a.GetInstance().GetBehaviorInstances();
        for (const b of a)
            if (a = b.GetBehaviorType(), a.GetInstanceSdkCtor() === this.constructor)
                return a
    }
    Trigger(a, b, c, d)
    {
        return this._runtime ? super.Trigger(a) : b.Trigger(a, c, d)
    }
    _FinishTriggers(a)
    {
        this._finishingTween = a;
        NAMESPACE.Cnds.SetFinishingTween(a);
        let b,
            c;
        if (this.GetRuntime())
            b = this._inst,
            c = this._runtime,
            this.Trigger(NAMESPACE.Cnds.OnTweensFinished),
            this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished),
            this.ReleaseTween(a);
        else {
            b = a.GetInstance();
            if (!b || b && b.IsDestroyed())
                return;
            c = b.GetRuntime();
            const d = this._GetBehaviorType(a);
            this.Trigger(NAMESPACE.Cnds.OnTweensFinished, c, b, d);
            this.Trigger(NAMESPACE.Cnds.OnAnyTweensFinished, c, b, d);
            a.Stop()
        }
        this._finishingTween = null;
        NAMESPACE.Cnds.SetFinishingTween(null);
        a.GetDestroyInstanceOnComplete() && c.DestroyInstance(b)
    }
    _AddTween(a, b)
    {
        b = NAMESPACE.Maps.GetPropertyFromIndex(b);
        this._activeTweens.has(b) || this._activeTweens.set(b, []);
        this._activeTweens.get(b).push(a)
    }
    _AddToWaitingList(a)
    {
        const b =
        a.GetId();
        this._waitingForReleaseTweens.has(b) || this._waitingForReleaseTweens.set(b, []);
        this._waitingForReleaseTweens.get(b).push(a);
        this.IsTicking2() || this._StartTicking2()
    }
    _IsInWaitingList(a)
    {
        const b = a.GetId();
        return this._waitingForReleaseTweens.has(b) ? this._waitingForReleaseTweens.get(b).includes(a) : !1
    }
    _ReleaseWaitingTweens()
    {
        if (this._waitingForReleaseTweens.size) {
            for (const a of this._waitingForReleaseTweens.values()) {
                for (const b of a)
                    b.IsReleased() || b.Release();
                C3$jscomp$289.clearArray(a)
            }
            this._waitingForReleaseTweens.clear();
            this.IsTicking2() && this._StopTicking2()
        }
    }
    GetDebuggerProperties()
    {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.tween.properties.enabled.name",
                value: this.IsEnabled(),
                onedit: a => this.SetEnabled(a)
            }]
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.ITweenBehaviorInstance
    }
}
;
const C3$jscomp$290 = self.C3;
let finishingTween$jscomp$2 = null;
C3$jscomp$290.Behaviors.Tween.Cnds = {
    OnAnyTweenLoop() {
        return !0
    },
    OnTweensLoop(a) {
        const b = this.GetTriggerTween();
        return b ? b.HasTags(a) : !1
    },
    OnAnyTweenPingPong(a) {
        const b = this.GetTriggerTween();
        return b ? b.GetPingPongState() === a || 2 === a ? !0 : !1 : !1
    },
    OnTweensPingPong(a, b) {
        const c = this.GetTriggerTween();
        return c ? c.GetPingPongState() === b || 2 === b ? c.HasTags(a) : !1 : !1
    },
    SetFinishingTween(a) {
        finishingTween$jscomp$2 = a
    },
    OnTweensFinished(a) {
        return finishingTween$jscomp$2.HasTags(a)
    },
    OnAnyTweensFinished() {
        return !0
    },
    IsPlaying(a) {
        return this.CheckTweensWithTags(a,
        C3$jscomp$290.TweenState.IsPlaying)
    },
    IsAnyPlaying() {
        return this.CheckTweens(C3$jscomp$290.TweenState.IsPlaying)
    },
    IsPaused(a) {
        return this.CheckTweensWithTags(a, C3$jscomp$290.TweenState.IsPaused)
    },
    IsAnyPaused() {
        return this.CheckTweens(C3$jscomp$290.TweenState.IsPaused)
    },
    IsPingPong(a, b) {
        return 0 === b ? this.CheckTweensWithTags(a, C3$jscomp$290.TweenState.IsPing) : 1 === b ? this.CheckTweensWithTags(a, C3$jscomp$290.TweenState.IsPong) : !1
    },
    IsAnyPingPong(a) {
        return 0 === a ? this.CheckTweens(C3$jscomp$290.TweenState.IsPing) :
        1 === a ? this.CheckTweens(C3$jscomp$290.TweenState.IsPong) : !1
    }
};
const C3$jscomp$291 = self.C3,
    Ease$jscomp$3 = self.Ease,
    NAMESPACE$jscomp$1 = C3$jscomp$291.Behaviors.Tween;
NAMESPACE$jscomp$1.Acts = {
    SetEnabled(a) {
        this.SetEnabled(!!a)
    },
    async TweenOneProperty(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.OneProperty(this, ...a)), a.Play() && await a.GetPlayPromise())
    },
    async TweenTwoProperties(...a) {
        this.IsEnabled() && this.IsInstanceValid() && (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.TwoProperties(this, ...a)), a.Play() && await a.GetPlayPromise())
    },
    async TweenValue(...a) {
        this.IsEnabled() && this.IsInstanceValid() &&
        (a = this.CreateTween(NAMESPACE$jscomp$1.TweenArguments.ValueProperty(this, ...a)), a.Play() && await a.GetPlayPromise())
    },
    PauseTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                b.Stop()
    },
    PauseAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                a.Stop()
    },
    ResumeTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                b.Resume()
    },
    ResumeAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                a.Resume()
    },
    StopTweens(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.GetTweens(a))
                this.ReleaseTween(b)
    },
    StopAllTweens() {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const a of this.AllTweens())
                this.ReleaseTween(a)
    },
    SetOnePropertyTweensEndValue(a, b, c) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = C3$jscomp$291.Behaviors.Tween.Maps.GetSinglePropertyFromIndex(b);
            for (const d of this.GetTweens(a))
                d.BeforeSetEndValues([b]),
                d.SetEndValue(c, b)
        }
    },
    SetTwoPropertiesTweensEndValue(a, b, c, d) {
        if (this.IsEnabled() &&
        this.IsInstanceValid()) {
            b = C3$jscomp$291.Behaviors.Tween.Maps.GetRealProperties(b);
            for (const e of this.GetTweens(a))
                e.BeforeSetEndValues(b),
                e.SetEndValue(c, b[0]),
                e.SetEndValue(d, b[1])
        }
    },
    SetValuePropertyTweensStartValue(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a, "value"))
                c.SetStartValue(b, "value")
    },
    SetValuePropertyTweensEndValue(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a, "value"))
                c.BeforeSetEndValues(["value"]),
                c.SetEndValue(b,
                "value")
    },
    SetTweensEase(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            b = Ease$jscomp$3.GetEaseFromIndex(b);
            for (const c of this.GetTweens(a))
                c.SetEase(b)
        }
    },
    SetAllTweensEase(a) {
        if (this.IsEnabled() && this.IsInstanceValid()) {
            a = Ease$jscomp$3.GetEaseFromIndex(a);
            for (const b of this.AllTweens())
                b.SetEase(a)
        }
    },
    SetTweensTime(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a))
                c.SetTime(b)
    },
    SetAllTweensTime(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetTime(a)
    },
    SetTweensPlaybackRate(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a))
                c.SetPlaybackRate(b)
    },
    SetAllTweensPlaybackRate(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetPlaybackRate(a)
    },
    SetTweensDestroyOnComplete(a, b) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const c of this.GetTweens(a))
                c.SetDestroyInstanceOnComplete(!!b)
    },
    SetAllTweensDestroyOnComplete(a) {
        if (this.IsEnabled() && this.IsInstanceValid())
            for (const b of this.AllTweens())
                b.SetDestroyInstanceOnComplete(!!a)
    }
};
self.C3.Behaviors.Tween.Exps = {
    Time(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetTime() : 0
    },
    Progress(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetTime() / a.GetTotalTime() : 0
    },
    PlaybackRate(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a)) ? a.GetPlaybackRate() : 0
    },
    Value(a) {
        return (a = this.GetTweenIncludingWaitingForRelease(a, "value")) ? a.GetPropertyTrack("value").GetSourceAdapterValue() : 0
    },
    Tags() {
        let a = this.GetFinishingTween();
        return a ? a.GetStringTags() : (a = this.GetTriggerTween()) ?
        a.GetStringTags() : ""
    }
};
"use strict";
const C3$jscomp$293 = self.C3,
    Ease$jscomp$4 = self.Ease,
    PAIR_PROPERTIES = ["position", "size", "scale"],
    SINGLE_PROPERTIES = "offsetX offsetY offsetWidth offsetHeight offsetAngle offsetOpacity offsetColor offsetZElevation offsetScaleX offsetScaleY".split(" "),
    VALUE_PROPERTIES = ["value"],
    PROPERTY_INDEX_TO_NAME = [].concat(PAIR_PROPERTIES).concat(SINGLE_PROPERTIES).concat(VALUE_PROPERTIES),
    PROPERTY_PAIR_TO_REAL_PROPERTIES = {
        position: ["offsetX", "offsetY"],
        size: ["offsetWidth", "offsetHeight"],
        scale: ["offsetScaleX", "offsetScaleY"]
    },
    ALL_REAL_PROPERTIES = Object.assign({}, PROPERTY_INDEX_TO_NAME.reduce((a, b) => Object.assign({}, a, {
        [b]: [b]
    }), {}), PROPERTY_PAIR_TO_REAL_PROPERTIES);
C3$jscomp$293.Behaviors.Tween.Maps = class {
    constructor() {}
    static GetEases()
    {
        return [...Ease$jscomp$4.GetRuntimeEaseNames()]
    }
    static GetEaseFromIndex(a)
    {
        return [...Ease$jscomp$4.GetRuntimeEaseNames()][a]
    }
    static GetPropertyFromIndex(a)
    {
        return PROPERTY_INDEX_TO_NAME[a]
    }
    static GetPropertyIndexFromName(a)
    {
        return PROPERTY_INDEX_TO_NAME.indexOf(a)
    }
    static GetPairPropertyFromIndex(a)
    {
        return PAIR_PROPERTIES[a]
    }
    static GetSinglePropertyFromIndex(a)
    {
        return SINGLE_PROPERTIES[a]
    }
    static GetValuePropertyFromIndex(a)
    {
        return VALUE_PROPERTIES[a]
    }
    static GetPairProperties(a)
    {
        return PROPERTY_PAIR_TO_REAL_PROPERTIES[a]
    }
    static GetRealProperties(a)
    {
        return C3$jscomp$293.IsString(a) ? ALL_REAL_PROPERTIES[a] :
        ALL_REAL_PROPERTIES[PROPERTY_INDEX_TO_NAME[a]]
    }
    static IsPairId(a)
    {
        return !!PROPERTY_PAIR_TO_REAL_PROPERTIES[a]
    }
    static IsColorId(a)
    {
        return "offsetColor" === a
    }
    static IsAngleId(a)
    {
        return "offsetAngle" === a
    }
    static IsOpacityId(a)
    {
        return "offsetOpacity" === a
    }
    static IsValueId(a)
    {
        return "value" === a
    }
}
;
"use strict";
const C3$jscomp$294 = self.C3,
    NAMESPACE$jscomp$2 = C3$jscomp$294.Behaviors.Tween,
    TWEEN_CONFIGURATIONS = new Map;
NAMESPACE$jscomp$2.Config = class {
    constructor() {}
    static GetPropertyTracksConfig(a, b, c, d, e, f)
    {
        0 === TWEEN_CONFIGURATIONS.size && this._CreateConfigObjects();
        var g = NAMESPACE$jscomp$2.PropertyTypes.Pick(a);
        g = TWEEN_CONFIGURATIONS.get(g);
        C3$jscomp$294.IsFiniteNumber(a) && (a = NAMESPACE$jscomp$2.Maps.GetPropertyFromIndex(a));
        return this._GetConfig(g, a, b, c, d, e, f)
    }
    static TransformValue(a, b)
    {
        return C3$jscomp$294.Behaviors.Tween.GetPropertyTracksConfig(a).valueGetter(b)
    }
    static _CreateConfigObjects()
    {
        const a = NAMESPACE$jscomp$2.PropertyTypes,
            b = NAMESPACE$jscomp$2.ValueGetters;
        this._AddConfigObject(a.PAIR, this._GetPairConfig, b._GetPropertyValue);
        this._AddConfigObject(a.COLOR, this._GetColorConfig, b._GetColorPropertyValue);
        this._AddConfigObject(a.ANGLE, this._GetAngleConfig, b._GetPropertyAngleValue);
        this._AddConfigObject(a.VALUE, this._GetValueConfig, b._GetPropertyValue);
        this._AddConfigObject(a.OTHER, this._GetCommonConfig, b._GetPropertyValue)
    }
    static _AddConfigObject(a, b, c)
    {
        TWEEN_CONFIGURATIONS.set(a, this._CreateConfigObject(a, b, c))
    }
    static _CreateConfigObject(a,
    b, c)
    {
        return {
            name: a,
            configFunc: b,
            valueGetter: c
        }
    }
    static _GetConfig(a, b, c, d, e, f, g)
    {
        return a.configFunc(b, a.valueGetter(c), a.valueGetter(d), e, f, g)
    }
    static _GetPairConfig(a, b, c, d, e, f)
    {
        return NAMESPACE$jscomp$2.Maps.GetPairProperties(a).map((g, h) => ({
            sourceId: "world-instance",
            property: g,
            type: "float",
            valueType: "numeric",
            startValue: b[h],
            endValue: c[h],
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }))
    }
    static _GetColorConfig(a, b, c, d, e, f)
    {
        return C3$jscomp$294.Plugins.Text && f.GetPlugin() instanceof
        C3$jscomp$294.Plugins.Text ? {
            sourceId: "plugin",
            sourceArgs: [7],
            property: "color",
            type: "color",
            valueType: "color",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        } : {
            sourceId: "world-instance",
            property: a,
            type: "color",
            valueType: "color",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
    static _GetAngleConfig(a, b, c, d, e, f)
    {
        return {
            sourceId: "world-instance",
            property: a,
            type: "angle",
            valueType: "angle",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
    static _GetCommonConfig(a, b, c, d, e, f)
    {
        return {
            sourceId: "world-instance",
            property: a,
            type: "float",
            valueType: "numeric",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
    static _GetValueConfig(a, b, c, d, e, f)
    {
        return {
            sourceId: "value",
            property: a,
            type: "float",
            valueType: "numeric",
            startValue: b,
            endValue: c,
            ease: NAMESPACE$jscomp$2.Maps.GetEaseFromIndex(d),
            resultMode: e
        }
    }
}
;
"use strict";
const C3$jscomp$295 = self.C3,
    NAMESPACE$jscomp$3 = C3$jscomp$295.Behaviors.Tween,
    COMMON_VARIABLE_ARGS = Object.assign({}, {
        resultMode: "absolute"
    }, {
        tags: "",
        property: "",
        time: 0,
        ease: 0,
        releaseOnComplete: 0,
        loop: !1,
        pingPong: !1,
        repeatCount: 1
    }),
    ONE_PROPERTY_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
        initialValueMode: "current-state",
        startValue: 0,
        endValue: 0
    }),
    TWO_PROPERTIES_ARGS = Object.assign({}, COMMON_VARIABLE_ARGS, {
        initialValueMode: "current-state",
        startValue: [0, 0],
        endValue: [0, 0]
    }),
    COLOR_PROPERTY_ARGS = Object.assign({},
    COMMON_VARIABLE_ARGS, {
        initialValueMode: "current-state",
        startValue: [0, 0, 0],
        endValue: [0, 0, 0]
    }),
    VALUE_PROPERTY_ARGS = Object.assign({}, ONE_PROPERTY_ARGS, {
        initialValueMode: "start-value"
    });
NAMESPACE$jscomp$3.TweenArguments = class {
    constructor() {}
    static _SetCommonProperties(a, b, c, d, e, f, g, h)
    {
        a.tags = b;
        a.time = c;
        a.ease = d;
        a.releaseOnComplete = e;
        a.loop = f;
        a.pingPong = g;
        a.repeatCount = h
    }
    static OneProperty(a, b, c, d, e, f, g, h, k, l)
    {
        a = "string" === typeof c ? c : NAMESPACE$jscomp$3.Maps.GetSinglePropertyFromIndex(c);
        c = NAMESPACE$jscomp$3.Maps.IsColorId(a) ? COLOR_PROPERTY_ARGS : ONE_PROPERTY_ARGS;
        this._SetCommonProperties(c, b, e, f, g, h, k, l);
        NAMESPACE$jscomp$3.Maps.IsColorId(a) ? (COLOR_PROPERTY_ARGS.endValue[0] = C3$jscomp$295.GetRValue(d),
        COLOR_PROPERTY_ARGS.endValue[1] = C3$jscomp$295.GetGValue(d), COLOR_PROPERTY_ARGS.endValue[2] = C3$jscomp$295.GetBValue(d), COLOR_PROPERTY_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a)) : NAMESPACE$jscomp$3.Maps.IsOpacityId(a) ? ONE_PROPERTY_ARGS.endValue = d / 100 : ONE_PROPERTY_ARGS.endValue = d;
        c.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a);
        return c
    }
    static TwoProperties(a, b, c, d, e, f, g, h, k, l, m)
    {
        this._SetCommonProperties(TWO_PROPERTIES_ARGS, b, f, g, h, k, l, m);
        a = "string" === typeof c ? c :
        NAMESPACE$jscomp$3.Maps.GetPairPropertyFromIndex(c);
        TWO_PROPERTIES_ARGS.endValue[0] = d;
        TWO_PROPERTIES_ARGS.endValue[1] = e;
        TWO_PROPERTIES_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName(a);
        return TWO_PROPERTIES_ARGS
    }
    static ValueProperty(a, b, c, d, e, f, g, h, k, l)
    {
        this._SetCommonProperties(VALUE_PROPERTY_ARGS, b, e, f, g, h, k, l);
        VALUE_PROPERTY_ARGS.startValue = c;
        VALUE_PROPERTY_ARGS.endValue = d;
        VALUE_PROPERTY_ARGS.property = NAMESPACE$jscomp$3.Maps.GetPropertyIndexFromName("value");
        return VALUE_PROPERTY_ARGS
    }
}
;
"use strict";
const C3$jscomp$296 = self.C3,
    NAMESPACE$jscomp$4 = C3$jscomp$296.Behaviors.Tween,
    TYPE_CHECK_OBJECTS = [];
NAMESPACE$jscomp$4.PropertyTypes = class {
    constructor() {}
    static Pick(a)
    {
        0 === TYPE_CHECK_OBJECTS.length && (TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsPairId,
            result: this.PAIR
        }), TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsColorId,
            result: this.COLOR
        }), TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsAngleId,
            result: this.ANGLE
        }), TYPE_CHECK_OBJECTS.push({
            checkFunc: NAMESPACE$jscomp$4.Maps.IsValueId,
            result: this.VALUE
        }), TYPE_CHECK_OBJECTS.push({
            checkFunc: () => !0,
            result: this.OTHER
        }));
        C3$jscomp$296.IsFiniteNumber(a) && (a = C3$jscomp$296.Behaviors.Tween.Maps.GetPropertyFromIndex(a));
        for (const b of TYPE_CHECK_OBJECTS)
            if (b.checkFunc(a))
                return b.result
    }
    static get PAIR()
    {
        return "pair"
    }
    static get COLOR()
    {
        return "color"
    }
    static get ANGLE()
    {
        return "angle"
    }
    static get VALUE()
    {
        return "value"
    }
    static get OTHER()
    {
        return "other"
    }
}
;
"use strict";
const C3$jscomp$297 = self.C3;
C3$jscomp$297.Behaviors.Tween.ValueGetters = class {
    constructor() {}
    static _GetPropertyAngleValue(a)
    {
        a = C3$jscomp$297.toRadians(parseFloat(a));
        return C3$jscomp$297.clampAngle(a)
    }
    static _GetColorPropertyValue(a)
    {
        return a.slice(0)
    }
    static _GetPropertyValue(a)
    {
        return a
    }
}
;
"use strict";
const C3$jscomp$298 = self.C3,
    C3X$jscomp$48 = self.C3X,
    IBehaviorInstance$jscomp$5 = self.IBehaviorInstance,
    Ease$jscomp$5 = self.Ease,
    NAMESPACE$jscomp$6 = C3$jscomp$298.Behaviors.Tween,
    map$jscomp$40 = new WeakMap,
    TWEEN_PROPERTIES = new Map([["x", {
        name: "offsetX",
        type: "one"
    }], ["y", {
        name: "offsetY",
        type: "one"
    }], ["width", {
        name: "offsetWidth",
        type: "one"
    }], ["height", {
        name: "offsetHeight",
        type: "one"
    }], ["angle", {
        name: "offsetAngle",
        type: "one"
    }], ["opacity", {
        name: "offsetOpacity",
        type: "one"
    }], ["color", {
        name: "offsetColor",
        type: "color"
    }],
    ["z-elevation", {
        name: "offsetZElevation",
        type: "one"
    }], ["x-scale", {
        name: "offsetScaleX",
        type: "one"
    }], ["y-scale", {
        name: "offsetScaleY",
        type: "one"
    }], ["position", {
        name: "position",
        type: "two"
    }], ["size", {
        name: "size",
        type: "two"
    }], ["scale", {
        name: "scale",
        type: "two"
    }], ["value", {
        name: "value",
        type: "value"
    }]]);
function getIndexForEase(a) {
    C3X$jscomp$48.RequireString(a);
    var b = Ease$jscomp$5.ToInternal(a);
    b = b ? Ease$jscomp$5.GetIndexForEase(b, null) : Ease$jscomp$5.GetIndexForEase(a, null);
    if (-1 === b)
        throw Error(`invalid ease name '${a}'`);
    return b
}
const TWEEN_OPTS = {
        tags: "",
        destroyOnComplete: !1,
        loop: !1,
        pingPong: !1,
        repeatCount: 1,
        startValue: 0
    },
    I_TWEEN_OPTS = {
        easeToIndexFunc: getIndexForEase
    };
function ValidateTags(a, b=!1) {
    if ((!b || "undefined" !== typeof a && null !== a) && "string" !== typeof a && !Array.isArray(a))
        throw Error("invalid tags");
}
self.ITweenBehaviorInstance = class  extends IBehaviorInstance$jscomp$5{
    constructor()
    {
        super();
        map$jscomp$40.set(this, IBehaviorInstance$jscomp$5._GetInitInst().GetSdkInstance())
    }
    startTween(a, b, c, d, e)
    {
        const f = map$jscomp$40.get(this);
        if (!f.IsEnabled() || !f.IsInstanceValid())
            return null;
        const g = TWEEN_PROPERTIES.get(a);
        if (!g)
            throw Error("invalid tween property");
        "one" === g.type || "value" === g.type ? C3X$jscomp$48.RequireNumber(b) : (C3X$jscomp$48.RequireArray(b), "two" === g.type ? (C3X$jscomp$48.RequireNumber(b[0]),
        C3X$jscomp$48.RequireNumber(b[1])) : "color" === g.type && (C3X$jscomp$48.RequireNumber(b[0]), C3X$jscomp$48.RequireNumber(b[1]), C3X$jscomp$48.RequireNumber(b[2])));
        "angle" === a ? b = C3$jscomp$298.toDegrees(b) : "opacity" === a ? b *= 100 : "color" === a && (b = C3$jscomp$298.PackRGBEx(b[0], b[1], b[2]));
        a = getIndexForEase(d);
        C3X$jscomp$48.RequireFiniteNumber(c);
        e = Object.assign({}, TWEEN_OPTS, e);
        "value" === g.type && C3X$jscomp$48.RequireNumber(e.startValue);
        ValidateTags(e.tags, !0);
        let h;
        "one" === g.type || "color" === g.type ? h = f.CreateTween(NAMESPACE$jscomp$6.TweenArguments.OneProperty(f,
        e.tags, g.name, b, c, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)) : "two" === g.type ? h = f.CreateTween(NAMESPACE$jscomp$6.TweenArguments.TwoProperties(f, e.tags, g.name, b[0], b[1], c, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)) : "value" === g.type && (h = f.CreateTween(NAMESPACE$jscomp$6.TweenArguments.ValueProperty(f, e.tags, e.startValue, b, c, a, !!e.destroyOnComplete, !!e.loop, !!e.pingPong, e.repeatCount)));
        if (!h.Play())
            throw Error("failed to start tween");
        return h.GetITweenState(f, I_TWEEN_OPTS)
    }
    *allTweens()
    {
        const a =
        map$jscomp$40.get(this);
        for (const b of a.AllTweens())
            yield b.GetITweenState(a, I_TWEEN_OPTS)
    }
    *tweensByTags(a)
    {
        ValidateTags(a);
        const b = map$jscomp$40.get(this);
        for (const c of b.GetTweens(a))
            yield c.GetITweenState(b, I_TWEEN_OPTS)
    }
    get isEnabled()
    {
        return map$jscomp$40.get(this).IsEnabled()
    }
    set isEnabled(a)
    {
        map$jscomp$40.get(this).SetEnabled(a)
    }
}
;
"use strict";
const C3$jscomp$299 = self.C3;
C3$jscomp$299.Behaviors.Timer = class  extends C3$jscomp$299.SDKBehaviorBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$300 = self.C3;
C3$jscomp$300.Behaviors.Timer.Type = class  extends C3$jscomp$300.SDKBehaviorTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$301 = self.C3,
    C3X$jscomp$49 = self.C3X,
    IBehaviorInstance$jscomp$6 = self.IBehaviorInstance;
C3$jscomp$301.Behaviors.Timer.SingleTimer = class {
    constructor(a, b, c, d)
    {
        this._current = C3$jscomp$301.New(C3$jscomp$301.KahanSum);
        this._current.Set(a || 0);
        this._total = C3$jscomp$301.New(C3$jscomp$301.KahanSum);
        this._total.Set(b || 0);
        this._duration = c || 0;
        this._isRegular = !!d;
        this._isPaused = !1
    }
    GetCurrentTime()
    {
        return this._current.Get()
    }
    GetTotalTime()
    {
        return this._total.Get()
    }
    GetDuration()
    {
        return this._duration
    }
    SetPaused(a)
    {
        this._isPaused = !!a
    }
    IsPaused()
    {
        return this._isPaused
    }
    Add(a)
    {
        this._current.Add(a);
        this._total.Add(a)
    }
    HasFinished()
    {
        return this._current.Get() >=
        this._duration
    }
    Update()
    {
        if (this.HasFinished())
            if (this._isRegular)
                this._current.Subtract(this._duration);
            else
                return !0;
        return !1
    }
    SaveToJson()
    {
        return {
            c: this._current.Get(),
            t: this._total.Get(),
            d: this._duration,
            r: this._isRegular,
            p: this._isPaused
        }
    }
    LoadFromJson(a)
    {
        this._current.Set(a.c);
        this._total.Set(a.t);
        this._duration = a.d;
        this._isRegular = !!a.r;
        this._isPaused = !!a.p
    }
}
;
C3$jscomp$301.Behaviors.Timer.Instance = class  extends C3$jscomp$301.SDKBehaviorInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._timers = new Map
    }
    Release()
    {
        this._timers.clear();
        super.Release()
    }
    _StartTimer(a, b, c)
    {
        a = new C3$jscomp$301.Behaviors.Timer.SingleTimer(0, 0, a, c);
        this._timers.set(b.toLowerCase(), a);
        this._UpdateTickState()
    }
    _StopTimer(a)
    {
        this._timers.delete(a.toLowerCase());
        this._UpdateTickState()
    }
    _StopAllTimers()
    {
        this._timers.clear();
        this._UpdateTickState()
    }
    _IsTimerRunning(a)
    {
        return this._timers.has(a.toLowerCase())
    }
    _GetTimerCurrentTime(a)
    {
        return (a =
        this._timers.get(a.toLowerCase())) ? a.GetCurrentTime() : 0
    }
    _GetTimerTotalTime(a)
    {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetTotalTime() : 0
    }
    _GetTimerDuration(a)
    {
        return (a = this._timers.get(a.toLowerCase())) ? a.GetDuration() : 0
    }
    _HasTimerFinished(a)
    {
        return (a = this._timers.get(a.toLowerCase())) ? a.HasFinished() : !1
    }
    _SetTimerPaused(a, b)
    {
        (a = this._timers.get(a.toLowerCase())) && a.SetPaused(b)
    }
    _IsTimerPaused(a)
    {
        return (a = this._timers.get(a.toLowerCase())) ? a.IsPaused() : !1
    }
    _SetAllTimersPaused(a)
    {
        for (const b of this._timers.values())
            b.SetPaused(a)
    }
    _UpdateTickState()
    {
        0 <
        this._timers.size ? (this._StartTicking(), this._StartTicking2()) : (this._StopTicking(), this._StopTicking2())
    }
    SaveToJson()
    {
        const a = {};
        for (const [b, c] of this._timers.entries())
            a[b] = c.SaveToJson();
        return a
    }
    LoadFromJson(a)
    {
        this._timers.clear();
        for (const [b, c] of Object.entries(a))
            a = new C3$jscomp$301.Behaviors.Timer.SingleTimer,
            a.LoadFromJson(c),
            this._timers.set(b, a);
        this._UpdateTickState()
    }
    Tick()
    {
        const a = this._runtime.GetDt(this._inst);
        for (const [b, c] of this._timers)
            c.IsPaused() || (c.Add(a), c.HasFinished() &&
            this.DispatchScriptEvent("timer", !1, {
                tag: b
            }))
    }
    Tick2()
    {
        for (const [a, b] of this._timers.entries())
            b.Update() && this._timers.delete(a)
    }
    GetDebuggerProperties()
    {
        return [{
            title: "behaviors.timer.debugger.timers",
            properties: [...this._timers.entries()].map(a => ({
                name: "$" + a[0],
                value: `${Math.round(10 * a[1].GetCurrentTime()) / 10} / ${Math.round(10 * a[1].GetDuration()) / 10}`
            }))
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.ITimerBehaviorInstance
    }
}
;
const map$jscomp$41 = new WeakMap,
    VALID_TIMER_TYPES = ["once", "regular"];
self.ITimerBehaviorInstance = class  extends IBehaviorInstance$jscomp$6{
    constructor()
    {
        super();
        map$jscomp$41.set(this, IBehaviorInstance$jscomp$6._GetInitInst().GetSdkInstance())
    }
    startTimer(a, b, c="once")
    {
        C3X$jscomp$49.RequireFiniteNumber(a);
        C3X$jscomp$49.RequireString(b);
        c = VALID_TIMER_TYPES.indexOf(c);
        if (-1 === c)
            throw Error("invalid type");
        map$jscomp$41.get(this)._StartTimer(a, b, 1 === c)
    }
    setTimerPaused(a, b)
    {
        C3X$jscomp$49.RequireString(a);
        map$jscomp$41.get(this)._SetTimerPaused(a, !!b)
    }
    setAllTimersPaused(a)
    {
        map$jscomp$41.get(this)._SetAllTimersPaused(!!a)
    }
    stopTimer(a)
    {
        C3X$jscomp$49.RequireString(a);
        map$jscomp$41.get(this)._StopTimer(a)
    }
    stopAllTimers()
    {
        map$jscomp$41.get(this)._StopAllTimers()
    }
    isTimerRunning(a)
    {
        C3X$jscomp$49.RequireString(a);
        return map$jscomp$41.get(this)._IsTimerRunning(a)
    }
    isTimerPaused(a)
    {
        C3X$jscomp$49.RequireString(a);
        return map$jscomp$41.get(this)._IsTimerPaused(a)
    }
    getCurrentTime(a)
    {
        C3X$jscomp$49.RequireString(a);
        return map$jscomp$41.get(this)._GetTimerCurrentTime(a)
    }
    getTotalTime(a)
    {
        C3X$jscomp$49.RequireString(a);
        return map$jscomp$41.get(this)._GetTimerTotalTime(a)
    }
    getDuration(a)
    {
        C3X$jscomp$49.RequireString(a);
        return map$jscomp$41.get(this)._GetTimerDuration(a)
    }
    hasFinished(a)
    {
        C3X$jscomp$49.RequireString(a);
        return map$jscomp$41.get(this)._HasTimerFinished(a)
    }
}
;
self.C3.Behaviors.Timer.Cnds = {
    OnTimer(a) {
        return this._HasTimerFinished(a)
    },
    IsTimerRunning(a) {
        return this._IsTimerRunning(a)
    },
    IsTimerPaused(a) {
        return this._IsTimerPaused(a)
    }
};
self.C3.Behaviors.Timer.Acts = {
    StartTimer(a, b, c) {
        this._StartTimer(a, c, 1 === b)
    },
    StopTimer(a) {
        this._StopTimer(a)
    },
    StopAllTimers() {
        this._StopAllTimers()
    },
    PauseResumeTimer(a, b) {
        this._SetTimerPaused(a, 0 === b)
    },
    PauseResumeAllTimers(a) {
        this._SetAllTimersPaused(0 === a)
    }
};
self.C3.Behaviors.Timer.Exps = {
    CurrentTime(a) {
        return this._GetTimerCurrentTime(a)
    },
    TotalTime(a) {
        return this._GetTimerTotalTime(a)
    },
    Duration(a) {
        return this._GetTimerDuration(a)
    }
};
"use strict";
const C3$jscomp$305 = self.C3;
C3$jscomp$305.Behaviors.Flash = class  extends C3$jscomp$305.SDKBehaviorBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
}
;
const C3$jscomp$306 = self.C3;
C3$jscomp$306.Behaviors.Flash.Type = class  extends C3$jscomp$306.SDKBehaviorTypeBase{
    constructor(a)
    {
        super(a)
    }
    Release()
    {
        super.Release()
    }
    OnCreate() {}
}
;
const C3$jscomp$307 = self.C3,
    C3X$jscomp$50 = self.C3X,
    IBehaviorInstance$jscomp$7 = self.IBehaviorInstance;
C3$jscomp$307.Behaviors.Flash.Instance = class  extends C3$jscomp$307.SDKBehaviorInstanceBase{
    constructor(a, b)
    {
        super(a);
        this._timeLeft = this._stageTimeLeft = this._stage = this._offTime = this._onTime = 0;
        this._StartTicking()
    }
    Release()
    {
        super.Release()
    }
    _Flash(a, b, c)
    {
        this._onTime = a;
        this._offTime = b;
        this._stage = 1;
        this._stageTimeLeft = b;
        this._timeLeft = c;
        this._inst.GetWorldInfo().SetVisible(!1);
        this._runtime.UpdateRender()
    }
    _StopFlashing()
    {
        this._timeLeft = 0;
        this._inst.GetWorldInfo().SetVisible(!0);
        this._runtime.UpdateRender()
    }
    _IsFlashing()
    {
        return 0 <
        this._timeLeft
    }
    SaveToJson()
    {
        return {
            on: this._onTime,
            off: this._offTime,
            s: this._stage,
            stl: this._stageTimeLeft,
            tl: this._timeLeft
        }
    }
    LoadFromJson(a)
    {
        this._onTime = a.on;
        this._offTime = a.off;
        this._stage = a.s;
        this._stageTimeLeft = a.stl;
        this._timeLeft = null === a.tl ? Infinity : a.tl
    }
    Tick()
    {
        if (!(0 >= this._timeLeft)) {
            var a = this._runtime.GetDt(this._inst);
            this._timeLeft -= a;
            if (0 >= this._timeLeft)
                return this._timeLeft = 0, this._inst.GetWorldInfo().SetVisible(!0), this._runtime.UpdateRender(), this.DispatchScriptEvent("flashend"),
                this.DebugTrigger(C3$jscomp$307.Behaviors.Flash.Cnds.OnFlashEnded);
            this._stageTimeLeft -= a;
            0 >= this._stageTimeLeft && (0 === this._stage ? (this._inst.GetWorldInfo().SetVisible(!1), this._stage = 1, this._stageTimeLeft += this._offTime) : (this._inst.GetWorldInfo().SetVisible(!0), this._stage = 0, this._stageTimeLeft += this._onTime), this._runtime.UpdateRender())
        }
    }
    GetDebuggerProperties()
    {
        return [{
            title: "$" + this.GetBehaviorType().GetName(),
            properties: [{
                name: "behaviors.flash.debugger.on-time",
                value: this._onTime,
                onedit: a =>
                this._onTime = a
            }, {
                name: "behaviors.flash.debugger.off-time",
                value: this._offTime,
                onedit: a => this._offTime = a
            }, {
                name: "behaviors.flash.debugger.is-flashing",
                value: 0 < this._timeLeft
            }, {
                name: "behaviors.flash.debugger.time-left",
                value: this._timeLeft
            }]
        }]
    }
    GetScriptInterfaceClass()
    {
        return self.IFlashBehaviorInstance
    }
}
;
const map$jscomp$42 = new WeakMap;
self.IFlashBehaviorInstance = class  extends IBehaviorInstance$jscomp$7{
    constructor()
    {
        super();
        map$jscomp$42.set(this, IBehaviorInstance$jscomp$7._GetInitInst().GetSdkInstance())
    }
    flash(a, b, c)
    {
        C3X$jscomp$50.RequireFiniteNumber(a);
        C3X$jscomp$50.RequireFiniteNumber(b);
        C3X$jscomp$50.RequireFiniteNumber(c);
        map$jscomp$42.get(this)._Flash(a, b, c)
    }
    stop()
    {
        map$jscomp$42.get(this)._StopFlashing()
    }
    get isFlashing()
    {
        return map$jscomp$42.get(this)._IsFlashing()
    }
}
;
self.C3.Behaviors.Flash.Cnds = {
    IsFlashing() {
        return this._IsFlashing()
    },
    OnFlashEnded() {
        return !0
    }
};
self.C3.Behaviors.Flash.Acts = {
    Flash(a, b, c) {
        this._Flash(a, b, c)
    },
    StopFlashing() {
        this._StopFlashing()
    }
};
self.C3.Behaviors.Flash.Exps = {};
function and(a, b) {
    return "string" === typeof a || "string" === typeof b ? ("number" === typeof a ? (Math.round(1E10 * a) / 1E10).toString() : a) + ("number" === typeof b ? (Math.round(1E10 * b) / 1E10).toString() : b) : a && b ? 1 : 0
}
self.C3_ExpressionFuncs = [a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => "Version " + b()
}, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue()
}, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b()
}, () => 1, () => 2, () => 0, () => "", () => "in", () => "Storage", () => "General", () => "out", a => {
    const b = a._GetNode(0).GetBoundMethod(),
        c = a._GetNode(1).GetBoundMethod();
    return () => b(c())
}, () => "Hud", () => "Gameplay", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b() / 2
}, () => 50, a => {
    const b = a._GetNode(0).GetBoundMethod(),
        c = a._GetNode(1).GetVar();
    return () => "Level " + b(c.GetValue(), 3)
}, a => {
    const b = a._GetNode(0);
    return () => 2 * b.ExpObject()
}, () => "moveDown", () => 180, () => "BG", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 1.5 * b()
}, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject()
}, () => 1E4, () => "Can you help me organize these treasures?", () => "hint", () => 3, () => "Functions", () => "Main", () => 340, a => {
    const b = a._GetNode(0),
        c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject() * c()
}, () => "s", a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() -
    1
}, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("s")
}, () => "a", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("a")
}, () => "move", a => {
    const b = a._GetNode(0).GetBoundMethod(),
        c = a._GetNode(1).GetBoundMethod(),
        d = a._GetNode(2).GetBoundMethod(),
        e = a._GetNode(3).GetBoundMethod(),
        f = a._GetNode(4).GetBoundMethod(),
        g = a._GetNode(5).GetBoundMethod(),
        h = a._GetNode(6).GetBoundMethod();
    return () => b(c("Main") - 2 * d(e()), f("Main") + 2 * g(h()))
}, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(1.5, 3)
}, () =>
"angle", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(260)
}, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(.5, 1)
}, a => {
    const b = a._GetNode(0),
        c = a._GetNode(1);
    return () => and(and(b.ExpObject(), ","), c.ExpObject())
}, a => {
    const b = a._GetNode(0).GetBoundMethod(),
        c = a._GetNode(1).GetBoundMethod(),
        d = a._GetNode(2).GetBoundMethod(),
        e = a._GetNode(3).GetBoundMethod(),
        f = a._GetNode(4).GetBoundMethod(),
        g = a._GetNode(5).GetBoundMethod(),
        h = a._GetNode(6).GetBoundMethod();
    return () => b(c("Main") - d(e()), f("Main") +
    g(h()))
}, a => {
    const b = a._GetNode(0).GetBoundMethod(),
        c = a._GetNode(1).GetBoundMethod(),
        d = a._GetNode(2);
    return () => b(c(d.ExpInstVar(), 0, ","))
}, a => {
    const b = a._GetNode(0).GetBoundMethod(),
        c = a._GetNode(1).GetBoundMethod(),
        d = a._GetNode(2);
    return () => b(c(d.ExpInstVar(), 1, ","))
}, () => .5, a => {
    const b = a._GetNode(0),
        c = a._GetNode(1).GetBoundMethod(),
        d = a._GetNode(2);
    return () => b.ExpObject(Math.floor(c(d.ExpObject())))
}, a => {
    const b = a._GetNode(0);
    return () => b.ExpInstVar()
}, () => "d", a => {
    const b = a._GetNode(0),
        c = a._GetNode(1).GetBoundMethod();
    return () => b.ExpObject(c("d"))
}, () => 15132390, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0) - 400
}, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b(0)
}, () => "scale", () => .55, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() - 150
}, () => .25, a => {
    const b = a._GetNode(0);
    return () => b.ExpObject() + 150
}, () => .75, () => "wid", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => 2 * b("Main")
}, () => 360, () => 510, () => 11842740, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => .38 * b()
}, () => .125, () => .6, () => "Completed!",
a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => .155 * b()
}, () => .4, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => b("Thank you!", "Treasure Mastery!", "Treasure exploration completed!", "Perfect!", "You\u2019ve balanced the treasure!", "Well done, treasure hunter!")
}, () => "moveY", a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => .825 * b()
}, () => .06, () => 1.8, () => "Buttons", a => {
    const b = a._GetNode(0);
    return () => 0 === b.ExpInstVar() ? "Tap an treasure to change it and others around it" : "All treasure must be exactly the same!"
},
() => 5066061, a => {
    const b = a._GetNode(0);
    return () => 1 === b.ExpInstVar() ? 1 : 0
}, a => {
    const b = a._GetNode(0).GetVar(),
        c = a._GetNode(1).GetVar(),
        d = a._GetNode(2).GetVar();
    return () => b.GetValue() === c.GetValue() ? "1" : (d.GetValue() + 1).toString()
}, () => "size", () => 4, a => {
    const b = a._GetNode(0).GetBoundMethod();
    return () => and("ot_", b(1, 2, 3, 4, 5))
}, () => "Loader", () => "Sound and Music", () => 100, a => {
    const b = a._GetNode(0).GetVar();
    return () => 0 === b.GetValue() ? 1 : 0
}, () => "MainMusic", () => -100, () => -10, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue().toString()
}, () => "Levels navigation", a => {
    const b = a._GetNode(0),
        c = a._GetNode(1).GetVar(),
        d = a._GetNode(2),
        e = a._GetNode(3).GetVar(),
        f = a._GetNode(4),
        g = a._GetNode(5).GetVar(),
        h = a._GetNode(6).GetVar();
    return () => 0 === b.ExpObject() ? c.GetValue() - 10 : 1 === d.ExpObject() ? e.GetValue() - 1 : 2 === f.ExpObject() ? g.GetValue() + 1 : h.GetValue() + 10
}, () => 15, () => 11, a => {
    const b = a._GetNode(0).GetVar();
    return () => b.GetValue() - 10
}];
var module$content$working$237635295$scripts$c3runtime = {};
const C3$$module$content$working$237635295$scripts$objRefTable = self.C3;
self.C3_GetObjectRefTable = function() {
    return [C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Fade, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Sin, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Touch, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Spritefont2, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Audio,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.TiledBg, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Anchor, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Tween, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Timer, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Keyboard, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage,
    C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Flash, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.OnLayoutStart, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetVisible, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.SetVisible, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.TiledBg.Acts.Destroy, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.SetText,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.projectversion, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage.Acts.CheckItemExists, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.Destroy, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.Destroy, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.Compare, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.loadingprogress,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.imageloadingprogress, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.TriggerOnce, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.SetVar, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Fade.Acts.RestartFade, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.Wait, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Touch.Cnds.OnTouchStart,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Cnds.IsVisible, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Audio.Acts.Play, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.GoToLayout, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.IsGroupActive, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage.Cnds.OnItemExists, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage.Acts.GetItem,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage.Cnds.OnItemGet, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage.Exps.ItemValue, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage.Cnds.OnItemMissing, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.int, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.layoutname, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.LocalStorage.Acts.SetItem,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.MoveToLayer, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.SetGroupActive, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Spritefont2.Acts.Destroy, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Acts.Clear, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Acts.SetSize, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.CreateObject,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.layoutwidth, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.zeropad, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.SetHeight, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Exps.Height, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Tween.Acts.TweenOneProperty, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.MoveToTop,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.layoutheight, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.TiledBg.Acts.SetSize, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.ForEach, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Cnds.Contains, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.AnimationName, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Acts.Push,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.dt, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.CompareVar, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.Else, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Timer.Acts.StartTimer, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Cnds.OnDestroyed, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Timer.Cnds.OnTimer,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.PickByComparison, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.Y, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.PickRandom, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.Spawn, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetAngle, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Cnds.CompareSize,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.Count, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.For, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.IID, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.loopindex, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Cnds.IsAnimPlaying, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.AddVar,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Exps.Width, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Cnds.CompareX, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Acts.Delete, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Tween.Acts.TweenTwoProperties, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.choose, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.viewportleft,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.random, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.viewportright, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.viewporttop, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.viewportbottom, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetInstanceVar, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.X,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetPos, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Exps.tokenat, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetAnim, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Arr.Exps.At, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetScale, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.PickAll,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetBoolInstanceVar, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.MoveToTop, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.SetFontColor, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.TypewriterText, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Cnds.CompareBoolVar, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetY,
    C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Timer.Acts.StopTimer, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.TiledBg.Acts.SetWidth, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Fade.Acts.SetFadeInTime, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Fade.Acts.SetFadeOutTime, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Text.Acts.SetY, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetAnimFrame,
    C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Sin.Acts.SetEnabled, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Flash.Acts.Flash, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Touch.Cnds.OnTouchObject, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Cnds.CompareFrame, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.AddInstanceVar, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Cnds.IsVisible,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.SetTimescale, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Touch.Exps.X, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.GoToLayoutByName, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.System.Acts.RestartLayout, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Tween.Cnds.IsAnyPlaying, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.TiledBg.Exps.Count,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.Width, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.Height, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Cnds.OnCollision, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Audio.Acts.PlayByName, C3$$module$content$working$237635295$scripts$objRefTable.Behaviors.Fade.Acts.SetWaitTime, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Cnds.CompareOpacity,
    C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Audio.Cnds.IsTagPlaying, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Audio.Acts.FadeVolume, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Audio.Acts.Stop, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Audio.Acts.SetSilent, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Exps.AnimationFrame, C3$$module$content$working$237635295$scripts$objRefTable.Plugins.Sprite.Acts.SetOpacity]
};
self.C3_JsPropNameTable = [{
    Fade: 0
}, {
    intro_: 0
}, {
    Sine: 0
}, {
    txt_taptocontinue: 0
}, {
    Touch: 0
}, {
    debug: 0
}, {
    Audio: 0
}, {
    fade: 0
}, {
    Anchor: 0
}, {
    btn_main: 0
}, {
    btn_sound: 0
}, {
    bgPaused: 0
}, {
    b_play: 0
}, {
    txt_ver: 0
}, {
    warning: 0
}, {
    changed: 0
}, {
    memPos: 0
}, {
    Tween: 0
}, {
    slot: 0
}, {
    memX: 0
}, {
    memY: 0
}, {
    slotThrow: 0
}, {
    newColor: 0
}, {
    compare: 0
}, {
    setColor: 0
}, {
    a_colorsInLevel: 0
}, {
    Timer: 0
}, {
    txt_status: 0
}, {
    completedBG: 0
}, {
    pause: 0
}, {
    btn_restart: 0
}, {
    title: 0
}, {
    txt_levelSelect: 0
}, {
    btn_levels: 0
}, {
    Keyboard: 0
}, {
    LocalStorage: 0
}, {
    bgGame: 0
}, {
    fontSizeDefault: 0
},
{
    txt_congrats: 0
}, {
    alch: 0
}, {
    balloon: 0
}, {
    txt_msg: 0
}, {
    steps: 0
}, {
    btn_intro: 0
}, {
    Flash: 0
}, {
    btn_end: 0
}, {
    handAlch: 0
}, {
    otaviofurlan_alchemists_laboratory_cartoon_style_6528d8df1a58407fbdd6e141916d: 0
}, {
    mainBoard: 0
}, {
    btn_music: 0
}, {
    txt_credits: 0
}, {
    load_ok: 0
}, {
    storageName: 0
}, {
    timeAnimation: 0
}, {
    currentLevel: 0
}, {
    totalLevels: 0
}, {
    firstTime: 0
}, {
    counter: 0
}, {
    p_colorClicked: 0
}, {
    color: 0
}, {
    count: 0
}, {
    p_msgShow: 0
}, {
    p_intro: 0
}, {
    Sound: 0
}, {
    Music: 0
}, {
    fadeTime: 0
}, {
    type: 0
}];
self.InstanceType = {
    intro_: class  extends self.ISpriteInstance{}
    ,
    txt_taptocontinue: class  extends self.ITextInstance{}
    ,
    Touch: class  extends self.IInstance{}
    ,
    debug: class  extends self.ISpriteFontInstance{}
    ,
    Audio: class  extends self.IInstance{}
    ,
    fade: class  extends self.ITiledBackgroundInstance{}
    ,
    btn_main: class  extends self.ISpriteInstance{}
    ,
    btn_sound: class  extends self.ISpriteInstance{}
    ,
    bgPaused: class  extends self.ITiledBackgroundInstance{}
    ,
    b_play: class  extends self.ISpriteInstance{}
    ,
    txt_ver: class  extends self.ITextInstance{}
    ,
    warning: class  extends self.ITextInstance{}
    ,
    slot: class  extends self.ISpriteInstance{}
    ,
    slotThrow: class  extends self.ISpriteInstance{}
    ,
    setColor: class  extends self.ISpriteInstance{}
    ,
    a_colorsInLevel: class  extends self.IArrayInstance{}
    ,
    txt_status: class  extends self.ITextInstance{}
    ,
    completedBG: class  extends self.ITiledBackgroundInstance{}
    ,
    btn_restart: class  extends self.ISpriteInstance{}
    ,
    title: class  extends self.ISpriteInstance{}
    ,
    txt_levelSelect: class  extends self.ITextInstance{}
    ,
    btn_levels: class  extends self.ISpriteInstance{}
    ,
    Keyboard: class  extends self.IInstance{}
    ,
    LocalStorage: class  extends self.IInstance{}
    ,
    bgGame: class  extends self.ITiledBackgroundInstance{}
    ,
    txt_congrats: class  extends self.ITextInstance{}
    ,
    alch: class  extends self.ISpriteInstance{}
    ,
    balloon: class  extends self.ISpriteInstance{}
    ,
    txt_msg: class  extends self.ITextInstance{}
    ,
    btn_intro: class  extends self.ISpriteInstance{}
    ,
    btn_end: class  extends self.ISpriteInstance{}
    ,
    handAlch: class  extends self.ISpriteInstance{}
    ,
    otaviofurlan_alchemists_laboratory_cartoon_style_6528d8df1a58407fbdd6e141916d: class  extends self.ISpriteInstance{}
    ,
    mainBoard: class  extends self.ITiledBackgroundInstance{}
    ,
    btn_music: class  extends self.ISpriteInstance{}
    ,
    txt_credits: class  extends self.ITextInstance{}
};
var module$content$working$237635295$scripts$objRefTable = {};
var module$content$working$237635295$scripts$c3main = {};
